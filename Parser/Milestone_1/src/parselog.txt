INFO:root:Created by PLY version 3.11 (http://www.dabeaz.com/ply)
INFO:root:
INFO:root:Grammar
INFO:root:
INFO:root:Rule 0     S' -> goal_symbol
INFO:root:Rule 1     goal_symbol -> compilation
INFO:root:Rule 2     pragma -> PRAGMA IDENTIFIER ;
INFO:root:Rule 3     pragma -> PRAGMA simple_name ( pragma_arg_s ) ;
INFO:root:Rule 4     pragma_arg_s -> pragma_arg
INFO:root:Rule 5     pragma_arg_s -> pragma_arg_s , pragma_arg
INFO:root:Rule 6     pragma_arg -> expression
INFO:root:Rule 7     pragma_arg -> simple_name ARROW expression
INFO:root:Rule 8     pragma_s -> <empty>
INFO:root:Rule 9     pragma_s -> pragma_s pragma
INFO:root:Rule 10    decl -> object_decl
INFO:root:Rule 11    decl -> number_decl
INFO:root:Rule 12    decl -> type_decl
INFO:root:Rule 13    decl -> subtype_decl
INFO:root:Rule 14    decl -> subprog_decl
INFO:root:Rule 15    decl -> pkg_decl
INFO:root:Rule 16    decl -> task_decl
INFO:root:Rule 17    decl -> prot_decl
INFO:root:Rule 18    decl -> exception_decl
INFO:root:Rule 19    decl -> rename_decl
INFO:root:Rule 20    decl -> generic_decl
INFO:root:Rule 21    decl -> body_stub
INFO:root:Rule 22    decl -> error ;
INFO:root:Rule 23    object_decl -> def_id_s : object_qualifier_opt object_subtype_def init_opt ;
INFO:root:Rule 24    def_id_s -> def_id
INFO:root:Rule 25    def_id_s -> def_id_s , def_id
INFO:root:Rule 26    def_id -> IDENTIFIER
INFO:root:Rule 27    object_qualifier_opt -> <empty>
INFO:root:Rule 28    object_qualifier_opt -> ALIASED
INFO:root:Rule 29    object_qualifier_opt -> CONSTANT
INFO:root:Rule 30    object_qualifier_opt -> ALIASED CONSTANT
INFO:root:Rule 31    object_subtype_def -> subtype_ind
INFO:root:Rule 32    object_subtype_def -> array_type
INFO:root:Rule 33    init_opt -> <empty>
INFO:root:Rule 34    init_opt -> ASSIGN expression
INFO:root:Rule 35    number_decl -> def_id_s : CONSTANT ASSIGN expression ;
INFO:root:Rule 36    type_decl -> TYPE IDENTIFIER discrim_part_opt type_completion ;
INFO:root:Rule 37    discrim_part_opt -> <empty>
INFO:root:Rule 38    discrim_part_opt -> discrim_part
INFO:root:Rule 39    discrim_part_opt -> ( BOX )
INFO:root:Rule 40    type_completion -> <empty>
INFO:root:Rule 41    type_completion -> IS type_def
INFO:root:Rule 42    type_def -> enumeration_type
INFO:root:Rule 43    type_def -> integer_type
INFO:root:Rule 44    type_def -> real_type
INFO:root:Rule 45    type_def -> array_type
INFO:root:Rule 46    type_def -> record_type
INFO:root:Rule 47    type_def -> access_type
INFO:root:Rule 48    type_def -> derived_type
INFO:root:Rule 49    type_def -> private_type
INFO:root:Rule 50    subtype_decl -> SUBTYPE IDENTIFIER IS subtype_ind ;
INFO:root:Rule 51    subtype_ind -> name constraint
INFO:root:Rule 52    subtype_ind -> name
INFO:root:Rule 53    constraint -> range_constraint
INFO:root:Rule 54    constraint -> decimal_digits_constraint
INFO:root:Rule 55    decimal_digits_constraint -> DIGITS expression range_constr_opt
INFO:root:Rule 56    derived_type -> NEW subtype_ind
INFO:root:Rule 57    derived_type -> NEW subtype_ind WITH PRIVATE
INFO:root:Rule 58    derived_type -> NEW subtype_ind WITH record_def
INFO:root:Rule 59    derived_type -> ABSTRACT NEW subtype_ind WITH PRIVATE
INFO:root:Rule 60    derived_type -> ABSTRACT NEW subtype_ind WITH record_def
INFO:root:Rule 61    range_constraint -> RANGE range
INFO:root:Rule 62    range -> simple_expression DOTDOT simple_expression
INFO:root:Rule 63    enumeration_type -> ( enum_id_s )
INFO:root:Rule 64    enum_id_s -> enum_id
INFO:root:Rule 65    enum_id_s -> enum_id_s , enum_id
INFO:root:Rule 66    enum_id -> IDENTIFIER
INFO:root:Rule 67    enum_id -> CHAR
INFO:root:Rule 68    integer_type -> range_spec
INFO:root:Rule 69    integer_type -> MOD expression
INFO:root:Rule 70    range_spec -> range_constraint
INFO:root:Rule 71    range_spec_opt -> <empty>
INFO:root:Rule 72    range_spec_opt -> range_spec
INFO:root:Rule 73    real_type -> float_type
INFO:root:Rule 74    real_type -> fixed_type
INFO:root:Rule 75    float_type -> DIGITS expression range_spec_opt
INFO:root:Rule 76    fixed_type -> DELTA expression range_spec
INFO:root:Rule 77    fixed_type -> DELTA expression DIGITS expression range_spec_opt
INFO:root:Rule 78    array_type -> unconstr_array_type
INFO:root:Rule 79    array_type -> constr_array_type
INFO:root:Rule 80    unconstr_array_type -> ARRAY ( index_s ) OF component_subtype_def
INFO:root:Rule 81    constr_array_type -> ARRAY iter_index_constraint OF component_subtype_def
INFO:root:Rule 82    component_subtype_def -> aliased_opt subtype_ind
INFO:root:Rule 83    aliased_opt -> <empty>
INFO:root:Rule 84    aliased_opt -> ALIASED
INFO:root:Rule 85    index_s -> index
INFO:root:Rule 86    index_s -> index_s , index
INFO:root:Rule 87    index -> name RANGE BOX
INFO:root:Rule 88    iter_index_constraint -> ( iter_discrete_range_s )
INFO:root:Rule 89    iter_discrete_range_s -> discrete_range
INFO:root:Rule 90    iter_discrete_range_s -> iter_discrete_range_s , discrete_range
INFO:root:Rule 91    discrete_range -> name range_constr_opt
INFO:root:Rule 92    discrete_range -> range
INFO:root:Rule 93    range_constr_opt -> <empty>
INFO:root:Rule 94    range_constr_opt -> range_constraint
INFO:root:Rule 95    record_type -> tagged_opt limited_opt record_def
INFO:root:Rule 96    record_def -> RECORD pragma_s comp_list END RECORD
INFO:root:Rule 97    record_def -> NuLL RECORD
INFO:root:Rule 98    tagged_opt -> <empty>
INFO:root:Rule 99    tagged_opt -> TAGGED
INFO:root:Rule 100   tagged_opt -> ABSTRACT TAGGED
INFO:root:Rule 101   comp_list -> comp_decl_s variant_part_opt
INFO:root:Rule 102   comp_list -> variant_part pragma_s
INFO:root:Rule 103   comp_list -> NuLL ; pragma_s
INFO:root:Rule 104   comp_decl_s -> comp_decl
INFO:root:Rule 105   comp_decl_s -> comp_decl_s pragma_s comp_decl
INFO:root:Rule 106   variant_part_opt -> pragma_s
INFO:root:Rule 107   variant_part_opt -> pragma_s variant_part pragma_s
INFO:root:Rule 108   comp_decl -> def_id_s : component_subtype_def init_opt ;
INFO:root:Rule 109   comp_decl -> error ;
INFO:root:Rule 110   discrim_part -> ( discrim_spec_s )
INFO:root:Rule 111   discrim_spec_s -> discrim_spec
INFO:root:Rule 112   discrim_spec_s -> discrim_spec_s ; discrim_spec
INFO:root:Rule 113   discrim_spec -> def_id_s : access_opt mark init_opt
INFO:root:Rule 114   discrim_spec -> error
INFO:root:Rule 115   access_opt -> <empty>
INFO:root:Rule 116   access_opt -> ACCESS
INFO:root:Rule 117   variant_part -> CASE simple_name IS pragma_s variant_s END CASE ;
INFO:root:Rule 118   variant_s -> variant
INFO:root:Rule 119   variant_s -> variant_s variant
INFO:root:Rule 120   variant -> WHEN choice_s ARROW pragma_s comp_list
INFO:root:Rule 121   choice_s -> choice
INFO:root:Rule 122   choice_s -> choice_s | choice
INFO:root:Rule 123   choice -> expression
INFO:root:Rule 124   choice -> discrete_with_range
INFO:root:Rule 125   choice -> OTHERS
INFO:root:Rule 126   discrete_with_range -> name range_constraint
INFO:root:Rule 127   discrete_with_range -> range
INFO:root:Rule 128   access_type -> ACCESS subtype_ind
INFO:root:Rule 129   access_type -> ACCESS CONSTANT subtype_ind
INFO:root:Rule 130   access_type -> ACCESS ALL subtype_ind
INFO:root:Rule 131   decl_part -> <empty>
INFO:root:Rule 132   decl_part -> decl_item_or_body_s1
INFO:root:Rule 133   decl_item_s -> <empty>
INFO:root:Rule 134   decl_item_s -> decl_item_s1
INFO:root:Rule 135   decl_item_s1 -> decl_item
INFO:root:Rule 136   decl_item_s1 -> decl_item_s1 decl_item
INFO:root:Rule 137   decl_item -> decl
INFO:root:Rule 138   decl_item -> use_clause
INFO:root:Rule 139   decl_item -> rep_spec
INFO:root:Rule 140   decl_item -> pragma
INFO:root:Rule 141   decl_item_or_body_s1 -> decl_item_or_body
INFO:root:Rule 142   decl_item_or_body_s1 -> decl_item_or_body_s1 decl_item_or_body
INFO:root:Rule 143   decl_item_or_body -> body
INFO:root:Rule 144   decl_item_or_body -> decl_item
INFO:root:Rule 145   body -> subprog_body
INFO:root:Rule 146   body -> pkg_body
INFO:root:Rule 147   body -> task_body
INFO:root:Rule 148   body -> prot_body
INFO:root:Rule 149   name -> simple_name
INFO:root:Rule 150   name -> indexed_comp
INFO:root:Rule 151   name -> selected_comp
INFO:root:Rule 152   name -> attribute
INFO:root:Rule 153   name -> operator_symbol
INFO:root:Rule 154   mark -> simple_name
INFO:root:Rule 155   mark -> mark TICK attribute_id
INFO:root:Rule 156   mark -> mark . simple_name
INFO:root:Rule 157   simple_name -> IDENTIFIER
INFO:root:Rule 158   compound_name -> simple_name
INFO:root:Rule 159   compound_name -> compound_name . simple_name
INFO:root:Rule 160   c_name_list -> compound_name
INFO:root:Rule 161   c_name_list -> c_name_list , compound_name
INFO:root:Rule 162   used_char -> CHAR
INFO:root:Rule 163   operator_symbol -> STRING
INFO:root:Rule 164   indexed_comp -> name ( value_s )
INFO:root:Rule 165   value_s -> value
INFO:root:Rule 166   value_s -> value_s , value
INFO:root:Rule 167   value -> expression
INFO:root:Rule 168   value -> comp_assoc
INFO:root:Rule 169   value -> discrete_with_range
INFO:root:Rule 170   value -> error
INFO:root:Rule 171   selected_comp -> name . simple_name
INFO:root:Rule 172   selected_comp -> name . used_char
INFO:root:Rule 173   selected_comp -> name . operator_symbol
INFO:root:Rule 174   selected_comp -> name . ALL
INFO:root:Rule 175   attribute -> name TICK attribute_id
INFO:root:Rule 176   attribute_id -> IDENTIFIER
INFO:root:Rule 177   attribute_id -> DIGITS
INFO:root:Rule 178   attribute_id -> DELTA
INFO:root:Rule 179   attribute_id -> ACCESS
INFO:root:Rule 180   literal -> INT
INFO:root:Rule 181   literal -> FLOAT
INFO:root:Rule 182   literal -> NuLL
INFO:root:Rule 183   aggregate -> ( comp_assoc )
INFO:root:Rule 184   aggregate -> ( expression WITH value_s )
INFO:root:Rule 185   aggregate -> ( expression WITH NuLL RECORD )
INFO:root:Rule 186   aggregate -> ( NuLL RECORD )
INFO:root:Rule 187   comp_assoc -> choice_s ARROW expression
INFO:root:Rule 188   expression -> relation
INFO:root:Rule 189   expression -> expression logical relation
INFO:root:Rule 190   expression -> expression short_circuit relation
INFO:root:Rule 191   logical -> AND
INFO:root:Rule 192   logical -> OR
INFO:root:Rule 193   logical -> XOR
INFO:root:Rule 194   short_circuit -> AND THEN
INFO:root:Rule 195   short_circuit -> OR ELSE
INFO:root:Rule 196   relation -> simple_expression
INFO:root:Rule 197   relation -> simple_expression relational simple_expression
INFO:root:Rule 198   relation -> simple_expression membership range
INFO:root:Rule 199   relation -> simple_expression membership name
INFO:root:Rule 200   relational -> =
INFO:root:Rule 201   relational -> NEQ
INFO:root:Rule 202   relational -> <
INFO:root:Rule 203   relational -> LEQ
INFO:root:Rule 204   relational -> >
INFO:root:Rule 205   relational -> GEQ
INFO:root:Rule 206   membership -> IN
INFO:root:Rule 207   membership -> NOT IN
INFO:root:Rule 208   simple_expression -> unary term
INFO:root:Rule 209   simple_expression -> term
INFO:root:Rule 210   simple_expression -> simple_expression adding term
INFO:root:Rule 211   unary -> +
INFO:root:Rule 212   unary -> -
INFO:root:Rule 213   adding -> +
INFO:root:Rule 214   adding -> -
INFO:root:Rule 215   adding -> &
INFO:root:Rule 216   term -> factor
INFO:root:Rule 217   term -> term multiplying factor
INFO:root:Rule 218   multiplying -> *
INFO:root:Rule 219   multiplying -> /
INFO:root:Rule 220   multiplying -> MOD
INFO:root:Rule 221   multiplying -> REM
INFO:root:Rule 222   multiplying -> STARSTAR
INFO:root:Rule 223   factor -> primary
INFO:root:Rule 224   factor -> NOT primary
INFO:root:Rule 225   factor -> ABS primary
INFO:root:Rule 226   primary -> literal
INFO:root:Rule 227   primary -> name
INFO:root:Rule 228   primary -> allocator
INFO:root:Rule 229   primary -> qualified
INFO:root:Rule 230   primary -> parenthesized_primary
INFO:root:Rule 231   parenthesized_primary -> aggregate
INFO:root:Rule 232   parenthesized_primary -> ( expression )
INFO:root:Rule 233   qualified -> name TICK parenthesized_primary
INFO:root:Rule 234   allocator -> NEW name
INFO:root:Rule 235   allocator -> NEW qualified
INFO:root:Rule 236   statement_s -> statement
INFO:root:Rule 237   statement_s -> statement_s statement
INFO:root:Rule 238   statement -> unlabeled
INFO:root:Rule 239   statement -> label statement
INFO:root:Rule 240   unlabeled -> simple_stmt
INFO:root:Rule 241   unlabeled -> compound_stmt
INFO:root:Rule 242   simple_stmt -> null_stmt
INFO:root:Rule 243   simple_stmt -> assign_stmt
INFO:root:Rule 244   simple_stmt -> exit_stmt
INFO:root:Rule 245   simple_stmt -> return_stmt
INFO:root:Rule 246   simple_stmt -> procedure_call
INFO:root:Rule 247   simple_stmt -> delay_stmt
INFO:root:Rule 248   simple_stmt -> abort_stmt
INFO:root:Rule 249   simple_stmt -> raise_stmt
INFO:root:Rule 250   simple_stmt -> code_stmt
INFO:root:Rule 251   simple_stmt -> requeue_stmt
INFO:root:Rule 252   simple_stmt -> error ;
INFO:root:Rule 253   compound_stmt -> if_stmt
INFO:root:Rule 254   compound_stmt -> case_stmt
INFO:root:Rule 255   compound_stmt -> loop_stmt
INFO:root:Rule 256   compound_stmt -> block
INFO:root:Rule 257   compound_stmt -> accept_stmt
INFO:root:Rule 258   compound_stmt -> select_stmt
INFO:root:Rule 259   label -> LL IDENTIFIER RR
INFO:root:Rule 260   null_stmt -> NuLL ;
INFO:root:Rule 261   assign_stmt -> name ASSIGN expression ;
INFO:root:Rule 262   if_stmt -> IF cond_clause_s else_opt END IF ;
INFO:root:Rule 263   cond_clause_s -> cond_clause
INFO:root:Rule 264   cond_clause_s -> cond_clause_s ELSIF cond_clause
INFO:root:Rule 265   cond_clause -> cond_part statement_s
INFO:root:Rule 266   cond_part -> condition THEN
INFO:root:Rule 267   condition -> expression
INFO:root:Rule 268   else_opt -> <empty>
INFO:root:Rule 269   else_opt -> ELSE statement_s
INFO:root:Rule 270   case_stmt -> case_hdr pragma_s alternative_s END CASE ;
INFO:root:Rule 271   case_hdr -> CASE expression IS
INFO:root:Rule 272   alternative_s -> <empty>
INFO:root:Rule 273   alternative_s -> alternative_s alternative
INFO:root:Rule 274   alternative -> WHEN choice_s ARROW statement_s
INFO:root:Rule 275   loop_stmt -> label_opt iteration basic_loop id_opt ;
INFO:root:Rule 276   label_opt -> <empty>
INFO:root:Rule 277   label_opt -> IDENTIFIER :
INFO:root:Rule 278   iteration -> <empty>
INFO:root:Rule 279   iteration -> WHILE condition
INFO:root:Rule 280   iteration -> iter_part reverse_opt discrete_range
INFO:root:Rule 281   iter_part -> FOR IDENTIFIER IN
INFO:root:Rule 282   reverse_opt -> <empty>
INFO:root:Rule 283   reverse_opt -> REVERSE
INFO:root:Rule 284   basic_loop -> LOOP statement_s END LOOP
INFO:root:Rule 285   id_opt -> <empty>
INFO:root:Rule 286   id_opt -> designator
INFO:root:Rule 287   block -> label_opt block_decl block_body END id_opt ;
INFO:root:Rule 288   block_decl -> <empty>
INFO:root:Rule 289   block_decl -> DECLARE decl_part
INFO:root:Rule 290   block_body -> BEGIN handled_stmt_s
INFO:root:Rule 291   handled_stmt_s -> statement_s except_handler_part_opt
INFO:root:Rule 292   except_handler_part_opt -> <empty>
INFO:root:Rule 293   except_handler_part_opt -> except_handler_part
INFO:root:Rule 294   exit_stmt -> EXIT name_opt when_opt ;
INFO:root:Rule 295   name_opt -> <empty>
INFO:root:Rule 296   name_opt -> name
INFO:root:Rule 297   when_opt -> <empty>
INFO:root:Rule 298   when_opt -> WHEN condition
INFO:root:Rule 299   return_stmt -> RETURN ;
INFO:root:Rule 300   return_stmt -> RETURN expression ;
INFO:root:Rule 301   subprog_decl -> subprog_spec ;
INFO:root:Rule 302   subprog_decl -> generic_subp_inst ;
INFO:root:Rule 303   subprog_decl -> subprog_spec_is_push ABSTRACT ;
INFO:root:Rule 304   subprog_spec -> PROCEDURE compound_name formal_part_opt
INFO:root:Rule 305   subprog_spec -> FUNCTION designator formal_part_opt RETURN name
INFO:root:Rule 306   subprog_spec -> FUNCTION designator
INFO:root:Rule 307   designator -> compound_name
INFO:root:Rule 308   designator -> STRING
INFO:root:Rule 309   formal_part_opt -> <empty>
INFO:root:Rule 310   formal_part_opt -> formal_part
INFO:root:Rule 311   formal_part -> ( param_s )
INFO:root:Rule 312   param_s -> param
INFO:root:Rule 313   param_s -> param_s ; param
INFO:root:Rule 314   param -> def_id_s : mode mark init_opt
INFO:root:Rule 315   param -> error
INFO:root:Rule 316   mode -> <empty>
INFO:root:Rule 317   mode -> IN
INFO:root:Rule 318   mode -> OUT
INFO:root:Rule 319   mode -> IN OUT
INFO:root:Rule 320   mode -> ACCESS
INFO:root:Rule 321   subprog_spec_is_push -> subprog_spec IS
INFO:root:Rule 322   subprog_body -> subprog_spec_is_push decl_part block_body END id_opt ;
INFO:root:Rule 323   procedure_call -> name ;
INFO:root:Rule 324   pkg_decl -> pkg_spec ;
INFO:root:Rule 325   pkg_decl -> generic_pkg_inst ;
INFO:root:Rule 326   pkg_spec -> PACKAGE compound_name IS decl_item_s private_part END c_id_opt
INFO:root:Rule 327   private_part -> <empty>
INFO:root:Rule 328   private_part -> PRIVATE decl_item_s
INFO:root:Rule 329   c_id_opt -> <empty>
INFO:root:Rule 330   c_id_opt -> compound_name
INFO:root:Rule 331   pkg_body -> PACKAGE BODY compound_name IS decl_part body_opt END c_id_opt ;
INFO:root:Rule 332   body_opt -> <empty>
INFO:root:Rule 333   body_opt -> block_body
INFO:root:Rule 334   private_type -> tagged_opt limited_opt PRIVATE
INFO:root:Rule 335   limited_opt -> <empty>
INFO:root:Rule 336   limited_opt -> LIMITED
INFO:root:Rule 337   use_clause -> USE name_s ;
INFO:root:Rule 338   use_clause -> USE TYPE name_s ;
INFO:root:Rule 339   name_s -> name
INFO:root:Rule 340   name_s -> name_s , name
INFO:root:Rule 341   rename_decl -> def_id_s : object_qualifier_opt subtype_ind renames ;
INFO:root:Rule 342   rename_decl -> def_id_s : EXCEPTION renames ;
INFO:root:Rule 343   rename_decl -> rename_unit
INFO:root:Rule 344   rename_unit -> PACKAGE compound_name renames ;
INFO:root:Rule 345   rename_unit -> subprog_spec renames ;
INFO:root:Rule 346   rename_unit -> generic_formal_part PACKAGE compound_name renames ;
INFO:root:Rule 347   rename_unit -> generic_formal_part subprog_spec renames ;
INFO:root:Rule 348   renames -> RENAMES name
INFO:root:Rule 349   task_decl -> task_spec ;
INFO:root:Rule 350   task_spec -> TASK simple_name task_def
INFO:root:Rule 351   task_spec -> TASK TYPE simple_name discrim_part_opt task_def
INFO:root:Rule 352   task_def -> <empty>
INFO:root:Rule 353   task_def -> IS entry_decl_s rep_spec_s task_private_opt END id_opt
INFO:root:Rule 354   task_private_opt -> <empty>
INFO:root:Rule 355   task_private_opt -> PRIVATE entry_decl_s rep_spec_s
INFO:root:Rule 356   task_body -> TASK BODY simple_name IS decl_part block_body END id_opt ;
INFO:root:Rule 357   prot_decl -> prot_spec ;
INFO:root:Rule 358   prot_spec -> PROTECTED IDENTIFIER prot_def
INFO:root:Rule 359   prot_spec -> PROTECTED TYPE simple_name discrim_part_opt prot_def
INFO:root:Rule 360   prot_def -> IS prot_op_decl_s prot_private_opt END id_opt
INFO:root:Rule 361   prot_private_opt -> <empty>
INFO:root:Rule 362   prot_private_opt -> PRIVATE prot_elem_decl_s
INFO:root:Rule 363   prot_op_decl_s -> <empty>
INFO:root:Rule 364   prot_op_decl_s -> prot_op_decl_s prot_op_decl
INFO:root:Rule 365   prot_op_decl -> entry_decl
INFO:root:Rule 366   prot_op_decl -> subprog_spec ;
INFO:root:Rule 367   prot_op_decl -> rep_spec
INFO:root:Rule 368   prot_op_decl -> pragma
INFO:root:Rule 369   prot_elem_decl_s -> <empty>
INFO:root:Rule 370   prot_elem_decl_s -> prot_elem_decl_s prot_elem_decl
INFO:root:Rule 371   prot_elem_decl -> prot_op_decl
INFO:root:Rule 372   prot_elem_decl -> comp_decl
INFO:root:Rule 373   prot_body -> PROTECTED BODY simple_name IS prot_op_body_s END id_opt ;
INFO:root:Rule 374   prot_op_body_s -> pragma_s
INFO:root:Rule 375   prot_op_body_s -> prot_op_body_s prot_op_body pragma_s
INFO:root:Rule 376   prot_op_body -> entry_body
INFO:root:Rule 377   prot_op_body -> subprog_body
INFO:root:Rule 378   prot_op_body -> subprog_spec ;
INFO:root:Rule 379   entry_decl_s -> pragma_s
INFO:root:Rule 380   entry_decl_s -> entry_decl_s entry_decl pragma_s
INFO:root:Rule 381   entry_decl -> ENTRY IDENTIFIER formal_part_opt ;
INFO:root:Rule 382   entry_decl -> ENTRY IDENTIFIER ( discrete_range ) formal_part_opt ;
INFO:root:Rule 383   entry_body -> ENTRY IDENTIFIER formal_part_opt WHEN condition entry_body_part
INFO:root:Rule 384   entry_body -> ENTRY IDENTIFIER ( iter_part discrete_range ) formal_part_opt WHEN condition entry_body_part
INFO:root:Rule 385   entry_body_part -> ;
INFO:root:Rule 386   entry_body_part -> IS decl_part block_body END id_opt ;
INFO:root:Rule 387   rep_spec_s -> <empty>
INFO:root:Rule 388   rep_spec_s -> rep_spec_s rep_spec pragma_s
INFO:root:Rule 389   entry_call -> procedure_call
INFO:root:Rule 390   accept_stmt -> accept_hdr ;
INFO:root:Rule 391   accept_stmt -> accept_hdr DO handled_stmt_s END id_opt ;
INFO:root:Rule 392   accept_hdr -> ACCEPT entry_name formal_part_opt
INFO:root:Rule 393   entry_name -> simple_name
INFO:root:Rule 394   entry_name -> entry_name ( expression )
INFO:root:Rule 395   delay_stmt -> DELAY expression ;
INFO:root:Rule 396   delay_stmt -> DELAY UNTIL expression ;
INFO:root:Rule 397   select_stmt -> select_wait
INFO:root:Rule 398   select_stmt -> async_select
INFO:root:Rule 399   select_stmt -> timed_entry_call
INFO:root:Rule 400   select_stmt -> cond_entry_call
INFO:root:Rule 401   select_wait -> SELECT guarded_select_alt or_select else_opt END SELECT ;
INFO:root:Rule 402   guarded_select_alt -> select_alt
INFO:root:Rule 403   guarded_select_alt -> WHEN condition ARROW select_alt
INFO:root:Rule 404   or_select -> <empty>
INFO:root:Rule 405   or_select -> or_select OR guarded_select_alt
INFO:root:Rule 406   select_alt -> accept_stmt stmts_opt
INFO:root:Rule 407   select_alt -> delay_stmt stmts_opt
INFO:root:Rule 408   select_alt -> TERMINATE ;
INFO:root:Rule 409   delay_or_entry_alt -> delay_stmt stmts_opt
INFO:root:Rule 410   delay_or_entry_alt -> entry_call stmts_opt
INFO:root:Rule 411   async_select -> SELECT delay_or_entry_alt THEN ABORT statement_s END SELECT ;
INFO:root:Rule 412   timed_entry_call -> SELECT entry_call stmts_opt OR delay_stmt stmts_opt END SELECT ;
INFO:root:Rule 413   cond_entry_call -> SELECT entry_call stmts_opt ELSE statement_s END SELECT ;
INFO:root:Rule 414   stmts_opt -> <empty>
INFO:root:Rule 415   stmts_opt -> statement_s
INFO:root:Rule 416   abort_stmt -> ABORT name_s ;
INFO:root:Rule 417   compilation -> <empty>
INFO:root:Rule 418   compilation -> compilation comp_unit
INFO:root:Rule 419   compilation -> pragma pragma_s
INFO:root:Rule 420   comp_unit -> context_spec private_opt unit pragma_s
INFO:root:Rule 421   comp_unit -> private_opt unit pragma_s
INFO:root:Rule 422   private_opt -> <empty>
INFO:root:Rule 423   private_opt -> PRIVATE
INFO:root:Rule 424   context_spec -> with_clause use_clause_opt
INFO:root:Rule 425   context_spec -> context_spec with_clause use_clause_opt
INFO:root:Rule 426   context_spec -> context_spec pragma
INFO:root:Rule 427   with_clause -> WITH c_name_list ;
INFO:root:Rule 428   use_clause_opt -> <empty>
INFO:root:Rule 429   use_clause_opt -> use_clause_opt use_clause
INFO:root:Rule 430   unit -> pkg_decl
INFO:root:Rule 431   unit -> pkg_body
INFO:root:Rule 432   unit -> subprog_decl
INFO:root:Rule 433   unit -> subprog_body
INFO:root:Rule 434   unit -> subunit
INFO:root:Rule 435   unit -> generic_decl
INFO:root:Rule 436   unit -> rename_unit
INFO:root:Rule 437   subunit -> SEPARATE ( compound_name ) subunit_body
INFO:root:Rule 438   subunit_body -> subprog_body
INFO:root:Rule 439   subunit_body -> pkg_body
INFO:root:Rule 440   subunit_body -> task_body
INFO:root:Rule 441   subunit_body -> prot_body
INFO:root:Rule 442   body_stub -> TASK BODY simple_name IS SEPARATE ;
INFO:root:Rule 443   body_stub -> PACKAGE BODY compound_name IS SEPARATE ;
INFO:root:Rule 444   body_stub -> subprog_spec IS SEPARATE ;
INFO:root:Rule 445   body_stub -> PROTECTED BODY simple_name IS SEPARATE ;
INFO:root:Rule 446   exception_decl -> def_id_s : EXCEPTION ;
INFO:root:Rule 447   except_handler_part -> EXCEPTION exception_handler
INFO:root:Rule 448   except_handler_part -> except_handler_part exception_handler
INFO:root:Rule 449   exception_handler -> WHEN except_choice_s ARROW statement_s
INFO:root:Rule 450   exception_handler -> WHEN IDENTIFIER : except_choice_s ARROW statement_s
INFO:root:Rule 451   except_choice_s -> except_choice
INFO:root:Rule 452   except_choice_s -> except_choice_s | except_choice
INFO:root:Rule 453   except_choice -> name
INFO:root:Rule 454   except_choice -> OTHERS
INFO:root:Rule 455   raise_stmt -> RAISE name_opt ;
INFO:root:Rule 456   requeue_stmt -> REQUEUE name ;
INFO:root:Rule 457   requeue_stmt -> REQUEUE name WITH ABORT ;
INFO:root:Rule 458   generic_decl -> generic_formal_part subprog_spec ;
INFO:root:Rule 459   generic_decl -> generic_formal_part pkg_spec ;
INFO:root:Rule 460   generic_formal_part -> GENERIC
INFO:root:Rule 461   generic_formal_part -> generic_formal_part generic_formal
INFO:root:Rule 462   generic_formal -> param ;
INFO:root:Rule 463   generic_formal -> TYPE simple_name generic_discrim_part_opt IS generic_type_def ;
INFO:root:Rule 464   generic_formal -> WITH PROCEDURE simple_name formal_part_opt subp_default ;
INFO:root:Rule 465   generic_formal -> WITH FUNCTION designator formal_part_opt RETURN name subp_default ;
INFO:root:Rule 466   generic_formal -> WITH PACKAGE simple_name IS NEW name ( BOX ) ;
INFO:root:Rule 467   generic_formal -> WITH PACKAGE simple_name IS NEW name ;
INFO:root:Rule 468   generic_formal -> use_clause
INFO:root:Rule 469   generic_discrim_part_opt -> <empty>
INFO:root:Rule 470   generic_discrim_part_opt -> discrim_part
INFO:root:Rule 471   generic_discrim_part_opt -> ( BOX )
INFO:root:Rule 472   subp_default -> <empty>
INFO:root:Rule 473   subp_default -> IS name
INFO:root:Rule 474   subp_default -> IS BOX
INFO:root:Rule 475   generic_type_def -> ( BOX )
INFO:root:Rule 476   generic_type_def -> RANGE BOX
INFO:root:Rule 477   generic_type_def -> MOD BOX
INFO:root:Rule 478   generic_type_def -> DELTA BOX
INFO:root:Rule 479   generic_type_def -> DELTA BOX DIGITS BOX
INFO:root:Rule 480   generic_type_def -> DIGITS BOX
INFO:root:Rule 481   generic_type_def -> array_type
INFO:root:Rule 482   generic_type_def -> access_type
INFO:root:Rule 483   generic_type_def -> private_type
INFO:root:Rule 484   generic_type_def -> generic_derived_type
INFO:root:Rule 485   generic_derived_type -> NEW subtype_ind
INFO:root:Rule 486   generic_derived_type -> NEW subtype_ind WITH PRIVATE
INFO:root:Rule 487   generic_derived_type -> ABSTRACT NEW subtype_ind WITH PRIVATE
INFO:root:Rule 488   generic_subp_inst -> subprog_spec IS generic_inst
INFO:root:Rule 489   generic_pkg_inst -> PACKAGE compound_name IS generic_inst
INFO:root:Rule 490   generic_inst -> NEW name
INFO:root:Rule 491   rep_spec -> attrib_def
INFO:root:Rule 492   rep_spec -> record_type_spec
INFO:root:Rule 493   rep_spec -> address_spec
INFO:root:Rule 494   attrib_def -> FOR mark USE expression ;
INFO:root:Rule 495   record_type_spec -> FOR mark USE RECORD align_opt comp_loc_s END RECORD ;
INFO:root:Rule 496   align_opt -> <empty>
INFO:root:Rule 497   align_opt -> AT MOD expression ;
INFO:root:Rule 498   comp_loc_s -> <empty>
INFO:root:Rule 499   comp_loc_s -> comp_loc_s mark AT expression RANGE range ;
INFO:root:Rule 500   address_spec -> FOR mark USE AT expression ;
INFO:root:Rule 501   code_stmt -> qualified ;
INFO:root:
INFO:root:Terminals, with rules where they appear
INFO:root:
INFO:root:&                    : 215
INFO:root:(                    : 3 39 63 80 88 110 164 183 184 185 186 232 311 382 384 394 437 466 471 475
INFO:root:)                    : 3 39 63 80 88 110 164 183 184 185 186 232 311 382 384 394 437 466 471 475
INFO:root:*                    : 218
INFO:root:+                    : 211 213
INFO:root:,                    : 5 25 65 86 90 161 166 340
INFO:root:-                    : 212 214
INFO:root:.                    : 156 159 171 172 173 174
INFO:root:/                    : 219
INFO:root::                    : 23 35 108 113 277 314 341 342 446 450
INFO:root:;                    : 2 3 22 23 35 36 50 103 108 109 112 117 252 260 261 262 270 275 287 294 299 300 301 302 303 313 322 323 324 325 331 337 338 341 342 344 345 346 347 349 356 357 366 373 378 381 382 385 386 390 391 395 396 401 408 411 412 413 416 427 442 443 444 445 446 455 456 457 458 459 462 463 464 465 466 467 494 495 497 499 500 501
INFO:root:<                    : 202
INFO:root:=                    : 200
INFO:root:>                    : 204
INFO:root:ABORT                : 411 416 457
INFO:root:ABS                  : 225
INFO:root:ABSTRACT             : 59 60 100 303 487
INFO:root:ACCEPT               : 392
INFO:root:ACCESS               : 116 128 129 130 179 320
INFO:root:ALIASED              : 28 30 84
INFO:root:ALL                  : 130 174
INFO:root:AND                  : 191 194
INFO:root:ARRAY                : 80 81
INFO:root:ARROW                : 7 120 187 274 403 449 450
INFO:root:ASSIGN               : 34 35 261
INFO:root:AT                   : 497 499 500
INFO:root:BEGIN                : 290
INFO:root:BODY                 : 331 356 373 442 443 445
INFO:root:BOX                  : 39 87 466 471 474 475 476 477 478 479 479 480
INFO:root:CASE                 : 117 117 270 271
INFO:root:CHAR                 : 67 162
INFO:root:CONSTANT             : 29 30 35 129
INFO:root:DECLARE              : 289
INFO:root:DELAY                : 395 396
INFO:root:DELTA                : 76 77 178 478 479
INFO:root:DIGITS               : 55 75 77 177 479 480
INFO:root:DO                   : 391
INFO:root:DOTDOT               : 62
INFO:root:ELSE                 : 195 269 413
INFO:root:ELSIF                : 264
INFO:root:END                  : 96 117 262 270 284 287 322 326 331 353 356 360 373 386 391 401 411 412 413 495
INFO:root:ENTRY                : 381 382 383 384
INFO:root:EXCEPTION            : 342 446 447
INFO:root:EXIT                 : 294
INFO:root:FLOAT                : 181
INFO:root:FOR                  : 281 494 495 500
INFO:root:FUNCTION             : 305 306 465
INFO:root:GENERIC              : 460
INFO:root:GEQ                  : 205
INFO:root:IDENTIFIER           : 2 26 36 50 66 157 176 259 277 281 358 381 382 383 384 450
INFO:root:IF                   : 262 262
INFO:root:IN                   : 206 207 281 317 319
INFO:root:INT                  : 180
INFO:root:IS                   : 41 50 117 271 321 326 331 353 356 360 373 386 442 443 444 445 463 466 467 473 474 488 489
INFO:root:LEQ                  : 203
INFO:root:LIMITED              : 336
INFO:root:LL                   : 259
INFO:root:LOOP                 : 284 284
INFO:root:MOD                  : 69 220 477 497
INFO:root:NEQ                  : 201
INFO:root:NEW                  : 56 57 58 59 60 234 235 466 467 485 486 487 490
INFO:root:NOT                  : 207 224
INFO:root:NuLL                 : 97 103 182 185 186 260
INFO:root:OF                   : 80 81
INFO:root:OR                   : 192 195 405 412
INFO:root:OTHERS               : 125 454
INFO:root:OUT                  : 318 319
INFO:root:PACKAGE              : 326 331 344 346 443 466 467 489
INFO:root:PRAGMA               : 2 3
INFO:root:PRIVATE              : 57 59 328 334 355 362 423 486 487
INFO:root:PROCEDURE            : 304 464
INFO:root:PROTECTED            : 358 359 373 445
INFO:root:RAISE                : 455
INFO:root:RANGE                : 61 87 476 499
INFO:root:RECORD               : 96 96 97 185 186 495 495
INFO:root:REM                  : 221
INFO:root:RENAMES              : 348
INFO:root:REQUEUE              : 456 457
INFO:root:RETURN               : 299 300 305 465
INFO:root:REVERSE              : 283
INFO:root:RR                   : 259
INFO:root:SELECT               : 401 401 411 411 412 412 413 413
INFO:root:SEPARATE             : 437 442 443 444 445
INFO:root:STARSTAR             : 222
INFO:root:STRING               : 163 308
INFO:root:SUBTYPE              : 50
INFO:root:TAGGED               : 99 100
INFO:root:TASK                 : 350 351 356 442
INFO:root:TERMINATE            : 408
INFO:root:THEN                 : 194 266 411
INFO:root:TICK                 : 155 175 233
INFO:root:TYPE                 : 36 338 351 359 463
INFO:root:UNTIL                : 396
INFO:root:USE                  : 337 338 494 495 500
INFO:root:WHEN                 : 120 274 298 383 384 403 449 450
INFO:root:WHILE                : 279
INFO:root:WITH                 : 57 58 59 60 184 185 427 457 464 465 466 467 486 487
INFO:root:XOR                  : 193
INFO:root:error                : 22 109 114 170 252 315
INFO:root:|                    : 122 452
INFO:root:
INFO:root:Nonterminals, with rules where they appear
INFO:root:
INFO:root:abort_stmt           : 248
INFO:root:accept_hdr           : 390 391
INFO:root:accept_stmt          : 257 406
INFO:root:access_opt           : 113
INFO:root:access_type          : 47 482
INFO:root:adding               : 210
INFO:root:address_spec         : 493
INFO:root:aggregate            : 231
INFO:root:aliased_opt          : 82
INFO:root:align_opt            : 495
INFO:root:allocator            : 228
INFO:root:alternative          : 273
INFO:root:alternative_s        : 270 273
INFO:root:array_type           : 32 45 481
INFO:root:assign_stmt          : 243
INFO:root:async_select         : 398
INFO:root:attrib_def           : 491
INFO:root:attribute            : 152
INFO:root:attribute_id         : 155 175
INFO:root:basic_loop           : 275
INFO:root:block                : 256
INFO:root:block_body           : 287 322 333 356 386
INFO:root:block_decl           : 287
INFO:root:body                 : 143
INFO:root:body_opt             : 331
INFO:root:body_stub            : 21
INFO:root:c_id_opt             : 326 331
INFO:root:c_name_list          : 161 427
INFO:root:case_hdr             : 270
INFO:root:case_stmt            : 254
INFO:root:choice               : 121 122
INFO:root:choice_s             : 120 122 187 274
INFO:root:code_stmt            : 250
INFO:root:comp_assoc           : 168 183
INFO:root:comp_decl            : 104 105 372
INFO:root:comp_decl_s          : 101 105
INFO:root:comp_list            : 96 120
INFO:root:comp_loc_s           : 495 499
INFO:root:comp_unit            : 418
INFO:root:compilation          : 1 418
INFO:root:component_subtype_def : 80 81 108
INFO:root:compound_name        : 159 160 161 304 307 326 330 331 344 346 437 443 489
INFO:root:compound_stmt        : 241
INFO:root:cond_clause          : 263 264
INFO:root:cond_clause_s        : 262 264
INFO:root:cond_entry_call      : 400
INFO:root:cond_part            : 265
INFO:root:condition            : 266 279 298 383 384 403
INFO:root:constr_array_type    : 79
INFO:root:constraint           : 51
INFO:root:context_spec         : 420 425 426
INFO:root:decimal_digits_constraint : 54
INFO:root:decl                 : 137
INFO:root:decl_item            : 135 136 144
INFO:root:decl_item_or_body    : 141 142
INFO:root:decl_item_or_body_s1 : 132 142
INFO:root:decl_item_s          : 326 328
INFO:root:decl_item_s1         : 134 136
INFO:root:decl_part            : 289 322 331 356 386
INFO:root:def_id               : 24 25
INFO:root:def_id_s             : 23 25 35 108 113 314 341 342 446
INFO:root:delay_or_entry_alt   : 411
INFO:root:delay_stmt           : 247 407 409 412
INFO:root:derived_type         : 48
INFO:root:designator           : 286 305 306 465
INFO:root:discrete_range       : 89 90 280 382 384
INFO:root:discrete_with_range  : 124 169
INFO:root:discrim_part         : 38 470
INFO:root:discrim_part_opt     : 36 351 359
INFO:root:discrim_spec         : 111 112
INFO:root:discrim_spec_s       : 110 112
INFO:root:else_opt             : 262 401
INFO:root:entry_body           : 376
INFO:root:entry_body_part      : 383 384
INFO:root:entry_call           : 410 412 413
INFO:root:entry_decl           : 365 380
INFO:root:entry_decl_s         : 353 355 380
INFO:root:entry_name           : 392 394
INFO:root:enum_id              : 64 65
INFO:root:enum_id_s            : 63 65
INFO:root:enumeration_type     : 42
INFO:root:except_choice        : 451 452
INFO:root:except_choice_s      : 449 450 452
INFO:root:except_handler_part  : 293 448
INFO:root:except_handler_part_opt : 291
INFO:root:exception_decl       : 18
INFO:root:exception_handler    : 447 448
INFO:root:exit_stmt            : 244
INFO:root:expression           : 6 7 34 35 55 69 75 76 77 77 123 167 184 185 187 189 190 232 261 267 271 300 394 395 396 494 497 499 500
INFO:root:factor               : 216 217
INFO:root:fixed_type           : 74
INFO:root:float_type           : 73
INFO:root:formal_part          : 310
INFO:root:formal_part_opt      : 304 305 381 382 383 384 392 464 465
INFO:root:generic_decl         : 20 435
INFO:root:generic_derived_type : 484
INFO:root:generic_discrim_part_opt : 463
INFO:root:generic_formal       : 461
INFO:root:generic_formal_part  : 346 347 458 459 461
INFO:root:generic_inst         : 488 489
INFO:root:generic_pkg_inst     : 325
INFO:root:generic_subp_inst    : 302
INFO:root:generic_type_def     : 463
INFO:root:goal_symbol          : 0
INFO:root:guarded_select_alt   : 401 405
INFO:root:handled_stmt_s       : 290 391
INFO:root:id_opt               : 275 287 322 353 356 360 373 386 391
INFO:root:if_stmt              : 253
INFO:root:index                : 85 86
INFO:root:index_s              : 80 86
INFO:root:indexed_comp         : 150
INFO:root:init_opt             : 23 108 113 314
INFO:root:integer_type         : 43
INFO:root:iter_discrete_range_s : 88 90
INFO:root:iter_index_constraint : 81
INFO:root:iter_part            : 280 384
INFO:root:iteration            : 275
INFO:root:label                : 239
INFO:root:label_opt            : 275 287
INFO:root:limited_opt          : 95 334
INFO:root:literal              : 226
INFO:root:logical              : 189
INFO:root:loop_stmt            : 255
INFO:root:mark                 : 113 155 156 314 494 495 499 500
INFO:root:membership           : 198 199
INFO:root:mode                 : 314
INFO:root:multiplying          : 217
INFO:root:name                 : 51 52 87 91 126 164 171 172 173 174 175 199 227 233 234 261 296 305 323 339 340 348 453 456 457 465 466 467 473 490
INFO:root:name_opt             : 294 455
INFO:root:name_s               : 337 338 340 416
INFO:root:null_stmt            : 242
INFO:root:number_decl          : 11
INFO:root:object_decl          : 10
INFO:root:object_qualifier_opt : 23 341
INFO:root:object_subtype_def   : 23
INFO:root:operator_symbol      : 153 173
INFO:root:or_select            : 401 405
INFO:root:param                : 312 313 462
INFO:root:param_s              : 311 313
INFO:root:parenthesized_primary : 230 233
INFO:root:pkg_body             : 146 431 439
INFO:root:pkg_decl             : 15 430
INFO:root:pkg_spec             : 324 459
INFO:root:pragma               : 9 140 368 419 426
INFO:root:pragma_arg           : 4 5
INFO:root:pragma_arg_s         : 3 5
INFO:root:pragma_s             : 9 96 102 103 105 106 107 107 117 120 270 374 375 379 380 388 419 420 421
INFO:root:primary              : 223 224 225
INFO:root:private_opt          : 420 421
INFO:root:private_part         : 326
INFO:root:private_type         : 49 483
INFO:root:procedure_call       : 246 389
INFO:root:prot_body            : 148 441
INFO:root:prot_decl            : 17
INFO:root:prot_def             : 358 359
INFO:root:prot_elem_decl       : 370
INFO:root:prot_elem_decl_s     : 362 370
INFO:root:prot_op_body         : 375
INFO:root:prot_op_body_s       : 373 375
INFO:root:prot_op_decl         : 364 371
INFO:root:prot_op_decl_s       : 360 364
INFO:root:prot_private_opt     : 360
INFO:root:prot_spec            : 357
INFO:root:qualified            : 229 235 501
INFO:root:raise_stmt           : 249
INFO:root:range                : 61 92 127 198 499
INFO:root:range_constr_opt     : 55 91
INFO:root:range_constraint     : 53 70 94 126
INFO:root:range_spec           : 68 72 76
INFO:root:range_spec_opt       : 75 77
INFO:root:real_type            : 44
INFO:root:record_def           : 58 60 95
INFO:root:record_type          : 46
INFO:root:record_type_spec     : 492
INFO:root:relation             : 188 189 190
INFO:root:relational           : 197
INFO:root:rename_decl          : 19
INFO:root:rename_unit          : 343 436
INFO:root:renames              : 341 342 344 345 346 347
INFO:root:rep_spec             : 139 367 388
INFO:root:rep_spec_s           : 353 355 388
INFO:root:requeue_stmt         : 251
INFO:root:return_stmt          : 245
INFO:root:reverse_opt          : 280
INFO:root:select_alt           : 402 403
INFO:root:select_stmt          : 258
INFO:root:select_wait          : 397
INFO:root:selected_comp        : 151
INFO:root:short_circuit        : 190
INFO:root:simple_expression    : 62 62 196 197 197 198 199 210
INFO:root:simple_name          : 3 7 117 149 154 156 158 159 171 350 351 356 359 373 393 442 445 463 464 466 467
INFO:root:simple_stmt          : 240
INFO:root:statement            : 236 237 239
INFO:root:statement_s          : 237 265 269 274 284 291 411 413 415 449 450
INFO:root:stmts_opt            : 406 407 409 410 412 412 413
INFO:root:subp_default         : 464 465
INFO:root:subprog_body         : 145 377 433 438
INFO:root:subprog_decl         : 14 432
INFO:root:subprog_spec         : 301 321 345 347 366 378 444 458 488
INFO:root:subprog_spec_is_push : 303 322
INFO:root:subtype_decl         : 13
INFO:root:subtype_ind          : 31 50 56 57 58 59 60 82 128 129 130 341 485 486 487
INFO:root:subunit              : 434
INFO:root:subunit_body         : 437
INFO:root:tagged_opt           : 95 334
INFO:root:task_body            : 147 440
INFO:root:task_decl            : 16
INFO:root:task_def             : 350 351
INFO:root:task_private_opt     : 353
INFO:root:task_spec            : 349
INFO:root:term                 : 208 209 210 217
INFO:root:timed_entry_call     : 399
INFO:root:type_completion      : 36
INFO:root:type_decl            : 12
INFO:root:type_def             : 41
INFO:root:unary                : 208
INFO:root:unconstr_array_type  : 78
INFO:root:unit                 : 420 421
INFO:root:unlabeled            : 238
INFO:root:use_clause           : 138 429 468
INFO:root:use_clause_opt       : 424 425 429
INFO:root:used_char            : 172
INFO:root:value                : 165 166
INFO:root:value_s              : 164 166 184
INFO:root:variant              : 118 119
INFO:root:variant_part         : 102 107
INFO:root:variant_part_opt     : 101
INFO:root:variant_s            : 117 119
INFO:root:when_opt             : 294
INFO:root:with_clause          : 424 425
INFO:root:
INFO:root:Parsing method: LALR
INFO:root:
INFO:root:state 0
INFO:root:
INFO:root:    (0) S' -> . goal_symbol
INFO:root:    (1) goal_symbol -> . compilation
INFO:root:    (417) compilation -> .
INFO:root:    (418) compilation -> . compilation comp_unit
INFO:root:    (419) compilation -> . pragma pragma_s
INFO:root:    (2) pragma -> . PRAGMA IDENTIFIER ;
INFO:root:    (3) pragma -> . PRAGMA simple_name ( pragma_arg_s ) ;
INFO:root:
INFO:root:    PRIVATE         reduce using rule 417 (compilation -> .)
INFO:root:    WITH            reduce using rule 417 (compilation -> .)
INFO:root:    PACKAGE         reduce using rule 417 (compilation -> .)
INFO:root:    SEPARATE        reduce using rule 417 (compilation -> .)
INFO:root:    PROCEDURE       reduce using rule 417 (compilation -> .)
INFO:root:    FUNCTION        reduce using rule 417 (compilation -> .)
INFO:root:    GENERIC         reduce using rule 417 (compilation -> .)
INFO:root:    $end            reduce using rule 417 (compilation -> .)
INFO:root:    PRAGMA          shift and go to state 2
INFO:root:
INFO:root:    goal_symbol                    shift and go to state 3
INFO:root:    compilation                    shift and go to state 1
INFO:root:    pragma                         shift and go to state 4
INFO:root:
INFO:root:state 1
INFO:root:
INFO:root:    (1) goal_symbol -> compilation .
INFO:root:    (418) compilation -> compilation . comp_unit
INFO:root:    (420) comp_unit -> . context_spec private_opt unit pragma_s
INFO:root:    (421) comp_unit -> . private_opt unit pragma_s
INFO:root:    (424) context_spec -> . with_clause use_clause_opt
INFO:root:    (425) context_spec -> . context_spec with_clause use_clause_opt
INFO:root:    (426) context_spec -> . context_spec pragma
INFO:root:    (422) private_opt -> .
INFO:root:    (423) private_opt -> . PRIVATE
INFO:root:    (427) with_clause -> . WITH c_name_list ;
INFO:root:
INFO:root:    $end            reduce using rule 1 (goal_symbol -> compilation .)
INFO:root:    PACKAGE         reduce using rule 422 (private_opt -> .)
INFO:root:    SEPARATE        reduce using rule 422 (private_opt -> .)
INFO:root:    PROCEDURE       reduce using rule 422 (private_opt -> .)
INFO:root:    FUNCTION        reduce using rule 422 (private_opt -> .)
INFO:root:    GENERIC         reduce using rule 422 (private_opt -> .)
INFO:root:    PRIVATE         shift and go to state 7
INFO:root:    WITH            shift and go to state 6
INFO:root:
INFO:root:    private_opt                    shift and go to state 5
INFO:root:    context_spec                   shift and go to state 8
INFO:root:    comp_unit                      shift and go to state 9
INFO:root:    with_clause                    shift and go to state 10
INFO:root:
INFO:root:state 2
INFO:root:
INFO:root:    (2) pragma -> PRAGMA . IDENTIFIER ;
INFO:root:    (3) pragma -> PRAGMA . simple_name ( pragma_arg_s ) ;
INFO:root:    (157) simple_name -> . IDENTIFIER
INFO:root:
INFO:root:    IDENTIFIER      shift and go to state 12
INFO:root:
INFO:root:    simple_name                    shift and go to state 11
INFO:root:
INFO:root:state 3
INFO:root:
INFO:root:    (0) S' -> goal_symbol .
INFO:root:
INFO:root:
INFO:root:
INFO:root:state 4
INFO:root:
INFO:root:    (419) compilation -> pragma . pragma_s
INFO:root:    (8) pragma_s -> .
INFO:root:    (9) pragma_s -> . pragma_s pragma
INFO:root:
INFO:root:    PRAGMA          reduce using rule 8 (pragma_s -> .)
INFO:root:    PRIVATE         reduce using rule 8 (pragma_s -> .)
INFO:root:    WITH            reduce using rule 8 (pragma_s -> .)
INFO:root:    PACKAGE         reduce using rule 8 (pragma_s -> .)
INFO:root:    SEPARATE        reduce using rule 8 (pragma_s -> .)
INFO:root:    PROCEDURE       reduce using rule 8 (pragma_s -> .)
INFO:root:    FUNCTION        reduce using rule 8 (pragma_s -> .)
INFO:root:    GENERIC         reduce using rule 8 (pragma_s -> .)
INFO:root:    $end            reduce using rule 8 (pragma_s -> .)
INFO:root:
INFO:root:    pragma_s                       shift and go to state 13
INFO:root:
INFO:root:state 5
INFO:root:
INFO:root:    (421) comp_unit -> private_opt . unit pragma_s
INFO:root:    (430) unit -> . pkg_decl
INFO:root:    (431) unit -> . pkg_body
INFO:root:    (432) unit -> . subprog_decl
INFO:root:    (433) unit -> . subprog_body
INFO:root:    (434) unit -> . subunit
INFO:root:    (435) unit -> . generic_decl
INFO:root:    (436) unit -> . rename_unit
INFO:root:    (324) pkg_decl -> . pkg_spec ;
INFO:root:    (325) pkg_decl -> . generic_pkg_inst ;
INFO:root:    (331) pkg_body -> . PACKAGE BODY compound_name IS decl_part body_opt END c_id_opt ;
INFO:root:    (301) subprog_decl -> . subprog_spec ;
INFO:root:    (302) subprog_decl -> . generic_subp_inst ;
INFO:root:    (303) subprog_decl -> . subprog_spec_is_push ABSTRACT ;
INFO:root:    (322) subprog_body -> . subprog_spec_is_push decl_part block_body END id_opt ;
INFO:root:    (437) subunit -> . SEPARATE ( compound_name ) subunit_body
INFO:root:    (458) generic_decl -> . generic_formal_part subprog_spec ;
INFO:root:    (459) generic_decl -> . generic_formal_part pkg_spec ;
INFO:root:    (344) rename_unit -> . PACKAGE compound_name renames ;
INFO:root:    (345) rename_unit -> . subprog_spec renames ;
INFO:root:    (346) rename_unit -> . generic_formal_part PACKAGE compound_name renames ;
INFO:root:    (347) rename_unit -> . generic_formal_part subprog_spec renames ;
INFO:root:    (326) pkg_spec -> . PACKAGE compound_name IS decl_item_s private_part END c_id_opt
INFO:root:    (489) generic_pkg_inst -> . PACKAGE compound_name IS generic_inst
INFO:root:    (304) subprog_spec -> . PROCEDURE compound_name formal_part_opt
INFO:root:    (305) subprog_spec -> . FUNCTION designator formal_part_opt RETURN name
INFO:root:    (306) subprog_spec -> . FUNCTION designator
INFO:root:    (488) generic_subp_inst -> . subprog_spec IS generic_inst
INFO:root:    (321) subprog_spec_is_push -> . subprog_spec IS
INFO:root:    (460) generic_formal_part -> . GENERIC
INFO:root:    (461) generic_formal_part -> . generic_formal_part generic_formal
INFO:root:
INFO:root:    PACKAGE         shift and go to state 28
INFO:root:    SEPARATE        shift and go to state 22
INFO:root:    PROCEDURE       shift and go to state 17
INFO:root:    FUNCTION        shift and go to state 23
INFO:root:    GENERIC         shift and go to state 26
INFO:root:
INFO:root:    generic_subp_inst              shift and go to state 24
INFO:root:    subprog_decl                   shift and go to state 18
INFO:root:    pkg_decl                       shift and go to state 14
INFO:root:    generic_decl                   shift and go to state 15
INFO:root:    rename_unit                    shift and go to state 25
INFO:root:    subprog_spec                   shift and go to state 27
INFO:root:    generic_pkg_inst               shift and go to state 19
INFO:root:    pkg_spec                       shift and go to state 16
INFO:root:    subunit                        shift and go to state 29
INFO:root:    pkg_body                       shift and go to state 30
INFO:root:    generic_formal_part            shift and go to state 20
INFO:root:    unit                           shift and go to state 21
INFO:root:    subprog_body                   shift and go to state 32
INFO:root:    subprog_spec_is_push           shift and go to state 31
INFO:root:
INFO:root:state 6
INFO:root:
INFO:root:    (427) with_clause -> WITH . c_name_list ;
INFO:root:    (160) c_name_list -> . compound_name
INFO:root:    (161) c_name_list -> . c_name_list , compound_name
INFO:root:    (158) compound_name -> . simple_name
INFO:root:    (159) compound_name -> . compound_name . simple_name
INFO:root:    (157) simple_name -> . IDENTIFIER
INFO:root:
INFO:root:    IDENTIFIER      shift and go to state 33
INFO:root:
INFO:root:    c_name_list                    shift and go to state 35
INFO:root:    simple_name                    shift and go to state 34
INFO:root:    compound_name                  shift and go to state 36
INFO:root:
INFO:root:state 7
INFO:root:
INFO:root:    (423) private_opt -> PRIVATE .
INFO:root:
INFO:root:    PACKAGE         reduce using rule 423 (private_opt -> PRIVATE .)
INFO:root:    SEPARATE        reduce using rule 423 (private_opt -> PRIVATE .)
INFO:root:    PROCEDURE       reduce using rule 423 (private_opt -> PRIVATE .)
INFO:root:    FUNCTION        reduce using rule 423 (private_opt -> PRIVATE .)
INFO:root:    GENERIC         reduce using rule 423 (private_opt -> PRIVATE .)
INFO:root:
INFO:root:
INFO:root:state 8
INFO:root:
INFO:root:    (420) comp_unit -> context_spec . private_opt unit pragma_s
INFO:root:    (425) context_spec -> context_spec . with_clause use_clause_opt
INFO:root:    (426) context_spec -> context_spec . pragma
INFO:root:    (422) private_opt -> .
INFO:root:    (423) private_opt -> . PRIVATE
INFO:root:    (427) with_clause -> . WITH c_name_list ;
INFO:root:    (2) pragma -> . PRAGMA IDENTIFIER ;
INFO:root:    (3) pragma -> . PRAGMA simple_name ( pragma_arg_s ) ;
INFO:root:
INFO:root:    PACKAGE         reduce using rule 422 (private_opt -> .)
INFO:root:    SEPARATE        reduce using rule 422 (private_opt -> .)
INFO:root:    PROCEDURE       reduce using rule 422 (private_opt -> .)
INFO:root:    FUNCTION        reduce using rule 422 (private_opt -> .)
INFO:root:    GENERIC         reduce using rule 422 (private_opt -> .)
INFO:root:    PRIVATE         shift and go to state 7
INFO:root:    WITH            shift and go to state 6
INFO:root:    PRAGMA          shift and go to state 2
INFO:root:
INFO:root:    private_opt                    shift and go to state 37
INFO:root:    with_clause                    shift and go to state 39
INFO:root:    pragma                         shift and go to state 38
INFO:root:
INFO:root:state 9
INFO:root:
INFO:root:    (418) compilation -> compilation comp_unit .
INFO:root:
INFO:root:    PRIVATE         reduce using rule 418 (compilation -> compilation comp_unit .)
INFO:root:    WITH            reduce using rule 418 (compilation -> compilation comp_unit .)
INFO:root:    PACKAGE         reduce using rule 418 (compilation -> compilation comp_unit .)
INFO:root:    SEPARATE        reduce using rule 418 (compilation -> compilation comp_unit .)
INFO:root:    PROCEDURE       reduce using rule 418 (compilation -> compilation comp_unit .)
INFO:root:    FUNCTION        reduce using rule 418 (compilation -> compilation comp_unit .)
INFO:root:    GENERIC         reduce using rule 418 (compilation -> compilation comp_unit .)
INFO:root:    $end            reduce using rule 418 (compilation -> compilation comp_unit .)
INFO:root:
INFO:root:
INFO:root:state 10
INFO:root:
INFO:root:    (424) context_spec -> with_clause . use_clause_opt
INFO:root:    (428) use_clause_opt -> .
INFO:root:    (429) use_clause_opt -> . use_clause_opt use_clause
INFO:root:
INFO:root:    USE             reduce using rule 428 (use_clause_opt -> .)
INFO:root:    PRIVATE         reduce using rule 428 (use_clause_opt -> .)
INFO:root:    WITH            reduce using rule 428 (use_clause_opt -> .)
INFO:root:    PRAGMA          reduce using rule 428 (use_clause_opt -> .)
INFO:root:    PACKAGE         reduce using rule 428 (use_clause_opt -> .)
INFO:root:    SEPARATE        reduce using rule 428 (use_clause_opt -> .)
INFO:root:    PROCEDURE       reduce using rule 428 (use_clause_opt -> .)
INFO:root:    FUNCTION        reduce using rule 428 (use_clause_opt -> .)
INFO:root:    GENERIC         reduce using rule 428 (use_clause_opt -> .)
INFO:root:
INFO:root:    use_clause_opt                 shift and go to state 40
INFO:root:
INFO:root:state 11
INFO:root:
INFO:root:    (3) pragma -> PRAGMA simple_name . ( pragma_arg_s ) ;
INFO:root:
INFO:root:    (               shift and go to state 41
INFO:root:
INFO:root:
INFO:root:state 12
INFO:root:
INFO:root:    (2) pragma -> PRAGMA IDENTIFIER . ;
INFO:root:    (157) simple_name -> IDENTIFIER .
INFO:root:
INFO:root:    ;               shift and go to state 42
INFO:root:    (               reduce using rule 157 (simple_name -> IDENTIFIER .)
INFO:root:
INFO:root:
INFO:root:state 13
INFO:root:
INFO:root:    (419) compilation -> pragma pragma_s .
INFO:root:    (9) pragma_s -> pragma_s . pragma
INFO:root:    (2) pragma -> . PRAGMA IDENTIFIER ;
INFO:root:    (3) pragma -> . PRAGMA simple_name ( pragma_arg_s ) ;
INFO:root:
INFO:root:    PRIVATE         reduce using rule 419 (compilation -> pragma pragma_s .)
INFO:root:    WITH            reduce using rule 419 (compilation -> pragma pragma_s .)
INFO:root:    PACKAGE         reduce using rule 419 (compilation -> pragma pragma_s .)
INFO:root:    SEPARATE        reduce using rule 419 (compilation -> pragma pragma_s .)
INFO:root:    PROCEDURE       reduce using rule 419 (compilation -> pragma pragma_s .)
INFO:root:    FUNCTION        reduce using rule 419 (compilation -> pragma pragma_s .)
INFO:root:    GENERIC         reduce using rule 419 (compilation -> pragma pragma_s .)
INFO:root:    $end            reduce using rule 419 (compilation -> pragma pragma_s .)
INFO:root:    PRAGMA          shift and go to state 2
INFO:root:
INFO:root:    pragma                         shift and go to state 43
INFO:root:
INFO:root:state 14
INFO:root:
INFO:root:    (430) unit -> pkg_decl .
INFO:root:
INFO:root:    PRAGMA          reduce using rule 430 (unit -> pkg_decl .)
INFO:root:    PRIVATE         reduce using rule 430 (unit -> pkg_decl .)
INFO:root:    WITH            reduce using rule 430 (unit -> pkg_decl .)
INFO:root:    PACKAGE         reduce using rule 430 (unit -> pkg_decl .)
INFO:root:    SEPARATE        reduce using rule 430 (unit -> pkg_decl .)
INFO:root:    PROCEDURE       reduce using rule 430 (unit -> pkg_decl .)
INFO:root:    FUNCTION        reduce using rule 430 (unit -> pkg_decl .)
INFO:root:    GENERIC         reduce using rule 430 (unit -> pkg_decl .)
INFO:root:    $end            reduce using rule 430 (unit -> pkg_decl .)
INFO:root:
INFO:root:
INFO:root:state 15
INFO:root:
INFO:root:    (435) unit -> generic_decl .
INFO:root:
INFO:root:    PRAGMA          reduce using rule 435 (unit -> generic_decl .)
INFO:root:    PRIVATE         reduce using rule 435 (unit -> generic_decl .)
INFO:root:    WITH            reduce using rule 435 (unit -> generic_decl .)
INFO:root:    PACKAGE         reduce using rule 435 (unit -> generic_decl .)
INFO:root:    SEPARATE        reduce using rule 435 (unit -> generic_decl .)
INFO:root:    PROCEDURE       reduce using rule 435 (unit -> generic_decl .)
INFO:root:    FUNCTION        reduce using rule 435 (unit -> generic_decl .)
INFO:root:    GENERIC         reduce using rule 435 (unit -> generic_decl .)
INFO:root:    $end            reduce using rule 435 (unit -> generic_decl .)
INFO:root:
INFO:root:
INFO:root:state 16
INFO:root:
INFO:root:    (324) pkg_decl -> pkg_spec . ;
INFO:root:
INFO:root:    ;               shift and go to state 44
INFO:root:
INFO:root:
INFO:root:state 17
INFO:root:
INFO:root:    (304) subprog_spec -> PROCEDURE . compound_name formal_part_opt
INFO:root:    (158) compound_name -> . simple_name
INFO:root:    (159) compound_name -> . compound_name . simple_name
INFO:root:    (157) simple_name -> . IDENTIFIER
INFO:root:
INFO:root:    IDENTIFIER      shift and go to state 33
INFO:root:
INFO:root:    simple_name                    shift and go to state 34
INFO:root:    compound_name                  shift and go to state 45
INFO:root:
INFO:root:state 18
INFO:root:
INFO:root:    (432) unit -> subprog_decl .
INFO:root:
INFO:root:    PRAGMA          reduce using rule 432 (unit -> subprog_decl .)
INFO:root:    PRIVATE         reduce using rule 432 (unit -> subprog_decl .)
INFO:root:    WITH            reduce using rule 432 (unit -> subprog_decl .)
INFO:root:    PACKAGE         reduce using rule 432 (unit -> subprog_decl .)
INFO:root:    SEPARATE        reduce using rule 432 (unit -> subprog_decl .)
INFO:root:    PROCEDURE       reduce using rule 432 (unit -> subprog_decl .)
INFO:root:    FUNCTION        reduce using rule 432 (unit -> subprog_decl .)
INFO:root:    GENERIC         reduce using rule 432 (unit -> subprog_decl .)
INFO:root:    $end            reduce using rule 432 (unit -> subprog_decl .)
INFO:root:
INFO:root:
INFO:root:state 19
INFO:root:
INFO:root:    (325) pkg_decl -> generic_pkg_inst . ;
INFO:root:
INFO:root:    ;               shift and go to state 46
INFO:root:
INFO:root:
INFO:root:state 20
INFO:root:
INFO:root:    (458) generic_decl -> generic_formal_part . subprog_spec ;
INFO:root:    (459) generic_decl -> generic_formal_part . pkg_spec ;
INFO:root:    (346) rename_unit -> generic_formal_part . PACKAGE compound_name renames ;
INFO:root:    (347) rename_unit -> generic_formal_part . subprog_spec renames ;
INFO:root:    (461) generic_formal_part -> generic_formal_part . generic_formal
INFO:root:    (304) subprog_spec -> . PROCEDURE compound_name formal_part_opt
INFO:root:    (305) subprog_spec -> . FUNCTION designator formal_part_opt RETURN name
INFO:root:    (306) subprog_spec -> . FUNCTION designator
INFO:root:    (326) pkg_spec -> . PACKAGE compound_name IS decl_item_s private_part END c_id_opt
INFO:root:    (462) generic_formal -> . param ;
INFO:root:    (463) generic_formal -> . TYPE simple_name generic_discrim_part_opt IS generic_type_def ;
INFO:root:    (464) generic_formal -> . WITH PROCEDURE simple_name formal_part_opt subp_default ;
INFO:root:    (465) generic_formal -> . WITH FUNCTION designator formal_part_opt RETURN name subp_default ;
INFO:root:    (466) generic_formal -> . WITH PACKAGE simple_name IS NEW name ( BOX ) ;
INFO:root:    (467) generic_formal -> . WITH PACKAGE simple_name IS NEW name ;
INFO:root:    (468) generic_formal -> . use_clause
INFO:root:    (314) param -> . def_id_s : mode mark init_opt
INFO:root:    (315) param -> . error
INFO:root:    (337) use_clause -> . USE name_s ;
INFO:root:    (338) use_clause -> . USE TYPE name_s ;
INFO:root:    (24) def_id_s -> . def_id
INFO:root:    (25) def_id_s -> . def_id_s , def_id
INFO:root:    (26) def_id -> . IDENTIFIER
INFO:root:
INFO:root:    PACKAGE         shift and go to state 49
INFO:root:    PROCEDURE       shift and go to state 17
INFO:root:    FUNCTION        shift and go to state 23
INFO:root:    TYPE            shift and go to state 50
INFO:root:    WITH            shift and go to state 48
INFO:root:    error           shift and go to state 55
INFO:root:    USE             shift and go to state 53
INFO:root:    IDENTIFIER      shift and go to state 52
INFO:root:
INFO:root:    generic_formal                 shift and go to state 47
INFO:root:    subprog_spec                   shift and go to state 51
INFO:root:    pkg_spec                       shift and go to state 54
INFO:root:    def_id_s                       shift and go to state 56
INFO:root:    def_id                         shift and go to state 57
INFO:root:    use_clause                     shift and go to state 58
INFO:root:    param                          shift and go to state 59
INFO:root:
INFO:root:state 21
INFO:root:
INFO:root:    (421) comp_unit -> private_opt unit . pragma_s
INFO:root:    (8) pragma_s -> .
INFO:root:    (9) pragma_s -> . pragma_s pragma
INFO:root:
INFO:root:    PRAGMA          reduce using rule 8 (pragma_s -> .)
INFO:root:    PRIVATE         reduce using rule 8 (pragma_s -> .)
INFO:root:    WITH            reduce using rule 8 (pragma_s -> .)
INFO:root:    PACKAGE         reduce using rule 8 (pragma_s -> .)
INFO:root:    SEPARATE        reduce using rule 8 (pragma_s -> .)
INFO:root:    PROCEDURE       reduce using rule 8 (pragma_s -> .)
INFO:root:    FUNCTION        reduce using rule 8 (pragma_s -> .)
INFO:root:    GENERIC         reduce using rule 8 (pragma_s -> .)
INFO:root:    $end            reduce using rule 8 (pragma_s -> .)
INFO:root:
INFO:root:    pragma_s                       shift and go to state 60
INFO:root:
INFO:root:state 22
INFO:root:
INFO:root:    (437) subunit -> SEPARATE . ( compound_name ) subunit_body
INFO:root:
INFO:root:    (               shift and go to state 61
INFO:root:
INFO:root:
INFO:root:state 23
INFO:root:
INFO:root:    (305) subprog_spec -> FUNCTION . designator formal_part_opt RETURN name
INFO:root:    (306) subprog_spec -> FUNCTION . designator
INFO:root:    (307) designator -> . compound_name
INFO:root:    (308) designator -> . STRING
INFO:root:    (158) compound_name -> . simple_name
INFO:root:    (159) compound_name -> . compound_name . simple_name
INFO:root:    (157) simple_name -> . IDENTIFIER
INFO:root:
INFO:root:    STRING          shift and go to state 62
INFO:root:    IDENTIFIER      shift and go to state 33
INFO:root:
INFO:root:    designator                     shift and go to state 63
INFO:root:    simple_name                    shift and go to state 34
INFO:root:    compound_name                  shift and go to state 64
INFO:root:
INFO:root:state 24
INFO:root:
INFO:root:    (302) subprog_decl -> generic_subp_inst . ;
INFO:root:
INFO:root:    ;               shift and go to state 65
INFO:root:
INFO:root:
INFO:root:state 25
INFO:root:
INFO:root:    (436) unit -> rename_unit .
INFO:root:
INFO:root:    PRAGMA          reduce using rule 436 (unit -> rename_unit .)
INFO:root:    PRIVATE         reduce using rule 436 (unit -> rename_unit .)
INFO:root:    WITH            reduce using rule 436 (unit -> rename_unit .)
INFO:root:    PACKAGE         reduce using rule 436 (unit -> rename_unit .)
INFO:root:    SEPARATE        reduce using rule 436 (unit -> rename_unit .)
INFO:root:    PROCEDURE       reduce using rule 436 (unit -> rename_unit .)
INFO:root:    FUNCTION        reduce using rule 436 (unit -> rename_unit .)
INFO:root:    GENERIC         reduce using rule 436 (unit -> rename_unit .)
INFO:root:    $end            reduce using rule 436 (unit -> rename_unit .)
INFO:root:
INFO:root:
INFO:root:state 26
INFO:root:
INFO:root:    (460) generic_formal_part -> GENERIC .
INFO:root:
INFO:root:    PACKAGE         reduce using rule 460 (generic_formal_part -> GENERIC .)
INFO:root:    PROCEDURE       reduce using rule 460 (generic_formal_part -> GENERIC .)
INFO:root:    FUNCTION        reduce using rule 460 (generic_formal_part -> GENERIC .)
INFO:root:    TYPE            reduce using rule 460 (generic_formal_part -> GENERIC .)
INFO:root:    WITH            reduce using rule 460 (generic_formal_part -> GENERIC .)
INFO:root:    error           reduce using rule 460 (generic_formal_part -> GENERIC .)
INFO:root:    USE             reduce using rule 460 (generic_formal_part -> GENERIC .)
INFO:root:    IDENTIFIER      reduce using rule 460 (generic_formal_part -> GENERIC .)
INFO:root:
INFO:root:
INFO:root:state 27
INFO:root:
INFO:root:    (301) subprog_decl -> subprog_spec . ;
INFO:root:    (345) rename_unit -> subprog_spec . renames ;
INFO:root:    (488) generic_subp_inst -> subprog_spec . IS generic_inst
INFO:root:    (321) subprog_spec_is_push -> subprog_spec . IS
INFO:root:    (348) renames -> . RENAMES name
INFO:root:
INFO:root:    ;               shift and go to state 69
INFO:root:    IS              shift and go to state 68
INFO:root:    RENAMES         shift and go to state 66
INFO:root:
INFO:root:    renames                        shift and go to state 67
INFO:root:
INFO:root:state 28
INFO:root:
INFO:root:    (331) pkg_body -> PACKAGE . BODY compound_name IS decl_part body_opt END c_id_opt ;
INFO:root:    (344) rename_unit -> PACKAGE . compound_name renames ;
INFO:root:    (326) pkg_spec -> PACKAGE . compound_name IS decl_item_s private_part END c_id_opt
INFO:root:    (489) generic_pkg_inst -> PACKAGE . compound_name IS generic_inst
INFO:root:    (158) compound_name -> . simple_name
INFO:root:    (159) compound_name -> . compound_name . simple_name
INFO:root:    (157) simple_name -> . IDENTIFIER
INFO:root:
INFO:root:    BODY            shift and go to state 71
INFO:root:    IDENTIFIER      shift and go to state 33
INFO:root:
INFO:root:    simple_name                    shift and go to state 34
INFO:root:    compound_name                  shift and go to state 70
INFO:root:
INFO:root:state 29
INFO:root:
INFO:root:    (434) unit -> subunit .
INFO:root:
INFO:root:    PRAGMA          reduce using rule 434 (unit -> subunit .)
INFO:root:    PRIVATE         reduce using rule 434 (unit -> subunit .)
INFO:root:    WITH            reduce using rule 434 (unit -> subunit .)
INFO:root:    PACKAGE         reduce using rule 434 (unit -> subunit .)
INFO:root:    SEPARATE        reduce using rule 434 (unit -> subunit .)
INFO:root:    PROCEDURE       reduce using rule 434 (unit -> subunit .)
INFO:root:    FUNCTION        reduce using rule 434 (unit -> subunit .)
INFO:root:    GENERIC         reduce using rule 434 (unit -> subunit .)
INFO:root:    $end            reduce using rule 434 (unit -> subunit .)
INFO:root:
INFO:root:
INFO:root:state 30
INFO:root:
INFO:root:    (431) unit -> pkg_body .
INFO:root:
INFO:root:    PRAGMA          reduce using rule 431 (unit -> pkg_body .)
INFO:root:    PRIVATE         reduce using rule 431 (unit -> pkg_body .)
INFO:root:    WITH            reduce using rule 431 (unit -> pkg_body .)
INFO:root:    PACKAGE         reduce using rule 431 (unit -> pkg_body .)
INFO:root:    SEPARATE        reduce using rule 431 (unit -> pkg_body .)
INFO:root:    PROCEDURE       reduce using rule 431 (unit -> pkg_body .)
INFO:root:    FUNCTION        reduce using rule 431 (unit -> pkg_body .)
INFO:root:    GENERIC         reduce using rule 431 (unit -> pkg_body .)
INFO:root:    $end            reduce using rule 431 (unit -> pkg_body .)
INFO:root:
INFO:root:
INFO:root:state 31
INFO:root:
INFO:root:    (303) subprog_decl -> subprog_spec_is_push . ABSTRACT ;
INFO:root:    (322) subprog_body -> subprog_spec_is_push . decl_part block_body END id_opt ;
INFO:root:    (131) decl_part -> .
INFO:root:    (132) decl_part -> . decl_item_or_body_s1
INFO:root:    (141) decl_item_or_body_s1 -> . decl_item_or_body
INFO:root:    (142) decl_item_or_body_s1 -> . decl_item_or_body_s1 decl_item_or_body
INFO:root:    (143) decl_item_or_body -> . body
INFO:root:    (144) decl_item_or_body -> . decl_item
INFO:root:    (145) body -> . subprog_body
INFO:root:    (146) body -> . pkg_body
INFO:root:    (147) body -> . task_body
INFO:root:    (148) body -> . prot_body
INFO:root:    (137) decl_item -> . decl
INFO:root:    (138) decl_item -> . use_clause
INFO:root:    (139) decl_item -> . rep_spec
INFO:root:    (140) decl_item -> . pragma
INFO:root:    (322) subprog_body -> . subprog_spec_is_push decl_part block_body END id_opt ;
INFO:root:    (331) pkg_body -> . PACKAGE BODY compound_name IS decl_part body_opt END c_id_opt ;
INFO:root:    (356) task_body -> . TASK BODY simple_name IS decl_part block_body END id_opt ;
INFO:root:    (373) prot_body -> . PROTECTED BODY simple_name IS prot_op_body_s END id_opt ;
INFO:root:    (10) decl -> . object_decl
INFO:root:    (11) decl -> . number_decl
INFO:root:    (12) decl -> . type_decl
INFO:root:    (13) decl -> . subtype_decl
INFO:root:    (14) decl -> . subprog_decl
INFO:root:    (15) decl -> . pkg_decl
INFO:root:    (16) decl -> . task_decl
INFO:root:    (17) decl -> . prot_decl
INFO:root:    (18) decl -> . exception_decl
INFO:root:    (19) decl -> . rename_decl
INFO:root:    (20) decl -> . generic_decl
INFO:root:    (21) decl -> . body_stub
INFO:root:    (22) decl -> . error ;
INFO:root:    (337) use_clause -> . USE name_s ;
INFO:root:    (338) use_clause -> . USE TYPE name_s ;
INFO:root:    (491) rep_spec -> . attrib_def
INFO:root:    (492) rep_spec -> . record_type_spec
INFO:root:    (493) rep_spec -> . address_spec
INFO:root:    (2) pragma -> . PRAGMA IDENTIFIER ;
INFO:root:    (3) pragma -> . PRAGMA simple_name ( pragma_arg_s ) ;
INFO:root:    (321) subprog_spec_is_push -> . subprog_spec IS
INFO:root:    (23) object_decl -> . def_id_s : object_qualifier_opt object_subtype_def init_opt ;
INFO:root:    (35) number_decl -> . def_id_s : CONSTANT ASSIGN expression ;
INFO:root:    (36) type_decl -> . TYPE IDENTIFIER discrim_part_opt type_completion ;
INFO:root:    (50) subtype_decl -> . SUBTYPE IDENTIFIER IS subtype_ind ;
INFO:root:    (301) subprog_decl -> . subprog_spec ;
INFO:root:    (302) subprog_decl -> . generic_subp_inst ;
INFO:root:    (303) subprog_decl -> . subprog_spec_is_push ABSTRACT ;
INFO:root:    (324) pkg_decl -> . pkg_spec ;
INFO:root:    (325) pkg_decl -> . generic_pkg_inst ;
INFO:root:    (349) task_decl -> . task_spec ;
INFO:root:    (357) prot_decl -> . prot_spec ;
INFO:root:    (446) exception_decl -> . def_id_s : EXCEPTION ;
INFO:root:    (341) rename_decl -> . def_id_s : object_qualifier_opt subtype_ind renames ;
INFO:root:    (342) rename_decl -> . def_id_s : EXCEPTION renames ;
INFO:root:    (343) rename_decl -> . rename_unit
INFO:root:    (458) generic_decl -> . generic_formal_part subprog_spec ;
INFO:root:    (459) generic_decl -> . generic_formal_part pkg_spec ;
INFO:root:    (442) body_stub -> . TASK BODY simple_name IS SEPARATE ;
INFO:root:    (443) body_stub -> . PACKAGE BODY compound_name IS SEPARATE ;
INFO:root:    (444) body_stub -> . subprog_spec IS SEPARATE ;
INFO:root:    (445) body_stub -> . PROTECTED BODY simple_name IS SEPARATE ;
INFO:root:    (494) attrib_def -> . FOR mark USE expression ;
INFO:root:    (495) record_type_spec -> . FOR mark USE RECORD align_opt comp_loc_s END RECORD ;
INFO:root:    (500) address_spec -> . FOR mark USE AT expression ;
INFO:root:    (304) subprog_spec -> . PROCEDURE compound_name formal_part_opt
INFO:root:    (305) subprog_spec -> . FUNCTION designator formal_part_opt RETURN name
INFO:root:    (306) subprog_spec -> . FUNCTION designator
INFO:root:    (24) def_id_s -> . def_id
INFO:root:    (25) def_id_s -> . def_id_s , def_id
INFO:root:    (488) generic_subp_inst -> . subprog_spec IS generic_inst
INFO:root:    (326) pkg_spec -> . PACKAGE compound_name IS decl_item_s private_part END c_id_opt
INFO:root:    (489) generic_pkg_inst -> . PACKAGE compound_name IS generic_inst
INFO:root:    (350) task_spec -> . TASK simple_name task_def
INFO:root:    (351) task_spec -> . TASK TYPE simple_name discrim_part_opt task_def
INFO:root:    (358) prot_spec -> . PROTECTED IDENTIFIER prot_def
INFO:root:    (359) prot_spec -> . PROTECTED TYPE simple_name discrim_part_opt prot_def
INFO:root:    (344) rename_unit -> . PACKAGE compound_name renames ;
INFO:root:    (345) rename_unit -> . subprog_spec renames ;
INFO:root:    (346) rename_unit -> . generic_formal_part PACKAGE compound_name renames ;
INFO:root:    (347) rename_unit -> . generic_formal_part subprog_spec renames ;
INFO:root:    (460) generic_formal_part -> . GENERIC
INFO:root:    (461) generic_formal_part -> . generic_formal_part generic_formal
INFO:root:    (26) def_id -> . IDENTIFIER
INFO:root:
INFO:root:    ABSTRACT        shift and go to state 89
INFO:root:    BEGIN           reduce using rule 131 (decl_part -> .)
INFO:root:    PACKAGE         shift and go to state 73
INFO:root:    TASK            shift and go to state 84
INFO:root:    PROTECTED       shift and go to state 99
INFO:root:    error           shift and go to state 107
INFO:root:    USE             shift and go to state 53
INFO:root:    PRAGMA          shift and go to state 2
INFO:root:    TYPE            shift and go to state 74
INFO:root:    SUBTYPE         shift and go to state 110
INFO:root:    FOR             shift and go to state 102
INFO:root:    PROCEDURE       shift and go to state 17
INFO:root:    FUNCTION        shift and go to state 23
INFO:root:    GENERIC         shift and go to state 26
INFO:root:    IDENTIFIER      shift and go to state 52
INFO:root:
INFO:root:    generic_formal_part            shift and go to state 20
INFO:root:    pkg_decl                       shift and go to state 93
INFO:root:    pragma                         shift and go to state 94
INFO:root:    generic_pkg_inst               shift and go to state 19
INFO:root:    prot_decl                      shift and go to state 95
INFO:root:    body                           shift and go to state 75
INFO:root:    task_decl                      shift and go to state 76
INFO:root:    generic_decl                   shift and go to state 88
INFO:root:    subprog_decl                   shift and go to state 77
INFO:root:    type_decl                      shift and go to state 81
INFO:root:    def_id_s                       shift and go to state 79
INFO:root:    def_id                         shift and go to state 57
INFO:root:    rep_spec                       shift and go to state 72
INFO:root:    use_clause                     shift and go to state 97
INFO:root:    rename_decl                    shift and go to state 98
INFO:root:    body_stub                      shift and go to state 80
INFO:root:    address_spec                   shift and go to state 83
INFO:root:    task_spec                      shift and go to state 82
INFO:root:    number_decl                    shift and go to state 101
INFO:root:    generic_subp_inst              shift and go to state 24
INFO:root:    decl_item_or_body_s1           shift and go to state 103
INFO:root:    prot_spec                      shift and go to state 85
INFO:root:    rename_unit                    shift and go to state 104
INFO:root:    subprog_spec                   shift and go to state 86
INFO:root:    object_decl                    shift and go to state 87
INFO:root:    subtype_decl                   shift and go to state 105
INFO:root:    task_body                      shift and go to state 96
INFO:root:    prot_body                      shift and go to state 100
INFO:root:    pkg_body                       shift and go to state 90
INFO:root:    decl_part                      shift and go to state 106
INFO:root:    pkg_spec                       shift and go to state 16
INFO:root:    record_type_spec               shift and go to state 108
INFO:root:    decl                           shift and go to state 109
INFO:root:    decl_item                      shift and go to state 78
INFO:root:    exception_decl                 shift and go to state 91
INFO:root:    subprog_body                   shift and go to state 113
INFO:root:    attrib_def                     shift and go to state 92
INFO:root:    subprog_spec_is_push           shift and go to state 111
INFO:root:    decl_item_or_body              shift and go to state 112
INFO:root:
INFO:root:state 32
INFO:root:
INFO:root:    (433) unit -> subprog_body .
INFO:root:
INFO:root:    PRAGMA          reduce using rule 433 (unit -> subprog_body .)
INFO:root:    PRIVATE         reduce using rule 433 (unit -> subprog_body .)
INFO:root:    WITH            reduce using rule 433 (unit -> subprog_body .)
INFO:root:    PACKAGE         reduce using rule 433 (unit -> subprog_body .)
INFO:root:    SEPARATE        reduce using rule 433 (unit -> subprog_body .)
INFO:root:    PROCEDURE       reduce using rule 433 (unit -> subprog_body .)
INFO:root:    FUNCTION        reduce using rule 433 (unit -> subprog_body .)
INFO:root:    GENERIC         reduce using rule 433 (unit -> subprog_body .)
INFO:root:    $end            reduce using rule 433 (unit -> subprog_body .)
INFO:root:
INFO:root:
INFO:root:state 33
INFO:root:
INFO:root:    (157) simple_name -> IDENTIFIER .
INFO:root:
INFO:root:    (               reduce using rule 157 (simple_name -> IDENTIFIER .)
INFO:root:    .               reduce using rule 157 (simple_name -> IDENTIFIER .)
INFO:root:    TICK            reduce using rule 157 (simple_name -> IDENTIFIER .)
INFO:root:    ;               reduce using rule 157 (simple_name -> IDENTIFIER .)
INFO:root:    RANGE           reduce using rule 157 (simple_name -> IDENTIFIER .)
INFO:root:    *               reduce using rule 157 (simple_name -> IDENTIFIER .)
INFO:root:    /               reduce using rule 157 (simple_name -> IDENTIFIER .)
INFO:root:    MOD             reduce using rule 157 (simple_name -> IDENTIFIER .)
INFO:root:    REM             reduce using rule 157 (simple_name -> IDENTIFIER .)
INFO:root:    STARSTAR        reduce using rule 157 (simple_name -> IDENTIFIER .)
INFO:root:    DOTDOT          reduce using rule 157 (simple_name -> IDENTIFIER .)
INFO:root:    =               reduce using rule 157 (simple_name -> IDENTIFIER .)
INFO:root:    NEQ             reduce using rule 157 (simple_name -> IDENTIFIER .)
INFO:root:    <               reduce using rule 157 (simple_name -> IDENTIFIER .)
INFO:root:    LEQ             reduce using rule 157 (simple_name -> IDENTIFIER .)
INFO:root:    >               reduce using rule 157 (simple_name -> IDENTIFIER .)
INFO:root:    GEQ             reduce using rule 157 (simple_name -> IDENTIFIER .)
INFO:root:    IN              reduce using rule 157 (simple_name -> IDENTIFIER .)
INFO:root:    NOT             reduce using rule 157 (simple_name -> IDENTIFIER .)
INFO:root:    +               reduce using rule 157 (simple_name -> IDENTIFIER .)
INFO:root:    -               reduce using rule 157 (simple_name -> IDENTIFIER .)
INFO:root:    &               reduce using rule 157 (simple_name -> IDENTIFIER .)
INFO:root:    AND             reduce using rule 157 (simple_name -> IDENTIFIER .)
INFO:root:    OR              reduce using rule 157 (simple_name -> IDENTIFIER .)
INFO:root:    XOR             reduce using rule 157 (simple_name -> IDENTIFIER .)
INFO:root:    ARROW           reduce using rule 157 (simple_name -> IDENTIFIER .)
INFO:root:    |               reduce using rule 157 (simple_name -> IDENTIFIER .)
INFO:root:    IS              reduce using rule 157 (simple_name -> IDENTIFIER .)
INFO:root:    RETURN          reduce using rule 157 (simple_name -> IDENTIFIER .)
INFO:root:    RENAMES         reduce using rule 157 (simple_name -> IDENTIFIER .)
INFO:root:    AT              reduce using rule 157 (simple_name -> IDENTIFIER .)
INFO:root:    DIGITS          reduce using rule 157 (simple_name -> IDENTIFIER .)
INFO:root:    WITH            reduce using rule 157 (simple_name -> IDENTIFIER .)
INFO:root:    THEN            reduce using rule 157 (simple_name -> IDENTIFIER .)
INFO:root:    LOOP            reduce using rule 157 (simple_name -> IDENTIFIER .)
INFO:root:    ,               reduce using rule 157 (simple_name -> IDENTIFIER .)
INFO:root:    )               reduce using rule 157 (simple_name -> IDENTIFIER .)
INFO:root:    ASSIGN          reduce using rule 157 (simple_name -> IDENTIFIER .)
INFO:root:    WHEN            reduce using rule 157 (simple_name -> IDENTIFIER .)
INFO:root:    DO              reduce using rule 157 (simple_name -> IDENTIFIER .)
INFO:root:    USE             reduce using rule 157 (simple_name -> IDENTIFIER .)
INFO:root:
INFO:root:
INFO:root:state 34
INFO:root:
INFO:root:    (158) compound_name -> simple_name .
INFO:root:
INFO:root:    .               reduce using rule 158 (compound_name -> simple_name .)
INFO:root:    (               reduce using rule 158 (compound_name -> simple_name .)
INFO:root:    RETURN          reduce using rule 158 (compound_name -> simple_name .)
INFO:root:    ;               reduce using rule 158 (compound_name -> simple_name .)
INFO:root:    IS              reduce using rule 158 (compound_name -> simple_name .)
INFO:root:    RENAMES         reduce using rule 158 (compound_name -> simple_name .)
INFO:root:    ,               reduce using rule 158 (compound_name -> simple_name .)
INFO:root:    )               reduce using rule 158 (compound_name -> simple_name .)
INFO:root:
INFO:root:
INFO:root:state 35
INFO:root:
INFO:root:    (427) with_clause -> WITH c_name_list . ;
INFO:root:    (161) c_name_list -> c_name_list . , compound_name
INFO:root:
INFO:root:    ;               shift and go to state 115
INFO:root:    ,               shift and go to state 114
INFO:root:
INFO:root:
INFO:root:state 36
INFO:root:
INFO:root:    (160) c_name_list -> compound_name .
INFO:root:    (159) compound_name -> compound_name . . simple_name
INFO:root:
INFO:root:    ;               reduce using rule 160 (c_name_list -> compound_name .)
INFO:root:    ,               reduce using rule 160 (c_name_list -> compound_name .)
INFO:root:    .               shift and go to state 116
INFO:root:
INFO:root:
INFO:root:state 37
INFO:root:
INFO:root:    (420) comp_unit -> context_spec private_opt . unit pragma_s
INFO:root:    (430) unit -> . pkg_decl
INFO:root:    (431) unit -> . pkg_body
INFO:root:    (432) unit -> . subprog_decl
INFO:root:    (433) unit -> . subprog_body
INFO:root:    (434) unit -> . subunit
INFO:root:    (435) unit -> . generic_decl
INFO:root:    (436) unit -> . rename_unit
INFO:root:    (324) pkg_decl -> . pkg_spec ;
INFO:root:    (325) pkg_decl -> . generic_pkg_inst ;
INFO:root:    (331) pkg_body -> . PACKAGE BODY compound_name IS decl_part body_opt END c_id_opt ;
INFO:root:    (301) subprog_decl -> . subprog_spec ;
INFO:root:    (302) subprog_decl -> . generic_subp_inst ;
INFO:root:    (303) subprog_decl -> . subprog_spec_is_push ABSTRACT ;
INFO:root:    (322) subprog_body -> . subprog_spec_is_push decl_part block_body END id_opt ;
INFO:root:    (437) subunit -> . SEPARATE ( compound_name ) subunit_body
INFO:root:    (458) generic_decl -> . generic_formal_part subprog_spec ;
INFO:root:    (459) generic_decl -> . generic_formal_part pkg_spec ;
INFO:root:    (344) rename_unit -> . PACKAGE compound_name renames ;
INFO:root:    (345) rename_unit -> . subprog_spec renames ;
INFO:root:    (346) rename_unit -> . generic_formal_part PACKAGE compound_name renames ;
INFO:root:    (347) rename_unit -> . generic_formal_part subprog_spec renames ;
INFO:root:    (326) pkg_spec -> . PACKAGE compound_name IS decl_item_s private_part END c_id_opt
INFO:root:    (489) generic_pkg_inst -> . PACKAGE compound_name IS generic_inst
INFO:root:    (304) subprog_spec -> . PROCEDURE compound_name formal_part_opt
INFO:root:    (305) subprog_spec -> . FUNCTION designator formal_part_opt RETURN name
INFO:root:    (306) subprog_spec -> . FUNCTION designator
INFO:root:    (488) generic_subp_inst -> . subprog_spec IS generic_inst
INFO:root:    (321) subprog_spec_is_push -> . subprog_spec IS
INFO:root:    (460) generic_formal_part -> . GENERIC
INFO:root:    (461) generic_formal_part -> . generic_formal_part generic_formal
INFO:root:
INFO:root:    PACKAGE         shift and go to state 28
INFO:root:    SEPARATE        shift and go to state 22
INFO:root:    PROCEDURE       shift and go to state 17
INFO:root:    FUNCTION        shift and go to state 23
INFO:root:    GENERIC         shift and go to state 26
INFO:root:
INFO:root:    generic_subp_inst              shift and go to state 24
INFO:root:    subprog_decl                   shift and go to state 18
INFO:root:    pkg_decl                       shift and go to state 14
INFO:root:    generic_decl                   shift and go to state 15
INFO:root:    rename_unit                    shift and go to state 25
INFO:root:    subprog_spec                   shift and go to state 27
INFO:root:    generic_pkg_inst               shift and go to state 19
INFO:root:    pkg_spec                       shift and go to state 16
INFO:root:    subunit                        shift and go to state 29
INFO:root:    pkg_body                       shift and go to state 30
INFO:root:    generic_formal_part            shift and go to state 20
INFO:root:    unit                           shift and go to state 117
INFO:root:    subprog_body                   shift and go to state 32
INFO:root:    subprog_spec_is_push           shift and go to state 31
INFO:root:
INFO:root:state 38
INFO:root:
INFO:root:    (426) context_spec -> context_spec pragma .
INFO:root:
INFO:root:    PRIVATE         reduce using rule 426 (context_spec -> context_spec pragma .)
INFO:root:    WITH            reduce using rule 426 (context_spec -> context_spec pragma .)
INFO:root:    PRAGMA          reduce using rule 426 (context_spec -> context_spec pragma .)
INFO:root:    PACKAGE         reduce using rule 426 (context_spec -> context_spec pragma .)
INFO:root:    SEPARATE        reduce using rule 426 (context_spec -> context_spec pragma .)
INFO:root:    PROCEDURE       reduce using rule 426 (context_spec -> context_spec pragma .)
INFO:root:    FUNCTION        reduce using rule 426 (context_spec -> context_spec pragma .)
INFO:root:    GENERIC         reduce using rule 426 (context_spec -> context_spec pragma .)
INFO:root:
INFO:root:
INFO:root:state 39
INFO:root:
INFO:root:    (425) context_spec -> context_spec with_clause . use_clause_opt
INFO:root:    (428) use_clause_opt -> .
INFO:root:    (429) use_clause_opt -> . use_clause_opt use_clause
INFO:root:
INFO:root:    USE             reduce using rule 428 (use_clause_opt -> .)
INFO:root:    PRIVATE         reduce using rule 428 (use_clause_opt -> .)
INFO:root:    WITH            reduce using rule 428 (use_clause_opt -> .)
INFO:root:    PRAGMA          reduce using rule 428 (use_clause_opt -> .)
INFO:root:    PACKAGE         reduce using rule 428 (use_clause_opt -> .)
INFO:root:    SEPARATE        reduce using rule 428 (use_clause_opt -> .)
INFO:root:    PROCEDURE       reduce using rule 428 (use_clause_opt -> .)
INFO:root:    FUNCTION        reduce using rule 428 (use_clause_opt -> .)
INFO:root:    GENERIC         reduce using rule 428 (use_clause_opt -> .)
INFO:root:
INFO:root:    use_clause_opt                 shift and go to state 118
INFO:root:
INFO:root:state 40
INFO:root:
INFO:root:    (424) context_spec -> with_clause use_clause_opt .
INFO:root:    (429) use_clause_opt -> use_clause_opt . use_clause
INFO:root:    (337) use_clause -> . USE name_s ;
INFO:root:    (338) use_clause -> . USE TYPE name_s ;
INFO:root:
INFO:root:    PRIVATE         reduce using rule 424 (context_spec -> with_clause use_clause_opt .)
INFO:root:    WITH            reduce using rule 424 (context_spec -> with_clause use_clause_opt .)
INFO:root:    PRAGMA          reduce using rule 424 (context_spec -> with_clause use_clause_opt .)
INFO:root:    PACKAGE         reduce using rule 424 (context_spec -> with_clause use_clause_opt .)
INFO:root:    SEPARATE        reduce using rule 424 (context_spec -> with_clause use_clause_opt .)
INFO:root:    PROCEDURE       reduce using rule 424 (context_spec -> with_clause use_clause_opt .)
INFO:root:    FUNCTION        reduce using rule 424 (context_spec -> with_clause use_clause_opt .)
INFO:root:    GENERIC         reduce using rule 424 (context_spec -> with_clause use_clause_opt .)
INFO:root:    USE             shift and go to state 53
INFO:root:
INFO:root:    use_clause                     shift and go to state 119
INFO:root:
INFO:root:state 41
INFO:root:
INFO:root:    (3) pragma -> PRAGMA simple_name ( . pragma_arg_s ) ;
INFO:root:    (4) pragma_arg_s -> . pragma_arg
INFO:root:    (5) pragma_arg_s -> . pragma_arg_s , pragma_arg
INFO:root:    (6) pragma_arg -> . expression
INFO:root:    (7) pragma_arg -> . simple_name ARROW expression
INFO:root:    (188) expression -> . relation
INFO:root:    (189) expression -> . expression logical relation
INFO:root:    (190) expression -> . expression short_circuit relation
INFO:root:    (157) simple_name -> . IDENTIFIER
INFO:root:    (196) relation -> . simple_expression
INFO:root:    (197) relation -> . simple_expression relational simple_expression
INFO:root:    (198) relation -> . simple_expression membership range
INFO:root:    (199) relation -> . simple_expression membership name
INFO:root:    (208) simple_expression -> . unary term
INFO:root:    (209) simple_expression -> . term
INFO:root:    (210) simple_expression -> . simple_expression adding term
INFO:root:    (211) unary -> . +
INFO:root:    (212) unary -> . -
INFO:root:    (216) term -> . factor
INFO:root:    (217) term -> . term multiplying factor
INFO:root:    (223) factor -> . primary
INFO:root:    (224) factor -> . NOT primary
INFO:root:    (225) factor -> . ABS primary
INFO:root:    (226) primary -> . literal
INFO:root:    (227) primary -> . name
INFO:root:    (228) primary -> . allocator
INFO:root:    (229) primary -> . qualified
INFO:root:    (230) primary -> . parenthesized_primary
INFO:root:    (180) literal -> . INT
INFO:root:    (181) literal -> . FLOAT
INFO:root:    (182) literal -> . NuLL
INFO:root:    (149) name -> . simple_name
INFO:root:    (150) name -> . indexed_comp
INFO:root:    (151) name -> . selected_comp
INFO:root:    (152) name -> . attribute
INFO:root:    (153) name -> . operator_symbol
INFO:root:    (234) allocator -> . NEW name
INFO:root:    (235) allocator -> . NEW qualified
INFO:root:    (233) qualified -> . name TICK parenthesized_primary
INFO:root:    (231) parenthesized_primary -> . aggregate
INFO:root:    (232) parenthesized_primary -> . ( expression )
INFO:root:    (164) indexed_comp -> . name ( value_s )
INFO:root:    (171) selected_comp -> . name . simple_name
INFO:root:    (172) selected_comp -> . name . used_char
INFO:root:    (173) selected_comp -> . name . operator_symbol
INFO:root:    (174) selected_comp -> . name . ALL
INFO:root:    (175) attribute -> . name TICK attribute_id
INFO:root:    (163) operator_symbol -> . STRING
INFO:root:    (183) aggregate -> . ( comp_assoc )
INFO:root:    (184) aggregate -> . ( expression WITH value_s )
INFO:root:    (185) aggregate -> . ( expression WITH NuLL RECORD )
INFO:root:    (186) aggregate -> . ( NuLL RECORD )
INFO:root:
INFO:root:    IDENTIFIER      shift and go to state 33
INFO:root:    +               shift and go to state 148
INFO:root:    -               shift and go to state 136
INFO:root:    NOT             shift and go to state 131
INFO:root:    ABS             shift and go to state 132
INFO:root:    INT             shift and go to state 120
INFO:root:    FLOAT           shift and go to state 128
INFO:root:    NuLL            shift and go to state 130
INFO:root:    NEW             shift and go to state 137
INFO:root:    (               shift and go to state 125
INFO:root:    STRING          shift and go to state 149
INFO:root:
INFO:root:    literal                        shift and go to state 121
INFO:root:    allocator                      shift and go to state 122
INFO:root:    simple_name                    shift and go to state 123
INFO:root:    indexed_comp                   shift and go to state 140
INFO:root:    pragma_arg_s                   shift and go to state 141
INFO:root:    name                           shift and go to state 142
INFO:root:    pragma_arg                     shift and go to state 124
INFO:root:    selected_comp                  shift and go to state 139
INFO:root:    factor                         shift and go to state 126
INFO:root:    expression                     shift and go to state 127
INFO:root:    unary                          shift and go to state 144
INFO:root:    qualified                      shift and go to state 145
INFO:root:    aggregate                      shift and go to state 143
INFO:root:    simple_expression              shift and go to state 129
INFO:root:    term                           shift and go to state 146
INFO:root:    operator_symbol                shift and go to state 133
INFO:root:    parenthesized_primary          shift and go to state 147
INFO:root:    attribute                      shift and go to state 134
INFO:root:    primary                        shift and go to state 135
INFO:root:    relation                       shift and go to state 138
INFO:root:
INFO:root:state 42
INFO:root:
INFO:root:    (2) pragma -> PRAGMA IDENTIFIER ; .
INFO:root:
INFO:root:    PACKAGE         reduce using rule 2 (pragma -> PRAGMA IDENTIFIER ; .)
INFO:root:    TASK            reduce using rule 2 (pragma -> PRAGMA IDENTIFIER ; .)
INFO:root:    PROTECTED       reduce using rule 2 (pragma -> PRAGMA IDENTIFIER ; .)
INFO:root:    error           reduce using rule 2 (pragma -> PRAGMA IDENTIFIER ; .)
INFO:root:    USE             reduce using rule 2 (pragma -> PRAGMA IDENTIFIER ; .)
INFO:root:    PRAGMA          reduce using rule 2 (pragma -> PRAGMA IDENTIFIER ; .)
INFO:root:    TYPE            reduce using rule 2 (pragma -> PRAGMA IDENTIFIER ; .)
INFO:root:    SUBTYPE         reduce using rule 2 (pragma -> PRAGMA IDENTIFIER ; .)
INFO:root:    FOR             reduce using rule 2 (pragma -> PRAGMA IDENTIFIER ; .)
INFO:root:    PROCEDURE       reduce using rule 2 (pragma -> PRAGMA IDENTIFIER ; .)
INFO:root:    FUNCTION        reduce using rule 2 (pragma -> PRAGMA IDENTIFIER ; .)
INFO:root:    GENERIC         reduce using rule 2 (pragma -> PRAGMA IDENTIFIER ; .)
INFO:root:    IDENTIFIER      reduce using rule 2 (pragma -> PRAGMA IDENTIFIER ; .)
INFO:root:    BEGIN           reduce using rule 2 (pragma -> PRAGMA IDENTIFIER ; .)
INFO:root:    PRIVATE         reduce using rule 2 (pragma -> PRAGMA IDENTIFIER ; .)
INFO:root:    END             reduce using rule 2 (pragma -> PRAGMA IDENTIFIER ; .)
INFO:root:    WITH            reduce using rule 2 (pragma -> PRAGMA IDENTIFIER ; .)
INFO:root:    SEPARATE        reduce using rule 2 (pragma -> PRAGMA IDENTIFIER ; .)
INFO:root:    $end            reduce using rule 2 (pragma -> PRAGMA IDENTIFIER ; .)
INFO:root:    ENTRY           reduce using rule 2 (pragma -> PRAGMA IDENTIFIER ; .)
INFO:root:    WHEN            reduce using rule 2 (pragma -> PRAGMA IDENTIFIER ; .)
INFO:root:    CASE            reduce using rule 2 (pragma -> PRAGMA IDENTIFIER ; .)
INFO:root:    NuLL            reduce using rule 2 (pragma -> PRAGMA IDENTIFIER ; .)
INFO:root:
INFO:root:
INFO:root:state 43
INFO:root:
INFO:root:    (9) pragma_s -> pragma_s pragma .
INFO:root:
INFO:root:    PRAGMA          reduce using rule 9 (pragma_s -> pragma_s pragma .)
INFO:root:    PRIVATE         reduce using rule 9 (pragma_s -> pragma_s pragma .)
INFO:root:    WITH            reduce using rule 9 (pragma_s -> pragma_s pragma .)
INFO:root:    PACKAGE         reduce using rule 9 (pragma_s -> pragma_s pragma .)
INFO:root:    SEPARATE        reduce using rule 9 (pragma_s -> pragma_s pragma .)
INFO:root:    PROCEDURE       reduce using rule 9 (pragma_s -> pragma_s pragma .)
INFO:root:    FUNCTION        reduce using rule 9 (pragma_s -> pragma_s pragma .)
INFO:root:    GENERIC         reduce using rule 9 (pragma_s -> pragma_s pragma .)
INFO:root:    $end            reduce using rule 9 (pragma_s -> pragma_s pragma .)
INFO:root:    NuLL            reduce using rule 9 (pragma_s -> pragma_s pragma .)
INFO:root:    CASE            reduce using rule 9 (pragma_s -> pragma_s pragma .)
INFO:root:    error           reduce using rule 9 (pragma_s -> pragma_s pragma .)
INFO:root:    IDENTIFIER      reduce using rule 9 (pragma_s -> pragma_s pragma .)
INFO:root:    END             reduce using rule 9 (pragma_s -> pragma_s pragma .)
INFO:root:    ENTRY           reduce using rule 9 (pragma_s -> pragma_s pragma .)
INFO:root:    WHEN            reduce using rule 9 (pragma_s -> pragma_s pragma .)
INFO:root:    FOR             reduce using rule 9 (pragma_s -> pragma_s pragma .)
INFO:root:
INFO:root:
INFO:root:state 44
INFO:root:
INFO:root:    (324) pkg_decl -> pkg_spec ; .
INFO:root:
INFO:root:    PRAGMA          reduce using rule 324 (pkg_decl -> pkg_spec ; .)
INFO:root:    PRIVATE         reduce using rule 324 (pkg_decl -> pkg_spec ; .)
INFO:root:    WITH            reduce using rule 324 (pkg_decl -> pkg_spec ; .)
INFO:root:    PACKAGE         reduce using rule 324 (pkg_decl -> pkg_spec ; .)
INFO:root:    SEPARATE        reduce using rule 324 (pkg_decl -> pkg_spec ; .)
INFO:root:    PROCEDURE       reduce using rule 324 (pkg_decl -> pkg_spec ; .)
INFO:root:    FUNCTION        reduce using rule 324 (pkg_decl -> pkg_spec ; .)
INFO:root:    GENERIC         reduce using rule 324 (pkg_decl -> pkg_spec ; .)
INFO:root:    $end            reduce using rule 324 (pkg_decl -> pkg_spec ; .)
INFO:root:    TASK            reduce using rule 324 (pkg_decl -> pkg_spec ; .)
INFO:root:    PROTECTED       reduce using rule 324 (pkg_decl -> pkg_spec ; .)
INFO:root:    error           reduce using rule 324 (pkg_decl -> pkg_spec ; .)
INFO:root:    USE             reduce using rule 324 (pkg_decl -> pkg_spec ; .)
INFO:root:    TYPE            reduce using rule 324 (pkg_decl -> pkg_spec ; .)
INFO:root:    SUBTYPE         reduce using rule 324 (pkg_decl -> pkg_spec ; .)
INFO:root:    FOR             reduce using rule 324 (pkg_decl -> pkg_spec ; .)
INFO:root:    IDENTIFIER      reduce using rule 324 (pkg_decl -> pkg_spec ; .)
INFO:root:    BEGIN           reduce using rule 324 (pkg_decl -> pkg_spec ; .)
INFO:root:    END             reduce using rule 324 (pkg_decl -> pkg_spec ; .)
INFO:root:
INFO:root:
INFO:root:state 45
INFO:root:
INFO:root:    (304) subprog_spec -> PROCEDURE compound_name . formal_part_opt
INFO:root:    (159) compound_name -> compound_name . . simple_name
INFO:root:    (309) formal_part_opt -> .
INFO:root:    (310) formal_part_opt -> . formal_part
INFO:root:    (311) formal_part -> . ( param_s )
INFO:root:
INFO:root:    .               shift and go to state 116
INFO:root:    ;               reduce using rule 309 (formal_part_opt -> .)
INFO:root:    IS              reduce using rule 309 (formal_part_opt -> .)
INFO:root:    RENAMES         reduce using rule 309 (formal_part_opt -> .)
INFO:root:    (               shift and go to state 151
INFO:root:
INFO:root:    formal_part                    shift and go to state 152
INFO:root:    formal_part_opt                shift and go to state 150
INFO:root:
INFO:root:state 46
INFO:root:
INFO:root:    (325) pkg_decl -> generic_pkg_inst ; .
INFO:root:
INFO:root:    PRAGMA          reduce using rule 325 (pkg_decl -> generic_pkg_inst ; .)
INFO:root:    PRIVATE         reduce using rule 325 (pkg_decl -> generic_pkg_inst ; .)
INFO:root:    WITH            reduce using rule 325 (pkg_decl -> generic_pkg_inst ; .)
INFO:root:    PACKAGE         reduce using rule 325 (pkg_decl -> generic_pkg_inst ; .)
INFO:root:    SEPARATE        reduce using rule 325 (pkg_decl -> generic_pkg_inst ; .)
INFO:root:    PROCEDURE       reduce using rule 325 (pkg_decl -> generic_pkg_inst ; .)
INFO:root:    FUNCTION        reduce using rule 325 (pkg_decl -> generic_pkg_inst ; .)
INFO:root:    GENERIC         reduce using rule 325 (pkg_decl -> generic_pkg_inst ; .)
INFO:root:    $end            reduce using rule 325 (pkg_decl -> generic_pkg_inst ; .)
INFO:root:    TASK            reduce using rule 325 (pkg_decl -> generic_pkg_inst ; .)
INFO:root:    PROTECTED       reduce using rule 325 (pkg_decl -> generic_pkg_inst ; .)
INFO:root:    error           reduce using rule 325 (pkg_decl -> generic_pkg_inst ; .)
INFO:root:    USE             reduce using rule 325 (pkg_decl -> generic_pkg_inst ; .)
INFO:root:    TYPE            reduce using rule 325 (pkg_decl -> generic_pkg_inst ; .)
INFO:root:    SUBTYPE         reduce using rule 325 (pkg_decl -> generic_pkg_inst ; .)
INFO:root:    FOR             reduce using rule 325 (pkg_decl -> generic_pkg_inst ; .)
INFO:root:    IDENTIFIER      reduce using rule 325 (pkg_decl -> generic_pkg_inst ; .)
INFO:root:    BEGIN           reduce using rule 325 (pkg_decl -> generic_pkg_inst ; .)
INFO:root:    END             reduce using rule 325 (pkg_decl -> generic_pkg_inst ; .)
INFO:root:
INFO:root:
INFO:root:state 47
INFO:root:
INFO:root:    (461) generic_formal_part -> generic_formal_part generic_formal .
INFO:root:
INFO:root:    PACKAGE         reduce using rule 461 (generic_formal_part -> generic_formal_part generic_formal .)
INFO:root:    PROCEDURE       reduce using rule 461 (generic_formal_part -> generic_formal_part generic_formal .)
INFO:root:    FUNCTION        reduce using rule 461 (generic_formal_part -> generic_formal_part generic_formal .)
INFO:root:    TYPE            reduce using rule 461 (generic_formal_part -> generic_formal_part generic_formal .)
INFO:root:    WITH            reduce using rule 461 (generic_formal_part -> generic_formal_part generic_formal .)
INFO:root:    error           reduce using rule 461 (generic_formal_part -> generic_formal_part generic_formal .)
INFO:root:    USE             reduce using rule 461 (generic_formal_part -> generic_formal_part generic_formal .)
INFO:root:    IDENTIFIER      reduce using rule 461 (generic_formal_part -> generic_formal_part generic_formal .)
INFO:root:
INFO:root:
INFO:root:state 48
INFO:root:
INFO:root:    (464) generic_formal -> WITH . PROCEDURE simple_name formal_part_opt subp_default ;
INFO:root:    (465) generic_formal -> WITH . FUNCTION designator formal_part_opt RETURN name subp_default ;
INFO:root:    (466) generic_formal -> WITH . PACKAGE simple_name IS NEW name ( BOX ) ;
INFO:root:    (467) generic_formal -> WITH . PACKAGE simple_name IS NEW name ;
INFO:root:
INFO:root:    PROCEDURE       shift and go to state 154
INFO:root:    FUNCTION        shift and go to state 153
INFO:root:    PACKAGE         shift and go to state 155
INFO:root:
INFO:root:
INFO:root:state 49
INFO:root:
INFO:root:    (346) rename_unit -> generic_formal_part PACKAGE . compound_name renames ;
INFO:root:    (326) pkg_spec -> PACKAGE . compound_name IS decl_item_s private_part END c_id_opt
INFO:root:    (158) compound_name -> . simple_name
INFO:root:    (159) compound_name -> . compound_name . simple_name
INFO:root:    (157) simple_name -> . IDENTIFIER
INFO:root:
INFO:root:    IDENTIFIER      shift and go to state 33
INFO:root:
INFO:root:    simple_name                    shift and go to state 34
INFO:root:    compound_name                  shift and go to state 156
INFO:root:
INFO:root:state 50
INFO:root:
INFO:root:    (463) generic_formal -> TYPE . simple_name generic_discrim_part_opt IS generic_type_def ;
INFO:root:    (157) simple_name -> . IDENTIFIER
INFO:root:
INFO:root:    IDENTIFIER      shift and go to state 33
INFO:root:
INFO:root:    simple_name                    shift and go to state 157
INFO:root:
INFO:root:state 51
INFO:root:
INFO:root:    (458) generic_decl -> generic_formal_part subprog_spec . ;
INFO:root:    (347) rename_unit -> generic_formal_part subprog_spec . renames ;
INFO:root:    (348) renames -> . RENAMES name
INFO:root:
INFO:root:    ;               shift and go to state 159
INFO:root:    RENAMES         shift and go to state 66
INFO:root:
INFO:root:    renames                        shift and go to state 158
INFO:root:
INFO:root:state 52
INFO:root:
INFO:root:    (26) def_id -> IDENTIFIER .
INFO:root:
INFO:root:    :               reduce using rule 26 (def_id -> IDENTIFIER .)
INFO:root:    ,               reduce using rule 26 (def_id -> IDENTIFIER .)
INFO:root:
INFO:root:
INFO:root:state 53
INFO:root:
INFO:root:    (337) use_clause -> USE . name_s ;
INFO:root:    (338) use_clause -> USE . TYPE name_s ;
INFO:root:    (339) name_s -> . name
INFO:root:    (340) name_s -> . name_s , name
INFO:root:    (149) name -> . simple_name
INFO:root:    (150) name -> . indexed_comp
INFO:root:    (151) name -> . selected_comp
INFO:root:    (152) name -> . attribute
INFO:root:    (153) name -> . operator_symbol
INFO:root:    (157) simple_name -> . IDENTIFIER
INFO:root:    (164) indexed_comp -> . name ( value_s )
INFO:root:    (171) selected_comp -> . name . simple_name
INFO:root:    (172) selected_comp -> . name . used_char
INFO:root:    (173) selected_comp -> . name . operator_symbol
INFO:root:    (174) selected_comp -> . name . ALL
INFO:root:    (175) attribute -> . name TICK attribute_id
INFO:root:    (163) operator_symbol -> . STRING
INFO:root:
INFO:root:    TYPE            shift and go to state 162
INFO:root:    IDENTIFIER      shift and go to state 33
INFO:root:    STRING          shift and go to state 149
INFO:root:
INFO:root:    selected_comp                  shift and go to state 139
INFO:root:    simple_name                    shift and go to state 163
INFO:root:    indexed_comp                   shift and go to state 140
INFO:root:    attribute                      shift and go to state 134
INFO:root:    name                           shift and go to state 161
INFO:root:    name_s                         shift and go to state 160
INFO:root:    operator_symbol                shift and go to state 133
INFO:root:
INFO:root:state 54
INFO:root:
INFO:root:    (459) generic_decl -> generic_formal_part pkg_spec . ;
INFO:root:
INFO:root:    ;               shift and go to state 164
INFO:root:
INFO:root:
INFO:root:state 55
INFO:root:
INFO:root:    (315) param -> error .
INFO:root:
INFO:root:    )               reduce using rule 315 (param -> error .)
INFO:root:    ;               reduce using rule 315 (param -> error .)
INFO:root:
INFO:root:
INFO:root:state 56
INFO:root:
INFO:root:    (314) param -> def_id_s . : mode mark init_opt
INFO:root:    (25) def_id_s -> def_id_s . , def_id
INFO:root:
INFO:root:    :               shift and go to state 166
INFO:root:    ,               shift and go to state 165
INFO:root:
INFO:root:
INFO:root:state 57
INFO:root:
INFO:root:    (24) def_id_s -> def_id .
INFO:root:
INFO:root:    :               reduce using rule 24 (def_id_s -> def_id .)
INFO:root:    ,               reduce using rule 24 (def_id_s -> def_id .)
INFO:root:
INFO:root:
INFO:root:state 58
INFO:root:
INFO:root:    (468) generic_formal -> use_clause .
INFO:root:
INFO:root:    PACKAGE         reduce using rule 468 (generic_formal -> use_clause .)
INFO:root:    PROCEDURE       reduce using rule 468 (generic_formal -> use_clause .)
INFO:root:    FUNCTION        reduce using rule 468 (generic_formal -> use_clause .)
INFO:root:    TYPE            reduce using rule 468 (generic_formal -> use_clause .)
INFO:root:    WITH            reduce using rule 468 (generic_formal -> use_clause .)
INFO:root:    error           reduce using rule 468 (generic_formal -> use_clause .)
INFO:root:    USE             reduce using rule 468 (generic_formal -> use_clause .)
INFO:root:    IDENTIFIER      reduce using rule 468 (generic_formal -> use_clause .)
INFO:root:
INFO:root:
INFO:root:state 59
INFO:root:
INFO:root:    (462) generic_formal -> param . ;
INFO:root:
INFO:root:    ;               shift and go to state 167
INFO:root:
INFO:root:
INFO:root:state 60
INFO:root:
INFO:root:    (421) comp_unit -> private_opt unit pragma_s .
INFO:root:    (9) pragma_s -> pragma_s . pragma
INFO:root:    (2) pragma -> . PRAGMA IDENTIFIER ;
INFO:root:    (3) pragma -> . PRAGMA simple_name ( pragma_arg_s ) ;
INFO:root:
INFO:root:    PRIVATE         reduce using rule 421 (comp_unit -> private_opt unit pragma_s .)
INFO:root:    WITH            reduce using rule 421 (comp_unit -> private_opt unit pragma_s .)
INFO:root:    PACKAGE         reduce using rule 421 (comp_unit -> private_opt unit pragma_s .)
INFO:root:    SEPARATE        reduce using rule 421 (comp_unit -> private_opt unit pragma_s .)
INFO:root:    PROCEDURE       reduce using rule 421 (comp_unit -> private_opt unit pragma_s .)
INFO:root:    FUNCTION        reduce using rule 421 (comp_unit -> private_opt unit pragma_s .)
INFO:root:    GENERIC         reduce using rule 421 (comp_unit -> private_opt unit pragma_s .)
INFO:root:    $end            reduce using rule 421 (comp_unit -> private_opt unit pragma_s .)
INFO:root:    PRAGMA          shift and go to state 2
INFO:root:
INFO:root:    pragma                         shift and go to state 43
INFO:root:
INFO:root:state 61
INFO:root:
INFO:root:    (437) subunit -> SEPARATE ( . compound_name ) subunit_body
INFO:root:    (158) compound_name -> . simple_name
INFO:root:    (159) compound_name -> . compound_name . simple_name
INFO:root:    (157) simple_name -> . IDENTIFIER
INFO:root:
INFO:root:    IDENTIFIER      shift and go to state 33
INFO:root:
INFO:root:    simple_name                    shift and go to state 34
INFO:root:    compound_name                  shift and go to state 168
INFO:root:
INFO:root:state 62
INFO:root:
INFO:root:    (308) designator -> STRING .
INFO:root:
INFO:root:    ;               reduce using rule 308 (designator -> STRING .)
INFO:root:    (               reduce using rule 308 (designator -> STRING .)
INFO:root:    RETURN          reduce using rule 308 (designator -> STRING .)
INFO:root:    IS              reduce using rule 308 (designator -> STRING .)
INFO:root:    RENAMES         reduce using rule 308 (designator -> STRING .)
INFO:root:
INFO:root:
INFO:root:state 63
INFO:root:
INFO:root:    (305) subprog_spec -> FUNCTION designator . formal_part_opt RETURN name
INFO:root:    (306) subprog_spec -> FUNCTION designator .
INFO:root:    (309) formal_part_opt -> .
INFO:root:    (310) formal_part_opt -> . formal_part
INFO:root:    (311) formal_part -> . ( param_s )
INFO:root:
INFO:root:    ;               reduce using rule 306 (subprog_spec -> FUNCTION designator .)
INFO:root:    IS              reduce using rule 306 (subprog_spec -> FUNCTION designator .)
INFO:root:    RENAMES         reduce using rule 306 (subprog_spec -> FUNCTION designator .)
INFO:root:    RETURN          reduce using rule 309 (formal_part_opt -> .)
INFO:root:    (               shift and go to state 151
INFO:root:
INFO:root:    formal_part_opt                shift and go to state 169
INFO:root:    formal_part                    shift and go to state 152
INFO:root:
INFO:root:state 64
INFO:root:
INFO:root:    (307) designator -> compound_name .
INFO:root:    (159) compound_name -> compound_name . . simple_name
INFO:root:
INFO:root:    ;               reduce using rule 307 (designator -> compound_name .)
INFO:root:    (               reduce using rule 307 (designator -> compound_name .)
INFO:root:    RETURN          reduce using rule 307 (designator -> compound_name .)
INFO:root:    IS              reduce using rule 307 (designator -> compound_name .)
INFO:root:    RENAMES         reduce using rule 307 (designator -> compound_name .)
INFO:root:    .               shift and go to state 116
INFO:root:
INFO:root:
INFO:root:state 65
INFO:root:
INFO:root:    (302) subprog_decl -> generic_subp_inst ; .
INFO:root:
INFO:root:    PACKAGE         reduce using rule 302 (subprog_decl -> generic_subp_inst ; .)
INFO:root:    TASK            reduce using rule 302 (subprog_decl -> generic_subp_inst ; .)
INFO:root:    PROTECTED       reduce using rule 302 (subprog_decl -> generic_subp_inst ; .)
INFO:root:    error           reduce using rule 302 (subprog_decl -> generic_subp_inst ; .)
INFO:root:    USE             reduce using rule 302 (subprog_decl -> generic_subp_inst ; .)
INFO:root:    PRAGMA          reduce using rule 302 (subprog_decl -> generic_subp_inst ; .)
INFO:root:    TYPE            reduce using rule 302 (subprog_decl -> generic_subp_inst ; .)
INFO:root:    SUBTYPE         reduce using rule 302 (subprog_decl -> generic_subp_inst ; .)
INFO:root:    FOR             reduce using rule 302 (subprog_decl -> generic_subp_inst ; .)
INFO:root:    PROCEDURE       reduce using rule 302 (subprog_decl -> generic_subp_inst ; .)
INFO:root:    FUNCTION        reduce using rule 302 (subprog_decl -> generic_subp_inst ; .)
INFO:root:    GENERIC         reduce using rule 302 (subprog_decl -> generic_subp_inst ; .)
INFO:root:    IDENTIFIER      reduce using rule 302 (subprog_decl -> generic_subp_inst ; .)
INFO:root:    BEGIN           reduce using rule 302 (subprog_decl -> generic_subp_inst ; .)
INFO:root:    END             reduce using rule 302 (subprog_decl -> generic_subp_inst ; .)
INFO:root:    PRIVATE         reduce using rule 302 (subprog_decl -> generic_subp_inst ; .)
INFO:root:    WITH            reduce using rule 302 (subprog_decl -> generic_subp_inst ; .)
INFO:root:    SEPARATE        reduce using rule 302 (subprog_decl -> generic_subp_inst ; .)
INFO:root:    $end            reduce using rule 302 (subprog_decl -> generic_subp_inst ; .)
INFO:root:
INFO:root:
INFO:root:state 66
INFO:root:
INFO:root:    (348) renames -> RENAMES . name
INFO:root:    (149) name -> . simple_name
INFO:root:    (150) name -> . indexed_comp
INFO:root:    (151) name -> . selected_comp
INFO:root:    (152) name -> . attribute
INFO:root:    (153) name -> . operator_symbol
INFO:root:    (157) simple_name -> . IDENTIFIER
INFO:root:    (164) indexed_comp -> . name ( value_s )
INFO:root:    (171) selected_comp -> . name . simple_name
INFO:root:    (172) selected_comp -> . name . used_char
INFO:root:    (173) selected_comp -> . name . operator_symbol
INFO:root:    (174) selected_comp -> . name . ALL
INFO:root:    (175) attribute -> . name TICK attribute_id
INFO:root:    (163) operator_symbol -> . STRING
INFO:root:
INFO:root:    IDENTIFIER      shift and go to state 33
INFO:root:    STRING          shift and go to state 149
INFO:root:
INFO:root:    selected_comp                  shift and go to state 139
INFO:root:    simple_name                    shift and go to state 163
INFO:root:    indexed_comp                   shift and go to state 140
INFO:root:    attribute                      shift and go to state 134
INFO:root:    name                           shift and go to state 170
INFO:root:    operator_symbol                shift and go to state 133
INFO:root:
INFO:root:state 67
INFO:root:
INFO:root:    (345) rename_unit -> subprog_spec renames . ;
INFO:root:
INFO:root:    ;               shift and go to state 171
INFO:root:
INFO:root:
INFO:root:state 68
INFO:root:
INFO:root:    (488) generic_subp_inst -> subprog_spec IS . generic_inst
INFO:root:    (321) subprog_spec_is_push -> subprog_spec IS .
INFO:root:    (490) generic_inst -> . NEW name
INFO:root:
INFO:root:    ABSTRACT        reduce using rule 321 (subprog_spec_is_push -> subprog_spec IS .)
INFO:root:    PACKAGE         reduce using rule 321 (subprog_spec_is_push -> subprog_spec IS .)
INFO:root:    TASK            reduce using rule 321 (subprog_spec_is_push -> subprog_spec IS .)
INFO:root:    PROTECTED       reduce using rule 321 (subprog_spec_is_push -> subprog_spec IS .)
INFO:root:    error           reduce using rule 321 (subprog_spec_is_push -> subprog_spec IS .)
INFO:root:    USE             reduce using rule 321 (subprog_spec_is_push -> subprog_spec IS .)
INFO:root:    PRAGMA          reduce using rule 321 (subprog_spec_is_push -> subprog_spec IS .)
INFO:root:    TYPE            reduce using rule 321 (subprog_spec_is_push -> subprog_spec IS .)
INFO:root:    SUBTYPE         reduce using rule 321 (subprog_spec_is_push -> subprog_spec IS .)
INFO:root:    FOR             reduce using rule 321 (subprog_spec_is_push -> subprog_spec IS .)
INFO:root:    PROCEDURE       reduce using rule 321 (subprog_spec_is_push -> subprog_spec IS .)
INFO:root:    FUNCTION        reduce using rule 321 (subprog_spec_is_push -> subprog_spec IS .)
INFO:root:    GENERIC         reduce using rule 321 (subprog_spec_is_push -> subprog_spec IS .)
INFO:root:    IDENTIFIER      reduce using rule 321 (subprog_spec_is_push -> subprog_spec IS .)
INFO:root:    BEGIN           reduce using rule 321 (subprog_spec_is_push -> subprog_spec IS .)
INFO:root:    NEW             shift and go to state 173
INFO:root:
INFO:root:    generic_inst                   shift and go to state 172
INFO:root:
INFO:root:state 69
INFO:root:
INFO:root:    (301) subprog_decl -> subprog_spec ; .
INFO:root:
INFO:root:    PACKAGE         reduce using rule 301 (subprog_decl -> subprog_spec ; .)
INFO:root:    TASK            reduce using rule 301 (subprog_decl -> subprog_spec ; .)
INFO:root:    PROTECTED       reduce using rule 301 (subprog_decl -> subprog_spec ; .)
INFO:root:    error           reduce using rule 301 (subprog_decl -> subprog_spec ; .)
INFO:root:    USE             reduce using rule 301 (subprog_decl -> subprog_spec ; .)
INFO:root:    PRAGMA          reduce using rule 301 (subprog_decl -> subprog_spec ; .)
INFO:root:    TYPE            reduce using rule 301 (subprog_decl -> subprog_spec ; .)
INFO:root:    SUBTYPE         reduce using rule 301 (subprog_decl -> subprog_spec ; .)
INFO:root:    FOR             reduce using rule 301 (subprog_decl -> subprog_spec ; .)
INFO:root:    PROCEDURE       reduce using rule 301 (subprog_decl -> subprog_spec ; .)
INFO:root:    FUNCTION        reduce using rule 301 (subprog_decl -> subprog_spec ; .)
INFO:root:    GENERIC         reduce using rule 301 (subprog_decl -> subprog_spec ; .)
INFO:root:    IDENTIFIER      reduce using rule 301 (subprog_decl -> subprog_spec ; .)
INFO:root:    BEGIN           reduce using rule 301 (subprog_decl -> subprog_spec ; .)
INFO:root:    END             reduce using rule 301 (subprog_decl -> subprog_spec ; .)
INFO:root:    PRIVATE         reduce using rule 301 (subprog_decl -> subprog_spec ; .)
INFO:root:    WITH            reduce using rule 301 (subprog_decl -> subprog_spec ; .)
INFO:root:    SEPARATE        reduce using rule 301 (subprog_decl -> subprog_spec ; .)
INFO:root:    $end            reduce using rule 301 (subprog_decl -> subprog_spec ; .)
INFO:root:
INFO:root:
INFO:root:state 70
INFO:root:
INFO:root:    (344) rename_unit -> PACKAGE compound_name . renames ;
INFO:root:    (326) pkg_spec -> PACKAGE compound_name . IS decl_item_s private_part END c_id_opt
INFO:root:    (489) generic_pkg_inst -> PACKAGE compound_name . IS generic_inst
INFO:root:    (159) compound_name -> compound_name . . simple_name
INFO:root:    (348) renames -> . RENAMES name
INFO:root:
INFO:root:    IS              shift and go to state 175
INFO:root:    .               shift and go to state 116
INFO:root:    RENAMES         shift and go to state 66
INFO:root:
INFO:root:    renames                        shift and go to state 174
INFO:root:
INFO:root:state 71
INFO:root:
INFO:root:    (331) pkg_body -> PACKAGE BODY . compound_name IS decl_part body_opt END c_id_opt ;
INFO:root:    (158) compound_name -> . simple_name
INFO:root:    (159) compound_name -> . compound_name . simple_name
INFO:root:    (157) simple_name -> . IDENTIFIER
INFO:root:
INFO:root:    IDENTIFIER      shift and go to state 33
INFO:root:
INFO:root:    simple_name                    shift and go to state 34
INFO:root:    compound_name                  shift and go to state 176
INFO:root:
INFO:root:state 72
INFO:root:
INFO:root:    (139) decl_item -> rep_spec .
INFO:root:
INFO:root:    PACKAGE         reduce using rule 139 (decl_item -> rep_spec .)
INFO:root:    TASK            reduce using rule 139 (decl_item -> rep_spec .)
INFO:root:    PROTECTED       reduce using rule 139 (decl_item -> rep_spec .)
INFO:root:    error           reduce using rule 139 (decl_item -> rep_spec .)
INFO:root:    USE             reduce using rule 139 (decl_item -> rep_spec .)
INFO:root:    PRAGMA          reduce using rule 139 (decl_item -> rep_spec .)
INFO:root:    TYPE            reduce using rule 139 (decl_item -> rep_spec .)
INFO:root:    SUBTYPE         reduce using rule 139 (decl_item -> rep_spec .)
INFO:root:    FOR             reduce using rule 139 (decl_item -> rep_spec .)
INFO:root:    PROCEDURE       reduce using rule 139 (decl_item -> rep_spec .)
INFO:root:    FUNCTION        reduce using rule 139 (decl_item -> rep_spec .)
INFO:root:    GENERIC         reduce using rule 139 (decl_item -> rep_spec .)
INFO:root:    IDENTIFIER      reduce using rule 139 (decl_item -> rep_spec .)
INFO:root:    BEGIN           reduce using rule 139 (decl_item -> rep_spec .)
INFO:root:    END             reduce using rule 139 (decl_item -> rep_spec .)
INFO:root:    PRIVATE         reduce using rule 139 (decl_item -> rep_spec .)
INFO:root:
INFO:root:
INFO:root:state 73
INFO:root:
INFO:root:    (331) pkg_body -> PACKAGE . BODY compound_name IS decl_part body_opt END c_id_opt ;
INFO:root:    (443) body_stub -> PACKAGE . BODY compound_name IS SEPARATE ;
INFO:root:    (326) pkg_spec -> PACKAGE . compound_name IS decl_item_s private_part END c_id_opt
INFO:root:    (489) generic_pkg_inst -> PACKAGE . compound_name IS generic_inst
INFO:root:    (344) rename_unit -> PACKAGE . compound_name renames ;
INFO:root:    (158) compound_name -> . simple_name
INFO:root:    (159) compound_name -> . compound_name . simple_name
INFO:root:    (157) simple_name -> . IDENTIFIER
INFO:root:
INFO:root:    BODY            shift and go to state 178
INFO:root:    IDENTIFIER      shift and go to state 33
INFO:root:
INFO:root:    simple_name                    shift and go to state 34
INFO:root:    compound_name                  shift and go to state 177
INFO:root:
INFO:root:state 74
INFO:root:
INFO:root:    (36) type_decl -> TYPE . IDENTIFIER discrim_part_opt type_completion ;
INFO:root:
INFO:root:    IDENTIFIER      shift and go to state 179
INFO:root:
INFO:root:
INFO:root:state 75
INFO:root:
INFO:root:    (143) decl_item_or_body -> body .
INFO:root:
INFO:root:    PACKAGE         reduce using rule 143 (decl_item_or_body -> body .)
INFO:root:    TASK            reduce using rule 143 (decl_item_or_body -> body .)
INFO:root:    PROTECTED       reduce using rule 143 (decl_item_or_body -> body .)
INFO:root:    error           reduce using rule 143 (decl_item_or_body -> body .)
INFO:root:    USE             reduce using rule 143 (decl_item_or_body -> body .)
INFO:root:    PRAGMA          reduce using rule 143 (decl_item_or_body -> body .)
INFO:root:    TYPE            reduce using rule 143 (decl_item_or_body -> body .)
INFO:root:    SUBTYPE         reduce using rule 143 (decl_item_or_body -> body .)
INFO:root:    FOR             reduce using rule 143 (decl_item_or_body -> body .)
INFO:root:    PROCEDURE       reduce using rule 143 (decl_item_or_body -> body .)
INFO:root:    FUNCTION        reduce using rule 143 (decl_item_or_body -> body .)
INFO:root:    GENERIC         reduce using rule 143 (decl_item_or_body -> body .)
INFO:root:    IDENTIFIER      reduce using rule 143 (decl_item_or_body -> body .)
INFO:root:    BEGIN           reduce using rule 143 (decl_item_or_body -> body .)
INFO:root:    END             reduce using rule 143 (decl_item_or_body -> body .)
INFO:root:
INFO:root:
INFO:root:state 76
INFO:root:
INFO:root:    (16) decl -> task_decl .
INFO:root:
INFO:root:    PACKAGE         reduce using rule 16 (decl -> task_decl .)
INFO:root:    TASK            reduce using rule 16 (decl -> task_decl .)
INFO:root:    PROTECTED       reduce using rule 16 (decl -> task_decl .)
INFO:root:    error           reduce using rule 16 (decl -> task_decl .)
INFO:root:    USE             reduce using rule 16 (decl -> task_decl .)
INFO:root:    PRAGMA          reduce using rule 16 (decl -> task_decl .)
INFO:root:    TYPE            reduce using rule 16 (decl -> task_decl .)
INFO:root:    SUBTYPE         reduce using rule 16 (decl -> task_decl .)
INFO:root:    FOR             reduce using rule 16 (decl -> task_decl .)
INFO:root:    PROCEDURE       reduce using rule 16 (decl -> task_decl .)
INFO:root:    FUNCTION        reduce using rule 16 (decl -> task_decl .)
INFO:root:    GENERIC         reduce using rule 16 (decl -> task_decl .)
INFO:root:    IDENTIFIER      reduce using rule 16 (decl -> task_decl .)
INFO:root:    BEGIN           reduce using rule 16 (decl -> task_decl .)
INFO:root:    END             reduce using rule 16 (decl -> task_decl .)
INFO:root:    PRIVATE         reduce using rule 16 (decl -> task_decl .)
INFO:root:
INFO:root:
INFO:root:state 77
INFO:root:
INFO:root:    (14) decl -> subprog_decl .
INFO:root:
INFO:root:    PACKAGE         reduce using rule 14 (decl -> subprog_decl .)
INFO:root:    TASK            reduce using rule 14 (decl -> subprog_decl .)
INFO:root:    PROTECTED       reduce using rule 14 (decl -> subprog_decl .)
INFO:root:    error           reduce using rule 14 (decl -> subprog_decl .)
INFO:root:    USE             reduce using rule 14 (decl -> subprog_decl .)
INFO:root:    PRAGMA          reduce using rule 14 (decl -> subprog_decl .)
INFO:root:    TYPE            reduce using rule 14 (decl -> subprog_decl .)
INFO:root:    SUBTYPE         reduce using rule 14 (decl -> subprog_decl .)
INFO:root:    FOR             reduce using rule 14 (decl -> subprog_decl .)
INFO:root:    PROCEDURE       reduce using rule 14 (decl -> subprog_decl .)
INFO:root:    FUNCTION        reduce using rule 14 (decl -> subprog_decl .)
INFO:root:    GENERIC         reduce using rule 14 (decl -> subprog_decl .)
INFO:root:    IDENTIFIER      reduce using rule 14 (decl -> subprog_decl .)
INFO:root:    BEGIN           reduce using rule 14 (decl -> subprog_decl .)
INFO:root:    END             reduce using rule 14 (decl -> subprog_decl .)
INFO:root:    PRIVATE         reduce using rule 14 (decl -> subprog_decl .)
INFO:root:
INFO:root:
INFO:root:state 78
INFO:root:
INFO:root:    (144) decl_item_or_body -> decl_item .
INFO:root:
INFO:root:    PACKAGE         reduce using rule 144 (decl_item_or_body -> decl_item .)
INFO:root:    TASK            reduce using rule 144 (decl_item_or_body -> decl_item .)
INFO:root:    PROTECTED       reduce using rule 144 (decl_item_or_body -> decl_item .)
INFO:root:    error           reduce using rule 144 (decl_item_or_body -> decl_item .)
INFO:root:    USE             reduce using rule 144 (decl_item_or_body -> decl_item .)
INFO:root:    PRAGMA          reduce using rule 144 (decl_item_or_body -> decl_item .)
INFO:root:    TYPE            reduce using rule 144 (decl_item_or_body -> decl_item .)
INFO:root:    SUBTYPE         reduce using rule 144 (decl_item_or_body -> decl_item .)
INFO:root:    FOR             reduce using rule 144 (decl_item_or_body -> decl_item .)
INFO:root:    PROCEDURE       reduce using rule 144 (decl_item_or_body -> decl_item .)
INFO:root:    FUNCTION        reduce using rule 144 (decl_item_or_body -> decl_item .)
INFO:root:    GENERIC         reduce using rule 144 (decl_item_or_body -> decl_item .)
INFO:root:    IDENTIFIER      reduce using rule 144 (decl_item_or_body -> decl_item .)
INFO:root:    BEGIN           reduce using rule 144 (decl_item_or_body -> decl_item .)
INFO:root:    END             reduce using rule 144 (decl_item_or_body -> decl_item .)
INFO:root:
INFO:root:
INFO:root:state 79
INFO:root:
INFO:root:    (23) object_decl -> def_id_s . : object_qualifier_opt object_subtype_def init_opt ;
INFO:root:    (35) number_decl -> def_id_s . : CONSTANT ASSIGN expression ;
INFO:root:    (446) exception_decl -> def_id_s . : EXCEPTION ;
INFO:root:    (341) rename_decl -> def_id_s . : object_qualifier_opt subtype_ind renames ;
INFO:root:    (342) rename_decl -> def_id_s . : EXCEPTION renames ;
INFO:root:    (25) def_id_s -> def_id_s . , def_id
INFO:root:
INFO:root:    :               shift and go to state 180
INFO:root:    ,               shift and go to state 165
INFO:root:
INFO:root:
INFO:root:state 80
INFO:root:
INFO:root:    (21) decl -> body_stub .
INFO:root:
INFO:root:    PACKAGE         reduce using rule 21 (decl -> body_stub .)
INFO:root:    TASK            reduce using rule 21 (decl -> body_stub .)
INFO:root:    PROTECTED       reduce using rule 21 (decl -> body_stub .)
INFO:root:    error           reduce using rule 21 (decl -> body_stub .)
INFO:root:    USE             reduce using rule 21 (decl -> body_stub .)
INFO:root:    PRAGMA          reduce using rule 21 (decl -> body_stub .)
INFO:root:    TYPE            reduce using rule 21 (decl -> body_stub .)
INFO:root:    SUBTYPE         reduce using rule 21 (decl -> body_stub .)
INFO:root:    FOR             reduce using rule 21 (decl -> body_stub .)
INFO:root:    PROCEDURE       reduce using rule 21 (decl -> body_stub .)
INFO:root:    FUNCTION        reduce using rule 21 (decl -> body_stub .)
INFO:root:    GENERIC         reduce using rule 21 (decl -> body_stub .)
INFO:root:    IDENTIFIER      reduce using rule 21 (decl -> body_stub .)
INFO:root:    BEGIN           reduce using rule 21 (decl -> body_stub .)
INFO:root:    END             reduce using rule 21 (decl -> body_stub .)
INFO:root:    PRIVATE         reduce using rule 21 (decl -> body_stub .)
INFO:root:
INFO:root:
INFO:root:state 81
INFO:root:
INFO:root:    (12) decl -> type_decl .
INFO:root:
INFO:root:    PACKAGE         reduce using rule 12 (decl -> type_decl .)
INFO:root:    TASK            reduce using rule 12 (decl -> type_decl .)
INFO:root:    PROTECTED       reduce using rule 12 (decl -> type_decl .)
INFO:root:    error           reduce using rule 12 (decl -> type_decl .)
INFO:root:    USE             reduce using rule 12 (decl -> type_decl .)
INFO:root:    PRAGMA          reduce using rule 12 (decl -> type_decl .)
INFO:root:    TYPE            reduce using rule 12 (decl -> type_decl .)
INFO:root:    SUBTYPE         reduce using rule 12 (decl -> type_decl .)
INFO:root:    FOR             reduce using rule 12 (decl -> type_decl .)
INFO:root:    PROCEDURE       reduce using rule 12 (decl -> type_decl .)
INFO:root:    FUNCTION        reduce using rule 12 (decl -> type_decl .)
INFO:root:    GENERIC         reduce using rule 12 (decl -> type_decl .)
INFO:root:    IDENTIFIER      reduce using rule 12 (decl -> type_decl .)
INFO:root:    BEGIN           reduce using rule 12 (decl -> type_decl .)
INFO:root:    END             reduce using rule 12 (decl -> type_decl .)
INFO:root:    PRIVATE         reduce using rule 12 (decl -> type_decl .)
INFO:root:
INFO:root:
INFO:root:state 82
INFO:root:
INFO:root:    (349) task_decl -> task_spec . ;
INFO:root:
INFO:root:    ;               shift and go to state 181
INFO:root:
INFO:root:
INFO:root:state 83
INFO:root:
INFO:root:    (493) rep_spec -> address_spec .
INFO:root:
INFO:root:    PACKAGE         reduce using rule 493 (rep_spec -> address_spec .)
INFO:root:    TASK            reduce using rule 493 (rep_spec -> address_spec .)
INFO:root:    PROTECTED       reduce using rule 493 (rep_spec -> address_spec .)
INFO:root:    error           reduce using rule 493 (rep_spec -> address_spec .)
INFO:root:    USE             reduce using rule 493 (rep_spec -> address_spec .)
INFO:root:    PRAGMA          reduce using rule 493 (rep_spec -> address_spec .)
INFO:root:    TYPE            reduce using rule 493 (rep_spec -> address_spec .)
INFO:root:    SUBTYPE         reduce using rule 493 (rep_spec -> address_spec .)
INFO:root:    FOR             reduce using rule 493 (rep_spec -> address_spec .)
INFO:root:    PROCEDURE       reduce using rule 493 (rep_spec -> address_spec .)
INFO:root:    FUNCTION        reduce using rule 493 (rep_spec -> address_spec .)
INFO:root:    GENERIC         reduce using rule 493 (rep_spec -> address_spec .)
INFO:root:    IDENTIFIER      reduce using rule 493 (rep_spec -> address_spec .)
INFO:root:    BEGIN           reduce using rule 493 (rep_spec -> address_spec .)
INFO:root:    END             reduce using rule 493 (rep_spec -> address_spec .)
INFO:root:    PRIVATE         reduce using rule 493 (rep_spec -> address_spec .)
INFO:root:    ENTRY           reduce using rule 493 (rep_spec -> address_spec .)
INFO:root:
INFO:root:
INFO:root:state 84
INFO:root:
INFO:root:    (356) task_body -> TASK . BODY simple_name IS decl_part block_body END id_opt ;
INFO:root:    (442) body_stub -> TASK . BODY simple_name IS SEPARATE ;
INFO:root:    (350) task_spec -> TASK . simple_name task_def
INFO:root:    (351) task_spec -> TASK . TYPE simple_name discrim_part_opt task_def
INFO:root:    (157) simple_name -> . IDENTIFIER
INFO:root:
INFO:root:    BODY            shift and go to state 183
INFO:root:    TYPE            shift and go to state 182
INFO:root:    IDENTIFIER      shift and go to state 33
INFO:root:
INFO:root:    simple_name                    shift and go to state 184
INFO:root:
INFO:root:state 85
INFO:root:
INFO:root:    (357) prot_decl -> prot_spec . ;
INFO:root:
INFO:root:    ;               shift and go to state 185
INFO:root:
INFO:root:
INFO:root:state 86
INFO:root:
INFO:root:    (321) subprog_spec_is_push -> subprog_spec . IS
INFO:root:    (301) subprog_decl -> subprog_spec . ;
INFO:root:    (444) body_stub -> subprog_spec . IS SEPARATE ;
INFO:root:    (488) generic_subp_inst -> subprog_spec . IS generic_inst
INFO:root:    (345) rename_unit -> subprog_spec . renames ;
INFO:root:    (348) renames -> . RENAMES name
INFO:root:
INFO:root:    IS              shift and go to state 186
INFO:root:    ;               shift and go to state 69
INFO:root:    RENAMES         shift and go to state 66
INFO:root:
INFO:root:    renames                        shift and go to state 67
INFO:root:
INFO:root:state 87
INFO:root:
INFO:root:    (10) decl -> object_decl .
INFO:root:
INFO:root:    PACKAGE         reduce using rule 10 (decl -> object_decl .)
INFO:root:    TASK            reduce using rule 10 (decl -> object_decl .)
INFO:root:    PROTECTED       reduce using rule 10 (decl -> object_decl .)
INFO:root:    error           reduce using rule 10 (decl -> object_decl .)
INFO:root:    USE             reduce using rule 10 (decl -> object_decl .)
INFO:root:    PRAGMA          reduce using rule 10 (decl -> object_decl .)
INFO:root:    TYPE            reduce using rule 10 (decl -> object_decl .)
INFO:root:    SUBTYPE         reduce using rule 10 (decl -> object_decl .)
INFO:root:    FOR             reduce using rule 10 (decl -> object_decl .)
INFO:root:    PROCEDURE       reduce using rule 10 (decl -> object_decl .)
INFO:root:    FUNCTION        reduce using rule 10 (decl -> object_decl .)
INFO:root:    GENERIC         reduce using rule 10 (decl -> object_decl .)
INFO:root:    IDENTIFIER      reduce using rule 10 (decl -> object_decl .)
INFO:root:    BEGIN           reduce using rule 10 (decl -> object_decl .)
INFO:root:    END             reduce using rule 10 (decl -> object_decl .)
INFO:root:    PRIVATE         reduce using rule 10 (decl -> object_decl .)
INFO:root:
INFO:root:
INFO:root:state 88
INFO:root:
INFO:root:    (20) decl -> generic_decl .
INFO:root:
INFO:root:    PACKAGE         reduce using rule 20 (decl -> generic_decl .)
INFO:root:    TASK            reduce using rule 20 (decl -> generic_decl .)
INFO:root:    PROTECTED       reduce using rule 20 (decl -> generic_decl .)
INFO:root:    error           reduce using rule 20 (decl -> generic_decl .)
INFO:root:    USE             reduce using rule 20 (decl -> generic_decl .)
INFO:root:    PRAGMA          reduce using rule 20 (decl -> generic_decl .)
INFO:root:    TYPE            reduce using rule 20 (decl -> generic_decl .)
INFO:root:    SUBTYPE         reduce using rule 20 (decl -> generic_decl .)
INFO:root:    FOR             reduce using rule 20 (decl -> generic_decl .)
INFO:root:    PROCEDURE       reduce using rule 20 (decl -> generic_decl .)
INFO:root:    FUNCTION        reduce using rule 20 (decl -> generic_decl .)
INFO:root:    GENERIC         reduce using rule 20 (decl -> generic_decl .)
INFO:root:    IDENTIFIER      reduce using rule 20 (decl -> generic_decl .)
INFO:root:    BEGIN           reduce using rule 20 (decl -> generic_decl .)
INFO:root:    END             reduce using rule 20 (decl -> generic_decl .)
INFO:root:    PRIVATE         reduce using rule 20 (decl -> generic_decl .)
INFO:root:
INFO:root:
INFO:root:state 89
INFO:root:
INFO:root:    (303) subprog_decl -> subprog_spec_is_push ABSTRACT . ;
INFO:root:
INFO:root:    ;               shift and go to state 187
INFO:root:
INFO:root:
INFO:root:state 90
INFO:root:
INFO:root:    (146) body -> pkg_body .
INFO:root:
INFO:root:    PACKAGE         reduce using rule 146 (body -> pkg_body .)
INFO:root:    TASK            reduce using rule 146 (body -> pkg_body .)
INFO:root:    PROTECTED       reduce using rule 146 (body -> pkg_body .)
INFO:root:    error           reduce using rule 146 (body -> pkg_body .)
INFO:root:    USE             reduce using rule 146 (body -> pkg_body .)
INFO:root:    PRAGMA          reduce using rule 146 (body -> pkg_body .)
INFO:root:    TYPE            reduce using rule 146 (body -> pkg_body .)
INFO:root:    SUBTYPE         reduce using rule 146 (body -> pkg_body .)
INFO:root:    FOR             reduce using rule 146 (body -> pkg_body .)
INFO:root:    PROCEDURE       reduce using rule 146 (body -> pkg_body .)
INFO:root:    FUNCTION        reduce using rule 146 (body -> pkg_body .)
INFO:root:    GENERIC         reduce using rule 146 (body -> pkg_body .)
INFO:root:    IDENTIFIER      reduce using rule 146 (body -> pkg_body .)
INFO:root:    BEGIN           reduce using rule 146 (body -> pkg_body .)
INFO:root:    END             reduce using rule 146 (body -> pkg_body .)
INFO:root:
INFO:root:
INFO:root:state 91
INFO:root:
INFO:root:    (18) decl -> exception_decl .
INFO:root:
INFO:root:    PACKAGE         reduce using rule 18 (decl -> exception_decl .)
INFO:root:    TASK            reduce using rule 18 (decl -> exception_decl .)
INFO:root:    PROTECTED       reduce using rule 18 (decl -> exception_decl .)
INFO:root:    error           reduce using rule 18 (decl -> exception_decl .)
INFO:root:    USE             reduce using rule 18 (decl -> exception_decl .)
INFO:root:    PRAGMA          reduce using rule 18 (decl -> exception_decl .)
INFO:root:    TYPE            reduce using rule 18 (decl -> exception_decl .)
INFO:root:    SUBTYPE         reduce using rule 18 (decl -> exception_decl .)
INFO:root:    FOR             reduce using rule 18 (decl -> exception_decl .)
INFO:root:    PROCEDURE       reduce using rule 18 (decl -> exception_decl .)
INFO:root:    FUNCTION        reduce using rule 18 (decl -> exception_decl .)
INFO:root:    GENERIC         reduce using rule 18 (decl -> exception_decl .)
INFO:root:    IDENTIFIER      reduce using rule 18 (decl -> exception_decl .)
INFO:root:    BEGIN           reduce using rule 18 (decl -> exception_decl .)
INFO:root:    END             reduce using rule 18 (decl -> exception_decl .)
INFO:root:    PRIVATE         reduce using rule 18 (decl -> exception_decl .)
INFO:root:
INFO:root:
INFO:root:state 92
INFO:root:
INFO:root:    (491) rep_spec -> attrib_def .
INFO:root:
INFO:root:    PACKAGE         reduce using rule 491 (rep_spec -> attrib_def .)
INFO:root:    TASK            reduce using rule 491 (rep_spec -> attrib_def .)
INFO:root:    PROTECTED       reduce using rule 491 (rep_spec -> attrib_def .)
INFO:root:    error           reduce using rule 491 (rep_spec -> attrib_def .)
INFO:root:    USE             reduce using rule 491 (rep_spec -> attrib_def .)
INFO:root:    PRAGMA          reduce using rule 491 (rep_spec -> attrib_def .)
INFO:root:    TYPE            reduce using rule 491 (rep_spec -> attrib_def .)
INFO:root:    SUBTYPE         reduce using rule 491 (rep_spec -> attrib_def .)
INFO:root:    FOR             reduce using rule 491 (rep_spec -> attrib_def .)
INFO:root:    PROCEDURE       reduce using rule 491 (rep_spec -> attrib_def .)
INFO:root:    FUNCTION        reduce using rule 491 (rep_spec -> attrib_def .)
INFO:root:    GENERIC         reduce using rule 491 (rep_spec -> attrib_def .)
INFO:root:    IDENTIFIER      reduce using rule 491 (rep_spec -> attrib_def .)
INFO:root:    BEGIN           reduce using rule 491 (rep_spec -> attrib_def .)
INFO:root:    END             reduce using rule 491 (rep_spec -> attrib_def .)
INFO:root:    PRIVATE         reduce using rule 491 (rep_spec -> attrib_def .)
INFO:root:    ENTRY           reduce using rule 491 (rep_spec -> attrib_def .)
INFO:root:
INFO:root:
INFO:root:state 93
INFO:root:
INFO:root:    (15) decl -> pkg_decl .
INFO:root:
INFO:root:    PACKAGE         reduce using rule 15 (decl -> pkg_decl .)
INFO:root:    TASK            reduce using rule 15 (decl -> pkg_decl .)
INFO:root:    PROTECTED       reduce using rule 15 (decl -> pkg_decl .)
INFO:root:    error           reduce using rule 15 (decl -> pkg_decl .)
INFO:root:    USE             reduce using rule 15 (decl -> pkg_decl .)
INFO:root:    PRAGMA          reduce using rule 15 (decl -> pkg_decl .)
INFO:root:    TYPE            reduce using rule 15 (decl -> pkg_decl .)
INFO:root:    SUBTYPE         reduce using rule 15 (decl -> pkg_decl .)
INFO:root:    FOR             reduce using rule 15 (decl -> pkg_decl .)
INFO:root:    PROCEDURE       reduce using rule 15 (decl -> pkg_decl .)
INFO:root:    FUNCTION        reduce using rule 15 (decl -> pkg_decl .)
INFO:root:    GENERIC         reduce using rule 15 (decl -> pkg_decl .)
INFO:root:    IDENTIFIER      reduce using rule 15 (decl -> pkg_decl .)
INFO:root:    BEGIN           reduce using rule 15 (decl -> pkg_decl .)
INFO:root:    END             reduce using rule 15 (decl -> pkg_decl .)
INFO:root:    PRIVATE         reduce using rule 15 (decl -> pkg_decl .)
INFO:root:
INFO:root:
INFO:root:state 94
INFO:root:
INFO:root:    (140) decl_item -> pragma .
INFO:root:
INFO:root:    PACKAGE         reduce using rule 140 (decl_item -> pragma .)
INFO:root:    TASK            reduce using rule 140 (decl_item -> pragma .)
INFO:root:    PROTECTED       reduce using rule 140 (decl_item -> pragma .)
INFO:root:    error           reduce using rule 140 (decl_item -> pragma .)
INFO:root:    USE             reduce using rule 140 (decl_item -> pragma .)
INFO:root:    PRAGMA          reduce using rule 140 (decl_item -> pragma .)
INFO:root:    TYPE            reduce using rule 140 (decl_item -> pragma .)
INFO:root:    SUBTYPE         reduce using rule 140 (decl_item -> pragma .)
INFO:root:    FOR             reduce using rule 140 (decl_item -> pragma .)
INFO:root:    PROCEDURE       reduce using rule 140 (decl_item -> pragma .)
INFO:root:    FUNCTION        reduce using rule 140 (decl_item -> pragma .)
INFO:root:    GENERIC         reduce using rule 140 (decl_item -> pragma .)
INFO:root:    IDENTIFIER      reduce using rule 140 (decl_item -> pragma .)
INFO:root:    BEGIN           reduce using rule 140 (decl_item -> pragma .)
INFO:root:    END             reduce using rule 140 (decl_item -> pragma .)
INFO:root:    PRIVATE         reduce using rule 140 (decl_item -> pragma .)
INFO:root:
INFO:root:
INFO:root:state 95
INFO:root:
INFO:root:    (17) decl -> prot_decl .
INFO:root:
INFO:root:    PACKAGE         reduce using rule 17 (decl -> prot_decl .)
INFO:root:    TASK            reduce using rule 17 (decl -> prot_decl .)
INFO:root:    PROTECTED       reduce using rule 17 (decl -> prot_decl .)
INFO:root:    error           reduce using rule 17 (decl -> prot_decl .)
INFO:root:    USE             reduce using rule 17 (decl -> prot_decl .)
INFO:root:    PRAGMA          reduce using rule 17 (decl -> prot_decl .)
INFO:root:    TYPE            reduce using rule 17 (decl -> prot_decl .)
INFO:root:    SUBTYPE         reduce using rule 17 (decl -> prot_decl .)
INFO:root:    FOR             reduce using rule 17 (decl -> prot_decl .)
INFO:root:    PROCEDURE       reduce using rule 17 (decl -> prot_decl .)
INFO:root:    FUNCTION        reduce using rule 17 (decl -> prot_decl .)
INFO:root:    GENERIC         reduce using rule 17 (decl -> prot_decl .)
INFO:root:    IDENTIFIER      reduce using rule 17 (decl -> prot_decl .)
INFO:root:    BEGIN           reduce using rule 17 (decl -> prot_decl .)
INFO:root:    END             reduce using rule 17 (decl -> prot_decl .)
INFO:root:    PRIVATE         reduce using rule 17 (decl -> prot_decl .)
INFO:root:
INFO:root:
INFO:root:state 96
INFO:root:
INFO:root:    (147) body -> task_body .
INFO:root:
INFO:root:    PACKAGE         reduce using rule 147 (body -> task_body .)
INFO:root:    TASK            reduce using rule 147 (body -> task_body .)
INFO:root:    PROTECTED       reduce using rule 147 (body -> task_body .)
INFO:root:    error           reduce using rule 147 (body -> task_body .)
INFO:root:    USE             reduce using rule 147 (body -> task_body .)
INFO:root:    PRAGMA          reduce using rule 147 (body -> task_body .)
INFO:root:    TYPE            reduce using rule 147 (body -> task_body .)
INFO:root:    SUBTYPE         reduce using rule 147 (body -> task_body .)
INFO:root:    FOR             reduce using rule 147 (body -> task_body .)
INFO:root:    PROCEDURE       reduce using rule 147 (body -> task_body .)
INFO:root:    FUNCTION        reduce using rule 147 (body -> task_body .)
INFO:root:    GENERIC         reduce using rule 147 (body -> task_body .)
INFO:root:    IDENTIFIER      reduce using rule 147 (body -> task_body .)
INFO:root:    BEGIN           reduce using rule 147 (body -> task_body .)
INFO:root:    END             reduce using rule 147 (body -> task_body .)
INFO:root:
INFO:root:
INFO:root:state 97
INFO:root:
INFO:root:    (138) decl_item -> use_clause .
INFO:root:
INFO:root:    PACKAGE         reduce using rule 138 (decl_item -> use_clause .)
INFO:root:    TASK            reduce using rule 138 (decl_item -> use_clause .)
INFO:root:    PROTECTED       reduce using rule 138 (decl_item -> use_clause .)
INFO:root:    error           reduce using rule 138 (decl_item -> use_clause .)
INFO:root:    USE             reduce using rule 138 (decl_item -> use_clause .)
INFO:root:    PRAGMA          reduce using rule 138 (decl_item -> use_clause .)
INFO:root:    TYPE            reduce using rule 138 (decl_item -> use_clause .)
INFO:root:    SUBTYPE         reduce using rule 138 (decl_item -> use_clause .)
INFO:root:    FOR             reduce using rule 138 (decl_item -> use_clause .)
INFO:root:    PROCEDURE       reduce using rule 138 (decl_item -> use_clause .)
INFO:root:    FUNCTION        reduce using rule 138 (decl_item -> use_clause .)
INFO:root:    GENERIC         reduce using rule 138 (decl_item -> use_clause .)
INFO:root:    IDENTIFIER      reduce using rule 138 (decl_item -> use_clause .)
INFO:root:    BEGIN           reduce using rule 138 (decl_item -> use_clause .)
INFO:root:    END             reduce using rule 138 (decl_item -> use_clause .)
INFO:root:    PRIVATE         reduce using rule 138 (decl_item -> use_clause .)
INFO:root:
INFO:root:
INFO:root:state 98
INFO:root:
INFO:root:    (19) decl -> rename_decl .
INFO:root:
INFO:root:    PACKAGE         reduce using rule 19 (decl -> rename_decl .)
INFO:root:    TASK            reduce using rule 19 (decl -> rename_decl .)
INFO:root:    PROTECTED       reduce using rule 19 (decl -> rename_decl .)
INFO:root:    error           reduce using rule 19 (decl -> rename_decl .)
INFO:root:    USE             reduce using rule 19 (decl -> rename_decl .)
INFO:root:    PRAGMA          reduce using rule 19 (decl -> rename_decl .)
INFO:root:    TYPE            reduce using rule 19 (decl -> rename_decl .)
INFO:root:    SUBTYPE         reduce using rule 19 (decl -> rename_decl .)
INFO:root:    FOR             reduce using rule 19 (decl -> rename_decl .)
INFO:root:    PROCEDURE       reduce using rule 19 (decl -> rename_decl .)
INFO:root:    FUNCTION        reduce using rule 19 (decl -> rename_decl .)
INFO:root:    GENERIC         reduce using rule 19 (decl -> rename_decl .)
INFO:root:    IDENTIFIER      reduce using rule 19 (decl -> rename_decl .)
INFO:root:    BEGIN           reduce using rule 19 (decl -> rename_decl .)
INFO:root:    END             reduce using rule 19 (decl -> rename_decl .)
INFO:root:    PRIVATE         reduce using rule 19 (decl -> rename_decl .)
INFO:root:
INFO:root:
INFO:root:state 99
INFO:root:
INFO:root:    (373) prot_body -> PROTECTED . BODY simple_name IS prot_op_body_s END id_opt ;
INFO:root:    (445) body_stub -> PROTECTED . BODY simple_name IS SEPARATE ;
INFO:root:    (358) prot_spec -> PROTECTED . IDENTIFIER prot_def
INFO:root:    (359) prot_spec -> PROTECTED . TYPE simple_name discrim_part_opt prot_def
INFO:root:
INFO:root:    BODY            shift and go to state 188
INFO:root:    IDENTIFIER      shift and go to state 190
INFO:root:    TYPE            shift and go to state 189
INFO:root:
INFO:root:
INFO:root:state 100
INFO:root:
INFO:root:    (148) body -> prot_body .
INFO:root:
INFO:root:    PACKAGE         reduce using rule 148 (body -> prot_body .)
INFO:root:    TASK            reduce using rule 148 (body -> prot_body .)
INFO:root:    PROTECTED       reduce using rule 148 (body -> prot_body .)
INFO:root:    error           reduce using rule 148 (body -> prot_body .)
INFO:root:    USE             reduce using rule 148 (body -> prot_body .)
INFO:root:    PRAGMA          reduce using rule 148 (body -> prot_body .)
INFO:root:    TYPE            reduce using rule 148 (body -> prot_body .)
INFO:root:    SUBTYPE         reduce using rule 148 (body -> prot_body .)
INFO:root:    FOR             reduce using rule 148 (body -> prot_body .)
INFO:root:    PROCEDURE       reduce using rule 148 (body -> prot_body .)
INFO:root:    FUNCTION        reduce using rule 148 (body -> prot_body .)
INFO:root:    GENERIC         reduce using rule 148 (body -> prot_body .)
INFO:root:    IDENTIFIER      reduce using rule 148 (body -> prot_body .)
INFO:root:    BEGIN           reduce using rule 148 (body -> prot_body .)
INFO:root:    END             reduce using rule 148 (body -> prot_body .)
INFO:root:
INFO:root:
INFO:root:state 101
INFO:root:
INFO:root:    (11) decl -> number_decl .
INFO:root:
INFO:root:    PACKAGE         reduce using rule 11 (decl -> number_decl .)
INFO:root:    TASK            reduce using rule 11 (decl -> number_decl .)
INFO:root:    PROTECTED       reduce using rule 11 (decl -> number_decl .)
INFO:root:    error           reduce using rule 11 (decl -> number_decl .)
INFO:root:    USE             reduce using rule 11 (decl -> number_decl .)
INFO:root:    PRAGMA          reduce using rule 11 (decl -> number_decl .)
INFO:root:    TYPE            reduce using rule 11 (decl -> number_decl .)
INFO:root:    SUBTYPE         reduce using rule 11 (decl -> number_decl .)
INFO:root:    FOR             reduce using rule 11 (decl -> number_decl .)
INFO:root:    PROCEDURE       reduce using rule 11 (decl -> number_decl .)
INFO:root:    FUNCTION        reduce using rule 11 (decl -> number_decl .)
INFO:root:    GENERIC         reduce using rule 11 (decl -> number_decl .)
INFO:root:    IDENTIFIER      reduce using rule 11 (decl -> number_decl .)
INFO:root:    BEGIN           reduce using rule 11 (decl -> number_decl .)
INFO:root:    END             reduce using rule 11 (decl -> number_decl .)
INFO:root:    PRIVATE         reduce using rule 11 (decl -> number_decl .)
INFO:root:
INFO:root:
INFO:root:state 102
INFO:root:
INFO:root:    (494) attrib_def -> FOR . mark USE expression ;
INFO:root:    (495) record_type_spec -> FOR . mark USE RECORD align_opt comp_loc_s END RECORD ;
INFO:root:    (500) address_spec -> FOR . mark USE AT expression ;
INFO:root:    (154) mark -> . simple_name
INFO:root:    (155) mark -> . mark TICK attribute_id
INFO:root:    (156) mark -> . mark . simple_name
INFO:root:    (157) simple_name -> . IDENTIFIER
INFO:root:
INFO:root:    IDENTIFIER      shift and go to state 33
INFO:root:
INFO:root:    mark                           shift and go to state 191
INFO:root:    simple_name                    shift and go to state 192
INFO:root:
INFO:root:state 103
INFO:root:
INFO:root:    (132) decl_part -> decl_item_or_body_s1 .
INFO:root:    (142) decl_item_or_body_s1 -> decl_item_or_body_s1 . decl_item_or_body
INFO:root:    (143) decl_item_or_body -> . body
INFO:root:    (144) decl_item_or_body -> . decl_item
INFO:root:    (145) body -> . subprog_body
INFO:root:    (146) body -> . pkg_body
INFO:root:    (147) body -> . task_body
INFO:root:    (148) body -> . prot_body
INFO:root:    (137) decl_item -> . decl
INFO:root:    (138) decl_item -> . use_clause
INFO:root:    (139) decl_item -> . rep_spec
INFO:root:    (140) decl_item -> . pragma
INFO:root:    (322) subprog_body -> . subprog_spec_is_push decl_part block_body END id_opt ;
INFO:root:    (331) pkg_body -> . PACKAGE BODY compound_name IS decl_part body_opt END c_id_opt ;
INFO:root:    (356) task_body -> . TASK BODY simple_name IS decl_part block_body END id_opt ;
INFO:root:    (373) prot_body -> . PROTECTED BODY simple_name IS prot_op_body_s END id_opt ;
INFO:root:    (10) decl -> . object_decl
INFO:root:    (11) decl -> . number_decl
INFO:root:    (12) decl -> . type_decl
INFO:root:    (13) decl -> . subtype_decl
INFO:root:    (14) decl -> . subprog_decl
INFO:root:    (15) decl -> . pkg_decl
INFO:root:    (16) decl -> . task_decl
INFO:root:    (17) decl -> . prot_decl
INFO:root:    (18) decl -> . exception_decl
INFO:root:    (19) decl -> . rename_decl
INFO:root:    (20) decl -> . generic_decl
INFO:root:    (21) decl -> . body_stub
INFO:root:    (22) decl -> . error ;
INFO:root:    (337) use_clause -> . USE name_s ;
INFO:root:    (338) use_clause -> . USE TYPE name_s ;
INFO:root:    (491) rep_spec -> . attrib_def
INFO:root:    (492) rep_spec -> . record_type_spec
INFO:root:    (493) rep_spec -> . address_spec
INFO:root:    (2) pragma -> . PRAGMA IDENTIFIER ;
INFO:root:    (3) pragma -> . PRAGMA simple_name ( pragma_arg_s ) ;
INFO:root:    (321) subprog_spec_is_push -> . subprog_spec IS
INFO:root:    (23) object_decl -> . def_id_s : object_qualifier_opt object_subtype_def init_opt ;
INFO:root:    (35) number_decl -> . def_id_s : CONSTANT ASSIGN expression ;
INFO:root:    (36) type_decl -> . TYPE IDENTIFIER discrim_part_opt type_completion ;
INFO:root:    (50) subtype_decl -> . SUBTYPE IDENTIFIER IS subtype_ind ;
INFO:root:    (301) subprog_decl -> . subprog_spec ;
INFO:root:    (302) subprog_decl -> . generic_subp_inst ;
INFO:root:    (303) subprog_decl -> . subprog_spec_is_push ABSTRACT ;
INFO:root:    (324) pkg_decl -> . pkg_spec ;
INFO:root:    (325) pkg_decl -> . generic_pkg_inst ;
INFO:root:    (349) task_decl -> . task_spec ;
INFO:root:    (357) prot_decl -> . prot_spec ;
INFO:root:    (446) exception_decl -> . def_id_s : EXCEPTION ;
INFO:root:    (341) rename_decl -> . def_id_s : object_qualifier_opt subtype_ind renames ;
INFO:root:    (342) rename_decl -> . def_id_s : EXCEPTION renames ;
INFO:root:    (343) rename_decl -> . rename_unit
INFO:root:    (458) generic_decl -> . generic_formal_part subprog_spec ;
INFO:root:    (459) generic_decl -> . generic_formal_part pkg_spec ;
INFO:root:    (442) body_stub -> . TASK BODY simple_name IS SEPARATE ;
INFO:root:    (443) body_stub -> . PACKAGE BODY compound_name IS SEPARATE ;
INFO:root:    (444) body_stub -> . subprog_spec IS SEPARATE ;
INFO:root:    (445) body_stub -> . PROTECTED BODY simple_name IS SEPARATE ;
INFO:root:    (494) attrib_def -> . FOR mark USE expression ;
INFO:root:    (495) record_type_spec -> . FOR mark USE RECORD align_opt comp_loc_s END RECORD ;
INFO:root:    (500) address_spec -> . FOR mark USE AT expression ;
INFO:root:    (304) subprog_spec -> . PROCEDURE compound_name formal_part_opt
INFO:root:    (305) subprog_spec -> . FUNCTION designator formal_part_opt RETURN name
INFO:root:    (306) subprog_spec -> . FUNCTION designator
INFO:root:    (24) def_id_s -> . def_id
INFO:root:    (25) def_id_s -> . def_id_s , def_id
INFO:root:    (488) generic_subp_inst -> . subprog_spec IS generic_inst
INFO:root:    (326) pkg_spec -> . PACKAGE compound_name IS decl_item_s private_part END c_id_opt
INFO:root:    (489) generic_pkg_inst -> . PACKAGE compound_name IS generic_inst
INFO:root:    (350) task_spec -> . TASK simple_name task_def
INFO:root:    (351) task_spec -> . TASK TYPE simple_name discrim_part_opt task_def
INFO:root:    (358) prot_spec -> . PROTECTED IDENTIFIER prot_def
INFO:root:    (359) prot_spec -> . PROTECTED TYPE simple_name discrim_part_opt prot_def
INFO:root:    (344) rename_unit -> . PACKAGE compound_name renames ;
INFO:root:    (345) rename_unit -> . subprog_spec renames ;
INFO:root:    (346) rename_unit -> . generic_formal_part PACKAGE compound_name renames ;
INFO:root:    (347) rename_unit -> . generic_formal_part subprog_spec renames ;
INFO:root:    (460) generic_formal_part -> . GENERIC
INFO:root:    (461) generic_formal_part -> . generic_formal_part generic_formal
INFO:root:    (26) def_id -> . IDENTIFIER
INFO:root:
INFO:root:    BEGIN           reduce using rule 132 (decl_part -> decl_item_or_body_s1 .)
INFO:root:    END             reduce using rule 132 (decl_part -> decl_item_or_body_s1 .)
INFO:root:    PACKAGE         shift and go to state 73
INFO:root:    TASK            shift and go to state 84
INFO:root:    PROTECTED       shift and go to state 99
INFO:root:    error           shift and go to state 107
INFO:root:    USE             shift and go to state 53
INFO:root:    PRAGMA          shift and go to state 2
INFO:root:    TYPE            shift and go to state 74
INFO:root:    SUBTYPE         shift and go to state 110
INFO:root:    FOR             shift and go to state 102
INFO:root:    PROCEDURE       shift and go to state 17
INFO:root:    FUNCTION        shift and go to state 23
INFO:root:    GENERIC         shift and go to state 26
INFO:root:    IDENTIFIER      shift and go to state 52
INFO:root:
INFO:root:    generic_formal_part            shift and go to state 20
INFO:root:    pkg_decl                       shift and go to state 93
INFO:root:    pragma                         shift and go to state 94
INFO:root:    generic_pkg_inst               shift and go to state 19
INFO:root:    prot_decl                      shift and go to state 95
INFO:root:    body                           shift and go to state 75
INFO:root:    task_decl                      shift and go to state 76
INFO:root:    generic_decl                   shift and go to state 88
INFO:root:    subprog_decl                   shift and go to state 77
INFO:root:    type_decl                      shift and go to state 81
INFO:root:    def_id_s                       shift and go to state 79
INFO:root:    def_id                         shift and go to state 57
INFO:root:    rep_spec                       shift and go to state 72
INFO:root:    use_clause                     shift and go to state 97
INFO:root:    rename_decl                    shift and go to state 98
INFO:root:    body_stub                      shift and go to state 80
INFO:root:    address_spec                   shift and go to state 83
INFO:root:    task_spec                      shift and go to state 82
INFO:root:    number_decl                    shift and go to state 101
INFO:root:    generic_subp_inst              shift and go to state 24
INFO:root:    prot_spec                      shift and go to state 85
INFO:root:    rename_unit                    shift and go to state 104
INFO:root:    subprog_spec                   shift and go to state 86
INFO:root:    object_decl                    shift and go to state 87
INFO:root:    subtype_decl                   shift and go to state 105
INFO:root:    task_body                      shift and go to state 96
INFO:root:    prot_body                      shift and go to state 100
INFO:root:    pkg_body                       shift and go to state 90
INFO:root:    pkg_spec                       shift and go to state 16
INFO:root:    record_type_spec               shift and go to state 108
INFO:root:    decl                           shift and go to state 109
INFO:root:    decl_item                      shift and go to state 78
INFO:root:    exception_decl                 shift and go to state 91
INFO:root:    subprog_body                   shift and go to state 113
INFO:root:    attrib_def                     shift and go to state 92
INFO:root:    subprog_spec_is_push           shift and go to state 111
INFO:root:    decl_item_or_body              shift and go to state 193
INFO:root:
INFO:root:state 104
INFO:root:
INFO:root:    (343) rename_decl -> rename_unit .
INFO:root:
INFO:root:    PACKAGE         reduce using rule 343 (rename_decl -> rename_unit .)
INFO:root:    TASK            reduce using rule 343 (rename_decl -> rename_unit .)
INFO:root:    PROTECTED       reduce using rule 343 (rename_decl -> rename_unit .)
INFO:root:    error           reduce using rule 343 (rename_decl -> rename_unit .)
INFO:root:    USE             reduce using rule 343 (rename_decl -> rename_unit .)
INFO:root:    PRAGMA          reduce using rule 343 (rename_decl -> rename_unit .)
INFO:root:    TYPE            reduce using rule 343 (rename_decl -> rename_unit .)
INFO:root:    SUBTYPE         reduce using rule 343 (rename_decl -> rename_unit .)
INFO:root:    FOR             reduce using rule 343 (rename_decl -> rename_unit .)
INFO:root:    PROCEDURE       reduce using rule 343 (rename_decl -> rename_unit .)
INFO:root:    FUNCTION        reduce using rule 343 (rename_decl -> rename_unit .)
INFO:root:    GENERIC         reduce using rule 343 (rename_decl -> rename_unit .)
INFO:root:    IDENTIFIER      reduce using rule 343 (rename_decl -> rename_unit .)
INFO:root:    BEGIN           reduce using rule 343 (rename_decl -> rename_unit .)
INFO:root:    END             reduce using rule 343 (rename_decl -> rename_unit .)
INFO:root:    PRIVATE         reduce using rule 343 (rename_decl -> rename_unit .)
INFO:root:
INFO:root:
INFO:root:state 105
INFO:root:
INFO:root:    (13) decl -> subtype_decl .
INFO:root:
INFO:root:    PACKAGE         reduce using rule 13 (decl -> subtype_decl .)
INFO:root:    TASK            reduce using rule 13 (decl -> subtype_decl .)
INFO:root:    PROTECTED       reduce using rule 13 (decl -> subtype_decl .)
INFO:root:    error           reduce using rule 13 (decl -> subtype_decl .)
INFO:root:    USE             reduce using rule 13 (decl -> subtype_decl .)
INFO:root:    PRAGMA          reduce using rule 13 (decl -> subtype_decl .)
INFO:root:    TYPE            reduce using rule 13 (decl -> subtype_decl .)
INFO:root:    SUBTYPE         reduce using rule 13 (decl -> subtype_decl .)
INFO:root:    FOR             reduce using rule 13 (decl -> subtype_decl .)
INFO:root:    PROCEDURE       reduce using rule 13 (decl -> subtype_decl .)
INFO:root:    FUNCTION        reduce using rule 13 (decl -> subtype_decl .)
INFO:root:    GENERIC         reduce using rule 13 (decl -> subtype_decl .)
INFO:root:    IDENTIFIER      reduce using rule 13 (decl -> subtype_decl .)
INFO:root:    BEGIN           reduce using rule 13 (decl -> subtype_decl .)
INFO:root:    END             reduce using rule 13 (decl -> subtype_decl .)
INFO:root:    PRIVATE         reduce using rule 13 (decl -> subtype_decl .)
INFO:root:
INFO:root:
INFO:root:state 106
INFO:root:
INFO:root:    (322) subprog_body -> subprog_spec_is_push decl_part . block_body END id_opt ;
INFO:root:    (290) block_body -> . BEGIN handled_stmt_s
INFO:root:
INFO:root:    BEGIN           shift and go to state 195
INFO:root:
INFO:root:    block_body                     shift and go to state 194
INFO:root:
INFO:root:state 107
INFO:root:
INFO:root:    (22) decl -> error . ;
INFO:root:
INFO:root:    ;               shift and go to state 196
INFO:root:
INFO:root:
INFO:root:state 108
INFO:root:
INFO:root:    (492) rep_spec -> record_type_spec .
INFO:root:
INFO:root:    PACKAGE         reduce using rule 492 (rep_spec -> record_type_spec .)
INFO:root:    TASK            reduce using rule 492 (rep_spec -> record_type_spec .)
INFO:root:    PROTECTED       reduce using rule 492 (rep_spec -> record_type_spec .)
INFO:root:    error           reduce using rule 492 (rep_spec -> record_type_spec .)
INFO:root:    USE             reduce using rule 492 (rep_spec -> record_type_spec .)
INFO:root:    PRAGMA          reduce using rule 492 (rep_spec -> record_type_spec .)
INFO:root:    TYPE            reduce using rule 492 (rep_spec -> record_type_spec .)
INFO:root:    SUBTYPE         reduce using rule 492 (rep_spec -> record_type_spec .)
INFO:root:    FOR             reduce using rule 492 (rep_spec -> record_type_spec .)
INFO:root:    PROCEDURE       reduce using rule 492 (rep_spec -> record_type_spec .)
INFO:root:    FUNCTION        reduce using rule 492 (rep_spec -> record_type_spec .)
INFO:root:    GENERIC         reduce using rule 492 (rep_spec -> record_type_spec .)
INFO:root:    IDENTIFIER      reduce using rule 492 (rep_spec -> record_type_spec .)
INFO:root:    BEGIN           reduce using rule 492 (rep_spec -> record_type_spec .)
INFO:root:    END             reduce using rule 492 (rep_spec -> record_type_spec .)
INFO:root:    PRIVATE         reduce using rule 492 (rep_spec -> record_type_spec .)
INFO:root:    ENTRY           reduce using rule 492 (rep_spec -> record_type_spec .)
INFO:root:
INFO:root:
INFO:root:state 109
INFO:root:
INFO:root:    (137) decl_item -> decl .
INFO:root:
INFO:root:    PACKAGE         reduce using rule 137 (decl_item -> decl .)
INFO:root:    TASK            reduce using rule 137 (decl_item -> decl .)
INFO:root:    PROTECTED       reduce using rule 137 (decl_item -> decl .)
INFO:root:    error           reduce using rule 137 (decl_item -> decl .)
INFO:root:    USE             reduce using rule 137 (decl_item -> decl .)
INFO:root:    PRAGMA          reduce using rule 137 (decl_item -> decl .)
INFO:root:    TYPE            reduce using rule 137 (decl_item -> decl .)
INFO:root:    SUBTYPE         reduce using rule 137 (decl_item -> decl .)
INFO:root:    FOR             reduce using rule 137 (decl_item -> decl .)
INFO:root:    PROCEDURE       reduce using rule 137 (decl_item -> decl .)
INFO:root:    FUNCTION        reduce using rule 137 (decl_item -> decl .)
INFO:root:    GENERIC         reduce using rule 137 (decl_item -> decl .)
INFO:root:    IDENTIFIER      reduce using rule 137 (decl_item -> decl .)
INFO:root:    BEGIN           reduce using rule 137 (decl_item -> decl .)
INFO:root:    END             reduce using rule 137 (decl_item -> decl .)
INFO:root:    PRIVATE         reduce using rule 137 (decl_item -> decl .)
INFO:root:
INFO:root:
INFO:root:state 110
INFO:root:
INFO:root:    (50) subtype_decl -> SUBTYPE . IDENTIFIER IS subtype_ind ;
INFO:root:
INFO:root:    IDENTIFIER      shift and go to state 197
INFO:root:
INFO:root:
INFO:root:state 111
INFO:root:
INFO:root:    (322) subprog_body -> subprog_spec_is_push . decl_part block_body END id_opt ;
INFO:root:    (303) subprog_decl -> subprog_spec_is_push . ABSTRACT ;
INFO:root:    (131) decl_part -> .
INFO:root:    (132) decl_part -> . decl_item_or_body_s1
INFO:root:    (141) decl_item_or_body_s1 -> . decl_item_or_body
INFO:root:    (142) decl_item_or_body_s1 -> . decl_item_or_body_s1 decl_item_or_body
INFO:root:    (143) decl_item_or_body -> . body
INFO:root:    (144) decl_item_or_body -> . decl_item
INFO:root:    (145) body -> . subprog_body
INFO:root:    (146) body -> . pkg_body
INFO:root:    (147) body -> . task_body
INFO:root:    (148) body -> . prot_body
INFO:root:    (137) decl_item -> . decl
INFO:root:    (138) decl_item -> . use_clause
INFO:root:    (139) decl_item -> . rep_spec
INFO:root:    (140) decl_item -> . pragma
INFO:root:    (322) subprog_body -> . subprog_spec_is_push decl_part block_body END id_opt ;
INFO:root:    (331) pkg_body -> . PACKAGE BODY compound_name IS decl_part body_opt END c_id_opt ;
INFO:root:    (356) task_body -> . TASK BODY simple_name IS decl_part block_body END id_opt ;
INFO:root:    (373) prot_body -> . PROTECTED BODY simple_name IS prot_op_body_s END id_opt ;
INFO:root:    (10) decl -> . object_decl
INFO:root:    (11) decl -> . number_decl
INFO:root:    (12) decl -> . type_decl
INFO:root:    (13) decl -> . subtype_decl
INFO:root:    (14) decl -> . subprog_decl
INFO:root:    (15) decl -> . pkg_decl
INFO:root:    (16) decl -> . task_decl
INFO:root:    (17) decl -> . prot_decl
INFO:root:    (18) decl -> . exception_decl
INFO:root:    (19) decl -> . rename_decl
INFO:root:    (20) decl -> . generic_decl
INFO:root:    (21) decl -> . body_stub
INFO:root:    (22) decl -> . error ;
INFO:root:    (337) use_clause -> . USE name_s ;
INFO:root:    (338) use_clause -> . USE TYPE name_s ;
INFO:root:    (491) rep_spec -> . attrib_def
INFO:root:    (492) rep_spec -> . record_type_spec
INFO:root:    (493) rep_spec -> . address_spec
INFO:root:    (2) pragma -> . PRAGMA IDENTIFIER ;
INFO:root:    (3) pragma -> . PRAGMA simple_name ( pragma_arg_s ) ;
INFO:root:    (321) subprog_spec_is_push -> . subprog_spec IS
INFO:root:    (23) object_decl -> . def_id_s : object_qualifier_opt object_subtype_def init_opt ;
INFO:root:    (35) number_decl -> . def_id_s : CONSTANT ASSIGN expression ;
INFO:root:    (36) type_decl -> . TYPE IDENTIFIER discrim_part_opt type_completion ;
INFO:root:    (50) subtype_decl -> . SUBTYPE IDENTIFIER IS subtype_ind ;
INFO:root:    (301) subprog_decl -> . subprog_spec ;
INFO:root:    (302) subprog_decl -> . generic_subp_inst ;
INFO:root:    (303) subprog_decl -> . subprog_spec_is_push ABSTRACT ;
INFO:root:    (324) pkg_decl -> . pkg_spec ;
INFO:root:    (325) pkg_decl -> . generic_pkg_inst ;
INFO:root:    (349) task_decl -> . task_spec ;
INFO:root:    (357) prot_decl -> . prot_spec ;
INFO:root:    (446) exception_decl -> . def_id_s : EXCEPTION ;
INFO:root:    (341) rename_decl -> . def_id_s : object_qualifier_opt subtype_ind renames ;
INFO:root:    (342) rename_decl -> . def_id_s : EXCEPTION renames ;
INFO:root:    (343) rename_decl -> . rename_unit
INFO:root:    (458) generic_decl -> . generic_formal_part subprog_spec ;
INFO:root:    (459) generic_decl -> . generic_formal_part pkg_spec ;
INFO:root:    (442) body_stub -> . TASK BODY simple_name IS SEPARATE ;
INFO:root:    (443) body_stub -> . PACKAGE BODY compound_name IS SEPARATE ;
INFO:root:    (444) body_stub -> . subprog_spec IS SEPARATE ;
INFO:root:    (445) body_stub -> . PROTECTED BODY simple_name IS SEPARATE ;
INFO:root:    (494) attrib_def -> . FOR mark USE expression ;
INFO:root:    (495) record_type_spec -> . FOR mark USE RECORD align_opt comp_loc_s END RECORD ;
INFO:root:    (500) address_spec -> . FOR mark USE AT expression ;
INFO:root:    (304) subprog_spec -> . PROCEDURE compound_name formal_part_opt
INFO:root:    (305) subprog_spec -> . FUNCTION designator formal_part_opt RETURN name
INFO:root:    (306) subprog_spec -> . FUNCTION designator
INFO:root:    (24) def_id_s -> . def_id
INFO:root:    (25) def_id_s -> . def_id_s , def_id
INFO:root:    (488) generic_subp_inst -> . subprog_spec IS generic_inst
INFO:root:    (326) pkg_spec -> . PACKAGE compound_name IS decl_item_s private_part END c_id_opt
INFO:root:    (489) generic_pkg_inst -> . PACKAGE compound_name IS generic_inst
INFO:root:    (350) task_spec -> . TASK simple_name task_def
INFO:root:    (351) task_spec -> . TASK TYPE simple_name discrim_part_opt task_def
INFO:root:    (358) prot_spec -> . PROTECTED IDENTIFIER prot_def
INFO:root:    (359) prot_spec -> . PROTECTED TYPE simple_name discrim_part_opt prot_def
INFO:root:    (344) rename_unit -> . PACKAGE compound_name renames ;
INFO:root:    (345) rename_unit -> . subprog_spec renames ;
INFO:root:    (346) rename_unit -> . generic_formal_part PACKAGE compound_name renames ;
INFO:root:    (347) rename_unit -> . generic_formal_part subprog_spec renames ;
INFO:root:    (460) generic_formal_part -> . GENERIC
INFO:root:    (461) generic_formal_part -> . generic_formal_part generic_formal
INFO:root:    (26) def_id -> . IDENTIFIER
INFO:root:
INFO:root:    ABSTRACT        shift and go to state 89
INFO:root:    BEGIN           reduce using rule 131 (decl_part -> .)
INFO:root:    PACKAGE         shift and go to state 73
INFO:root:    TASK            shift and go to state 84
INFO:root:    PROTECTED       shift and go to state 99
INFO:root:    error           shift and go to state 107
INFO:root:    USE             shift and go to state 53
INFO:root:    PRAGMA          shift and go to state 2
INFO:root:    TYPE            shift and go to state 74
INFO:root:    SUBTYPE         shift and go to state 110
INFO:root:    FOR             shift and go to state 102
INFO:root:    PROCEDURE       shift and go to state 17
INFO:root:    FUNCTION        shift and go to state 23
INFO:root:    GENERIC         shift and go to state 26
INFO:root:    IDENTIFIER      shift and go to state 52
INFO:root:
INFO:root:    generic_formal_part            shift and go to state 20
INFO:root:    pkg_decl                       shift and go to state 93
INFO:root:    pragma                         shift and go to state 94
INFO:root:    generic_pkg_inst               shift and go to state 19
INFO:root:    prot_decl                      shift and go to state 95
INFO:root:    body                           shift and go to state 75
INFO:root:    task_decl                      shift and go to state 76
INFO:root:    generic_decl                   shift and go to state 88
INFO:root:    subprog_decl                   shift and go to state 77
INFO:root:    type_decl                      shift and go to state 81
INFO:root:    def_id_s                       shift and go to state 79
INFO:root:    def_id                         shift and go to state 57
INFO:root:    rep_spec                       shift and go to state 72
INFO:root:    use_clause                     shift and go to state 97
INFO:root:    rename_decl                    shift and go to state 98
INFO:root:    body_stub                      shift and go to state 80
INFO:root:    address_spec                   shift and go to state 83
INFO:root:    task_spec                      shift and go to state 82
INFO:root:    number_decl                    shift and go to state 101
INFO:root:    generic_subp_inst              shift and go to state 24
INFO:root:    decl_item_or_body_s1           shift and go to state 103
INFO:root:    prot_spec                      shift and go to state 85
INFO:root:    rename_unit                    shift and go to state 104
INFO:root:    subprog_spec                   shift and go to state 86
INFO:root:    object_decl                    shift and go to state 87
INFO:root:    subtype_decl                   shift and go to state 105
INFO:root:    task_body                      shift and go to state 96
INFO:root:    prot_body                      shift and go to state 100
INFO:root:    pkg_body                       shift and go to state 90
INFO:root:    decl_part                      shift and go to state 106
INFO:root:    pkg_spec                       shift and go to state 16
INFO:root:    record_type_spec               shift and go to state 108
INFO:root:    decl                           shift and go to state 109
INFO:root:    decl_item                      shift and go to state 78
INFO:root:    exception_decl                 shift and go to state 91
INFO:root:    subprog_body                   shift and go to state 113
INFO:root:    attrib_def                     shift and go to state 92
INFO:root:    subprog_spec_is_push           shift and go to state 111
INFO:root:    decl_item_or_body              shift and go to state 112
INFO:root:
INFO:root:state 112
INFO:root:
INFO:root:    (141) decl_item_or_body_s1 -> decl_item_or_body .
INFO:root:
INFO:root:    PACKAGE         reduce using rule 141 (decl_item_or_body_s1 -> decl_item_or_body .)
INFO:root:    TASK            reduce using rule 141 (decl_item_or_body_s1 -> decl_item_or_body .)
INFO:root:    PROTECTED       reduce using rule 141 (decl_item_or_body_s1 -> decl_item_or_body .)
INFO:root:    error           reduce using rule 141 (decl_item_or_body_s1 -> decl_item_or_body .)
INFO:root:    USE             reduce using rule 141 (decl_item_or_body_s1 -> decl_item_or_body .)
INFO:root:    PRAGMA          reduce using rule 141 (decl_item_or_body_s1 -> decl_item_or_body .)
INFO:root:    TYPE            reduce using rule 141 (decl_item_or_body_s1 -> decl_item_or_body .)
INFO:root:    SUBTYPE         reduce using rule 141 (decl_item_or_body_s1 -> decl_item_or_body .)
INFO:root:    FOR             reduce using rule 141 (decl_item_or_body_s1 -> decl_item_or_body .)
INFO:root:    PROCEDURE       reduce using rule 141 (decl_item_or_body_s1 -> decl_item_or_body .)
INFO:root:    FUNCTION        reduce using rule 141 (decl_item_or_body_s1 -> decl_item_or_body .)
INFO:root:    GENERIC         reduce using rule 141 (decl_item_or_body_s1 -> decl_item_or_body .)
INFO:root:    IDENTIFIER      reduce using rule 141 (decl_item_or_body_s1 -> decl_item_or_body .)
INFO:root:    BEGIN           reduce using rule 141 (decl_item_or_body_s1 -> decl_item_or_body .)
INFO:root:    END             reduce using rule 141 (decl_item_or_body_s1 -> decl_item_or_body .)
INFO:root:
INFO:root:
INFO:root:state 113
INFO:root:
INFO:root:    (145) body -> subprog_body .
INFO:root:
INFO:root:    PACKAGE         reduce using rule 145 (body -> subprog_body .)
INFO:root:    TASK            reduce using rule 145 (body -> subprog_body .)
INFO:root:    PROTECTED       reduce using rule 145 (body -> subprog_body .)
INFO:root:    error           reduce using rule 145 (body -> subprog_body .)
INFO:root:    USE             reduce using rule 145 (body -> subprog_body .)
INFO:root:    PRAGMA          reduce using rule 145 (body -> subprog_body .)
INFO:root:    TYPE            reduce using rule 145 (body -> subprog_body .)
INFO:root:    SUBTYPE         reduce using rule 145 (body -> subprog_body .)
INFO:root:    FOR             reduce using rule 145 (body -> subprog_body .)
INFO:root:    PROCEDURE       reduce using rule 145 (body -> subprog_body .)
INFO:root:    FUNCTION        reduce using rule 145 (body -> subprog_body .)
INFO:root:    GENERIC         reduce using rule 145 (body -> subprog_body .)
INFO:root:    IDENTIFIER      reduce using rule 145 (body -> subprog_body .)
INFO:root:    BEGIN           reduce using rule 145 (body -> subprog_body .)
INFO:root:    END             reduce using rule 145 (body -> subprog_body .)
INFO:root:
INFO:root:
INFO:root:state 114
INFO:root:
INFO:root:    (161) c_name_list -> c_name_list , . compound_name
INFO:root:    (158) compound_name -> . simple_name
INFO:root:    (159) compound_name -> . compound_name . simple_name
INFO:root:    (157) simple_name -> . IDENTIFIER
INFO:root:
INFO:root:    IDENTIFIER      shift and go to state 33
INFO:root:
INFO:root:    simple_name                    shift and go to state 34
INFO:root:    compound_name                  shift and go to state 198
INFO:root:
INFO:root:state 115
INFO:root:
INFO:root:    (427) with_clause -> WITH c_name_list ; .
INFO:root:
INFO:root:    USE             reduce using rule 427 (with_clause -> WITH c_name_list ; .)
INFO:root:    PRIVATE         reduce using rule 427 (with_clause -> WITH c_name_list ; .)
INFO:root:    WITH            reduce using rule 427 (with_clause -> WITH c_name_list ; .)
INFO:root:    PRAGMA          reduce using rule 427 (with_clause -> WITH c_name_list ; .)
INFO:root:    PACKAGE         reduce using rule 427 (with_clause -> WITH c_name_list ; .)
INFO:root:    SEPARATE        reduce using rule 427 (with_clause -> WITH c_name_list ; .)
INFO:root:    PROCEDURE       reduce using rule 427 (with_clause -> WITH c_name_list ; .)
INFO:root:    FUNCTION        reduce using rule 427 (with_clause -> WITH c_name_list ; .)
INFO:root:    GENERIC         reduce using rule 427 (with_clause -> WITH c_name_list ; .)
INFO:root:
INFO:root:
INFO:root:state 116
INFO:root:
INFO:root:    (159) compound_name -> compound_name . . simple_name
INFO:root:    (157) simple_name -> . IDENTIFIER
INFO:root:
INFO:root:    IDENTIFIER      shift and go to state 33
INFO:root:
INFO:root:    simple_name                    shift and go to state 199
INFO:root:
INFO:root:state 117
INFO:root:
INFO:root:    (420) comp_unit -> context_spec private_opt unit . pragma_s
INFO:root:    (8) pragma_s -> .
INFO:root:    (9) pragma_s -> . pragma_s pragma
INFO:root:
INFO:root:    PRAGMA          reduce using rule 8 (pragma_s -> .)
INFO:root:    PRIVATE         reduce using rule 8 (pragma_s -> .)
INFO:root:    WITH            reduce using rule 8 (pragma_s -> .)
INFO:root:    PACKAGE         reduce using rule 8 (pragma_s -> .)
INFO:root:    SEPARATE        reduce using rule 8 (pragma_s -> .)
INFO:root:    PROCEDURE       reduce using rule 8 (pragma_s -> .)
INFO:root:    FUNCTION        reduce using rule 8 (pragma_s -> .)
INFO:root:    GENERIC         reduce using rule 8 (pragma_s -> .)
INFO:root:    $end            reduce using rule 8 (pragma_s -> .)
INFO:root:
INFO:root:    pragma_s                       shift and go to state 200
INFO:root:
INFO:root:state 118
INFO:root:
INFO:root:    (425) context_spec -> context_spec with_clause use_clause_opt .
INFO:root:    (429) use_clause_opt -> use_clause_opt . use_clause
INFO:root:    (337) use_clause -> . USE name_s ;
INFO:root:    (338) use_clause -> . USE TYPE name_s ;
INFO:root:
INFO:root:    PRIVATE         reduce using rule 425 (context_spec -> context_spec with_clause use_clause_opt .)
INFO:root:    WITH            reduce using rule 425 (context_spec -> context_spec with_clause use_clause_opt .)
INFO:root:    PRAGMA          reduce using rule 425 (context_spec -> context_spec with_clause use_clause_opt .)
INFO:root:    PACKAGE         reduce using rule 425 (context_spec -> context_spec with_clause use_clause_opt .)
INFO:root:    SEPARATE        reduce using rule 425 (context_spec -> context_spec with_clause use_clause_opt .)
INFO:root:    PROCEDURE       reduce using rule 425 (context_spec -> context_spec with_clause use_clause_opt .)
INFO:root:    FUNCTION        reduce using rule 425 (context_spec -> context_spec with_clause use_clause_opt .)
INFO:root:    GENERIC         reduce using rule 425 (context_spec -> context_spec with_clause use_clause_opt .)
INFO:root:    USE             shift and go to state 53
INFO:root:
INFO:root:    use_clause                     shift and go to state 119
INFO:root:
INFO:root:state 119
INFO:root:
INFO:root:    (429) use_clause_opt -> use_clause_opt use_clause .
INFO:root:
INFO:root:    USE             reduce using rule 429 (use_clause_opt -> use_clause_opt use_clause .)
INFO:root:    PRIVATE         reduce using rule 429 (use_clause_opt -> use_clause_opt use_clause .)
INFO:root:    WITH            reduce using rule 429 (use_clause_opt -> use_clause_opt use_clause .)
INFO:root:    PRAGMA          reduce using rule 429 (use_clause_opt -> use_clause_opt use_clause .)
INFO:root:    PACKAGE         reduce using rule 429 (use_clause_opt -> use_clause_opt use_clause .)
INFO:root:    SEPARATE        reduce using rule 429 (use_clause_opt -> use_clause_opt use_clause .)
INFO:root:    PROCEDURE       reduce using rule 429 (use_clause_opt -> use_clause_opt use_clause .)
INFO:root:    FUNCTION        reduce using rule 429 (use_clause_opt -> use_clause_opt use_clause .)
INFO:root:    GENERIC         reduce using rule 429 (use_clause_opt -> use_clause_opt use_clause .)
INFO:root:
INFO:root:
INFO:root:state 120
INFO:root:
INFO:root:    (180) literal -> INT .
INFO:root:
INFO:root:    *               reduce using rule 180 (literal -> INT .)
INFO:root:    /               reduce using rule 180 (literal -> INT .)
INFO:root:    MOD             reduce using rule 180 (literal -> INT .)
INFO:root:    REM             reduce using rule 180 (literal -> INT .)
INFO:root:    STARSTAR        reduce using rule 180 (literal -> INT .)
INFO:root:    =               reduce using rule 180 (literal -> INT .)
INFO:root:    NEQ             reduce using rule 180 (literal -> INT .)
INFO:root:    <               reduce using rule 180 (literal -> INT .)
INFO:root:    LEQ             reduce using rule 180 (literal -> INT .)
INFO:root:    >               reduce using rule 180 (literal -> INT .)
INFO:root:    GEQ             reduce using rule 180 (literal -> INT .)
INFO:root:    IN              reduce using rule 180 (literal -> INT .)
INFO:root:    NOT             reduce using rule 180 (literal -> INT .)
INFO:root:    +               reduce using rule 180 (literal -> INT .)
INFO:root:    -               reduce using rule 180 (literal -> INT .)
INFO:root:    &               reduce using rule 180 (literal -> INT .)
INFO:root:    AND             reduce using rule 180 (literal -> INT .)
INFO:root:    OR              reduce using rule 180 (literal -> INT .)
INFO:root:    XOR             reduce using rule 180 (literal -> INT .)
INFO:root:    )               reduce using rule 180 (literal -> INT .)
INFO:root:    ,               reduce using rule 180 (literal -> INT .)
INFO:root:    DOTDOT          reduce using rule 180 (literal -> INT .)
INFO:root:    WITH            reduce using rule 180 (literal -> INT .)
INFO:root:    ARROW           reduce using rule 180 (literal -> INT .)
INFO:root:    |               reduce using rule 180 (literal -> INT .)
INFO:root:    ;               reduce using rule 180 (literal -> INT .)
INFO:root:    IS              reduce using rule 180 (literal -> INT .)
INFO:root:    THEN            reduce using rule 180 (literal -> INT .)
INFO:root:    LOOP            reduce using rule 180 (literal -> INT .)
INFO:root:    RANGE           reduce using rule 180 (literal -> INT .)
INFO:root:    DIGITS          reduce using rule 180 (literal -> INT .)
INFO:root:    RENAMES         reduce using rule 180 (literal -> INT .)
INFO:root:    ASSIGN          reduce using rule 180 (literal -> INT .)
INFO:root:
INFO:root:
INFO:root:state 121
INFO:root:
INFO:root:    (226) primary -> literal .
INFO:root:
INFO:root:    *               reduce using rule 226 (primary -> literal .)
INFO:root:    /               reduce using rule 226 (primary -> literal .)
INFO:root:    MOD             reduce using rule 226 (primary -> literal .)
INFO:root:    REM             reduce using rule 226 (primary -> literal .)
INFO:root:    STARSTAR        reduce using rule 226 (primary -> literal .)
INFO:root:    =               reduce using rule 226 (primary -> literal .)
INFO:root:    NEQ             reduce using rule 226 (primary -> literal .)
INFO:root:    <               reduce using rule 226 (primary -> literal .)
INFO:root:    LEQ             reduce using rule 226 (primary -> literal .)
INFO:root:    >               reduce using rule 226 (primary -> literal .)
INFO:root:    GEQ             reduce using rule 226 (primary -> literal .)
INFO:root:    IN              reduce using rule 226 (primary -> literal .)
INFO:root:    NOT             reduce using rule 226 (primary -> literal .)
INFO:root:    +               reduce using rule 226 (primary -> literal .)
INFO:root:    -               reduce using rule 226 (primary -> literal .)
INFO:root:    &               reduce using rule 226 (primary -> literal .)
INFO:root:    AND             reduce using rule 226 (primary -> literal .)
INFO:root:    OR              reduce using rule 226 (primary -> literal .)
INFO:root:    XOR             reduce using rule 226 (primary -> literal .)
INFO:root:    ARROW           reduce using rule 226 (primary -> literal .)
INFO:root:    ;               reduce using rule 226 (primary -> literal .)
INFO:root:    )               reduce using rule 226 (primary -> literal .)
INFO:root:    ,               reduce using rule 226 (primary -> literal .)
INFO:root:    DOTDOT          reduce using rule 226 (primary -> literal .)
INFO:root:    WITH            reduce using rule 226 (primary -> literal .)
INFO:root:    |               reduce using rule 226 (primary -> literal .)
INFO:root:    IS              reduce using rule 226 (primary -> literal .)
INFO:root:    THEN            reduce using rule 226 (primary -> literal .)
INFO:root:    LOOP            reduce using rule 226 (primary -> literal .)
INFO:root:    RANGE           reduce using rule 226 (primary -> literal .)
INFO:root:    DIGITS          reduce using rule 226 (primary -> literal .)
INFO:root:    RENAMES         reduce using rule 226 (primary -> literal .)
INFO:root:    ASSIGN          reduce using rule 226 (primary -> literal .)
INFO:root:
INFO:root:
INFO:root:state 122
INFO:root:
INFO:root:    (228) primary -> allocator .
INFO:root:
INFO:root:    *               reduce using rule 228 (primary -> allocator .)
INFO:root:    /               reduce using rule 228 (primary -> allocator .)
INFO:root:    MOD             reduce using rule 228 (primary -> allocator .)
INFO:root:    REM             reduce using rule 228 (primary -> allocator .)
INFO:root:    STARSTAR        reduce using rule 228 (primary -> allocator .)
INFO:root:    =               reduce using rule 228 (primary -> allocator .)
INFO:root:    NEQ             reduce using rule 228 (primary -> allocator .)
INFO:root:    <               reduce using rule 228 (primary -> allocator .)
INFO:root:    LEQ             reduce using rule 228 (primary -> allocator .)
INFO:root:    >               reduce using rule 228 (primary -> allocator .)
INFO:root:    GEQ             reduce using rule 228 (primary -> allocator .)
INFO:root:    IN              reduce using rule 228 (primary -> allocator .)
INFO:root:    NOT             reduce using rule 228 (primary -> allocator .)
INFO:root:    +               reduce using rule 228 (primary -> allocator .)
INFO:root:    -               reduce using rule 228 (primary -> allocator .)
INFO:root:    &               reduce using rule 228 (primary -> allocator .)
INFO:root:    AND             reduce using rule 228 (primary -> allocator .)
INFO:root:    OR              reduce using rule 228 (primary -> allocator .)
INFO:root:    XOR             reduce using rule 228 (primary -> allocator .)
INFO:root:    ARROW           reduce using rule 228 (primary -> allocator .)
INFO:root:    ;               reduce using rule 228 (primary -> allocator .)
INFO:root:    )               reduce using rule 228 (primary -> allocator .)
INFO:root:    ,               reduce using rule 228 (primary -> allocator .)
INFO:root:    DOTDOT          reduce using rule 228 (primary -> allocator .)
INFO:root:    WITH            reduce using rule 228 (primary -> allocator .)
INFO:root:    |               reduce using rule 228 (primary -> allocator .)
INFO:root:    IS              reduce using rule 228 (primary -> allocator .)
INFO:root:    THEN            reduce using rule 228 (primary -> allocator .)
INFO:root:    LOOP            reduce using rule 228 (primary -> allocator .)
INFO:root:    RANGE           reduce using rule 228 (primary -> allocator .)
INFO:root:    DIGITS          reduce using rule 228 (primary -> allocator .)
INFO:root:    RENAMES         reduce using rule 228 (primary -> allocator .)
INFO:root:    ASSIGN          reduce using rule 228 (primary -> allocator .)
INFO:root:
INFO:root:
INFO:root:state 123
INFO:root:
INFO:root:    (7) pragma_arg -> simple_name . ARROW expression
INFO:root:    (149) name -> simple_name .
INFO:root:
INFO:root:    ARROW           shift and go to state 201
INFO:root:    TICK            reduce using rule 149 (name -> simple_name .)
INFO:root:    (               reduce using rule 149 (name -> simple_name .)
INFO:root:    .               reduce using rule 149 (name -> simple_name .)
INFO:root:    *               reduce using rule 149 (name -> simple_name .)
INFO:root:    /               reduce using rule 149 (name -> simple_name .)
INFO:root:    MOD             reduce using rule 149 (name -> simple_name .)
INFO:root:    REM             reduce using rule 149 (name -> simple_name .)
INFO:root:    STARSTAR        reduce using rule 149 (name -> simple_name .)
INFO:root:    =               reduce using rule 149 (name -> simple_name .)
INFO:root:    NEQ             reduce using rule 149 (name -> simple_name .)
INFO:root:    <               reduce using rule 149 (name -> simple_name .)
INFO:root:    LEQ             reduce using rule 149 (name -> simple_name .)
INFO:root:    >               reduce using rule 149 (name -> simple_name .)
INFO:root:    GEQ             reduce using rule 149 (name -> simple_name .)
INFO:root:    IN              reduce using rule 149 (name -> simple_name .)
INFO:root:    NOT             reduce using rule 149 (name -> simple_name .)
INFO:root:    +               reduce using rule 149 (name -> simple_name .)
INFO:root:    -               reduce using rule 149 (name -> simple_name .)
INFO:root:    &               reduce using rule 149 (name -> simple_name .)
INFO:root:    AND             reduce using rule 149 (name -> simple_name .)
INFO:root:    OR              reduce using rule 149 (name -> simple_name .)
INFO:root:    XOR             reduce using rule 149 (name -> simple_name .)
INFO:root:    )               reduce using rule 149 (name -> simple_name .)
INFO:root:    ,               reduce using rule 149 (name -> simple_name .)
INFO:root:
INFO:root:
INFO:root:state 124
INFO:root:
INFO:root:    (4) pragma_arg_s -> pragma_arg .
INFO:root:
INFO:root:    )               reduce using rule 4 (pragma_arg_s -> pragma_arg .)
INFO:root:    ,               reduce using rule 4 (pragma_arg_s -> pragma_arg .)
INFO:root:
INFO:root:
INFO:root:state 125
INFO:root:
INFO:root:    (232) parenthesized_primary -> ( . expression )
INFO:root:    (183) aggregate -> ( . comp_assoc )
INFO:root:    (184) aggregate -> ( . expression WITH value_s )
INFO:root:    (185) aggregate -> ( . expression WITH NuLL RECORD )
INFO:root:    (186) aggregate -> ( . NuLL RECORD )
INFO:root:    (188) expression -> . relation
INFO:root:    (189) expression -> . expression logical relation
INFO:root:    (190) expression -> . expression short_circuit relation
INFO:root:    (187) comp_assoc -> . choice_s ARROW expression
INFO:root:    (196) relation -> . simple_expression
INFO:root:    (197) relation -> . simple_expression relational simple_expression
INFO:root:    (198) relation -> . simple_expression membership range
INFO:root:    (199) relation -> . simple_expression membership name
INFO:root:    (121) choice_s -> . choice
INFO:root:    (122) choice_s -> . choice_s | choice
INFO:root:    (208) simple_expression -> . unary term
INFO:root:    (209) simple_expression -> . term
INFO:root:    (210) simple_expression -> . simple_expression adding term
INFO:root:    (123) choice -> . expression
INFO:root:    (124) choice -> . discrete_with_range
INFO:root:    (125) choice -> . OTHERS
INFO:root:    (211) unary -> . +
INFO:root:    (212) unary -> . -
INFO:root:    (216) term -> . factor
INFO:root:    (217) term -> . term multiplying factor
INFO:root:    (126) discrete_with_range -> . name range_constraint
INFO:root:    (127) discrete_with_range -> . range
INFO:root:    (223) factor -> . primary
INFO:root:    (224) factor -> . NOT primary
INFO:root:    (225) factor -> . ABS primary
INFO:root:    (149) name -> . simple_name
INFO:root:    (150) name -> . indexed_comp
INFO:root:    (151) name -> . selected_comp
INFO:root:    (152) name -> . attribute
INFO:root:    (153) name -> . operator_symbol
INFO:root:    (62) range -> . simple_expression DOTDOT simple_expression
INFO:root:    (226) primary -> . literal
INFO:root:    (227) primary -> . name
INFO:root:    (228) primary -> . allocator
INFO:root:    (229) primary -> . qualified
INFO:root:    (230) primary -> . parenthesized_primary
INFO:root:    (157) simple_name -> . IDENTIFIER
INFO:root:    (164) indexed_comp -> . name ( value_s )
INFO:root:    (171) selected_comp -> . name . simple_name
INFO:root:    (172) selected_comp -> . name . used_char
INFO:root:    (173) selected_comp -> . name . operator_symbol
INFO:root:    (174) selected_comp -> . name . ALL
INFO:root:    (175) attribute -> . name TICK attribute_id
INFO:root:    (163) operator_symbol -> . STRING
INFO:root:    (180) literal -> . INT
INFO:root:    (181) literal -> . FLOAT
INFO:root:    (182) literal -> . NuLL
INFO:root:    (234) allocator -> . NEW name
INFO:root:    (235) allocator -> . NEW qualified
INFO:root:    (233) qualified -> . name TICK parenthesized_primary
INFO:root:    (231) parenthesized_primary -> . aggregate
INFO:root:    (232) parenthesized_primary -> . ( expression )
INFO:root:    (183) aggregate -> . ( comp_assoc )
INFO:root:    (184) aggregate -> . ( expression WITH value_s )
INFO:root:    (185) aggregate -> . ( expression WITH NuLL RECORD )
INFO:root:    (186) aggregate -> . ( NuLL RECORD )
INFO:root:
INFO:root:    NuLL            shift and go to state 206
INFO:root:    OTHERS          shift and go to state 204
INFO:root:    +               shift and go to state 148
INFO:root:    -               shift and go to state 136
INFO:root:    NOT             shift and go to state 131
INFO:root:    ABS             shift and go to state 132
INFO:root:    IDENTIFIER      shift and go to state 33
INFO:root:    STRING          shift and go to state 149
INFO:root:    INT             shift and go to state 120
INFO:root:    FLOAT           shift and go to state 128
INFO:root:    NEW             shift and go to state 137
INFO:root:    (               shift and go to state 125
INFO:root:
INFO:root:    selected_comp                  shift and go to state 139
INFO:root:    comp_assoc                     shift and go to state 208
INFO:root:    simple_name                    shift and go to state 163
INFO:root:    indexed_comp                   shift and go to state 140
INFO:root:    name                           shift and go to state 209
INFO:root:    literal                        shift and go to state 121
INFO:root:    simple_expression              shift and go to state 205
INFO:root:    factor                         shift and go to state 126
INFO:root:    expression                     shift and go to state 203
INFO:root:    unary                          shift and go to state 144
INFO:root:    term                           shift and go to state 146
INFO:root:    aggregate                      shift and go to state 143
INFO:root:    discrete_with_range            shift and go to state 210
INFO:root:    operator_symbol                shift and go to state 133
INFO:root:    parenthesized_primary          shift and go to state 147
INFO:root:    qualified                      shift and go to state 145
INFO:root:    choice_s                       shift and go to state 202
INFO:root:    primary                        shift and go to state 135
INFO:root:    attribute                      shift and go to state 134
INFO:root:    relation                       shift and go to state 138
INFO:root:    range                          shift and go to state 211
INFO:root:    allocator                      shift and go to state 122
INFO:root:    choice                         shift and go to state 207
INFO:root:
INFO:root:state 126
INFO:root:
INFO:root:    (216) term -> factor .
INFO:root:
INFO:root:    *               reduce using rule 216 (term -> factor .)
INFO:root:    /               reduce using rule 216 (term -> factor .)
INFO:root:    MOD             reduce using rule 216 (term -> factor .)
INFO:root:    REM             reduce using rule 216 (term -> factor .)
INFO:root:    STARSTAR        reduce using rule 216 (term -> factor .)
INFO:root:    DOTDOT          reduce using rule 216 (term -> factor .)
INFO:root:    +               reduce using rule 216 (term -> factor .)
INFO:root:    -               reduce using rule 216 (term -> factor .)
INFO:root:    &               reduce using rule 216 (term -> factor .)
INFO:root:    =               reduce using rule 216 (term -> factor .)
INFO:root:    NEQ             reduce using rule 216 (term -> factor .)
INFO:root:    <               reduce using rule 216 (term -> factor .)
INFO:root:    LEQ             reduce using rule 216 (term -> factor .)
INFO:root:    >               reduce using rule 216 (term -> factor .)
INFO:root:    GEQ             reduce using rule 216 (term -> factor .)
INFO:root:    IN              reduce using rule 216 (term -> factor .)
INFO:root:    NOT             reduce using rule 216 (term -> factor .)
INFO:root:    AND             reduce using rule 216 (term -> factor .)
INFO:root:    OR              reduce using rule 216 (term -> factor .)
INFO:root:    XOR             reduce using rule 216 (term -> factor .)
INFO:root:    )               reduce using rule 216 (term -> factor .)
INFO:root:    ,               reduce using rule 216 (term -> factor .)
INFO:root:    WITH            reduce using rule 216 (term -> factor .)
INFO:root:    ARROW           reduce using rule 216 (term -> factor .)
INFO:root:    |               reduce using rule 216 (term -> factor .)
INFO:root:    ;               reduce using rule 216 (term -> factor .)
INFO:root:    IS              reduce using rule 216 (term -> factor .)
INFO:root:    THEN            reduce using rule 216 (term -> factor .)
INFO:root:    LOOP            reduce using rule 216 (term -> factor .)
INFO:root:    RANGE           reduce using rule 216 (term -> factor .)
INFO:root:    DIGITS          reduce using rule 216 (term -> factor .)
INFO:root:    RENAMES         reduce using rule 216 (term -> factor .)
INFO:root:    ASSIGN          reduce using rule 216 (term -> factor .)
INFO:root:
INFO:root:
INFO:root:state 127
INFO:root:
INFO:root:    (6) pragma_arg -> expression .
INFO:root:    (189) expression -> expression . logical relation
INFO:root:    (190) expression -> expression . short_circuit relation
INFO:root:    (191) logical -> . AND
INFO:root:    (192) logical -> . OR
INFO:root:    (193) logical -> . XOR
INFO:root:    (194) short_circuit -> . AND THEN
INFO:root:    (195) short_circuit -> . OR ELSE
INFO:root:
INFO:root:    )               reduce using rule 6 (pragma_arg -> expression .)
INFO:root:    ,               reduce using rule 6 (pragma_arg -> expression .)
INFO:root:    AND             shift and go to state 215
INFO:root:    OR              shift and go to state 216
INFO:root:    XOR             shift and go to state 214
INFO:root:
INFO:root:    short_circuit                  shift and go to state 212
INFO:root:    logical                        shift and go to state 213
INFO:root:
INFO:root:state 128
INFO:root:
INFO:root:    (181) literal -> FLOAT .
INFO:root:
INFO:root:    *               reduce using rule 181 (literal -> FLOAT .)
INFO:root:    /               reduce using rule 181 (literal -> FLOAT .)
INFO:root:    MOD             reduce using rule 181 (literal -> FLOAT .)
INFO:root:    REM             reduce using rule 181 (literal -> FLOAT .)
INFO:root:    STARSTAR        reduce using rule 181 (literal -> FLOAT .)
INFO:root:    =               reduce using rule 181 (literal -> FLOAT .)
INFO:root:    NEQ             reduce using rule 181 (literal -> FLOAT .)
INFO:root:    <               reduce using rule 181 (literal -> FLOAT .)
INFO:root:    LEQ             reduce using rule 181 (literal -> FLOAT .)
INFO:root:    >               reduce using rule 181 (literal -> FLOAT .)
INFO:root:    GEQ             reduce using rule 181 (literal -> FLOAT .)
INFO:root:    IN              reduce using rule 181 (literal -> FLOAT .)
INFO:root:    NOT             reduce using rule 181 (literal -> FLOAT .)
INFO:root:    +               reduce using rule 181 (literal -> FLOAT .)
INFO:root:    -               reduce using rule 181 (literal -> FLOAT .)
INFO:root:    &               reduce using rule 181 (literal -> FLOAT .)
INFO:root:    AND             reduce using rule 181 (literal -> FLOAT .)
INFO:root:    OR              reduce using rule 181 (literal -> FLOAT .)
INFO:root:    XOR             reduce using rule 181 (literal -> FLOAT .)
INFO:root:    )               reduce using rule 181 (literal -> FLOAT .)
INFO:root:    ,               reduce using rule 181 (literal -> FLOAT .)
INFO:root:    DOTDOT          reduce using rule 181 (literal -> FLOAT .)
INFO:root:    WITH            reduce using rule 181 (literal -> FLOAT .)
INFO:root:    ARROW           reduce using rule 181 (literal -> FLOAT .)
INFO:root:    |               reduce using rule 181 (literal -> FLOAT .)
INFO:root:    ;               reduce using rule 181 (literal -> FLOAT .)
INFO:root:    IS              reduce using rule 181 (literal -> FLOAT .)
INFO:root:    THEN            reduce using rule 181 (literal -> FLOAT .)
INFO:root:    LOOP            reduce using rule 181 (literal -> FLOAT .)
INFO:root:    RANGE           reduce using rule 181 (literal -> FLOAT .)
INFO:root:    DIGITS          reduce using rule 181 (literal -> FLOAT .)
INFO:root:    RENAMES         reduce using rule 181 (literal -> FLOAT .)
INFO:root:    ASSIGN          reduce using rule 181 (literal -> FLOAT .)
INFO:root:
INFO:root:
INFO:root:state 129
INFO:root:
INFO:root:    (196) relation -> simple_expression .
INFO:root:    (197) relation -> simple_expression . relational simple_expression
INFO:root:    (198) relation -> simple_expression . membership range
INFO:root:    (199) relation -> simple_expression . membership name
INFO:root:    (210) simple_expression -> simple_expression . adding term
INFO:root:    (200) relational -> . =
INFO:root:    (201) relational -> . NEQ
INFO:root:    (202) relational -> . <
INFO:root:    (203) relational -> . LEQ
INFO:root:    (204) relational -> . >
INFO:root:    (205) relational -> . GEQ
INFO:root:    (206) membership -> . IN
INFO:root:    (207) membership -> . NOT IN
INFO:root:    (213) adding -> . +
INFO:root:    (214) adding -> . -
INFO:root:    (215) adding -> . &
INFO:root:
INFO:root:    AND             reduce using rule 196 (relation -> simple_expression .)
INFO:root:    OR              reduce using rule 196 (relation -> simple_expression .)
INFO:root:    XOR             reduce using rule 196 (relation -> simple_expression .)
INFO:root:    RANGE           reduce using rule 196 (relation -> simple_expression .)
INFO:root:    RENAMES         reduce using rule 196 (relation -> simple_expression .)
INFO:root:    ASSIGN          reduce using rule 196 (relation -> simple_expression .)
INFO:root:    ;               reduce using rule 196 (relation -> simple_expression .)
INFO:root:    WITH            reduce using rule 196 (relation -> simple_expression .)
INFO:root:    )               reduce using rule 196 (relation -> simple_expression .)
INFO:root:    ,               reduce using rule 196 (relation -> simple_expression .)
INFO:root:    IS              reduce using rule 196 (relation -> simple_expression .)
INFO:root:    ARROW           reduce using rule 196 (relation -> simple_expression .)
INFO:root:    |               reduce using rule 196 (relation -> simple_expression .)
INFO:root:    THEN            reduce using rule 196 (relation -> simple_expression .)
INFO:root:    LOOP            reduce using rule 196 (relation -> simple_expression .)
INFO:root:    DIGITS          reduce using rule 196 (relation -> simple_expression .)
INFO:root:    =               shift and go to state 219
INFO:root:    NEQ             shift and go to state 224
INFO:root:    <               shift and go to state 228
INFO:root:    LEQ             shift and go to state 218
INFO:root:    >               shift and go to state 222
INFO:root:    GEQ             shift and go to state 225
INFO:root:    IN              shift and go to state 223
INFO:root:    NOT             shift and go to state 220
INFO:root:    +               shift and go to state 226
INFO:root:    -               shift and go to state 217
INFO:root:    &               shift and go to state 229
INFO:root:
INFO:root:    membership                     shift and go to state 221
INFO:root:    relational                     shift and go to state 227
INFO:root:    adding                         shift and go to state 230
INFO:root:
INFO:root:state 130
INFO:root:
INFO:root:    (182) literal -> NuLL .
INFO:root:
INFO:root:    *               reduce using rule 182 (literal -> NuLL .)
INFO:root:    /               reduce using rule 182 (literal -> NuLL .)
INFO:root:    MOD             reduce using rule 182 (literal -> NuLL .)
INFO:root:    REM             reduce using rule 182 (literal -> NuLL .)
INFO:root:    STARSTAR        reduce using rule 182 (literal -> NuLL .)
INFO:root:    =               reduce using rule 182 (literal -> NuLL .)
INFO:root:    NEQ             reduce using rule 182 (literal -> NuLL .)
INFO:root:    <               reduce using rule 182 (literal -> NuLL .)
INFO:root:    LEQ             reduce using rule 182 (literal -> NuLL .)
INFO:root:    >               reduce using rule 182 (literal -> NuLL .)
INFO:root:    GEQ             reduce using rule 182 (literal -> NuLL .)
INFO:root:    IN              reduce using rule 182 (literal -> NuLL .)
INFO:root:    NOT             reduce using rule 182 (literal -> NuLL .)
INFO:root:    +               reduce using rule 182 (literal -> NuLL .)
INFO:root:    -               reduce using rule 182 (literal -> NuLL .)
INFO:root:    &               reduce using rule 182 (literal -> NuLL .)
INFO:root:    AND             reduce using rule 182 (literal -> NuLL .)
INFO:root:    OR              reduce using rule 182 (literal -> NuLL .)
INFO:root:    XOR             reduce using rule 182 (literal -> NuLL .)
INFO:root:    )               reduce using rule 182 (literal -> NuLL .)
INFO:root:    ,               reduce using rule 182 (literal -> NuLL .)
INFO:root:    DOTDOT          reduce using rule 182 (literal -> NuLL .)
INFO:root:    WITH            reduce using rule 182 (literal -> NuLL .)
INFO:root:    ARROW           reduce using rule 182 (literal -> NuLL .)
INFO:root:    |               reduce using rule 182 (literal -> NuLL .)
INFO:root:    ;               reduce using rule 182 (literal -> NuLL .)
INFO:root:    IS              reduce using rule 182 (literal -> NuLL .)
INFO:root:    THEN            reduce using rule 182 (literal -> NuLL .)
INFO:root:    LOOP            reduce using rule 182 (literal -> NuLL .)
INFO:root:    RANGE           reduce using rule 182 (literal -> NuLL .)
INFO:root:    DIGITS          reduce using rule 182 (literal -> NuLL .)
INFO:root:    RENAMES         reduce using rule 182 (literal -> NuLL .)
INFO:root:    ASSIGN          reduce using rule 182 (literal -> NuLL .)
INFO:root:
INFO:root:
INFO:root:state 131
INFO:root:
INFO:root:    (224) factor -> NOT . primary
INFO:root:    (226) primary -> . literal
INFO:root:    (227) primary -> . name
INFO:root:    (228) primary -> . allocator
INFO:root:    (229) primary -> . qualified
INFO:root:    (230) primary -> . parenthesized_primary
INFO:root:    (180) literal -> . INT
INFO:root:    (181) literal -> . FLOAT
INFO:root:    (182) literal -> . NuLL
INFO:root:    (149) name -> . simple_name
INFO:root:    (150) name -> . indexed_comp
INFO:root:    (151) name -> . selected_comp
INFO:root:    (152) name -> . attribute
INFO:root:    (153) name -> . operator_symbol
INFO:root:    (234) allocator -> . NEW name
INFO:root:    (235) allocator -> . NEW qualified
INFO:root:    (233) qualified -> . name TICK parenthesized_primary
INFO:root:    (231) parenthesized_primary -> . aggregate
INFO:root:    (232) parenthesized_primary -> . ( expression )
INFO:root:    (157) simple_name -> . IDENTIFIER
INFO:root:    (164) indexed_comp -> . name ( value_s )
INFO:root:    (171) selected_comp -> . name . simple_name
INFO:root:    (172) selected_comp -> . name . used_char
INFO:root:    (173) selected_comp -> . name . operator_symbol
INFO:root:    (174) selected_comp -> . name . ALL
INFO:root:    (175) attribute -> . name TICK attribute_id
INFO:root:    (163) operator_symbol -> . STRING
INFO:root:    (183) aggregate -> . ( comp_assoc )
INFO:root:    (184) aggregate -> . ( expression WITH value_s )
INFO:root:    (185) aggregate -> . ( expression WITH NuLL RECORD )
INFO:root:    (186) aggregate -> . ( NuLL RECORD )
INFO:root:
INFO:root:    INT             shift and go to state 120
INFO:root:    FLOAT           shift and go to state 128
INFO:root:    NuLL            shift and go to state 130
INFO:root:    NEW             shift and go to state 137
INFO:root:    (               shift and go to state 125
INFO:root:    IDENTIFIER      shift and go to state 33
INFO:root:    STRING          shift and go to state 149
INFO:root:
INFO:root:    literal                        shift and go to state 121
INFO:root:    allocator                      shift and go to state 122
INFO:root:    qualified                      shift and go to state 145
INFO:root:    indexed_comp                   shift and go to state 140
INFO:root:    attribute                      shift and go to state 134
INFO:root:    name                           shift and go to state 142
INFO:root:    operator_symbol                shift and go to state 133
INFO:root:    parenthesized_primary          shift and go to state 147
INFO:root:    primary                        shift and go to state 231
INFO:root:    selected_comp                  shift and go to state 139
INFO:root:    simple_name                    shift and go to state 163
INFO:root:    aggregate                      shift and go to state 143
INFO:root:
INFO:root:state 132
INFO:root:
INFO:root:    (225) factor -> ABS . primary
INFO:root:    (226) primary -> . literal
INFO:root:    (227) primary -> . name
INFO:root:    (228) primary -> . allocator
INFO:root:    (229) primary -> . qualified
INFO:root:    (230) primary -> . parenthesized_primary
INFO:root:    (180) literal -> . INT
INFO:root:    (181) literal -> . FLOAT
INFO:root:    (182) literal -> . NuLL
INFO:root:    (149) name -> . simple_name
INFO:root:    (150) name -> . indexed_comp
INFO:root:    (151) name -> . selected_comp
INFO:root:    (152) name -> . attribute
INFO:root:    (153) name -> . operator_symbol
INFO:root:    (234) allocator -> . NEW name
INFO:root:    (235) allocator -> . NEW qualified
INFO:root:    (233) qualified -> . name TICK parenthesized_primary
INFO:root:    (231) parenthesized_primary -> . aggregate
INFO:root:    (232) parenthesized_primary -> . ( expression )
INFO:root:    (157) simple_name -> . IDENTIFIER
INFO:root:    (164) indexed_comp -> . name ( value_s )
INFO:root:    (171) selected_comp -> . name . simple_name
INFO:root:    (172) selected_comp -> . name . used_char
INFO:root:    (173) selected_comp -> . name . operator_symbol
INFO:root:    (174) selected_comp -> . name . ALL
INFO:root:    (175) attribute -> . name TICK attribute_id
INFO:root:    (163) operator_symbol -> . STRING
INFO:root:    (183) aggregate -> . ( comp_assoc )
INFO:root:    (184) aggregate -> . ( expression WITH value_s )
INFO:root:    (185) aggregate -> . ( expression WITH NuLL RECORD )
INFO:root:    (186) aggregate -> . ( NuLL RECORD )
INFO:root:
INFO:root:    INT             shift and go to state 120
INFO:root:    FLOAT           shift and go to state 128
INFO:root:    NuLL            shift and go to state 130
INFO:root:    NEW             shift and go to state 137
INFO:root:    (               shift and go to state 125
INFO:root:    IDENTIFIER      shift and go to state 33
INFO:root:    STRING          shift and go to state 149
INFO:root:
INFO:root:    literal                        shift and go to state 121
INFO:root:    allocator                      shift and go to state 122
INFO:root:    qualified                      shift and go to state 145
INFO:root:    indexed_comp                   shift and go to state 140
INFO:root:    attribute                      shift and go to state 134
INFO:root:    name                           shift and go to state 142
INFO:root:    operator_symbol                shift and go to state 133
INFO:root:    parenthesized_primary          shift and go to state 147
INFO:root:    primary                        shift and go to state 232
INFO:root:    selected_comp                  shift and go to state 139
INFO:root:    simple_name                    shift and go to state 163
INFO:root:    aggregate                      shift and go to state 143
INFO:root:
INFO:root:state 133
INFO:root:
INFO:root:    (153) name -> operator_symbol .
INFO:root:
INFO:root:    ASSIGN          reduce using rule 153 (name -> operator_symbol .)
INFO:root:    ;               reduce using rule 153 (name -> operator_symbol .)
INFO:root:    TICK            reduce using rule 153 (name -> operator_symbol .)
INFO:root:    (               reduce using rule 153 (name -> operator_symbol .)
INFO:root:    .               reduce using rule 153 (name -> operator_symbol .)
INFO:root:    ,               reduce using rule 153 (name -> operator_symbol .)
INFO:root:    ARROW           reduce using rule 153 (name -> operator_symbol .)
INFO:root:    |               reduce using rule 153 (name -> operator_symbol .)
INFO:root:    *               reduce using rule 153 (name -> operator_symbol .)
INFO:root:    /               reduce using rule 153 (name -> operator_symbol .)
INFO:root:    MOD             reduce using rule 153 (name -> operator_symbol .)
INFO:root:    REM             reduce using rule 153 (name -> operator_symbol .)
INFO:root:    STARSTAR        reduce using rule 153 (name -> operator_symbol .)
INFO:root:    +               reduce using rule 153 (name -> operator_symbol .)
INFO:root:    -               reduce using rule 153 (name -> operator_symbol .)
INFO:root:    &               reduce using rule 153 (name -> operator_symbol .)
INFO:root:    AND             reduce using rule 153 (name -> operator_symbol .)
INFO:root:    OR              reduce using rule 153 (name -> operator_symbol .)
INFO:root:    XOR             reduce using rule 153 (name -> operator_symbol .)
INFO:root:    )               reduce using rule 153 (name -> operator_symbol .)
INFO:root:    WITH            reduce using rule 153 (name -> operator_symbol .)
INFO:root:    IS              reduce using rule 153 (name -> operator_symbol .)
INFO:root:    THEN            reduce using rule 153 (name -> operator_symbol .)
INFO:root:    LOOP            reduce using rule 153 (name -> operator_symbol .)
INFO:root:    RANGE           reduce using rule 153 (name -> operator_symbol .)
INFO:root:    DIGITS          reduce using rule 153 (name -> operator_symbol .)
INFO:root:    RENAMES         reduce using rule 153 (name -> operator_symbol .)
INFO:root:    =               reduce using rule 153 (name -> operator_symbol .)
INFO:root:    NEQ             reduce using rule 153 (name -> operator_symbol .)
INFO:root:    <               reduce using rule 153 (name -> operator_symbol .)
INFO:root:    LEQ             reduce using rule 153 (name -> operator_symbol .)
INFO:root:    >               reduce using rule 153 (name -> operator_symbol .)
INFO:root:    GEQ             reduce using rule 153 (name -> operator_symbol .)
INFO:root:    IN              reduce using rule 153 (name -> operator_symbol .)
INFO:root:    NOT             reduce using rule 153 (name -> operator_symbol .)
INFO:root:    DOTDOT          reduce using rule 153 (name -> operator_symbol .)
INFO:root:    WHEN            reduce using rule 153 (name -> operator_symbol .)
INFO:root:
INFO:root:
INFO:root:state 134
INFO:root:
INFO:root:    (152) name -> attribute .
INFO:root:
INFO:root:    ASSIGN          reduce using rule 152 (name -> attribute .)
INFO:root:    ;               reduce using rule 152 (name -> attribute .)
INFO:root:    TICK            reduce using rule 152 (name -> attribute .)
INFO:root:    (               reduce using rule 152 (name -> attribute .)
INFO:root:    .               reduce using rule 152 (name -> attribute .)
INFO:root:    ,               reduce using rule 152 (name -> attribute .)
INFO:root:    ARROW           reduce using rule 152 (name -> attribute .)
INFO:root:    |               reduce using rule 152 (name -> attribute .)
INFO:root:    *               reduce using rule 152 (name -> attribute .)
INFO:root:    /               reduce using rule 152 (name -> attribute .)
INFO:root:    MOD             reduce using rule 152 (name -> attribute .)
INFO:root:    REM             reduce using rule 152 (name -> attribute .)
INFO:root:    STARSTAR        reduce using rule 152 (name -> attribute .)
INFO:root:    +               reduce using rule 152 (name -> attribute .)
INFO:root:    -               reduce using rule 152 (name -> attribute .)
INFO:root:    &               reduce using rule 152 (name -> attribute .)
INFO:root:    AND             reduce using rule 152 (name -> attribute .)
INFO:root:    OR              reduce using rule 152 (name -> attribute .)
INFO:root:    XOR             reduce using rule 152 (name -> attribute .)
INFO:root:    )               reduce using rule 152 (name -> attribute .)
INFO:root:    WITH            reduce using rule 152 (name -> attribute .)
INFO:root:    IS              reduce using rule 152 (name -> attribute .)
INFO:root:    THEN            reduce using rule 152 (name -> attribute .)
INFO:root:    LOOP            reduce using rule 152 (name -> attribute .)
INFO:root:    RANGE           reduce using rule 152 (name -> attribute .)
INFO:root:    DIGITS          reduce using rule 152 (name -> attribute .)
INFO:root:    RENAMES         reduce using rule 152 (name -> attribute .)
INFO:root:    =               reduce using rule 152 (name -> attribute .)
INFO:root:    NEQ             reduce using rule 152 (name -> attribute .)
INFO:root:    <               reduce using rule 152 (name -> attribute .)
INFO:root:    LEQ             reduce using rule 152 (name -> attribute .)
INFO:root:    >               reduce using rule 152 (name -> attribute .)
INFO:root:    GEQ             reduce using rule 152 (name -> attribute .)
INFO:root:    IN              reduce using rule 152 (name -> attribute .)
INFO:root:    NOT             reduce using rule 152 (name -> attribute .)
INFO:root:    DOTDOT          reduce using rule 152 (name -> attribute .)
INFO:root:    WHEN            reduce using rule 152 (name -> attribute .)
INFO:root:
INFO:root:
INFO:root:state 135
INFO:root:
INFO:root:    (223) factor -> primary .
INFO:root:
INFO:root:    *               reduce using rule 223 (factor -> primary .)
INFO:root:    /               reduce using rule 223 (factor -> primary .)
INFO:root:    MOD             reduce using rule 223 (factor -> primary .)
INFO:root:    REM             reduce using rule 223 (factor -> primary .)
INFO:root:    STARSTAR        reduce using rule 223 (factor -> primary .)
INFO:root:    =               reduce using rule 223 (factor -> primary .)
INFO:root:    NEQ             reduce using rule 223 (factor -> primary .)
INFO:root:    <               reduce using rule 223 (factor -> primary .)
INFO:root:    LEQ             reduce using rule 223 (factor -> primary .)
INFO:root:    >               reduce using rule 223 (factor -> primary .)
INFO:root:    GEQ             reduce using rule 223 (factor -> primary .)
INFO:root:    IN              reduce using rule 223 (factor -> primary .)
INFO:root:    NOT             reduce using rule 223 (factor -> primary .)
INFO:root:    +               reduce using rule 223 (factor -> primary .)
INFO:root:    -               reduce using rule 223 (factor -> primary .)
INFO:root:    &               reduce using rule 223 (factor -> primary .)
INFO:root:    AND             reduce using rule 223 (factor -> primary .)
INFO:root:    OR              reduce using rule 223 (factor -> primary .)
INFO:root:    XOR             reduce using rule 223 (factor -> primary .)
INFO:root:    ;               reduce using rule 223 (factor -> primary .)
INFO:root:    IS              reduce using rule 223 (factor -> primary .)
INFO:root:    LOOP            reduce using rule 223 (factor -> primary .)
INFO:root:    DOTDOT          reduce using rule 223 (factor -> primary .)
INFO:root:    ARROW           reduce using rule 223 (factor -> primary .)
INFO:root:    |               reduce using rule 223 (factor -> primary .)
INFO:root:    DIGITS          reduce using rule 223 (factor -> primary .)
INFO:root:    RANGE           reduce using rule 223 (factor -> primary .)
INFO:root:    )               reduce using rule 223 (factor -> primary .)
INFO:root:    ,               reduce using rule 223 (factor -> primary .)
INFO:root:    WITH            reduce using rule 223 (factor -> primary .)
INFO:root:    THEN            reduce using rule 223 (factor -> primary .)
INFO:root:    RENAMES         reduce using rule 223 (factor -> primary .)
INFO:root:    ASSIGN          reduce using rule 223 (factor -> primary .)
INFO:root:
INFO:root:
INFO:root:state 136
INFO:root:
INFO:root:    (212) unary -> - .
INFO:root:
INFO:root:    NOT             reduce using rule 212 (unary -> - .)
INFO:root:    ABS             reduce using rule 212 (unary -> - .)
INFO:root:    INT             reduce using rule 212 (unary -> - .)
INFO:root:    FLOAT           reduce using rule 212 (unary -> - .)
INFO:root:    NuLL            reduce using rule 212 (unary -> - .)
INFO:root:    NEW             reduce using rule 212 (unary -> - .)
INFO:root:    (               reduce using rule 212 (unary -> - .)
INFO:root:    IDENTIFIER      reduce using rule 212 (unary -> - .)
INFO:root:    STRING          reduce using rule 212 (unary -> - .)
INFO:root:
INFO:root:
INFO:root:state 137
INFO:root:
INFO:root:    (234) allocator -> NEW . name
INFO:root:    (235) allocator -> NEW . qualified
INFO:root:    (149) name -> . simple_name
INFO:root:    (150) name -> . indexed_comp
INFO:root:    (151) name -> . selected_comp
INFO:root:    (152) name -> . attribute
INFO:root:    (153) name -> . operator_symbol
INFO:root:    (233) qualified -> . name TICK parenthesized_primary
INFO:root:    (157) simple_name -> . IDENTIFIER
INFO:root:    (164) indexed_comp -> . name ( value_s )
INFO:root:    (171) selected_comp -> . name . simple_name
INFO:root:    (172) selected_comp -> . name . used_char
INFO:root:    (173) selected_comp -> . name . operator_symbol
INFO:root:    (174) selected_comp -> . name . ALL
INFO:root:    (175) attribute -> . name TICK attribute_id
INFO:root:    (163) operator_symbol -> . STRING
INFO:root:
INFO:root:    IDENTIFIER      shift and go to state 33
INFO:root:    STRING          shift and go to state 149
INFO:root:
INFO:root:    selected_comp                  shift and go to state 139
INFO:root:    qualified                      shift and go to state 233
INFO:root:    indexed_comp                   shift and go to state 140
INFO:root:    attribute                      shift and go to state 134
INFO:root:    name                           shift and go to state 234
INFO:root:    simple_name                    shift and go to state 163
INFO:root:    operator_symbol                shift and go to state 133
INFO:root:
INFO:root:state 138
INFO:root:
INFO:root:    (188) expression -> relation .
INFO:root:
INFO:root:    )               reduce using rule 188 (expression -> relation .)
INFO:root:    WITH            reduce using rule 188 (expression -> relation .)
INFO:root:    AND             reduce using rule 188 (expression -> relation .)
INFO:root:    OR              reduce using rule 188 (expression -> relation .)
INFO:root:    XOR             reduce using rule 188 (expression -> relation .)
INFO:root:    ARROW           reduce using rule 188 (expression -> relation .)
INFO:root:    |               reduce using rule 188 (expression -> relation .)
INFO:root:    RANGE           reduce using rule 188 (expression -> relation .)
INFO:root:    ;               reduce using rule 188 (expression -> relation .)
INFO:root:    THEN            reduce using rule 188 (expression -> relation .)
INFO:root:    DIGITS          reduce using rule 188 (expression -> relation .)
INFO:root:    ,               reduce using rule 188 (expression -> relation .)
INFO:root:    RENAMES         reduce using rule 188 (expression -> relation .)
INFO:root:    ASSIGN          reduce using rule 188 (expression -> relation .)
INFO:root:    IS              reduce using rule 188 (expression -> relation .)
INFO:root:    LOOP            reduce using rule 188 (expression -> relation .)
INFO:root:
INFO:root:
INFO:root:state 139
INFO:root:
INFO:root:    (151) name -> selected_comp .
INFO:root:
INFO:root:    ASSIGN          reduce using rule 151 (name -> selected_comp .)
INFO:root:    ;               reduce using rule 151 (name -> selected_comp .)
INFO:root:    TICK            reduce using rule 151 (name -> selected_comp .)
INFO:root:    (               reduce using rule 151 (name -> selected_comp .)
INFO:root:    .               reduce using rule 151 (name -> selected_comp .)
INFO:root:    ,               reduce using rule 151 (name -> selected_comp .)
INFO:root:    ARROW           reduce using rule 151 (name -> selected_comp .)
INFO:root:    |               reduce using rule 151 (name -> selected_comp .)
INFO:root:    *               reduce using rule 151 (name -> selected_comp .)
INFO:root:    /               reduce using rule 151 (name -> selected_comp .)
INFO:root:    MOD             reduce using rule 151 (name -> selected_comp .)
INFO:root:    REM             reduce using rule 151 (name -> selected_comp .)
INFO:root:    STARSTAR        reduce using rule 151 (name -> selected_comp .)
INFO:root:    +               reduce using rule 151 (name -> selected_comp .)
INFO:root:    -               reduce using rule 151 (name -> selected_comp .)
INFO:root:    &               reduce using rule 151 (name -> selected_comp .)
INFO:root:    AND             reduce using rule 151 (name -> selected_comp .)
INFO:root:    OR              reduce using rule 151 (name -> selected_comp .)
INFO:root:    XOR             reduce using rule 151 (name -> selected_comp .)
INFO:root:    )               reduce using rule 151 (name -> selected_comp .)
INFO:root:    WITH            reduce using rule 151 (name -> selected_comp .)
INFO:root:    IS              reduce using rule 151 (name -> selected_comp .)
INFO:root:    THEN            reduce using rule 151 (name -> selected_comp .)
INFO:root:    LOOP            reduce using rule 151 (name -> selected_comp .)
INFO:root:    RANGE           reduce using rule 151 (name -> selected_comp .)
INFO:root:    DIGITS          reduce using rule 151 (name -> selected_comp .)
INFO:root:    RENAMES         reduce using rule 151 (name -> selected_comp .)
INFO:root:    =               reduce using rule 151 (name -> selected_comp .)
INFO:root:    NEQ             reduce using rule 151 (name -> selected_comp .)
INFO:root:    <               reduce using rule 151 (name -> selected_comp .)
INFO:root:    LEQ             reduce using rule 151 (name -> selected_comp .)
INFO:root:    >               reduce using rule 151 (name -> selected_comp .)
INFO:root:    GEQ             reduce using rule 151 (name -> selected_comp .)
INFO:root:    IN              reduce using rule 151 (name -> selected_comp .)
INFO:root:    NOT             reduce using rule 151 (name -> selected_comp .)
INFO:root:    DOTDOT          reduce using rule 151 (name -> selected_comp .)
INFO:root:    WHEN            reduce using rule 151 (name -> selected_comp .)
INFO:root:
INFO:root:
INFO:root:state 140
INFO:root:
INFO:root:    (150) name -> indexed_comp .
INFO:root:
INFO:root:    ASSIGN          reduce using rule 150 (name -> indexed_comp .)
INFO:root:    ;               reduce using rule 150 (name -> indexed_comp .)
INFO:root:    TICK            reduce using rule 150 (name -> indexed_comp .)
INFO:root:    (               reduce using rule 150 (name -> indexed_comp .)
INFO:root:    .               reduce using rule 150 (name -> indexed_comp .)
INFO:root:    ,               reduce using rule 150 (name -> indexed_comp .)
INFO:root:    ARROW           reduce using rule 150 (name -> indexed_comp .)
INFO:root:    |               reduce using rule 150 (name -> indexed_comp .)
INFO:root:    *               reduce using rule 150 (name -> indexed_comp .)
INFO:root:    /               reduce using rule 150 (name -> indexed_comp .)
INFO:root:    MOD             reduce using rule 150 (name -> indexed_comp .)
INFO:root:    REM             reduce using rule 150 (name -> indexed_comp .)
INFO:root:    STARSTAR        reduce using rule 150 (name -> indexed_comp .)
INFO:root:    +               reduce using rule 150 (name -> indexed_comp .)
INFO:root:    -               reduce using rule 150 (name -> indexed_comp .)
INFO:root:    &               reduce using rule 150 (name -> indexed_comp .)
INFO:root:    AND             reduce using rule 150 (name -> indexed_comp .)
INFO:root:    OR              reduce using rule 150 (name -> indexed_comp .)
INFO:root:    XOR             reduce using rule 150 (name -> indexed_comp .)
INFO:root:    )               reduce using rule 150 (name -> indexed_comp .)
INFO:root:    WITH            reduce using rule 150 (name -> indexed_comp .)
INFO:root:    IS              reduce using rule 150 (name -> indexed_comp .)
INFO:root:    THEN            reduce using rule 150 (name -> indexed_comp .)
INFO:root:    LOOP            reduce using rule 150 (name -> indexed_comp .)
INFO:root:    RANGE           reduce using rule 150 (name -> indexed_comp .)
INFO:root:    DIGITS          reduce using rule 150 (name -> indexed_comp .)
INFO:root:    RENAMES         reduce using rule 150 (name -> indexed_comp .)
INFO:root:    =               reduce using rule 150 (name -> indexed_comp .)
INFO:root:    NEQ             reduce using rule 150 (name -> indexed_comp .)
INFO:root:    <               reduce using rule 150 (name -> indexed_comp .)
INFO:root:    LEQ             reduce using rule 150 (name -> indexed_comp .)
INFO:root:    >               reduce using rule 150 (name -> indexed_comp .)
INFO:root:    GEQ             reduce using rule 150 (name -> indexed_comp .)
INFO:root:    IN              reduce using rule 150 (name -> indexed_comp .)
INFO:root:    NOT             reduce using rule 150 (name -> indexed_comp .)
INFO:root:    DOTDOT          reduce using rule 150 (name -> indexed_comp .)
INFO:root:    WHEN            reduce using rule 150 (name -> indexed_comp .)
INFO:root:
INFO:root:
INFO:root:state 141
INFO:root:
INFO:root:    (3) pragma -> PRAGMA simple_name ( pragma_arg_s . ) ;
INFO:root:    (5) pragma_arg_s -> pragma_arg_s . , pragma_arg
INFO:root:
INFO:root:    )               shift and go to state 235
INFO:root:    ,               shift and go to state 236
INFO:root:
INFO:root:
INFO:root:state 142
INFO:root:
INFO:root:    (227) primary -> name .
INFO:root:    (233) qualified -> name . TICK parenthesized_primary
INFO:root:    (164) indexed_comp -> name . ( value_s )
INFO:root:    (171) selected_comp -> name . . simple_name
INFO:root:    (172) selected_comp -> name . . used_char
INFO:root:    (173) selected_comp -> name . . operator_symbol
INFO:root:    (174) selected_comp -> name . . ALL
INFO:root:    (175) attribute -> name . TICK attribute_id
INFO:root:
INFO:root:    *               reduce using rule 227 (primary -> name .)
INFO:root:    /               reduce using rule 227 (primary -> name .)
INFO:root:    MOD             reduce using rule 227 (primary -> name .)
INFO:root:    REM             reduce using rule 227 (primary -> name .)
INFO:root:    STARSTAR        reduce using rule 227 (primary -> name .)
INFO:root:    =               reduce using rule 227 (primary -> name .)
INFO:root:    NEQ             reduce using rule 227 (primary -> name .)
INFO:root:    <               reduce using rule 227 (primary -> name .)
INFO:root:    LEQ             reduce using rule 227 (primary -> name .)
INFO:root:    >               reduce using rule 227 (primary -> name .)
INFO:root:    GEQ             reduce using rule 227 (primary -> name .)
INFO:root:    IN              reduce using rule 227 (primary -> name .)
INFO:root:    NOT             reduce using rule 227 (primary -> name .)
INFO:root:    +               reduce using rule 227 (primary -> name .)
INFO:root:    -               reduce using rule 227 (primary -> name .)
INFO:root:    &               reduce using rule 227 (primary -> name .)
INFO:root:    AND             reduce using rule 227 (primary -> name .)
INFO:root:    OR              reduce using rule 227 (primary -> name .)
INFO:root:    XOR             reduce using rule 227 (primary -> name .)
INFO:root:    ARROW           reduce using rule 227 (primary -> name .)
INFO:root:    ;               reduce using rule 227 (primary -> name .)
INFO:root:    )               reduce using rule 227 (primary -> name .)
INFO:root:    ,               reduce using rule 227 (primary -> name .)
INFO:root:    DOTDOT          reduce using rule 227 (primary -> name .)
INFO:root:    WITH            reduce using rule 227 (primary -> name .)
INFO:root:    |               reduce using rule 227 (primary -> name .)
INFO:root:    IS              reduce using rule 227 (primary -> name .)
INFO:root:    THEN            reduce using rule 227 (primary -> name .)
INFO:root:    LOOP            reduce using rule 227 (primary -> name .)
INFO:root:    RANGE           reduce using rule 227 (primary -> name .)
INFO:root:    DIGITS          reduce using rule 227 (primary -> name .)
INFO:root:    RENAMES         reduce using rule 227 (primary -> name .)
INFO:root:    ASSIGN          reduce using rule 227 (primary -> name .)
INFO:root:    TICK            shift and go to state 238
INFO:root:    (               shift and go to state 237
INFO:root:    .               shift and go to state 239
INFO:root:
INFO:root:
INFO:root:state 143
INFO:root:
INFO:root:    (231) parenthesized_primary -> aggregate .
INFO:root:
INFO:root:    *               reduce using rule 231 (parenthesized_primary -> aggregate .)
INFO:root:    /               reduce using rule 231 (parenthesized_primary -> aggregate .)
INFO:root:    MOD             reduce using rule 231 (parenthesized_primary -> aggregate .)
INFO:root:    REM             reduce using rule 231 (parenthesized_primary -> aggregate .)
INFO:root:    STARSTAR        reduce using rule 231 (parenthesized_primary -> aggregate .)
INFO:root:    =               reduce using rule 231 (parenthesized_primary -> aggregate .)
INFO:root:    NEQ             reduce using rule 231 (parenthesized_primary -> aggregate .)
INFO:root:    <               reduce using rule 231 (parenthesized_primary -> aggregate .)
INFO:root:    LEQ             reduce using rule 231 (parenthesized_primary -> aggregate .)
INFO:root:    >               reduce using rule 231 (parenthesized_primary -> aggregate .)
INFO:root:    GEQ             reduce using rule 231 (parenthesized_primary -> aggregate .)
INFO:root:    IN              reduce using rule 231 (parenthesized_primary -> aggregate .)
INFO:root:    NOT             reduce using rule 231 (parenthesized_primary -> aggregate .)
INFO:root:    +               reduce using rule 231 (parenthesized_primary -> aggregate .)
INFO:root:    -               reduce using rule 231 (parenthesized_primary -> aggregate .)
INFO:root:    &               reduce using rule 231 (parenthesized_primary -> aggregate .)
INFO:root:    IS              reduce using rule 231 (parenthesized_primary -> aggregate .)
INFO:root:    AND             reduce using rule 231 (parenthesized_primary -> aggregate .)
INFO:root:    OR              reduce using rule 231 (parenthesized_primary -> aggregate .)
INFO:root:    XOR             reduce using rule 231 (parenthesized_primary -> aggregate .)
INFO:root:    THEN            reduce using rule 231 (parenthesized_primary -> aggregate .)
INFO:root:    )               reduce using rule 231 (parenthesized_primary -> aggregate .)
INFO:root:    ,               reduce using rule 231 (parenthesized_primary -> aggregate .)
INFO:root:    DOTDOT          reduce using rule 231 (parenthesized_primary -> aggregate .)
INFO:root:    WITH            reduce using rule 231 (parenthesized_primary -> aggregate .)
INFO:root:    ARROW           reduce using rule 231 (parenthesized_primary -> aggregate .)
INFO:root:    |               reduce using rule 231 (parenthesized_primary -> aggregate .)
INFO:root:    ;               reduce using rule 231 (parenthesized_primary -> aggregate .)
INFO:root:    LOOP            reduce using rule 231 (parenthesized_primary -> aggregate .)
INFO:root:    RANGE           reduce using rule 231 (parenthesized_primary -> aggregate .)
INFO:root:    DIGITS          reduce using rule 231 (parenthesized_primary -> aggregate .)
INFO:root:    RENAMES         reduce using rule 231 (parenthesized_primary -> aggregate .)
INFO:root:    ASSIGN          reduce using rule 231 (parenthesized_primary -> aggregate .)
INFO:root:
INFO:root:
INFO:root:state 144
INFO:root:
INFO:root:    (208) simple_expression -> unary . term
INFO:root:    (216) term -> . factor
INFO:root:    (217) term -> . term multiplying factor
INFO:root:    (223) factor -> . primary
INFO:root:    (224) factor -> . NOT primary
INFO:root:    (225) factor -> . ABS primary
INFO:root:    (226) primary -> . literal
INFO:root:    (227) primary -> . name
INFO:root:    (228) primary -> . allocator
INFO:root:    (229) primary -> . qualified
INFO:root:    (230) primary -> . parenthesized_primary
INFO:root:    (180) literal -> . INT
INFO:root:    (181) literal -> . FLOAT
INFO:root:    (182) literal -> . NuLL
INFO:root:    (149) name -> . simple_name
INFO:root:    (150) name -> . indexed_comp
INFO:root:    (151) name -> . selected_comp
INFO:root:    (152) name -> . attribute
INFO:root:    (153) name -> . operator_symbol
INFO:root:    (234) allocator -> . NEW name
INFO:root:    (235) allocator -> . NEW qualified
INFO:root:    (233) qualified -> . name TICK parenthesized_primary
INFO:root:    (231) parenthesized_primary -> . aggregate
INFO:root:    (232) parenthesized_primary -> . ( expression )
INFO:root:    (157) simple_name -> . IDENTIFIER
INFO:root:    (164) indexed_comp -> . name ( value_s )
INFO:root:    (171) selected_comp -> . name . simple_name
INFO:root:    (172) selected_comp -> . name . used_char
INFO:root:    (173) selected_comp -> . name . operator_symbol
INFO:root:    (174) selected_comp -> . name . ALL
INFO:root:    (175) attribute -> . name TICK attribute_id
INFO:root:    (163) operator_symbol -> . STRING
INFO:root:    (183) aggregate -> . ( comp_assoc )
INFO:root:    (184) aggregate -> . ( expression WITH value_s )
INFO:root:    (185) aggregate -> . ( expression WITH NuLL RECORD )
INFO:root:    (186) aggregate -> . ( NuLL RECORD )
INFO:root:
INFO:root:    NOT             shift and go to state 131
INFO:root:    ABS             shift and go to state 132
INFO:root:    INT             shift and go to state 120
INFO:root:    FLOAT           shift and go to state 128
INFO:root:    NuLL            shift and go to state 130
INFO:root:    NEW             shift and go to state 137
INFO:root:    (               shift and go to state 125
INFO:root:    IDENTIFIER      shift and go to state 33
INFO:root:    STRING          shift and go to state 149
INFO:root:
INFO:root:    literal                        shift and go to state 121
INFO:root:    allocator                      shift and go to state 122
INFO:root:    term                           shift and go to state 240
INFO:root:    factor                         shift and go to state 126
INFO:root:    indexed_comp                   shift and go to state 140
INFO:root:    name                           shift and go to state 142
INFO:root:    operator_symbol                shift and go to state 133
INFO:root:    parenthesized_primary          shift and go to state 147
INFO:root:    attribute                      shift and go to state 134
INFO:root:    primary                        shift and go to state 135
INFO:root:    selected_comp                  shift and go to state 139
INFO:root:    simple_name                    shift and go to state 163
INFO:root:    aggregate                      shift and go to state 143
INFO:root:    qualified                      shift and go to state 145
INFO:root:
INFO:root:state 145
INFO:root:
INFO:root:    (229) primary -> qualified .
INFO:root:
INFO:root:    *               reduce using rule 229 (primary -> qualified .)
INFO:root:    /               reduce using rule 229 (primary -> qualified .)
INFO:root:    MOD             reduce using rule 229 (primary -> qualified .)
INFO:root:    REM             reduce using rule 229 (primary -> qualified .)
INFO:root:    STARSTAR        reduce using rule 229 (primary -> qualified .)
INFO:root:    =               reduce using rule 229 (primary -> qualified .)
INFO:root:    NEQ             reduce using rule 229 (primary -> qualified .)
INFO:root:    <               reduce using rule 229 (primary -> qualified .)
INFO:root:    LEQ             reduce using rule 229 (primary -> qualified .)
INFO:root:    >               reduce using rule 229 (primary -> qualified .)
INFO:root:    GEQ             reduce using rule 229 (primary -> qualified .)
INFO:root:    IN              reduce using rule 229 (primary -> qualified .)
INFO:root:    NOT             reduce using rule 229 (primary -> qualified .)
INFO:root:    +               reduce using rule 229 (primary -> qualified .)
INFO:root:    -               reduce using rule 229 (primary -> qualified .)
INFO:root:    &               reduce using rule 229 (primary -> qualified .)
INFO:root:    AND             reduce using rule 229 (primary -> qualified .)
INFO:root:    OR              reduce using rule 229 (primary -> qualified .)
INFO:root:    XOR             reduce using rule 229 (primary -> qualified .)
INFO:root:    ARROW           reduce using rule 229 (primary -> qualified .)
INFO:root:    ;               reduce using rule 229 (primary -> qualified .)
INFO:root:    )               reduce using rule 229 (primary -> qualified .)
INFO:root:    ,               reduce using rule 229 (primary -> qualified .)
INFO:root:    DOTDOT          reduce using rule 229 (primary -> qualified .)
INFO:root:    WITH            reduce using rule 229 (primary -> qualified .)
INFO:root:    |               reduce using rule 229 (primary -> qualified .)
INFO:root:    IS              reduce using rule 229 (primary -> qualified .)
INFO:root:    THEN            reduce using rule 229 (primary -> qualified .)
INFO:root:    LOOP            reduce using rule 229 (primary -> qualified .)
INFO:root:    RANGE           reduce using rule 229 (primary -> qualified .)
INFO:root:    DIGITS          reduce using rule 229 (primary -> qualified .)
INFO:root:    RENAMES         reduce using rule 229 (primary -> qualified .)
INFO:root:    ASSIGN          reduce using rule 229 (primary -> qualified .)
INFO:root:
INFO:root:
INFO:root:state 146
INFO:root:
INFO:root:    (209) simple_expression -> term .
INFO:root:    (217) term -> term . multiplying factor
INFO:root:    (218) multiplying -> . *
INFO:root:    (219) multiplying -> . /
INFO:root:    (220) multiplying -> . MOD
INFO:root:    (221) multiplying -> . REM
INFO:root:    (222) multiplying -> . STARSTAR
INFO:root:
INFO:root:    DOTDOT          reduce using rule 209 (simple_expression -> term .)
INFO:root:    +               reduce using rule 209 (simple_expression -> term .)
INFO:root:    -               reduce using rule 209 (simple_expression -> term .)
INFO:root:    &               reduce using rule 209 (simple_expression -> term .)
INFO:root:    =               reduce using rule 209 (simple_expression -> term .)
INFO:root:    NEQ             reduce using rule 209 (simple_expression -> term .)
INFO:root:    <               reduce using rule 209 (simple_expression -> term .)
INFO:root:    LEQ             reduce using rule 209 (simple_expression -> term .)
INFO:root:    >               reduce using rule 209 (simple_expression -> term .)
INFO:root:    GEQ             reduce using rule 209 (simple_expression -> term .)
INFO:root:    IN              reduce using rule 209 (simple_expression -> term .)
INFO:root:    NOT             reduce using rule 209 (simple_expression -> term .)
INFO:root:    DIGITS          reduce using rule 209 (simple_expression -> term .)
INFO:root:    AND             reduce using rule 209 (simple_expression -> term .)
INFO:root:    OR              reduce using rule 209 (simple_expression -> term .)
INFO:root:    XOR             reduce using rule 209 (simple_expression -> term .)
INFO:root:    RANGE           reduce using rule 209 (simple_expression -> term .)
INFO:root:    ARROW           reduce using rule 209 (simple_expression -> term .)
INFO:root:    |               reduce using rule 209 (simple_expression -> term .)
INFO:root:    )               reduce using rule 209 (simple_expression -> term .)
INFO:root:    ,               reduce using rule 209 (simple_expression -> term .)
INFO:root:    WITH            reduce using rule 209 (simple_expression -> term .)
INFO:root:    ;               reduce using rule 209 (simple_expression -> term .)
INFO:root:    IS              reduce using rule 209 (simple_expression -> term .)
INFO:root:    THEN            reduce using rule 209 (simple_expression -> term .)
INFO:root:    LOOP            reduce using rule 209 (simple_expression -> term .)
INFO:root:    RENAMES         reduce using rule 209 (simple_expression -> term .)
INFO:root:    ASSIGN          reduce using rule 209 (simple_expression -> term .)
INFO:root:    *               shift and go to state 243
INFO:root:    /               shift and go to state 246
INFO:root:    MOD             shift and go to state 241
INFO:root:    REM             shift and go to state 242
INFO:root:    STARSTAR        shift and go to state 245
INFO:root:
INFO:root:    multiplying                    shift and go to state 244
INFO:root:
INFO:root:state 147
INFO:root:
INFO:root:    (230) primary -> parenthesized_primary .
INFO:root:
INFO:root:    *               reduce using rule 230 (primary -> parenthesized_primary .)
INFO:root:    /               reduce using rule 230 (primary -> parenthesized_primary .)
INFO:root:    MOD             reduce using rule 230 (primary -> parenthesized_primary .)
INFO:root:    REM             reduce using rule 230 (primary -> parenthesized_primary .)
INFO:root:    STARSTAR        reduce using rule 230 (primary -> parenthesized_primary .)
INFO:root:    =               reduce using rule 230 (primary -> parenthesized_primary .)
INFO:root:    NEQ             reduce using rule 230 (primary -> parenthesized_primary .)
INFO:root:    <               reduce using rule 230 (primary -> parenthesized_primary .)
INFO:root:    LEQ             reduce using rule 230 (primary -> parenthesized_primary .)
INFO:root:    >               reduce using rule 230 (primary -> parenthesized_primary .)
INFO:root:    GEQ             reduce using rule 230 (primary -> parenthesized_primary .)
INFO:root:    IN              reduce using rule 230 (primary -> parenthesized_primary .)
INFO:root:    NOT             reduce using rule 230 (primary -> parenthesized_primary .)
INFO:root:    +               reduce using rule 230 (primary -> parenthesized_primary .)
INFO:root:    -               reduce using rule 230 (primary -> parenthesized_primary .)
INFO:root:    &               reduce using rule 230 (primary -> parenthesized_primary .)
INFO:root:    AND             reduce using rule 230 (primary -> parenthesized_primary .)
INFO:root:    OR              reduce using rule 230 (primary -> parenthesized_primary .)
INFO:root:    XOR             reduce using rule 230 (primary -> parenthesized_primary .)
INFO:root:    ARROW           reduce using rule 230 (primary -> parenthesized_primary .)
INFO:root:    ;               reduce using rule 230 (primary -> parenthesized_primary .)
INFO:root:    )               reduce using rule 230 (primary -> parenthesized_primary .)
INFO:root:    ,               reduce using rule 230 (primary -> parenthesized_primary .)
INFO:root:    DOTDOT          reduce using rule 230 (primary -> parenthesized_primary .)
INFO:root:    WITH            reduce using rule 230 (primary -> parenthesized_primary .)
INFO:root:    |               reduce using rule 230 (primary -> parenthesized_primary .)
INFO:root:    IS              reduce using rule 230 (primary -> parenthesized_primary .)
INFO:root:    THEN            reduce using rule 230 (primary -> parenthesized_primary .)
INFO:root:    LOOP            reduce using rule 230 (primary -> parenthesized_primary .)
INFO:root:    RANGE           reduce using rule 230 (primary -> parenthesized_primary .)
INFO:root:    DIGITS          reduce using rule 230 (primary -> parenthesized_primary .)
INFO:root:    RENAMES         reduce using rule 230 (primary -> parenthesized_primary .)
INFO:root:    ASSIGN          reduce using rule 230 (primary -> parenthesized_primary .)
INFO:root:
INFO:root:
INFO:root:state 148
INFO:root:
INFO:root:    (211) unary -> + .
INFO:root:
INFO:root:    NOT             reduce using rule 211 (unary -> + .)
INFO:root:    ABS             reduce using rule 211 (unary -> + .)
INFO:root:    INT             reduce using rule 211 (unary -> + .)
INFO:root:    FLOAT           reduce using rule 211 (unary -> + .)
INFO:root:    NuLL            reduce using rule 211 (unary -> + .)
INFO:root:    NEW             reduce using rule 211 (unary -> + .)
INFO:root:    (               reduce using rule 211 (unary -> + .)
INFO:root:    IDENTIFIER      reduce using rule 211 (unary -> + .)
INFO:root:    STRING          reduce using rule 211 (unary -> + .)
INFO:root:
INFO:root:
INFO:root:state 149
INFO:root:
INFO:root:    (163) operator_symbol -> STRING .
INFO:root:
INFO:root:    (               reduce using rule 163 (operator_symbol -> STRING .)
INFO:root:    .               reduce using rule 163 (operator_symbol -> STRING .)
INFO:root:    TICK            reduce using rule 163 (operator_symbol -> STRING .)
INFO:root:    ;               reduce using rule 163 (operator_symbol -> STRING .)
INFO:root:    *               reduce using rule 163 (operator_symbol -> STRING .)
INFO:root:    /               reduce using rule 163 (operator_symbol -> STRING .)
INFO:root:    MOD             reduce using rule 163 (operator_symbol -> STRING .)
INFO:root:    REM             reduce using rule 163 (operator_symbol -> STRING .)
INFO:root:    STARSTAR        reduce using rule 163 (operator_symbol -> STRING .)
INFO:root:    =               reduce using rule 163 (operator_symbol -> STRING .)
INFO:root:    NEQ             reduce using rule 163 (operator_symbol -> STRING .)
INFO:root:    <               reduce using rule 163 (operator_symbol -> STRING .)
INFO:root:    LEQ             reduce using rule 163 (operator_symbol -> STRING .)
INFO:root:    >               reduce using rule 163 (operator_symbol -> STRING .)
INFO:root:    GEQ             reduce using rule 163 (operator_symbol -> STRING .)
INFO:root:    IN              reduce using rule 163 (operator_symbol -> STRING .)
INFO:root:    NOT             reduce using rule 163 (operator_symbol -> STRING .)
INFO:root:    +               reduce using rule 163 (operator_symbol -> STRING .)
INFO:root:    -               reduce using rule 163 (operator_symbol -> STRING .)
INFO:root:    &               reduce using rule 163 (operator_symbol -> STRING .)
INFO:root:    AND             reduce using rule 163 (operator_symbol -> STRING .)
INFO:root:    OR              reduce using rule 163 (operator_symbol -> STRING .)
INFO:root:    XOR             reduce using rule 163 (operator_symbol -> STRING .)
INFO:root:    )               reduce using rule 163 (operator_symbol -> STRING .)
INFO:root:    ,               reduce using rule 163 (operator_symbol -> STRING .)
INFO:root:    DOTDOT          reduce using rule 163 (operator_symbol -> STRING .)
INFO:root:    WITH            reduce using rule 163 (operator_symbol -> STRING .)
INFO:root:    ARROW           reduce using rule 163 (operator_symbol -> STRING .)
INFO:root:    |               reduce using rule 163 (operator_symbol -> STRING .)
INFO:root:    IS              reduce using rule 163 (operator_symbol -> STRING .)
INFO:root:    THEN            reduce using rule 163 (operator_symbol -> STRING .)
INFO:root:    LOOP            reduce using rule 163 (operator_symbol -> STRING .)
INFO:root:    RANGE           reduce using rule 163 (operator_symbol -> STRING .)
INFO:root:    DIGITS          reduce using rule 163 (operator_symbol -> STRING .)
INFO:root:    RENAMES         reduce using rule 163 (operator_symbol -> STRING .)
INFO:root:    ASSIGN          reduce using rule 163 (operator_symbol -> STRING .)
INFO:root:    WHEN            reduce using rule 163 (operator_symbol -> STRING .)
INFO:root:
INFO:root:
INFO:root:state 150
INFO:root:
INFO:root:    (304) subprog_spec -> PROCEDURE compound_name formal_part_opt .
INFO:root:
INFO:root:    ;               reduce using rule 304 (subprog_spec -> PROCEDURE compound_name formal_part_opt .)
INFO:root:    IS              reduce using rule 304 (subprog_spec -> PROCEDURE compound_name formal_part_opt .)
INFO:root:    RENAMES         reduce using rule 304 (subprog_spec -> PROCEDURE compound_name formal_part_opt .)
INFO:root:
INFO:root:
INFO:root:state 151
INFO:root:
INFO:root:    (311) formal_part -> ( . param_s )
INFO:root:    (312) param_s -> . param
INFO:root:    (313) param_s -> . param_s ; param
INFO:root:    (314) param -> . def_id_s : mode mark init_opt
INFO:root:    (315) param -> . error
INFO:root:    (24) def_id_s -> . def_id
INFO:root:    (25) def_id_s -> . def_id_s , def_id
INFO:root:    (26) def_id -> . IDENTIFIER
INFO:root:
INFO:root:    error           shift and go to state 55
INFO:root:    IDENTIFIER      shift and go to state 52
INFO:root:
INFO:root:    def_id_s                       shift and go to state 56
INFO:root:    param_s                        shift and go to state 247
INFO:root:    def_id                         shift and go to state 57
INFO:root:    param                          shift and go to state 248
INFO:root:
INFO:root:state 152
INFO:root:
INFO:root:    (310) formal_part_opt -> formal_part .
INFO:root:
INFO:root:    WHEN            reduce using rule 310 (formal_part_opt -> formal_part .)
INFO:root:    ;               reduce using rule 310 (formal_part_opt -> formal_part .)
INFO:root:    DO              reduce using rule 310 (formal_part_opt -> formal_part .)
INFO:root:    RETURN          reduce using rule 310 (formal_part_opt -> formal_part .)
INFO:root:    IS              reduce using rule 310 (formal_part_opt -> formal_part .)
INFO:root:    RENAMES         reduce using rule 310 (formal_part_opt -> formal_part .)
INFO:root:
INFO:root:
INFO:root:state 153
INFO:root:
INFO:root:    (465) generic_formal -> WITH FUNCTION . designator formal_part_opt RETURN name subp_default ;
INFO:root:    (307) designator -> . compound_name
INFO:root:    (308) designator -> . STRING
INFO:root:    (158) compound_name -> . simple_name
INFO:root:    (159) compound_name -> . compound_name . simple_name
INFO:root:    (157) simple_name -> . IDENTIFIER
INFO:root:
INFO:root:    STRING          shift and go to state 62
INFO:root:    IDENTIFIER      shift and go to state 33
INFO:root:
INFO:root:    designator                     shift and go to state 249
INFO:root:    simple_name                    shift and go to state 34
INFO:root:    compound_name                  shift and go to state 64
INFO:root:
INFO:root:state 154
INFO:root:
INFO:root:    (464) generic_formal -> WITH PROCEDURE . simple_name formal_part_opt subp_default ;
INFO:root:    (157) simple_name -> . IDENTIFIER
INFO:root:
INFO:root:    IDENTIFIER      shift and go to state 33
INFO:root:
INFO:root:    simple_name                    shift and go to state 250
INFO:root:
INFO:root:state 155
INFO:root:
INFO:root:    (466) generic_formal -> WITH PACKAGE . simple_name IS NEW name ( BOX ) ;
INFO:root:    (467) generic_formal -> WITH PACKAGE . simple_name IS NEW name ;
INFO:root:    (157) simple_name -> . IDENTIFIER
INFO:root:
INFO:root:    IDENTIFIER      shift and go to state 33
INFO:root:
INFO:root:    simple_name                    shift and go to state 251
INFO:root:
INFO:root:state 156
INFO:root:
INFO:root:    (346) rename_unit -> generic_formal_part PACKAGE compound_name . renames ;
INFO:root:    (326) pkg_spec -> PACKAGE compound_name . IS decl_item_s private_part END c_id_opt
INFO:root:    (159) compound_name -> compound_name . . simple_name
INFO:root:    (348) renames -> . RENAMES name
INFO:root:
INFO:root:    IS              shift and go to state 253
INFO:root:    .               shift and go to state 116
INFO:root:    RENAMES         shift and go to state 66
INFO:root:
INFO:root:    renames                        shift and go to state 252
INFO:root:
INFO:root:state 157
INFO:root:
INFO:root:    (463) generic_formal -> TYPE simple_name . generic_discrim_part_opt IS generic_type_def ;
INFO:root:    (469) generic_discrim_part_opt -> .
INFO:root:    (470) generic_discrim_part_opt -> . discrim_part
INFO:root:    (471) generic_discrim_part_opt -> . ( BOX )
INFO:root:    (110) discrim_part -> . ( discrim_spec_s )
INFO:root:
INFO:root:    IS              reduce using rule 469 (generic_discrim_part_opt -> .)
INFO:root:    (               shift and go to state 254
INFO:root:
INFO:root:    discrim_part                   shift and go to state 255
INFO:root:    generic_discrim_part_opt       shift and go to state 256
INFO:root:
INFO:root:state 158
INFO:root:
INFO:root:    (347) rename_unit -> generic_formal_part subprog_spec renames . ;
INFO:root:
INFO:root:    ;               shift and go to state 257
INFO:root:
INFO:root:
INFO:root:state 159
INFO:root:
INFO:root:    (458) generic_decl -> generic_formal_part subprog_spec ; .
INFO:root:
INFO:root:    PACKAGE         reduce using rule 458 (generic_decl -> generic_formal_part subprog_spec ; .)
INFO:root:    TASK            reduce using rule 458 (generic_decl -> generic_formal_part subprog_spec ; .)
INFO:root:    PROTECTED       reduce using rule 458 (generic_decl -> generic_formal_part subprog_spec ; .)
INFO:root:    error           reduce using rule 458 (generic_decl -> generic_formal_part subprog_spec ; .)
INFO:root:    USE             reduce using rule 458 (generic_decl -> generic_formal_part subprog_spec ; .)
INFO:root:    PRAGMA          reduce using rule 458 (generic_decl -> generic_formal_part subprog_spec ; .)
INFO:root:    TYPE            reduce using rule 458 (generic_decl -> generic_formal_part subprog_spec ; .)
INFO:root:    SUBTYPE         reduce using rule 458 (generic_decl -> generic_formal_part subprog_spec ; .)
INFO:root:    FOR             reduce using rule 458 (generic_decl -> generic_formal_part subprog_spec ; .)
INFO:root:    PROCEDURE       reduce using rule 458 (generic_decl -> generic_formal_part subprog_spec ; .)
INFO:root:    FUNCTION        reduce using rule 458 (generic_decl -> generic_formal_part subprog_spec ; .)
INFO:root:    GENERIC         reduce using rule 458 (generic_decl -> generic_formal_part subprog_spec ; .)
INFO:root:    IDENTIFIER      reduce using rule 458 (generic_decl -> generic_formal_part subprog_spec ; .)
INFO:root:    BEGIN           reduce using rule 458 (generic_decl -> generic_formal_part subprog_spec ; .)
INFO:root:    END             reduce using rule 458 (generic_decl -> generic_formal_part subprog_spec ; .)
INFO:root:    PRIVATE         reduce using rule 458 (generic_decl -> generic_formal_part subprog_spec ; .)
INFO:root:    WITH            reduce using rule 458 (generic_decl -> generic_formal_part subprog_spec ; .)
INFO:root:    SEPARATE        reduce using rule 458 (generic_decl -> generic_formal_part subprog_spec ; .)
INFO:root:    $end            reduce using rule 458 (generic_decl -> generic_formal_part subprog_spec ; .)
INFO:root:
INFO:root:
INFO:root:state 160
INFO:root:
INFO:root:    (337) use_clause -> USE name_s . ;
INFO:root:    (340) name_s -> name_s . , name
INFO:root:
INFO:root:    ;               shift and go to state 259
INFO:root:    ,               shift and go to state 258
INFO:root:
INFO:root:
INFO:root:state 161
INFO:root:
INFO:root:    (339) name_s -> name .
INFO:root:    (164) indexed_comp -> name . ( value_s )
INFO:root:    (171) selected_comp -> name . . simple_name
INFO:root:    (172) selected_comp -> name . . used_char
INFO:root:    (173) selected_comp -> name . . operator_symbol
INFO:root:    (174) selected_comp -> name . . ALL
INFO:root:    (175) attribute -> name . TICK attribute_id
INFO:root:
INFO:root:    ;               reduce using rule 339 (name_s -> name .)
INFO:root:    ,               reduce using rule 339 (name_s -> name .)
INFO:root:    (               shift and go to state 237
INFO:root:    .               shift and go to state 239
INFO:root:    TICK            shift and go to state 260
INFO:root:
INFO:root:
INFO:root:state 162
INFO:root:
INFO:root:    (338) use_clause -> USE TYPE . name_s ;
INFO:root:    (339) name_s -> . name
INFO:root:    (340) name_s -> . name_s , name
INFO:root:    (149) name -> . simple_name
INFO:root:    (150) name -> . indexed_comp
INFO:root:    (151) name -> . selected_comp
INFO:root:    (152) name -> . attribute
INFO:root:    (153) name -> . operator_symbol
INFO:root:    (157) simple_name -> . IDENTIFIER
INFO:root:    (164) indexed_comp -> . name ( value_s )
INFO:root:    (171) selected_comp -> . name . simple_name
INFO:root:    (172) selected_comp -> . name . used_char
INFO:root:    (173) selected_comp -> . name . operator_symbol
INFO:root:    (174) selected_comp -> . name . ALL
INFO:root:    (175) attribute -> . name TICK attribute_id
INFO:root:    (163) operator_symbol -> . STRING
INFO:root:
INFO:root:    IDENTIFIER      shift and go to state 33
INFO:root:    STRING          shift and go to state 149
INFO:root:
INFO:root:    selected_comp                  shift and go to state 139
INFO:root:    simple_name                    shift and go to state 163
INFO:root:    indexed_comp                   shift and go to state 140
INFO:root:    attribute                      shift and go to state 134
INFO:root:    name                           shift and go to state 161
INFO:root:    name_s                         shift and go to state 261
INFO:root:    operator_symbol                shift and go to state 133
INFO:root:
INFO:root:state 163
INFO:root:
INFO:root:    (149) name -> simple_name .
INFO:root:
INFO:root:    ASSIGN          reduce using rule 149 (name -> simple_name .)
INFO:root:    ;               reduce using rule 149 (name -> simple_name .)
INFO:root:    TICK            reduce using rule 149 (name -> simple_name .)
INFO:root:    (               reduce using rule 149 (name -> simple_name .)
INFO:root:    .               reduce using rule 149 (name -> simple_name .)
INFO:root:    ,               reduce using rule 149 (name -> simple_name .)
INFO:root:    ARROW           reduce using rule 149 (name -> simple_name .)
INFO:root:    |               reduce using rule 149 (name -> simple_name .)
INFO:root:    *               reduce using rule 149 (name -> simple_name .)
INFO:root:    /               reduce using rule 149 (name -> simple_name .)
INFO:root:    MOD             reduce using rule 149 (name -> simple_name .)
INFO:root:    REM             reduce using rule 149 (name -> simple_name .)
INFO:root:    STARSTAR        reduce using rule 149 (name -> simple_name .)
INFO:root:    +               reduce using rule 149 (name -> simple_name .)
INFO:root:    -               reduce using rule 149 (name -> simple_name .)
INFO:root:    &               reduce using rule 149 (name -> simple_name .)
INFO:root:    AND             reduce using rule 149 (name -> simple_name .)
INFO:root:    OR              reduce using rule 149 (name -> simple_name .)
INFO:root:    XOR             reduce using rule 149 (name -> simple_name .)
INFO:root:    )               reduce using rule 149 (name -> simple_name .)
INFO:root:    WITH            reduce using rule 149 (name -> simple_name .)
INFO:root:    IS              reduce using rule 149 (name -> simple_name .)
INFO:root:    THEN            reduce using rule 149 (name -> simple_name .)
INFO:root:    LOOP            reduce using rule 149 (name -> simple_name .)
INFO:root:    RANGE           reduce using rule 149 (name -> simple_name .)
INFO:root:    DIGITS          reduce using rule 149 (name -> simple_name .)
INFO:root:    RENAMES         reduce using rule 149 (name -> simple_name .)
INFO:root:    DOTDOT          reduce using rule 149 (name -> simple_name .)
INFO:root:    =               reduce using rule 149 (name -> simple_name .)
INFO:root:    NEQ             reduce using rule 149 (name -> simple_name .)
INFO:root:    <               reduce using rule 149 (name -> simple_name .)
INFO:root:    LEQ             reduce using rule 149 (name -> simple_name .)
INFO:root:    >               reduce using rule 149 (name -> simple_name .)
INFO:root:    GEQ             reduce using rule 149 (name -> simple_name .)
INFO:root:    IN              reduce using rule 149 (name -> simple_name .)
INFO:root:    NOT             reduce using rule 149 (name -> simple_name .)
INFO:root:    WHEN            reduce using rule 149 (name -> simple_name .)
INFO:root:
INFO:root:
INFO:root:state 164
INFO:root:
INFO:root:    (459) generic_decl -> generic_formal_part pkg_spec ; .
INFO:root:
INFO:root:    PACKAGE         reduce using rule 459 (generic_decl -> generic_formal_part pkg_spec ; .)
INFO:root:    TASK            reduce using rule 459 (generic_decl -> generic_formal_part pkg_spec ; .)
INFO:root:    PROTECTED       reduce using rule 459 (generic_decl -> generic_formal_part pkg_spec ; .)
INFO:root:    error           reduce using rule 459 (generic_decl -> generic_formal_part pkg_spec ; .)
INFO:root:    USE             reduce using rule 459 (generic_decl -> generic_formal_part pkg_spec ; .)
INFO:root:    PRAGMA          reduce using rule 459 (generic_decl -> generic_formal_part pkg_spec ; .)
INFO:root:    TYPE            reduce using rule 459 (generic_decl -> generic_formal_part pkg_spec ; .)
INFO:root:    SUBTYPE         reduce using rule 459 (generic_decl -> generic_formal_part pkg_spec ; .)
INFO:root:    FOR             reduce using rule 459 (generic_decl -> generic_formal_part pkg_spec ; .)
INFO:root:    PROCEDURE       reduce using rule 459 (generic_decl -> generic_formal_part pkg_spec ; .)
INFO:root:    FUNCTION        reduce using rule 459 (generic_decl -> generic_formal_part pkg_spec ; .)
INFO:root:    GENERIC         reduce using rule 459 (generic_decl -> generic_formal_part pkg_spec ; .)
INFO:root:    IDENTIFIER      reduce using rule 459 (generic_decl -> generic_formal_part pkg_spec ; .)
INFO:root:    BEGIN           reduce using rule 459 (generic_decl -> generic_formal_part pkg_spec ; .)
INFO:root:    END             reduce using rule 459 (generic_decl -> generic_formal_part pkg_spec ; .)
INFO:root:    PRIVATE         reduce using rule 459 (generic_decl -> generic_formal_part pkg_spec ; .)
INFO:root:    WITH            reduce using rule 459 (generic_decl -> generic_formal_part pkg_spec ; .)
INFO:root:    SEPARATE        reduce using rule 459 (generic_decl -> generic_formal_part pkg_spec ; .)
INFO:root:    $end            reduce using rule 459 (generic_decl -> generic_formal_part pkg_spec ; .)
INFO:root:
INFO:root:
INFO:root:state 165
INFO:root:
INFO:root:    (25) def_id_s -> def_id_s , . def_id
INFO:root:    (26) def_id -> . IDENTIFIER
INFO:root:
INFO:root:    IDENTIFIER      shift and go to state 52
INFO:root:
INFO:root:    def_id                         shift and go to state 262
INFO:root:
INFO:root:state 166
INFO:root:
INFO:root:    (314) param -> def_id_s : . mode mark init_opt
INFO:root:    (316) mode -> .
INFO:root:    (317) mode -> . IN
INFO:root:    (318) mode -> . OUT
INFO:root:    (319) mode -> . IN OUT
INFO:root:    (320) mode -> . ACCESS
INFO:root:
INFO:root:    IDENTIFIER      reduce using rule 316 (mode -> .)
INFO:root:    IN              shift and go to state 265
INFO:root:    OUT             shift and go to state 266
INFO:root:    ACCESS          shift and go to state 263
INFO:root:
INFO:root:    mode                           shift and go to state 264
INFO:root:
INFO:root:state 167
INFO:root:
INFO:root:    (462) generic_formal -> param ; .
INFO:root:
INFO:root:    PACKAGE         reduce using rule 462 (generic_formal -> param ; .)
INFO:root:    PROCEDURE       reduce using rule 462 (generic_formal -> param ; .)
INFO:root:    FUNCTION        reduce using rule 462 (generic_formal -> param ; .)
INFO:root:    TYPE            reduce using rule 462 (generic_formal -> param ; .)
INFO:root:    WITH            reduce using rule 462 (generic_formal -> param ; .)
INFO:root:    error           reduce using rule 462 (generic_formal -> param ; .)
INFO:root:    USE             reduce using rule 462 (generic_formal -> param ; .)
INFO:root:    IDENTIFIER      reduce using rule 462 (generic_formal -> param ; .)
INFO:root:
INFO:root:
INFO:root:state 168
INFO:root:
INFO:root:    (437) subunit -> SEPARATE ( compound_name . ) subunit_body
INFO:root:    (159) compound_name -> compound_name . . simple_name
INFO:root:
INFO:root:    )               shift and go to state 267
INFO:root:    .               shift and go to state 116
INFO:root:
INFO:root:
INFO:root:state 169
INFO:root:
INFO:root:    (305) subprog_spec -> FUNCTION designator formal_part_opt . RETURN name
INFO:root:
INFO:root:    RETURN          shift and go to state 268
INFO:root:
INFO:root:
INFO:root:state 170
INFO:root:
INFO:root:    (348) renames -> RENAMES name .
INFO:root:    (164) indexed_comp -> name . ( value_s )
INFO:root:    (171) selected_comp -> name . . simple_name
INFO:root:    (172) selected_comp -> name . . used_char
INFO:root:    (173) selected_comp -> name . . operator_symbol
INFO:root:    (174) selected_comp -> name . . ALL
INFO:root:    (175) attribute -> name . TICK attribute_id
INFO:root:
INFO:root:    ;               reduce using rule 348 (renames -> RENAMES name .)
INFO:root:    (               shift and go to state 237
INFO:root:    .               shift and go to state 239
INFO:root:    TICK            shift and go to state 260
INFO:root:
INFO:root:
INFO:root:state 171
INFO:root:
INFO:root:    (345) rename_unit -> subprog_spec renames ; .
INFO:root:
INFO:root:    error           reduce using rule 345 (rename_unit -> subprog_spec renames ; .)
INFO:root:    USE             reduce using rule 345 (rename_unit -> subprog_spec renames ; .)
INFO:root:    PRAGMA          reduce using rule 345 (rename_unit -> subprog_spec renames ; .)
INFO:root:    TYPE            reduce using rule 345 (rename_unit -> subprog_spec renames ; .)
INFO:root:    SUBTYPE         reduce using rule 345 (rename_unit -> subprog_spec renames ; .)
INFO:root:    TASK            reduce using rule 345 (rename_unit -> subprog_spec renames ; .)
INFO:root:    PACKAGE         reduce using rule 345 (rename_unit -> subprog_spec renames ; .)
INFO:root:    PROTECTED       reduce using rule 345 (rename_unit -> subprog_spec renames ; .)
INFO:root:    FOR             reduce using rule 345 (rename_unit -> subprog_spec renames ; .)
INFO:root:    PROCEDURE       reduce using rule 345 (rename_unit -> subprog_spec renames ; .)
INFO:root:    FUNCTION        reduce using rule 345 (rename_unit -> subprog_spec renames ; .)
INFO:root:    GENERIC         reduce using rule 345 (rename_unit -> subprog_spec renames ; .)
INFO:root:    IDENTIFIER      reduce using rule 345 (rename_unit -> subprog_spec renames ; .)
INFO:root:    END             reduce using rule 345 (rename_unit -> subprog_spec renames ; .)
INFO:root:    BEGIN           reduce using rule 345 (rename_unit -> subprog_spec renames ; .)
INFO:root:    PRIVATE         reduce using rule 345 (rename_unit -> subprog_spec renames ; .)
INFO:root:    WITH            reduce using rule 345 (rename_unit -> subprog_spec renames ; .)
INFO:root:    SEPARATE        reduce using rule 345 (rename_unit -> subprog_spec renames ; .)
INFO:root:    $end            reduce using rule 345 (rename_unit -> subprog_spec renames ; .)
INFO:root:
INFO:root:
INFO:root:state 172
INFO:root:
INFO:root:    (488) generic_subp_inst -> subprog_spec IS generic_inst .
INFO:root:
INFO:root:    ;               reduce using rule 488 (generic_subp_inst -> subprog_spec IS generic_inst .)
INFO:root:
INFO:root:
INFO:root:state 173
INFO:root:
INFO:root:    (490) generic_inst -> NEW . name
INFO:root:    (149) name -> . simple_name
INFO:root:    (150) name -> . indexed_comp
INFO:root:    (151) name -> . selected_comp
INFO:root:    (152) name -> . attribute
INFO:root:    (153) name -> . operator_symbol
INFO:root:    (157) simple_name -> . IDENTIFIER
INFO:root:    (164) indexed_comp -> . name ( value_s )
INFO:root:    (171) selected_comp -> . name . simple_name
INFO:root:    (172) selected_comp -> . name . used_char
INFO:root:    (173) selected_comp -> . name . operator_symbol
INFO:root:    (174) selected_comp -> . name . ALL
INFO:root:    (175) attribute -> . name TICK attribute_id
INFO:root:    (163) operator_symbol -> . STRING
INFO:root:
INFO:root:    IDENTIFIER      shift and go to state 33
INFO:root:    STRING          shift and go to state 149
INFO:root:
INFO:root:    selected_comp                  shift and go to state 139
INFO:root:    simple_name                    shift and go to state 163
INFO:root:    indexed_comp                   shift and go to state 140
INFO:root:    attribute                      shift and go to state 134
INFO:root:    name                           shift and go to state 269
INFO:root:    operator_symbol                shift and go to state 133
INFO:root:
INFO:root:state 174
INFO:root:
INFO:root:    (344) rename_unit -> PACKAGE compound_name renames . ;
INFO:root:
INFO:root:    ;               shift and go to state 270
INFO:root:
INFO:root:
INFO:root:state 175
INFO:root:
INFO:root:    (326) pkg_spec -> PACKAGE compound_name IS . decl_item_s private_part END c_id_opt
INFO:root:    (489) generic_pkg_inst -> PACKAGE compound_name IS . generic_inst
INFO:root:    (133) decl_item_s -> .
INFO:root:    (134) decl_item_s -> . decl_item_s1
INFO:root:    (490) generic_inst -> . NEW name
INFO:root:    (135) decl_item_s1 -> . decl_item
INFO:root:    (136) decl_item_s1 -> . decl_item_s1 decl_item
INFO:root:    (137) decl_item -> . decl
INFO:root:    (138) decl_item -> . use_clause
INFO:root:    (139) decl_item -> . rep_spec
INFO:root:    (140) decl_item -> . pragma
INFO:root:    (10) decl -> . object_decl
INFO:root:    (11) decl -> . number_decl
INFO:root:    (12) decl -> . type_decl
INFO:root:    (13) decl -> . subtype_decl
INFO:root:    (14) decl -> . subprog_decl
INFO:root:    (15) decl -> . pkg_decl
INFO:root:    (16) decl -> . task_decl
INFO:root:    (17) decl -> . prot_decl
INFO:root:    (18) decl -> . exception_decl
INFO:root:    (19) decl -> . rename_decl
INFO:root:    (20) decl -> . generic_decl
INFO:root:    (21) decl -> . body_stub
INFO:root:    (22) decl -> . error ;
INFO:root:    (337) use_clause -> . USE name_s ;
INFO:root:    (338) use_clause -> . USE TYPE name_s ;
INFO:root:    (491) rep_spec -> . attrib_def
INFO:root:    (492) rep_spec -> . record_type_spec
INFO:root:    (493) rep_spec -> . address_spec
INFO:root:    (2) pragma -> . PRAGMA IDENTIFIER ;
INFO:root:    (3) pragma -> . PRAGMA simple_name ( pragma_arg_s ) ;
INFO:root:    (23) object_decl -> . def_id_s : object_qualifier_opt object_subtype_def init_opt ;
INFO:root:    (35) number_decl -> . def_id_s : CONSTANT ASSIGN expression ;
INFO:root:    (36) type_decl -> . TYPE IDENTIFIER discrim_part_opt type_completion ;
INFO:root:    (50) subtype_decl -> . SUBTYPE IDENTIFIER IS subtype_ind ;
INFO:root:    (301) subprog_decl -> . subprog_spec ;
INFO:root:    (302) subprog_decl -> . generic_subp_inst ;
INFO:root:    (303) subprog_decl -> . subprog_spec_is_push ABSTRACT ;
INFO:root:    (324) pkg_decl -> . pkg_spec ;
INFO:root:    (325) pkg_decl -> . generic_pkg_inst ;
INFO:root:    (349) task_decl -> . task_spec ;
INFO:root:    (357) prot_decl -> . prot_spec ;
INFO:root:    (446) exception_decl -> . def_id_s : EXCEPTION ;
INFO:root:    (341) rename_decl -> . def_id_s : object_qualifier_opt subtype_ind renames ;
INFO:root:    (342) rename_decl -> . def_id_s : EXCEPTION renames ;
INFO:root:    (343) rename_decl -> . rename_unit
INFO:root:    (458) generic_decl -> . generic_formal_part subprog_spec ;
INFO:root:    (459) generic_decl -> . generic_formal_part pkg_spec ;
INFO:root:    (442) body_stub -> . TASK BODY simple_name IS SEPARATE ;
INFO:root:    (443) body_stub -> . PACKAGE BODY compound_name IS SEPARATE ;
INFO:root:    (444) body_stub -> . subprog_spec IS SEPARATE ;
INFO:root:    (445) body_stub -> . PROTECTED BODY simple_name IS SEPARATE ;
INFO:root:    (494) attrib_def -> . FOR mark USE expression ;
INFO:root:    (495) record_type_spec -> . FOR mark USE RECORD align_opt comp_loc_s END RECORD ;
INFO:root:    (500) address_spec -> . FOR mark USE AT expression ;
INFO:root:    (24) def_id_s -> . def_id
INFO:root:    (25) def_id_s -> . def_id_s , def_id
INFO:root:    (304) subprog_spec -> . PROCEDURE compound_name formal_part_opt
INFO:root:    (305) subprog_spec -> . FUNCTION designator formal_part_opt RETURN name
INFO:root:    (306) subprog_spec -> . FUNCTION designator
INFO:root:    (488) generic_subp_inst -> . subprog_spec IS generic_inst
INFO:root:    (321) subprog_spec_is_push -> . subprog_spec IS
INFO:root:    (326) pkg_spec -> . PACKAGE compound_name IS decl_item_s private_part END c_id_opt
INFO:root:    (489) generic_pkg_inst -> . PACKAGE compound_name IS generic_inst
INFO:root:    (350) task_spec -> . TASK simple_name task_def
INFO:root:    (351) task_spec -> . TASK TYPE simple_name discrim_part_opt task_def
INFO:root:    (358) prot_spec -> . PROTECTED IDENTIFIER prot_def
INFO:root:    (359) prot_spec -> . PROTECTED TYPE simple_name discrim_part_opt prot_def
INFO:root:    (344) rename_unit -> . PACKAGE compound_name renames ;
INFO:root:    (345) rename_unit -> . subprog_spec renames ;
INFO:root:    (346) rename_unit -> . generic_formal_part PACKAGE compound_name renames ;
INFO:root:    (347) rename_unit -> . generic_formal_part subprog_spec renames ;
INFO:root:    (460) generic_formal_part -> . GENERIC
INFO:root:    (461) generic_formal_part -> . generic_formal_part generic_formal
INFO:root:    (26) def_id -> . IDENTIFIER
INFO:root:
INFO:root:    PRIVATE         reduce using rule 133 (decl_item_s -> .)
INFO:root:    END             reduce using rule 133 (decl_item_s -> .)
INFO:root:    NEW             shift and go to state 173
INFO:root:    error           shift and go to state 107
INFO:root:    USE             shift and go to state 53
INFO:root:    PRAGMA          shift and go to state 2
INFO:root:    TYPE            shift and go to state 74
INFO:root:    SUBTYPE         shift and go to state 110
INFO:root:    TASK            shift and go to state 275
INFO:root:    PACKAGE         shift and go to state 271
INFO:root:    PROTECTED       shift and go to state 277
INFO:root:    FOR             shift and go to state 102
INFO:root:    PROCEDURE       shift and go to state 17
INFO:root:    FUNCTION        shift and go to state 23
INFO:root:    GENERIC         shift and go to state 26
INFO:root:    IDENTIFIER      shift and go to state 52
INFO:root:
INFO:root:    generic_formal_part            shift and go to state 20
INFO:root:    generic_inst                   shift and go to state 274
INFO:root:    pkg_decl                       shift and go to state 93
INFO:root:    pragma                         shift and go to state 94
INFO:root:    prot_decl                      shift and go to state 95
INFO:root:    task_decl                      shift and go to state 76
INFO:root:    generic_decl                   shift and go to state 88
INFO:root:    subprog_decl                   shift and go to state 77
INFO:root:    type_decl                      shift and go to state 81
INFO:root:    def_id_s                       shift and go to state 79
INFO:root:    generic_pkg_inst               shift and go to state 19
INFO:root:    def_id                         shift and go to state 57
INFO:root:    rep_spec                       shift and go to state 72
INFO:root:    use_clause                     shift and go to state 97
INFO:root:    decl_item_s1                   shift and go to state 276
INFO:root:    rename_decl                    shift and go to state 98
INFO:root:    body_stub                      shift and go to state 80
INFO:root:    address_spec                   shift and go to state 83
INFO:root:    task_spec                      shift and go to state 82
INFO:root:    exception_decl                 shift and go to state 91
INFO:root:    number_decl                    shift and go to state 101
INFO:root:    generic_subp_inst              shift and go to state 24
INFO:root:    decl_item_s                    shift and go to state 278
INFO:root:    prot_spec                      shift and go to state 85
INFO:root:    rename_unit                    shift and go to state 104
INFO:root:    subprog_spec                   shift and go to state 273
INFO:root:    object_decl                    shift and go to state 87
INFO:root:    subtype_decl                   shift and go to state 105
INFO:root:    pkg_spec                       shift and go to state 16
INFO:root:    record_type_spec               shift and go to state 108
INFO:root:    decl                           shift and go to state 109
INFO:root:    decl_item                      shift and go to state 272
INFO:root:    attrib_def                     shift and go to state 92
INFO:root:    subprog_spec_is_push           shift and go to state 279
INFO:root:
INFO:root:state 176
INFO:root:
INFO:root:    (331) pkg_body -> PACKAGE BODY compound_name . IS decl_part body_opt END c_id_opt ;
INFO:root:    (159) compound_name -> compound_name . . simple_name
INFO:root:
INFO:root:    IS              shift and go to state 280
INFO:root:    .               shift and go to state 116
INFO:root:
INFO:root:
INFO:root:state 177
INFO:root:
INFO:root:    (326) pkg_spec -> PACKAGE compound_name . IS decl_item_s private_part END c_id_opt
INFO:root:    (489) generic_pkg_inst -> PACKAGE compound_name . IS generic_inst
INFO:root:    (344) rename_unit -> PACKAGE compound_name . renames ;
INFO:root:    (159) compound_name -> compound_name . . simple_name
INFO:root:    (348) renames -> . RENAMES name
INFO:root:
INFO:root:    IS              shift and go to state 175
INFO:root:    .               shift and go to state 116
INFO:root:    RENAMES         shift and go to state 66
INFO:root:
INFO:root:    renames                        shift and go to state 174
INFO:root:
INFO:root:state 178
INFO:root:
INFO:root:    (331) pkg_body -> PACKAGE BODY . compound_name IS decl_part body_opt END c_id_opt ;
INFO:root:    (443) body_stub -> PACKAGE BODY . compound_name IS SEPARATE ;
INFO:root:    (158) compound_name -> . simple_name
INFO:root:    (159) compound_name -> . compound_name . simple_name
INFO:root:    (157) simple_name -> . IDENTIFIER
INFO:root:
INFO:root:    IDENTIFIER      shift and go to state 33
INFO:root:
INFO:root:    simple_name                    shift and go to state 34
INFO:root:    compound_name                  shift and go to state 281
INFO:root:
INFO:root:state 179
INFO:root:
INFO:root:    (36) type_decl -> TYPE IDENTIFIER . discrim_part_opt type_completion ;
INFO:root:    (37) discrim_part_opt -> .
INFO:root:    (38) discrim_part_opt -> . discrim_part
INFO:root:    (39) discrim_part_opt -> . ( BOX )
INFO:root:    (110) discrim_part -> . ( discrim_spec_s )
INFO:root:
INFO:root:    IS              reduce using rule 37 (discrim_part_opt -> .)
INFO:root:    ;               reduce using rule 37 (discrim_part_opt -> .)
INFO:root:    (               shift and go to state 283
INFO:root:
INFO:root:    discrim_part_opt               shift and go to state 282
INFO:root:    discrim_part                   shift and go to state 284
INFO:root:
INFO:root:state 180
INFO:root:
INFO:root:    (23) object_decl -> def_id_s : . object_qualifier_opt object_subtype_def init_opt ;
INFO:root:    (35) number_decl -> def_id_s : . CONSTANT ASSIGN expression ;
INFO:root:    (446) exception_decl -> def_id_s : . EXCEPTION ;
INFO:root:    (341) rename_decl -> def_id_s : . object_qualifier_opt subtype_ind renames ;
INFO:root:    (342) rename_decl -> def_id_s : . EXCEPTION renames ;
INFO:root:    (27) object_qualifier_opt -> .
INFO:root:    (28) object_qualifier_opt -> . ALIASED
INFO:root:    (29) object_qualifier_opt -> . CONSTANT
INFO:root:    (30) object_qualifier_opt -> . ALIASED CONSTANT
INFO:root:
INFO:root:    CONSTANT        shift and go to state 286
INFO:root:    EXCEPTION       shift and go to state 287
INFO:root:    ARRAY           reduce using rule 27 (object_qualifier_opt -> .)
INFO:root:    IDENTIFIER      reduce using rule 27 (object_qualifier_opt -> .)
INFO:root:    STRING          reduce using rule 27 (object_qualifier_opt -> .)
INFO:root:    ALIASED         shift and go to state 288
INFO:root:
INFO:root:    object_qualifier_opt           shift and go to state 285
INFO:root:
INFO:root:state 181
INFO:root:
INFO:root:    (349) task_decl -> task_spec ; .
INFO:root:
INFO:root:    PACKAGE         reduce using rule 349 (task_decl -> task_spec ; .)
INFO:root:    TASK            reduce using rule 349 (task_decl -> task_spec ; .)
INFO:root:    PROTECTED       reduce using rule 349 (task_decl -> task_spec ; .)
INFO:root:    error           reduce using rule 349 (task_decl -> task_spec ; .)
INFO:root:    USE             reduce using rule 349 (task_decl -> task_spec ; .)
INFO:root:    PRAGMA          reduce using rule 349 (task_decl -> task_spec ; .)
INFO:root:    TYPE            reduce using rule 349 (task_decl -> task_spec ; .)
INFO:root:    SUBTYPE         reduce using rule 349 (task_decl -> task_spec ; .)
INFO:root:    FOR             reduce using rule 349 (task_decl -> task_spec ; .)
INFO:root:    PROCEDURE       reduce using rule 349 (task_decl -> task_spec ; .)
INFO:root:    FUNCTION        reduce using rule 349 (task_decl -> task_spec ; .)
INFO:root:    GENERIC         reduce using rule 349 (task_decl -> task_spec ; .)
INFO:root:    IDENTIFIER      reduce using rule 349 (task_decl -> task_spec ; .)
INFO:root:    BEGIN           reduce using rule 349 (task_decl -> task_spec ; .)
INFO:root:    END             reduce using rule 349 (task_decl -> task_spec ; .)
INFO:root:    PRIVATE         reduce using rule 349 (task_decl -> task_spec ; .)
INFO:root:
INFO:root:
INFO:root:state 182
INFO:root:
INFO:root:    (351) task_spec -> TASK TYPE . simple_name discrim_part_opt task_def
INFO:root:    (157) simple_name -> . IDENTIFIER
INFO:root:
INFO:root:    IDENTIFIER      shift and go to state 33
INFO:root:
INFO:root:    simple_name                    shift and go to state 289
INFO:root:
INFO:root:state 183
INFO:root:
INFO:root:    (356) task_body -> TASK BODY . simple_name IS decl_part block_body END id_opt ;
INFO:root:    (442) body_stub -> TASK BODY . simple_name IS SEPARATE ;
INFO:root:    (157) simple_name -> . IDENTIFIER
INFO:root:
INFO:root:    IDENTIFIER      shift and go to state 33
INFO:root:
INFO:root:    simple_name                    shift and go to state 290
INFO:root:
INFO:root:state 184
INFO:root:
INFO:root:    (350) task_spec -> TASK simple_name . task_def
INFO:root:    (352) task_def -> .
INFO:root:    (353) task_def -> . IS entry_decl_s rep_spec_s task_private_opt END id_opt
INFO:root:
INFO:root:    ;               reduce using rule 352 (task_def -> .)
INFO:root:    IS              shift and go to state 292
INFO:root:
INFO:root:    task_def                       shift and go to state 291
INFO:root:
INFO:root:state 185
INFO:root:
INFO:root:    (357) prot_decl -> prot_spec ; .
INFO:root:
INFO:root:    PACKAGE         reduce using rule 357 (prot_decl -> prot_spec ; .)
INFO:root:    TASK            reduce using rule 357 (prot_decl -> prot_spec ; .)
INFO:root:    PROTECTED       reduce using rule 357 (prot_decl -> prot_spec ; .)
INFO:root:    error           reduce using rule 357 (prot_decl -> prot_spec ; .)
INFO:root:    USE             reduce using rule 357 (prot_decl -> prot_spec ; .)
INFO:root:    PRAGMA          reduce using rule 357 (prot_decl -> prot_spec ; .)
INFO:root:    TYPE            reduce using rule 357 (prot_decl -> prot_spec ; .)
INFO:root:    SUBTYPE         reduce using rule 357 (prot_decl -> prot_spec ; .)
INFO:root:    FOR             reduce using rule 357 (prot_decl -> prot_spec ; .)
INFO:root:    PROCEDURE       reduce using rule 357 (prot_decl -> prot_spec ; .)
INFO:root:    FUNCTION        reduce using rule 357 (prot_decl -> prot_spec ; .)
INFO:root:    GENERIC         reduce using rule 357 (prot_decl -> prot_spec ; .)
INFO:root:    IDENTIFIER      reduce using rule 357 (prot_decl -> prot_spec ; .)
INFO:root:    BEGIN           reduce using rule 357 (prot_decl -> prot_spec ; .)
INFO:root:    PRIVATE         reduce using rule 357 (prot_decl -> prot_spec ; .)
INFO:root:    END             reduce using rule 357 (prot_decl -> prot_spec ; .)
INFO:root:
INFO:root:
INFO:root:state 186
INFO:root:
INFO:root:    (321) subprog_spec_is_push -> subprog_spec IS .
INFO:root:    (444) body_stub -> subprog_spec IS . SEPARATE ;
INFO:root:    (488) generic_subp_inst -> subprog_spec IS . generic_inst
INFO:root:    (490) generic_inst -> . NEW name
INFO:root:
INFO:root:    ABSTRACT        reduce using rule 321 (subprog_spec_is_push -> subprog_spec IS .)
INFO:root:    PACKAGE         reduce using rule 321 (subprog_spec_is_push -> subprog_spec IS .)
INFO:root:    TASK            reduce using rule 321 (subprog_spec_is_push -> subprog_spec IS .)
INFO:root:    PROTECTED       reduce using rule 321 (subprog_spec_is_push -> subprog_spec IS .)
INFO:root:    error           reduce using rule 321 (subprog_spec_is_push -> subprog_spec IS .)
INFO:root:    USE             reduce using rule 321 (subprog_spec_is_push -> subprog_spec IS .)
INFO:root:    PRAGMA          reduce using rule 321 (subprog_spec_is_push -> subprog_spec IS .)
INFO:root:    TYPE            reduce using rule 321 (subprog_spec_is_push -> subprog_spec IS .)
INFO:root:    SUBTYPE         reduce using rule 321 (subprog_spec_is_push -> subprog_spec IS .)
INFO:root:    FOR             reduce using rule 321 (subprog_spec_is_push -> subprog_spec IS .)
INFO:root:    PROCEDURE       reduce using rule 321 (subprog_spec_is_push -> subprog_spec IS .)
INFO:root:    FUNCTION        reduce using rule 321 (subprog_spec_is_push -> subprog_spec IS .)
INFO:root:    GENERIC         reduce using rule 321 (subprog_spec_is_push -> subprog_spec IS .)
INFO:root:    IDENTIFIER      reduce using rule 321 (subprog_spec_is_push -> subprog_spec IS .)
INFO:root:    BEGIN           reduce using rule 321 (subprog_spec_is_push -> subprog_spec IS .)
INFO:root:    SEPARATE        shift and go to state 293
INFO:root:    NEW             shift and go to state 173
INFO:root:
INFO:root:    generic_inst                   shift and go to state 172
INFO:root:
INFO:root:state 187
INFO:root:
INFO:root:    (303) subprog_decl -> subprog_spec_is_push ABSTRACT ; .
INFO:root:
INFO:root:    PACKAGE         reduce using rule 303 (subprog_decl -> subprog_spec_is_push ABSTRACT ; .)
INFO:root:    TASK            reduce using rule 303 (subprog_decl -> subprog_spec_is_push ABSTRACT ; .)
INFO:root:    PROTECTED       reduce using rule 303 (subprog_decl -> subprog_spec_is_push ABSTRACT ; .)
INFO:root:    error           reduce using rule 303 (subprog_decl -> subprog_spec_is_push ABSTRACT ; .)
INFO:root:    USE             reduce using rule 303 (subprog_decl -> subprog_spec_is_push ABSTRACT ; .)
INFO:root:    PRAGMA          reduce using rule 303 (subprog_decl -> subprog_spec_is_push ABSTRACT ; .)
INFO:root:    TYPE            reduce using rule 303 (subprog_decl -> subprog_spec_is_push ABSTRACT ; .)
INFO:root:    SUBTYPE         reduce using rule 303 (subprog_decl -> subprog_spec_is_push ABSTRACT ; .)
INFO:root:    FOR             reduce using rule 303 (subprog_decl -> subprog_spec_is_push ABSTRACT ; .)
INFO:root:    PROCEDURE       reduce using rule 303 (subprog_decl -> subprog_spec_is_push ABSTRACT ; .)
INFO:root:    FUNCTION        reduce using rule 303 (subprog_decl -> subprog_spec_is_push ABSTRACT ; .)
INFO:root:    GENERIC         reduce using rule 303 (subprog_decl -> subprog_spec_is_push ABSTRACT ; .)
INFO:root:    IDENTIFIER      reduce using rule 303 (subprog_decl -> subprog_spec_is_push ABSTRACT ; .)
INFO:root:    BEGIN           reduce using rule 303 (subprog_decl -> subprog_spec_is_push ABSTRACT ; .)
INFO:root:    END             reduce using rule 303 (subprog_decl -> subprog_spec_is_push ABSTRACT ; .)
INFO:root:    PRIVATE         reduce using rule 303 (subprog_decl -> subprog_spec_is_push ABSTRACT ; .)
INFO:root:    WITH            reduce using rule 303 (subprog_decl -> subprog_spec_is_push ABSTRACT ; .)
INFO:root:    SEPARATE        reduce using rule 303 (subprog_decl -> subprog_spec_is_push ABSTRACT ; .)
INFO:root:    $end            reduce using rule 303 (subprog_decl -> subprog_spec_is_push ABSTRACT ; .)
INFO:root:
INFO:root:
INFO:root:state 188
INFO:root:
INFO:root:    (373) prot_body -> PROTECTED BODY . simple_name IS prot_op_body_s END id_opt ;
INFO:root:    (445) body_stub -> PROTECTED BODY . simple_name IS SEPARATE ;
INFO:root:    (157) simple_name -> . IDENTIFIER
INFO:root:
INFO:root:    IDENTIFIER      shift and go to state 33
INFO:root:
INFO:root:    simple_name                    shift and go to state 294
INFO:root:
INFO:root:state 189
INFO:root:
INFO:root:    (359) prot_spec -> PROTECTED TYPE . simple_name discrim_part_opt prot_def
INFO:root:    (157) simple_name -> . IDENTIFIER
INFO:root:
INFO:root:    IDENTIFIER      shift and go to state 33
INFO:root:
INFO:root:    simple_name                    shift and go to state 295
INFO:root:
INFO:root:state 190
INFO:root:
INFO:root:    (358) prot_spec -> PROTECTED IDENTIFIER . prot_def
INFO:root:    (360) prot_def -> . IS prot_op_decl_s prot_private_opt END id_opt
INFO:root:
INFO:root:    IS              shift and go to state 297
INFO:root:
INFO:root:    prot_def                       shift and go to state 296
INFO:root:
INFO:root:state 191
INFO:root:
INFO:root:    (494) attrib_def -> FOR mark . USE expression ;
INFO:root:    (495) record_type_spec -> FOR mark . USE RECORD align_opt comp_loc_s END RECORD ;
INFO:root:    (500) address_spec -> FOR mark . USE AT expression ;
INFO:root:    (155) mark -> mark . TICK attribute_id
INFO:root:    (156) mark -> mark . . simple_name
INFO:root:
INFO:root:    USE             shift and go to state 299
INFO:root:    TICK            shift and go to state 300
INFO:root:    .               shift and go to state 298
INFO:root:
INFO:root:
INFO:root:state 192
INFO:root:
INFO:root:    (154) mark -> simple_name .
INFO:root:
INFO:root:    USE             reduce using rule 154 (mark -> simple_name .)
INFO:root:    TICK            reduce using rule 154 (mark -> simple_name .)
INFO:root:    .               reduce using rule 154 (mark -> simple_name .)
INFO:root:    ASSIGN          reduce using rule 154 (mark -> simple_name .)
INFO:root:    )               reduce using rule 154 (mark -> simple_name .)
INFO:root:    ;               reduce using rule 154 (mark -> simple_name .)
INFO:root:    AT              reduce using rule 154 (mark -> simple_name .)
INFO:root:
INFO:root:
INFO:root:state 193
INFO:root:
INFO:root:    (142) decl_item_or_body_s1 -> decl_item_or_body_s1 decl_item_or_body .
INFO:root:
INFO:root:    PACKAGE         reduce using rule 142 (decl_item_or_body_s1 -> decl_item_or_body_s1 decl_item_or_body .)
INFO:root:    TASK            reduce using rule 142 (decl_item_or_body_s1 -> decl_item_or_body_s1 decl_item_or_body .)
INFO:root:    PROTECTED       reduce using rule 142 (decl_item_or_body_s1 -> decl_item_or_body_s1 decl_item_or_body .)
INFO:root:    error           reduce using rule 142 (decl_item_or_body_s1 -> decl_item_or_body_s1 decl_item_or_body .)
INFO:root:    USE             reduce using rule 142 (decl_item_or_body_s1 -> decl_item_or_body_s1 decl_item_or_body .)
INFO:root:    PRAGMA          reduce using rule 142 (decl_item_or_body_s1 -> decl_item_or_body_s1 decl_item_or_body .)
INFO:root:    TYPE            reduce using rule 142 (decl_item_or_body_s1 -> decl_item_or_body_s1 decl_item_or_body .)
INFO:root:    SUBTYPE         reduce using rule 142 (decl_item_or_body_s1 -> decl_item_or_body_s1 decl_item_or_body .)
INFO:root:    FOR             reduce using rule 142 (decl_item_or_body_s1 -> decl_item_or_body_s1 decl_item_or_body .)
INFO:root:    PROCEDURE       reduce using rule 142 (decl_item_or_body_s1 -> decl_item_or_body_s1 decl_item_or_body .)
INFO:root:    FUNCTION        reduce using rule 142 (decl_item_or_body_s1 -> decl_item_or_body_s1 decl_item_or_body .)
INFO:root:    GENERIC         reduce using rule 142 (decl_item_or_body_s1 -> decl_item_or_body_s1 decl_item_or_body .)
INFO:root:    IDENTIFIER      reduce using rule 142 (decl_item_or_body_s1 -> decl_item_or_body_s1 decl_item_or_body .)
INFO:root:    BEGIN           reduce using rule 142 (decl_item_or_body_s1 -> decl_item_or_body_s1 decl_item_or_body .)
INFO:root:    END             reduce using rule 142 (decl_item_or_body_s1 -> decl_item_or_body_s1 decl_item_or_body .)
INFO:root:
INFO:root:
INFO:root:state 194
INFO:root:
INFO:root:    (322) subprog_body -> subprog_spec_is_push decl_part block_body . END id_opt ;
INFO:root:
INFO:root:    END             shift and go to state 301
INFO:root:
INFO:root:
INFO:root:state 195
INFO:root:
INFO:root:    (290) block_body -> BEGIN . handled_stmt_s
INFO:root:    (291) handled_stmt_s -> . statement_s except_handler_part_opt
INFO:root:    (236) statement_s -> . statement
INFO:root:    (237) statement_s -> . statement_s statement
INFO:root:    (238) statement -> . unlabeled
INFO:root:    (239) statement -> . label statement
INFO:root:    (240) unlabeled -> . simple_stmt
INFO:root:    (241) unlabeled -> . compound_stmt
INFO:root:    (259) label -> . LL IDENTIFIER RR
INFO:root:    (242) simple_stmt -> . null_stmt
INFO:root:    (243) simple_stmt -> . assign_stmt
INFO:root:    (244) simple_stmt -> . exit_stmt
INFO:root:    (245) simple_stmt -> . return_stmt
INFO:root:    (246) simple_stmt -> . procedure_call
INFO:root:    (247) simple_stmt -> . delay_stmt
INFO:root:    (248) simple_stmt -> . abort_stmt
INFO:root:    (249) simple_stmt -> . raise_stmt
INFO:root:    (250) simple_stmt -> . code_stmt
INFO:root:    (251) simple_stmt -> . requeue_stmt
INFO:root:    (252) simple_stmt -> . error ;
INFO:root:    (253) compound_stmt -> . if_stmt
INFO:root:    (254) compound_stmt -> . case_stmt
INFO:root:    (255) compound_stmt -> . loop_stmt
INFO:root:    (256) compound_stmt -> . block
INFO:root:    (257) compound_stmt -> . accept_stmt
INFO:root:    (258) compound_stmt -> . select_stmt
INFO:root:    (260) null_stmt -> . NuLL ;
INFO:root:    (261) assign_stmt -> . name ASSIGN expression ;
INFO:root:    (294) exit_stmt -> . EXIT name_opt when_opt ;
INFO:root:    (299) return_stmt -> . RETURN ;
INFO:root:    (300) return_stmt -> . RETURN expression ;
INFO:root:    (323) procedure_call -> . name ;
INFO:root:    (395) delay_stmt -> . DELAY expression ;
INFO:root:    (396) delay_stmt -> . DELAY UNTIL expression ;
INFO:root:    (416) abort_stmt -> . ABORT name_s ;
INFO:root:    (455) raise_stmt -> . RAISE name_opt ;
INFO:root:    (501) code_stmt -> . qualified ;
INFO:root:    (456) requeue_stmt -> . REQUEUE name ;
INFO:root:    (457) requeue_stmt -> . REQUEUE name WITH ABORT ;
INFO:root:    (262) if_stmt -> . IF cond_clause_s else_opt END IF ;
INFO:root:    (270) case_stmt -> . case_hdr pragma_s alternative_s END CASE ;
INFO:root:    (275) loop_stmt -> . label_opt iteration basic_loop id_opt ;
INFO:root:    (287) block -> . label_opt block_decl block_body END id_opt ;
INFO:root:    (390) accept_stmt -> . accept_hdr ;
INFO:root:    (391) accept_stmt -> . accept_hdr DO handled_stmt_s END id_opt ;
INFO:root:    (397) select_stmt -> . select_wait
INFO:root:    (398) select_stmt -> . async_select
INFO:root:    (399) select_stmt -> . timed_entry_call
INFO:root:    (400) select_stmt -> . cond_entry_call
INFO:root:    (149) name -> . simple_name
INFO:root:    (150) name -> . indexed_comp
INFO:root:    (151) name -> . selected_comp
INFO:root:    (152) name -> . attribute
INFO:root:    (153) name -> . operator_symbol
INFO:root:    (233) qualified -> . name TICK parenthesized_primary
INFO:root:    (271) case_hdr -> . CASE expression IS
INFO:root:    (276) label_opt -> .
INFO:root:    (277) label_opt -> . IDENTIFIER :
INFO:root:    (392) accept_hdr -> . ACCEPT entry_name formal_part_opt
INFO:root:    (401) select_wait -> . SELECT guarded_select_alt or_select else_opt END SELECT ;
INFO:root:    (411) async_select -> . SELECT delay_or_entry_alt THEN ABORT statement_s END SELECT ;
INFO:root:    (412) timed_entry_call -> . SELECT entry_call stmts_opt OR delay_stmt stmts_opt END SELECT ;
INFO:root:    (413) cond_entry_call -> . SELECT entry_call stmts_opt ELSE statement_s END SELECT ;
INFO:root:    (157) simple_name -> . IDENTIFIER
INFO:root:    (164) indexed_comp -> . name ( value_s )
INFO:root:    (171) selected_comp -> . name . simple_name
INFO:root:    (172) selected_comp -> . name . used_char
INFO:root:    (173) selected_comp -> . name . operator_symbol
INFO:root:    (174) selected_comp -> . name . ALL
INFO:root:    (175) attribute -> . name TICK attribute_id
INFO:root:    (163) operator_symbol -> . STRING
INFO:root:
INFO:root:    LL              shift and go to state 344
INFO:root:    error           shift and go to state 341
INFO:root:    NuLL            shift and go to state 347
INFO:root:    EXIT            shift and go to state 340
INFO:root:    RETURN          shift and go to state 303
INFO:root:    DELAY           shift and go to state 332
INFO:root:    ABORT           shift and go to state 326
INFO:root:    RAISE           shift and go to state 314
INFO:root:    REQUEUE         shift and go to state 317
INFO:root:    IF              shift and go to state 327
INFO:root:    CASE            shift and go to state 312
INFO:root:    WHILE           reduce using rule 276 (label_opt -> .)
INFO:root:    DECLARE         reduce using rule 276 (label_opt -> .)
INFO:root:    FOR             reduce using rule 276 (label_opt -> .)
INFO:root:    LOOP            reduce using rule 276 (label_opt -> .)
INFO:root:    BEGIN           reduce using rule 276 (label_opt -> .)
INFO:root:    IDENTIFIER      shift and go to state 322
INFO:root:    ACCEPT          shift and go to state 310
INFO:root:    SELECT          shift and go to state 320
INFO:root:    STRING          shift and go to state 149
INFO:root:
INFO:root:    cond_entry_call                shift and go to state 345
INFO:root:    simple_stmt                    shift and go to state 302
INFO:root:    async_select                   shift and go to state 328
INFO:root:    simple_name                    shift and go to state 163
INFO:root:    requeue_stmt                   shift and go to state 329
INFO:root:    if_stmt                        shift and go to state 304
INFO:root:    procedure_call                 shift and go to state 305
INFO:root:    select_wait                    shift and go to state 330
INFO:root:    indexed_comp                   shift and go to state 140
INFO:root:    timed_entry_call               shift and go to state 307
INFO:root:    statement                      shift and go to state 308
INFO:root:    operator_symbol                shift and go to state 133
INFO:root:    exit_stmt                      shift and go to state 306
INFO:root:    code_stmt                      shift and go to state 331
INFO:root:    loop_stmt                      shift and go to state 333
INFO:root:    null_stmt                      shift and go to state 334
INFO:root:    label                          shift and go to state 335
INFO:root:    select_stmt                    shift and go to state 311
INFO:root:    label_opt                      shift and go to state 313
INFO:root:    assign_stmt                    shift and go to state 336
INFO:root:    selected_comp                  shift and go to state 139
INFO:root:    abort_stmt                     shift and go to state 315
INFO:root:    attribute                      shift and go to state 134
INFO:root:    name                           shift and go to state 316
INFO:root:    accept_hdr                     shift and go to state 318
INFO:root:    accept_stmt                    shift and go to state 337
INFO:root:    case_hdr                       shift and go to state 319
INFO:root:    delay_stmt                     shift and go to state 338
INFO:root:    statement_s                    shift and go to state 339
INFO:root:    compound_stmt                  shift and go to state 309
INFO:root:    raise_stmt                     shift and go to state 342
INFO:root:    qualified                      shift and go to state 321
INFO:root:    return_stmt                    shift and go to state 323
INFO:root:    case_stmt                      shift and go to state 324
INFO:root:    block                          shift and go to state 325
INFO:root:    handled_stmt_s                 shift and go to state 343
INFO:root:    unlabeled                      shift and go to state 346
INFO:root:
INFO:root:state 196
INFO:root:
INFO:root:    (22) decl -> error ; .
INFO:root:
INFO:root:    PACKAGE         reduce using rule 22 (decl -> error ; .)
INFO:root:    TASK            reduce using rule 22 (decl -> error ; .)
INFO:root:    PROTECTED       reduce using rule 22 (decl -> error ; .)
INFO:root:    error           reduce using rule 22 (decl -> error ; .)
INFO:root:    USE             reduce using rule 22 (decl -> error ; .)
INFO:root:    PRAGMA          reduce using rule 22 (decl -> error ; .)
INFO:root:    TYPE            reduce using rule 22 (decl -> error ; .)
INFO:root:    SUBTYPE         reduce using rule 22 (decl -> error ; .)
INFO:root:    FOR             reduce using rule 22 (decl -> error ; .)
INFO:root:    PROCEDURE       reduce using rule 22 (decl -> error ; .)
INFO:root:    FUNCTION        reduce using rule 22 (decl -> error ; .)
INFO:root:    GENERIC         reduce using rule 22 (decl -> error ; .)
INFO:root:    IDENTIFIER      reduce using rule 22 (decl -> error ; .)
INFO:root:    BEGIN           reduce using rule 22 (decl -> error ; .)
INFO:root:    END             reduce using rule 22 (decl -> error ; .)
INFO:root:    PRIVATE         reduce using rule 22 (decl -> error ; .)
INFO:root:
INFO:root:
INFO:root:state 197
INFO:root:
INFO:root:    (50) subtype_decl -> SUBTYPE IDENTIFIER . IS subtype_ind ;
INFO:root:
INFO:root:    IS              shift and go to state 348
INFO:root:
INFO:root:
INFO:root:state 198
INFO:root:
INFO:root:    (161) c_name_list -> c_name_list , compound_name .
INFO:root:    (159) compound_name -> compound_name . . simple_name
INFO:root:
INFO:root:    ;               reduce using rule 161 (c_name_list -> c_name_list , compound_name .)
INFO:root:    ,               reduce using rule 161 (c_name_list -> c_name_list , compound_name .)
INFO:root:    .               shift and go to state 116
INFO:root:
INFO:root:
INFO:root:state 199
INFO:root:
INFO:root:    (159) compound_name -> compound_name . simple_name .
INFO:root:
INFO:root:    .               reduce using rule 159 (compound_name -> compound_name . simple_name .)
INFO:root:    (               reduce using rule 159 (compound_name -> compound_name . simple_name .)
INFO:root:    RETURN          reduce using rule 159 (compound_name -> compound_name . simple_name .)
INFO:root:    ;               reduce using rule 159 (compound_name -> compound_name . simple_name .)
INFO:root:    IS              reduce using rule 159 (compound_name -> compound_name . simple_name .)
INFO:root:    RENAMES         reduce using rule 159 (compound_name -> compound_name . simple_name .)
INFO:root:    ,               reduce using rule 159 (compound_name -> compound_name . simple_name .)
INFO:root:    )               reduce using rule 159 (compound_name -> compound_name . simple_name .)
INFO:root:
INFO:root:
INFO:root:state 200
INFO:root:
INFO:root:    (420) comp_unit -> context_spec private_opt unit pragma_s .
INFO:root:    (9) pragma_s -> pragma_s . pragma
INFO:root:    (2) pragma -> . PRAGMA IDENTIFIER ;
INFO:root:    (3) pragma -> . PRAGMA simple_name ( pragma_arg_s ) ;
INFO:root:
INFO:root:    PRIVATE         reduce using rule 420 (comp_unit -> context_spec private_opt unit pragma_s .)
INFO:root:    WITH            reduce using rule 420 (comp_unit -> context_spec private_opt unit pragma_s .)
INFO:root:    PACKAGE         reduce using rule 420 (comp_unit -> context_spec private_opt unit pragma_s .)
INFO:root:    SEPARATE        reduce using rule 420 (comp_unit -> context_spec private_opt unit pragma_s .)
INFO:root:    PROCEDURE       reduce using rule 420 (comp_unit -> context_spec private_opt unit pragma_s .)
INFO:root:    FUNCTION        reduce using rule 420 (comp_unit -> context_spec private_opt unit pragma_s .)
INFO:root:    GENERIC         reduce using rule 420 (comp_unit -> context_spec private_opt unit pragma_s .)
INFO:root:    $end            reduce using rule 420 (comp_unit -> context_spec private_opt unit pragma_s .)
INFO:root:    PRAGMA          shift and go to state 2
INFO:root:
INFO:root:    pragma                         shift and go to state 43
INFO:root:
INFO:root:state 201
INFO:root:
INFO:root:    (7) pragma_arg -> simple_name ARROW . expression
INFO:root:    (188) expression -> . relation
INFO:root:    (189) expression -> . expression logical relation
INFO:root:    (190) expression -> . expression short_circuit relation
INFO:root:    (196) relation -> . simple_expression
INFO:root:    (197) relation -> . simple_expression relational simple_expression
INFO:root:    (198) relation -> . simple_expression membership range
INFO:root:    (199) relation -> . simple_expression membership name
INFO:root:    (208) simple_expression -> . unary term
INFO:root:    (209) simple_expression -> . term
INFO:root:    (210) simple_expression -> . simple_expression adding term
INFO:root:    (211) unary -> . +
INFO:root:    (212) unary -> . -
INFO:root:    (216) term -> . factor
INFO:root:    (217) term -> . term multiplying factor
INFO:root:    (223) factor -> . primary
INFO:root:    (224) factor -> . NOT primary
INFO:root:    (225) factor -> . ABS primary
INFO:root:    (226) primary -> . literal
INFO:root:    (227) primary -> . name
INFO:root:    (228) primary -> . allocator
INFO:root:    (229) primary -> . qualified
INFO:root:    (230) primary -> . parenthesized_primary
INFO:root:    (180) literal -> . INT
INFO:root:    (181) literal -> . FLOAT
INFO:root:    (182) literal -> . NuLL
INFO:root:    (149) name -> . simple_name
INFO:root:    (150) name -> . indexed_comp
INFO:root:    (151) name -> . selected_comp
INFO:root:    (152) name -> . attribute
INFO:root:    (153) name -> . operator_symbol
INFO:root:    (234) allocator -> . NEW name
INFO:root:    (235) allocator -> . NEW qualified
INFO:root:    (233) qualified -> . name TICK parenthesized_primary
INFO:root:    (231) parenthesized_primary -> . aggregate
INFO:root:    (232) parenthesized_primary -> . ( expression )
INFO:root:    (157) simple_name -> . IDENTIFIER
INFO:root:    (164) indexed_comp -> . name ( value_s )
INFO:root:    (171) selected_comp -> . name . simple_name
INFO:root:    (172) selected_comp -> . name . used_char
INFO:root:    (173) selected_comp -> . name . operator_symbol
INFO:root:    (174) selected_comp -> . name . ALL
INFO:root:    (175) attribute -> . name TICK attribute_id
INFO:root:    (163) operator_symbol -> . STRING
INFO:root:    (183) aggregate -> . ( comp_assoc )
INFO:root:    (184) aggregate -> . ( expression WITH value_s )
INFO:root:    (185) aggregate -> . ( expression WITH NuLL RECORD )
INFO:root:    (186) aggregate -> . ( NuLL RECORD )
INFO:root:
INFO:root:    +               shift and go to state 148
INFO:root:    -               shift and go to state 136
INFO:root:    NOT             shift and go to state 131
INFO:root:    ABS             shift and go to state 132
INFO:root:    INT             shift and go to state 120
INFO:root:    FLOAT           shift and go to state 128
INFO:root:    NuLL            shift and go to state 130
INFO:root:    NEW             shift and go to state 137
INFO:root:    (               shift and go to state 125
INFO:root:    IDENTIFIER      shift and go to state 33
INFO:root:    STRING          shift and go to state 149
INFO:root:
INFO:root:    literal                        shift and go to state 121
INFO:root:    allocator                      shift and go to state 122
INFO:root:    simple_name                    shift and go to state 163
INFO:root:    indexed_comp                   shift and go to state 140
INFO:root:    name                           shift and go to state 142
INFO:root:    selected_comp                  shift and go to state 139
INFO:root:    factor                         shift and go to state 126
INFO:root:    expression                     shift and go to state 349
INFO:root:    unary                          shift and go to state 144
INFO:root:    qualified                      shift and go to state 145
INFO:root:    aggregate                      shift and go to state 143
INFO:root:    simple_expression              shift and go to state 129
INFO:root:    term                           shift and go to state 146
INFO:root:    operator_symbol                shift and go to state 133
INFO:root:    parenthesized_primary          shift and go to state 147
INFO:root:    attribute                      shift and go to state 134
INFO:root:    primary                        shift and go to state 135
INFO:root:    relation                       shift and go to state 138
INFO:root:
INFO:root:state 202
INFO:root:
INFO:root:    (187) comp_assoc -> choice_s . ARROW expression
INFO:root:    (122) choice_s -> choice_s . | choice
INFO:root:
INFO:root:    ARROW           shift and go to state 350
INFO:root:    |               shift and go to state 351
INFO:root:
INFO:root:
INFO:root:state 203
INFO:root:
INFO:root:    (232) parenthesized_primary -> ( expression . )
INFO:root:    (184) aggregate -> ( expression . WITH value_s )
INFO:root:    (185) aggregate -> ( expression . WITH NuLL RECORD )
INFO:root:    (189) expression -> expression . logical relation
INFO:root:    (190) expression -> expression . short_circuit relation
INFO:root:    (123) choice -> expression .
INFO:root:    (191) logical -> . AND
INFO:root:    (192) logical -> . OR
INFO:root:    (193) logical -> . XOR
INFO:root:    (194) short_circuit -> . AND THEN
INFO:root:    (195) short_circuit -> . OR ELSE
INFO:root:
INFO:root:    )               shift and go to state 352
INFO:root:    WITH            shift and go to state 353
INFO:root:    ARROW           reduce using rule 123 (choice -> expression .)
INFO:root:    |               reduce using rule 123 (choice -> expression .)
INFO:root:    AND             shift and go to state 215
INFO:root:    OR              shift and go to state 216
INFO:root:    XOR             shift and go to state 214
INFO:root:
INFO:root:    short_circuit                  shift and go to state 212
INFO:root:    logical                        shift and go to state 213
INFO:root:
INFO:root:state 204
INFO:root:
INFO:root:    (125) choice -> OTHERS .
INFO:root:
INFO:root:    ARROW           reduce using rule 125 (choice -> OTHERS .)
INFO:root:    |               reduce using rule 125 (choice -> OTHERS .)
INFO:root:
INFO:root:
INFO:root:state 205
INFO:root:
INFO:root:    (196) relation -> simple_expression .
INFO:root:    (197) relation -> simple_expression . relational simple_expression
INFO:root:    (198) relation -> simple_expression . membership range
INFO:root:    (199) relation -> simple_expression . membership name
INFO:root:    (210) simple_expression -> simple_expression . adding term
INFO:root:    (62) range -> simple_expression . DOTDOT simple_expression
INFO:root:    (200) relational -> . =
INFO:root:    (201) relational -> . NEQ
INFO:root:    (202) relational -> . <
INFO:root:    (203) relational -> . LEQ
INFO:root:    (204) relational -> . >
INFO:root:    (205) relational -> . GEQ
INFO:root:    (206) membership -> . IN
INFO:root:    (207) membership -> . NOT IN
INFO:root:    (213) adding -> . +
INFO:root:    (214) adding -> . -
INFO:root:    (215) adding -> . &
INFO:root:
INFO:root:    )               reduce using rule 196 (relation -> simple_expression .)
INFO:root:    WITH            reduce using rule 196 (relation -> simple_expression .)
INFO:root:    AND             reduce using rule 196 (relation -> simple_expression .)
INFO:root:    OR              reduce using rule 196 (relation -> simple_expression .)
INFO:root:    XOR             reduce using rule 196 (relation -> simple_expression .)
INFO:root:    ARROW           reduce using rule 196 (relation -> simple_expression .)
INFO:root:    |               reduce using rule 196 (relation -> simple_expression .)
INFO:root:    DOTDOT          shift and go to state 354
INFO:root:    =               shift and go to state 219
INFO:root:    NEQ             shift and go to state 224
INFO:root:    <               shift and go to state 228
INFO:root:    LEQ             shift and go to state 218
INFO:root:    >               shift and go to state 222
INFO:root:    GEQ             shift and go to state 225
INFO:root:    IN              shift and go to state 223
INFO:root:    NOT             shift and go to state 220
INFO:root:    +               shift and go to state 226
INFO:root:    -               shift and go to state 217
INFO:root:    &               shift and go to state 229
INFO:root:
INFO:root:    membership                     shift and go to state 221
INFO:root:    relational                     shift and go to state 227
INFO:root:    adding                         shift and go to state 230
INFO:root:
INFO:root:state 206
INFO:root:
INFO:root:    (186) aggregate -> ( NuLL . RECORD )
INFO:root:    (182) literal -> NuLL .
INFO:root:
INFO:root:    RECORD          shift and go to state 355
INFO:root:    *               reduce using rule 182 (literal -> NuLL .)
INFO:root:    /               reduce using rule 182 (literal -> NuLL .)
INFO:root:    MOD             reduce using rule 182 (literal -> NuLL .)
INFO:root:    REM             reduce using rule 182 (literal -> NuLL .)
INFO:root:    STARSTAR        reduce using rule 182 (literal -> NuLL .)
INFO:root:    DOTDOT          reduce using rule 182 (literal -> NuLL .)
INFO:root:    =               reduce using rule 182 (literal -> NuLL .)
INFO:root:    NEQ             reduce using rule 182 (literal -> NuLL .)
INFO:root:    <               reduce using rule 182 (literal -> NuLL .)
INFO:root:    LEQ             reduce using rule 182 (literal -> NuLL .)
INFO:root:    >               reduce using rule 182 (literal -> NuLL .)
INFO:root:    GEQ             reduce using rule 182 (literal -> NuLL .)
INFO:root:    IN              reduce using rule 182 (literal -> NuLL .)
INFO:root:    NOT             reduce using rule 182 (literal -> NuLL .)
INFO:root:    +               reduce using rule 182 (literal -> NuLL .)
INFO:root:    -               reduce using rule 182 (literal -> NuLL .)
INFO:root:    &               reduce using rule 182 (literal -> NuLL .)
INFO:root:    )               reduce using rule 182 (literal -> NuLL .)
INFO:root:    WITH            reduce using rule 182 (literal -> NuLL .)
INFO:root:    AND             reduce using rule 182 (literal -> NuLL .)
INFO:root:    OR              reduce using rule 182 (literal -> NuLL .)
INFO:root:    XOR             reduce using rule 182 (literal -> NuLL .)
INFO:root:    ARROW           reduce using rule 182 (literal -> NuLL .)
INFO:root:    |               reduce using rule 182 (literal -> NuLL .)
INFO:root:
INFO:root:
INFO:root:state 207
INFO:root:
INFO:root:    (121) choice_s -> choice .
INFO:root:
INFO:root:    ARROW           reduce using rule 121 (choice_s -> choice .)
INFO:root:    |               reduce using rule 121 (choice_s -> choice .)
INFO:root:
INFO:root:
INFO:root:state 208
INFO:root:
INFO:root:    (183) aggregate -> ( comp_assoc . )
INFO:root:
INFO:root:    )               shift and go to state 356
INFO:root:
INFO:root:
INFO:root:state 209
INFO:root:
INFO:root:    (126) discrete_with_range -> name . range_constraint
INFO:root:    (227) primary -> name .
INFO:root:    (164) indexed_comp -> name . ( value_s )
INFO:root:    (171) selected_comp -> name . . simple_name
INFO:root:    (172) selected_comp -> name . . used_char
INFO:root:    (173) selected_comp -> name . . operator_symbol
INFO:root:    (174) selected_comp -> name . . ALL
INFO:root:    (175) attribute -> name . TICK attribute_id
INFO:root:    (233) qualified -> name . TICK parenthesized_primary
INFO:root:    (61) range_constraint -> . RANGE range
INFO:root:
INFO:root:    *               reduce using rule 227 (primary -> name .)
INFO:root:    /               reduce using rule 227 (primary -> name .)
INFO:root:    MOD             reduce using rule 227 (primary -> name .)
INFO:root:    REM             reduce using rule 227 (primary -> name .)
INFO:root:    STARSTAR        reduce using rule 227 (primary -> name .)
INFO:root:    DOTDOT          reduce using rule 227 (primary -> name .)
INFO:root:    =               reduce using rule 227 (primary -> name .)
INFO:root:    NEQ             reduce using rule 227 (primary -> name .)
INFO:root:    <               reduce using rule 227 (primary -> name .)
INFO:root:    LEQ             reduce using rule 227 (primary -> name .)
INFO:root:    >               reduce using rule 227 (primary -> name .)
INFO:root:    GEQ             reduce using rule 227 (primary -> name .)
INFO:root:    IN              reduce using rule 227 (primary -> name .)
INFO:root:    NOT             reduce using rule 227 (primary -> name .)
INFO:root:    +               reduce using rule 227 (primary -> name .)
INFO:root:    -               reduce using rule 227 (primary -> name .)
INFO:root:    &               reduce using rule 227 (primary -> name .)
INFO:root:    )               reduce using rule 227 (primary -> name .)
INFO:root:    WITH            reduce using rule 227 (primary -> name .)
INFO:root:    AND             reduce using rule 227 (primary -> name .)
INFO:root:    OR              reduce using rule 227 (primary -> name .)
INFO:root:    XOR             reduce using rule 227 (primary -> name .)
INFO:root:    ARROW           reduce using rule 227 (primary -> name .)
INFO:root:    |               reduce using rule 227 (primary -> name .)
INFO:root:    (               shift and go to state 237
INFO:root:    .               shift and go to state 239
INFO:root:    TICK            shift and go to state 359
INFO:root:    RANGE           shift and go to state 358
INFO:root:
INFO:root:    range_constraint               shift and go to state 357
INFO:root:
INFO:root:state 210
INFO:root:
INFO:root:    (124) choice -> discrete_with_range .
INFO:root:
INFO:root:    ARROW           reduce using rule 124 (choice -> discrete_with_range .)
INFO:root:    |               reduce using rule 124 (choice -> discrete_with_range .)
INFO:root:
INFO:root:
INFO:root:state 211
INFO:root:
INFO:root:    (127) discrete_with_range -> range .
INFO:root:
INFO:root:    ARROW           reduce using rule 127 (discrete_with_range -> range .)
INFO:root:    |               reduce using rule 127 (discrete_with_range -> range .)
INFO:root:    )               reduce using rule 127 (discrete_with_range -> range .)
INFO:root:    ,               reduce using rule 127 (discrete_with_range -> range .)
INFO:root:
INFO:root:
INFO:root:state 212
INFO:root:
INFO:root:    (190) expression -> expression short_circuit . relation
INFO:root:    (196) relation -> . simple_expression
INFO:root:    (197) relation -> . simple_expression relational simple_expression
INFO:root:    (198) relation -> . simple_expression membership range
INFO:root:    (199) relation -> . simple_expression membership name
INFO:root:    (208) simple_expression -> . unary term
INFO:root:    (209) simple_expression -> . term
INFO:root:    (210) simple_expression -> . simple_expression adding term
INFO:root:    (211) unary -> . +
INFO:root:    (212) unary -> . -
INFO:root:    (216) term -> . factor
INFO:root:    (217) term -> . term multiplying factor
INFO:root:    (223) factor -> . primary
INFO:root:    (224) factor -> . NOT primary
INFO:root:    (225) factor -> . ABS primary
INFO:root:    (226) primary -> . literal
INFO:root:    (227) primary -> . name
INFO:root:    (228) primary -> . allocator
INFO:root:    (229) primary -> . qualified
INFO:root:    (230) primary -> . parenthesized_primary
INFO:root:    (180) literal -> . INT
INFO:root:    (181) literal -> . FLOAT
INFO:root:    (182) literal -> . NuLL
INFO:root:    (149) name -> . simple_name
INFO:root:    (150) name -> . indexed_comp
INFO:root:    (151) name -> . selected_comp
INFO:root:    (152) name -> . attribute
INFO:root:    (153) name -> . operator_symbol
INFO:root:    (234) allocator -> . NEW name
INFO:root:    (235) allocator -> . NEW qualified
INFO:root:    (233) qualified -> . name TICK parenthesized_primary
INFO:root:    (231) parenthesized_primary -> . aggregate
INFO:root:    (232) parenthesized_primary -> . ( expression )
INFO:root:    (157) simple_name -> . IDENTIFIER
INFO:root:    (164) indexed_comp -> . name ( value_s )
INFO:root:    (171) selected_comp -> . name . simple_name
INFO:root:    (172) selected_comp -> . name . used_char
INFO:root:    (173) selected_comp -> . name . operator_symbol
INFO:root:    (174) selected_comp -> . name . ALL
INFO:root:    (175) attribute -> . name TICK attribute_id
INFO:root:    (163) operator_symbol -> . STRING
INFO:root:    (183) aggregate -> . ( comp_assoc )
INFO:root:    (184) aggregate -> . ( expression WITH value_s )
INFO:root:    (185) aggregate -> . ( expression WITH NuLL RECORD )
INFO:root:    (186) aggregate -> . ( NuLL RECORD )
INFO:root:
INFO:root:    +               shift and go to state 148
INFO:root:    -               shift and go to state 136
INFO:root:    NOT             shift and go to state 131
INFO:root:    ABS             shift and go to state 132
INFO:root:    INT             shift and go to state 120
INFO:root:    FLOAT           shift and go to state 128
INFO:root:    NuLL            shift and go to state 130
INFO:root:    NEW             shift and go to state 137
INFO:root:    (               shift and go to state 125
INFO:root:    IDENTIFIER      shift and go to state 33
INFO:root:    STRING          shift and go to state 149
INFO:root:
INFO:root:    literal                        shift and go to state 121
INFO:root:    allocator                      shift and go to state 122
INFO:root:    simple_name                    shift and go to state 163
INFO:root:    indexed_comp                   shift and go to state 140
INFO:root:    name                           shift and go to state 142
INFO:root:    selected_comp                  shift and go to state 139
INFO:root:    factor                         shift and go to state 126
INFO:root:    unary                          shift and go to state 144
INFO:root:    qualified                      shift and go to state 145
INFO:root:    aggregate                      shift and go to state 143
INFO:root:    simple_expression              shift and go to state 129
INFO:root:    term                           shift and go to state 146
INFO:root:    operator_symbol                shift and go to state 133
INFO:root:    parenthesized_primary          shift and go to state 147
INFO:root:    attribute                      shift and go to state 134
INFO:root:    primary                        shift and go to state 135
INFO:root:    relation                       shift and go to state 360
INFO:root:
INFO:root:state 213
INFO:root:
INFO:root:    (189) expression -> expression logical . relation
INFO:root:    (196) relation -> . simple_expression
INFO:root:    (197) relation -> . simple_expression relational simple_expression
INFO:root:    (198) relation -> . simple_expression membership range
INFO:root:    (199) relation -> . simple_expression membership name
INFO:root:    (208) simple_expression -> . unary term
INFO:root:    (209) simple_expression -> . term
INFO:root:    (210) simple_expression -> . simple_expression adding term
INFO:root:    (211) unary -> . +
INFO:root:    (212) unary -> . -
INFO:root:    (216) term -> . factor
INFO:root:    (217) term -> . term multiplying factor
INFO:root:    (223) factor -> . primary
INFO:root:    (224) factor -> . NOT primary
INFO:root:    (225) factor -> . ABS primary
INFO:root:    (226) primary -> . literal
INFO:root:    (227) primary -> . name
INFO:root:    (228) primary -> . allocator
INFO:root:    (229) primary -> . qualified
INFO:root:    (230) primary -> . parenthesized_primary
INFO:root:    (180) literal -> . INT
INFO:root:    (181) literal -> . FLOAT
INFO:root:    (182) literal -> . NuLL
INFO:root:    (149) name -> . simple_name
INFO:root:    (150) name -> . indexed_comp
INFO:root:    (151) name -> . selected_comp
INFO:root:    (152) name -> . attribute
INFO:root:    (153) name -> . operator_symbol
INFO:root:    (234) allocator -> . NEW name
INFO:root:    (235) allocator -> . NEW qualified
INFO:root:    (233) qualified -> . name TICK parenthesized_primary
INFO:root:    (231) parenthesized_primary -> . aggregate
INFO:root:    (232) parenthesized_primary -> . ( expression )
INFO:root:    (157) simple_name -> . IDENTIFIER
INFO:root:    (164) indexed_comp -> . name ( value_s )
INFO:root:    (171) selected_comp -> . name . simple_name
INFO:root:    (172) selected_comp -> . name . used_char
INFO:root:    (173) selected_comp -> . name . operator_symbol
INFO:root:    (174) selected_comp -> . name . ALL
INFO:root:    (175) attribute -> . name TICK attribute_id
INFO:root:    (163) operator_symbol -> . STRING
INFO:root:    (183) aggregate -> . ( comp_assoc )
INFO:root:    (184) aggregate -> . ( expression WITH value_s )
INFO:root:    (185) aggregate -> . ( expression WITH NuLL RECORD )
INFO:root:    (186) aggregate -> . ( NuLL RECORD )
INFO:root:
INFO:root:    +               shift and go to state 148
INFO:root:    -               shift and go to state 136
INFO:root:    NOT             shift and go to state 131
INFO:root:    ABS             shift and go to state 132
INFO:root:    INT             shift and go to state 120
INFO:root:    FLOAT           shift and go to state 128
INFO:root:    NuLL            shift and go to state 130
INFO:root:    NEW             shift and go to state 137
INFO:root:    (               shift and go to state 125
INFO:root:    IDENTIFIER      shift and go to state 33
INFO:root:    STRING          shift and go to state 149
INFO:root:
INFO:root:    literal                        shift and go to state 121
INFO:root:    allocator                      shift and go to state 122
INFO:root:    simple_name                    shift and go to state 163
INFO:root:    indexed_comp                   shift and go to state 140
INFO:root:    attribute                      shift and go to state 134
INFO:root:    name                           shift and go to state 142
INFO:root:    selected_comp                  shift and go to state 139
INFO:root:    factor                         shift and go to state 126
INFO:root:    unary                          shift and go to state 144
INFO:root:    qualified                      shift and go to state 145
INFO:root:    aggregate                      shift and go to state 143
INFO:root:    simple_expression              shift and go to state 129
INFO:root:    term                           shift and go to state 146
INFO:root:    operator_symbol                shift and go to state 133
INFO:root:    parenthesized_primary          shift and go to state 147
INFO:root:    primary                        shift and go to state 135
INFO:root:    relation                       shift and go to state 361
INFO:root:
INFO:root:state 214
INFO:root:
INFO:root:    (193) logical -> XOR .
INFO:root:
INFO:root:    +               reduce using rule 193 (logical -> XOR .)
INFO:root:    -               reduce using rule 193 (logical -> XOR .)
INFO:root:    NOT             reduce using rule 193 (logical -> XOR .)
INFO:root:    ABS             reduce using rule 193 (logical -> XOR .)
INFO:root:    INT             reduce using rule 193 (logical -> XOR .)
INFO:root:    FLOAT           reduce using rule 193 (logical -> XOR .)
INFO:root:    NuLL            reduce using rule 193 (logical -> XOR .)
INFO:root:    NEW             reduce using rule 193 (logical -> XOR .)
INFO:root:    (               reduce using rule 193 (logical -> XOR .)
INFO:root:    IDENTIFIER      reduce using rule 193 (logical -> XOR .)
INFO:root:    STRING          reduce using rule 193 (logical -> XOR .)
INFO:root:
INFO:root:
INFO:root:state 215
INFO:root:
INFO:root:    (191) logical -> AND .
INFO:root:    (194) short_circuit -> AND . THEN
INFO:root:
INFO:root:    +               reduce using rule 191 (logical -> AND .)
INFO:root:    -               reduce using rule 191 (logical -> AND .)
INFO:root:    NOT             reduce using rule 191 (logical -> AND .)
INFO:root:    ABS             reduce using rule 191 (logical -> AND .)
INFO:root:    INT             reduce using rule 191 (logical -> AND .)
INFO:root:    FLOAT           reduce using rule 191 (logical -> AND .)
INFO:root:    NuLL            reduce using rule 191 (logical -> AND .)
INFO:root:    NEW             reduce using rule 191 (logical -> AND .)
INFO:root:    (               reduce using rule 191 (logical -> AND .)
INFO:root:    IDENTIFIER      reduce using rule 191 (logical -> AND .)
INFO:root:    STRING          reduce using rule 191 (logical -> AND .)
INFO:root:    THEN            shift and go to state 362
INFO:root:
INFO:root:
INFO:root:state 216
INFO:root:
INFO:root:    (192) logical -> OR .
INFO:root:    (195) short_circuit -> OR . ELSE
INFO:root:
INFO:root:    +               reduce using rule 192 (logical -> OR .)
INFO:root:    -               reduce using rule 192 (logical -> OR .)
INFO:root:    NOT             reduce using rule 192 (logical -> OR .)
INFO:root:    ABS             reduce using rule 192 (logical -> OR .)
INFO:root:    INT             reduce using rule 192 (logical -> OR .)
INFO:root:    FLOAT           reduce using rule 192 (logical -> OR .)
INFO:root:    NuLL            reduce using rule 192 (logical -> OR .)
INFO:root:    NEW             reduce using rule 192 (logical -> OR .)
INFO:root:    (               reduce using rule 192 (logical -> OR .)
INFO:root:    IDENTIFIER      reduce using rule 192 (logical -> OR .)
INFO:root:    STRING          reduce using rule 192 (logical -> OR .)
INFO:root:    ELSE            shift and go to state 363
INFO:root:
INFO:root:
INFO:root:state 217
INFO:root:
INFO:root:    (214) adding -> - .
INFO:root:
INFO:root:    NOT             reduce using rule 214 (adding -> - .)
INFO:root:    ABS             reduce using rule 214 (adding -> - .)
INFO:root:    INT             reduce using rule 214 (adding -> - .)
INFO:root:    FLOAT           reduce using rule 214 (adding -> - .)
INFO:root:    NuLL            reduce using rule 214 (adding -> - .)
INFO:root:    NEW             reduce using rule 214 (adding -> - .)
INFO:root:    (               reduce using rule 214 (adding -> - .)
INFO:root:    IDENTIFIER      reduce using rule 214 (adding -> - .)
INFO:root:    STRING          reduce using rule 214 (adding -> - .)
INFO:root:
INFO:root:
INFO:root:state 218
INFO:root:
INFO:root:    (203) relational -> LEQ .
INFO:root:
INFO:root:    +               reduce using rule 203 (relational -> LEQ .)
INFO:root:    -               reduce using rule 203 (relational -> LEQ .)
INFO:root:    NOT             reduce using rule 203 (relational -> LEQ .)
INFO:root:    ABS             reduce using rule 203 (relational -> LEQ .)
INFO:root:    INT             reduce using rule 203 (relational -> LEQ .)
INFO:root:    FLOAT           reduce using rule 203 (relational -> LEQ .)
INFO:root:    NuLL            reduce using rule 203 (relational -> LEQ .)
INFO:root:    NEW             reduce using rule 203 (relational -> LEQ .)
INFO:root:    (               reduce using rule 203 (relational -> LEQ .)
INFO:root:    IDENTIFIER      reduce using rule 203 (relational -> LEQ .)
INFO:root:    STRING          reduce using rule 203 (relational -> LEQ .)
INFO:root:
INFO:root:
INFO:root:state 219
INFO:root:
INFO:root:    (200) relational -> = .
INFO:root:
INFO:root:    +               reduce using rule 200 (relational -> = .)
INFO:root:    -               reduce using rule 200 (relational -> = .)
INFO:root:    NOT             reduce using rule 200 (relational -> = .)
INFO:root:    ABS             reduce using rule 200 (relational -> = .)
INFO:root:    INT             reduce using rule 200 (relational -> = .)
INFO:root:    FLOAT           reduce using rule 200 (relational -> = .)
INFO:root:    NuLL            reduce using rule 200 (relational -> = .)
INFO:root:    NEW             reduce using rule 200 (relational -> = .)
INFO:root:    (               reduce using rule 200 (relational -> = .)
INFO:root:    IDENTIFIER      reduce using rule 200 (relational -> = .)
INFO:root:    STRING          reduce using rule 200 (relational -> = .)
INFO:root:
INFO:root:
INFO:root:state 220
INFO:root:
INFO:root:    (207) membership -> NOT . IN
INFO:root:
INFO:root:    IN              shift and go to state 364
INFO:root:
INFO:root:
INFO:root:state 221
INFO:root:
INFO:root:    (198) relation -> simple_expression membership . range
INFO:root:    (199) relation -> simple_expression membership . name
INFO:root:    (62) range -> . simple_expression DOTDOT simple_expression
INFO:root:    (149) name -> . simple_name
INFO:root:    (150) name -> . indexed_comp
INFO:root:    (151) name -> . selected_comp
INFO:root:    (152) name -> . attribute
INFO:root:    (153) name -> . operator_symbol
INFO:root:    (208) simple_expression -> . unary term
INFO:root:    (209) simple_expression -> . term
INFO:root:    (210) simple_expression -> . simple_expression adding term
INFO:root:    (157) simple_name -> . IDENTIFIER
INFO:root:    (164) indexed_comp -> . name ( value_s )
INFO:root:    (171) selected_comp -> . name . simple_name
INFO:root:    (172) selected_comp -> . name . used_char
INFO:root:    (173) selected_comp -> . name . operator_symbol
INFO:root:    (174) selected_comp -> . name . ALL
INFO:root:    (175) attribute -> . name TICK attribute_id
INFO:root:    (163) operator_symbol -> . STRING
INFO:root:    (211) unary -> . +
INFO:root:    (212) unary -> . -
INFO:root:    (216) term -> . factor
INFO:root:    (217) term -> . term multiplying factor
INFO:root:    (223) factor -> . primary
INFO:root:    (224) factor -> . NOT primary
INFO:root:    (225) factor -> . ABS primary
INFO:root:    (226) primary -> . literal
INFO:root:    (227) primary -> . name
INFO:root:    (228) primary -> . allocator
INFO:root:    (229) primary -> . qualified
INFO:root:    (230) primary -> . parenthesized_primary
INFO:root:    (180) literal -> . INT
INFO:root:    (181) literal -> . FLOAT
INFO:root:    (182) literal -> . NuLL
INFO:root:    (234) allocator -> . NEW name
INFO:root:    (235) allocator -> . NEW qualified
INFO:root:    (233) qualified -> . name TICK parenthesized_primary
INFO:root:    (231) parenthesized_primary -> . aggregate
INFO:root:    (232) parenthesized_primary -> . ( expression )
INFO:root:    (183) aggregate -> . ( comp_assoc )
INFO:root:    (184) aggregate -> . ( expression WITH value_s )
INFO:root:    (185) aggregate -> . ( expression WITH NuLL RECORD )
INFO:root:    (186) aggregate -> . ( NuLL RECORD )
INFO:root:
INFO:root:    IDENTIFIER      shift and go to state 33
INFO:root:    STRING          shift and go to state 149
INFO:root:    +               shift and go to state 148
INFO:root:    -               shift and go to state 136
INFO:root:    NOT             shift and go to state 131
INFO:root:    ABS             shift and go to state 132
INFO:root:    INT             shift and go to state 120
INFO:root:    FLOAT           shift and go to state 128
INFO:root:    NuLL            shift and go to state 130
INFO:root:    NEW             shift and go to state 137
INFO:root:    (               shift and go to state 125
INFO:root:
INFO:root:    selected_comp                  shift and go to state 139
INFO:root:    allocator                      shift and go to state 122
INFO:root:    factor                         shift and go to state 126
INFO:root:    indexed_comp                   shift and go to state 140
INFO:root:    attribute                      shift and go to state 134
INFO:root:    name                           shift and go to state 365
INFO:root:    literal                        shift and go to state 121
INFO:root:    simple_name                    shift and go to state 163
INFO:root:    aggregate                      shift and go to state 143
INFO:root:    unary                          shift and go to state 144
INFO:root:    term                           shift and go to state 146
INFO:root:    simple_expression              shift and go to state 366
INFO:root:    operator_symbol                shift and go to state 133
INFO:root:    parenthesized_primary          shift and go to state 147
INFO:root:    primary                        shift and go to state 135
INFO:root:    qualified                      shift and go to state 145
INFO:root:    range                          shift and go to state 367
INFO:root:
INFO:root:state 222
INFO:root:
INFO:root:    (204) relational -> > .
INFO:root:
INFO:root:    +               reduce using rule 204 (relational -> > .)
INFO:root:    -               reduce using rule 204 (relational -> > .)
INFO:root:    NOT             reduce using rule 204 (relational -> > .)
INFO:root:    ABS             reduce using rule 204 (relational -> > .)
INFO:root:    INT             reduce using rule 204 (relational -> > .)
INFO:root:    FLOAT           reduce using rule 204 (relational -> > .)
INFO:root:    NuLL            reduce using rule 204 (relational -> > .)
INFO:root:    NEW             reduce using rule 204 (relational -> > .)
INFO:root:    (               reduce using rule 204 (relational -> > .)
INFO:root:    IDENTIFIER      reduce using rule 204 (relational -> > .)
INFO:root:    STRING          reduce using rule 204 (relational -> > .)
INFO:root:
INFO:root:
INFO:root:state 223
INFO:root:
INFO:root:    (206) membership -> IN .
INFO:root:
INFO:root:    IDENTIFIER      reduce using rule 206 (membership -> IN .)
INFO:root:    STRING          reduce using rule 206 (membership -> IN .)
INFO:root:    +               reduce using rule 206 (membership -> IN .)
INFO:root:    -               reduce using rule 206 (membership -> IN .)
INFO:root:    NOT             reduce using rule 206 (membership -> IN .)
INFO:root:    ABS             reduce using rule 206 (membership -> IN .)
INFO:root:    INT             reduce using rule 206 (membership -> IN .)
INFO:root:    FLOAT           reduce using rule 206 (membership -> IN .)
INFO:root:    NuLL            reduce using rule 206 (membership -> IN .)
INFO:root:    NEW             reduce using rule 206 (membership -> IN .)
INFO:root:    (               reduce using rule 206 (membership -> IN .)
INFO:root:
INFO:root:
INFO:root:state 224
INFO:root:
INFO:root:    (201) relational -> NEQ .
INFO:root:
INFO:root:    +               reduce using rule 201 (relational -> NEQ .)
INFO:root:    -               reduce using rule 201 (relational -> NEQ .)
INFO:root:    NOT             reduce using rule 201 (relational -> NEQ .)
INFO:root:    ABS             reduce using rule 201 (relational -> NEQ .)
INFO:root:    INT             reduce using rule 201 (relational -> NEQ .)
INFO:root:    FLOAT           reduce using rule 201 (relational -> NEQ .)
INFO:root:    NuLL            reduce using rule 201 (relational -> NEQ .)
INFO:root:    NEW             reduce using rule 201 (relational -> NEQ .)
INFO:root:    (               reduce using rule 201 (relational -> NEQ .)
INFO:root:    IDENTIFIER      reduce using rule 201 (relational -> NEQ .)
INFO:root:    STRING          reduce using rule 201 (relational -> NEQ .)
INFO:root:
INFO:root:
INFO:root:state 225
INFO:root:
INFO:root:    (205) relational -> GEQ .
INFO:root:
INFO:root:    +               reduce using rule 205 (relational -> GEQ .)
INFO:root:    -               reduce using rule 205 (relational -> GEQ .)
INFO:root:    NOT             reduce using rule 205 (relational -> GEQ .)
INFO:root:    ABS             reduce using rule 205 (relational -> GEQ .)
INFO:root:    INT             reduce using rule 205 (relational -> GEQ .)
INFO:root:    FLOAT           reduce using rule 205 (relational -> GEQ .)
INFO:root:    NuLL            reduce using rule 205 (relational -> GEQ .)
INFO:root:    NEW             reduce using rule 205 (relational -> GEQ .)
INFO:root:    (               reduce using rule 205 (relational -> GEQ .)
INFO:root:    IDENTIFIER      reduce using rule 205 (relational -> GEQ .)
INFO:root:    STRING          reduce using rule 205 (relational -> GEQ .)
INFO:root:
INFO:root:
INFO:root:state 226
INFO:root:
INFO:root:    (213) adding -> + .
INFO:root:
INFO:root:    NOT             reduce using rule 213 (adding -> + .)
INFO:root:    ABS             reduce using rule 213 (adding -> + .)
INFO:root:    INT             reduce using rule 213 (adding -> + .)
INFO:root:    FLOAT           reduce using rule 213 (adding -> + .)
INFO:root:    NuLL            reduce using rule 213 (adding -> + .)
INFO:root:    NEW             reduce using rule 213 (adding -> + .)
INFO:root:    (               reduce using rule 213 (adding -> + .)
INFO:root:    IDENTIFIER      reduce using rule 213 (adding -> + .)
INFO:root:    STRING          reduce using rule 213 (adding -> + .)
INFO:root:
INFO:root:
INFO:root:state 227
INFO:root:
INFO:root:    (197) relation -> simple_expression relational . simple_expression
INFO:root:    (208) simple_expression -> . unary term
INFO:root:    (209) simple_expression -> . term
INFO:root:    (210) simple_expression -> . simple_expression adding term
INFO:root:    (211) unary -> . +
INFO:root:    (212) unary -> . -
INFO:root:    (216) term -> . factor
INFO:root:    (217) term -> . term multiplying factor
INFO:root:    (223) factor -> . primary
INFO:root:    (224) factor -> . NOT primary
INFO:root:    (225) factor -> . ABS primary
INFO:root:    (226) primary -> . literal
INFO:root:    (227) primary -> . name
INFO:root:    (228) primary -> . allocator
INFO:root:    (229) primary -> . qualified
INFO:root:    (230) primary -> . parenthesized_primary
INFO:root:    (180) literal -> . INT
INFO:root:    (181) literal -> . FLOAT
INFO:root:    (182) literal -> . NuLL
INFO:root:    (149) name -> . simple_name
INFO:root:    (150) name -> . indexed_comp
INFO:root:    (151) name -> . selected_comp
INFO:root:    (152) name -> . attribute
INFO:root:    (153) name -> . operator_symbol
INFO:root:    (234) allocator -> . NEW name
INFO:root:    (235) allocator -> . NEW qualified
INFO:root:    (233) qualified -> . name TICK parenthesized_primary
INFO:root:    (231) parenthesized_primary -> . aggregate
INFO:root:    (232) parenthesized_primary -> . ( expression )
INFO:root:    (157) simple_name -> . IDENTIFIER
INFO:root:    (164) indexed_comp -> . name ( value_s )
INFO:root:    (171) selected_comp -> . name . simple_name
INFO:root:    (172) selected_comp -> . name . used_char
INFO:root:    (173) selected_comp -> . name . operator_symbol
INFO:root:    (174) selected_comp -> . name . ALL
INFO:root:    (175) attribute -> . name TICK attribute_id
INFO:root:    (163) operator_symbol -> . STRING
INFO:root:    (183) aggregate -> . ( comp_assoc )
INFO:root:    (184) aggregate -> . ( expression WITH value_s )
INFO:root:    (185) aggregate -> . ( expression WITH NuLL RECORD )
INFO:root:    (186) aggregate -> . ( NuLL RECORD )
INFO:root:
INFO:root:    +               shift and go to state 148
INFO:root:    -               shift and go to state 136
INFO:root:    NOT             shift and go to state 131
INFO:root:    ABS             shift and go to state 132
INFO:root:    INT             shift and go to state 120
INFO:root:    FLOAT           shift and go to state 128
INFO:root:    NuLL            shift and go to state 130
INFO:root:    NEW             shift and go to state 137
INFO:root:    (               shift and go to state 125
INFO:root:    IDENTIFIER      shift and go to state 33
INFO:root:    STRING          shift and go to state 149
INFO:root:
INFO:root:    literal                        shift and go to state 121
INFO:root:    allocator                      shift and go to state 122
INFO:root:    factor                         shift and go to state 126
INFO:root:    indexed_comp                   shift and go to state 140
INFO:root:    attribute                      shift and go to state 134
INFO:root:    name                           shift and go to state 142
INFO:root:    selected_comp                  shift and go to state 139
INFO:root:    aggregate                      shift and go to state 143
INFO:root:    simple_name                    shift and go to state 163
INFO:root:    unary                          shift and go to state 144
INFO:root:    simple_expression              shift and go to state 368
INFO:root:    term                           shift and go to state 146
INFO:root:    operator_symbol                shift and go to state 133
INFO:root:    parenthesized_primary          shift and go to state 147
INFO:root:    primary                        shift and go to state 135
INFO:root:    qualified                      shift and go to state 145
INFO:root:
INFO:root:state 228
INFO:root:
INFO:root:    (202) relational -> < .
INFO:root:
INFO:root:    +               reduce using rule 202 (relational -> < .)
INFO:root:    -               reduce using rule 202 (relational -> < .)
INFO:root:    NOT             reduce using rule 202 (relational -> < .)
INFO:root:    ABS             reduce using rule 202 (relational -> < .)
INFO:root:    INT             reduce using rule 202 (relational -> < .)
INFO:root:    FLOAT           reduce using rule 202 (relational -> < .)
INFO:root:    NuLL            reduce using rule 202 (relational -> < .)
INFO:root:    NEW             reduce using rule 202 (relational -> < .)
INFO:root:    (               reduce using rule 202 (relational -> < .)
INFO:root:    IDENTIFIER      reduce using rule 202 (relational -> < .)
INFO:root:    STRING          reduce using rule 202 (relational -> < .)
INFO:root:
INFO:root:
INFO:root:state 229
INFO:root:
INFO:root:    (215) adding -> & .
INFO:root:
INFO:root:    NOT             reduce using rule 215 (adding -> & .)
INFO:root:    ABS             reduce using rule 215 (adding -> & .)
INFO:root:    INT             reduce using rule 215 (adding -> & .)
INFO:root:    FLOAT           reduce using rule 215 (adding -> & .)
INFO:root:    NuLL            reduce using rule 215 (adding -> & .)
INFO:root:    NEW             reduce using rule 215 (adding -> & .)
INFO:root:    (               reduce using rule 215 (adding -> & .)
INFO:root:    IDENTIFIER      reduce using rule 215 (adding -> & .)
INFO:root:    STRING          reduce using rule 215 (adding -> & .)
INFO:root:
INFO:root:
INFO:root:state 230
INFO:root:
INFO:root:    (210) simple_expression -> simple_expression adding . term
INFO:root:    (216) term -> . factor
INFO:root:    (217) term -> . term multiplying factor
INFO:root:    (223) factor -> . primary
INFO:root:    (224) factor -> . NOT primary
INFO:root:    (225) factor -> . ABS primary
INFO:root:    (226) primary -> . literal
INFO:root:    (227) primary -> . name
INFO:root:    (228) primary -> . allocator
INFO:root:    (229) primary -> . qualified
INFO:root:    (230) primary -> . parenthesized_primary
INFO:root:    (180) literal -> . INT
INFO:root:    (181) literal -> . FLOAT
INFO:root:    (182) literal -> . NuLL
INFO:root:    (149) name -> . simple_name
INFO:root:    (150) name -> . indexed_comp
INFO:root:    (151) name -> . selected_comp
INFO:root:    (152) name -> . attribute
INFO:root:    (153) name -> . operator_symbol
INFO:root:    (234) allocator -> . NEW name
INFO:root:    (235) allocator -> . NEW qualified
INFO:root:    (233) qualified -> . name TICK parenthesized_primary
INFO:root:    (231) parenthesized_primary -> . aggregate
INFO:root:    (232) parenthesized_primary -> . ( expression )
INFO:root:    (157) simple_name -> . IDENTIFIER
INFO:root:    (164) indexed_comp -> . name ( value_s )
INFO:root:    (171) selected_comp -> . name . simple_name
INFO:root:    (172) selected_comp -> . name . used_char
INFO:root:    (173) selected_comp -> . name . operator_symbol
INFO:root:    (174) selected_comp -> . name . ALL
INFO:root:    (175) attribute -> . name TICK attribute_id
INFO:root:    (163) operator_symbol -> . STRING
INFO:root:    (183) aggregate -> . ( comp_assoc )
INFO:root:    (184) aggregate -> . ( expression WITH value_s )
INFO:root:    (185) aggregate -> . ( expression WITH NuLL RECORD )
INFO:root:    (186) aggregate -> . ( NuLL RECORD )
INFO:root:
INFO:root:    NOT             shift and go to state 131
INFO:root:    ABS             shift and go to state 132
INFO:root:    INT             shift and go to state 120
INFO:root:    FLOAT           shift and go to state 128
INFO:root:    NuLL            shift and go to state 130
INFO:root:    NEW             shift and go to state 137
INFO:root:    (               shift and go to state 125
INFO:root:    IDENTIFIER      shift and go to state 33
INFO:root:    STRING          shift and go to state 149
INFO:root:
INFO:root:    literal                        shift and go to state 121
INFO:root:    allocator                      shift and go to state 122
INFO:root:    simple_name                    shift and go to state 163
INFO:root:    indexed_comp                   shift and go to state 140
INFO:root:    attribute                      shift and go to state 134
INFO:root:    name                           shift and go to state 142
INFO:root:    operator_symbol                shift and go to state 133
INFO:root:    term                           shift and go to state 369
INFO:root:    selected_comp                  shift and go to state 139
INFO:root:    factor                         shift and go to state 126
INFO:root:    aggregate                      shift and go to state 143
INFO:root:    qualified                      shift and go to state 145
INFO:root:    parenthesized_primary          shift and go to state 147
INFO:root:    primary                        shift and go to state 135
INFO:root:
INFO:root:state 231
INFO:root:
INFO:root:    (224) factor -> NOT primary .
INFO:root:
INFO:root:    *               reduce using rule 224 (factor -> NOT primary .)
INFO:root:    /               reduce using rule 224 (factor -> NOT primary .)
INFO:root:    MOD             reduce using rule 224 (factor -> NOT primary .)
INFO:root:    REM             reduce using rule 224 (factor -> NOT primary .)
INFO:root:    STARSTAR        reduce using rule 224 (factor -> NOT primary .)
INFO:root:    =               reduce using rule 224 (factor -> NOT primary .)
INFO:root:    NEQ             reduce using rule 224 (factor -> NOT primary .)
INFO:root:    <               reduce using rule 224 (factor -> NOT primary .)
INFO:root:    LEQ             reduce using rule 224 (factor -> NOT primary .)
INFO:root:    >               reduce using rule 224 (factor -> NOT primary .)
INFO:root:    GEQ             reduce using rule 224 (factor -> NOT primary .)
INFO:root:    IN              reduce using rule 224 (factor -> NOT primary .)
INFO:root:    NOT             reduce using rule 224 (factor -> NOT primary .)
INFO:root:    +               reduce using rule 224 (factor -> NOT primary .)
INFO:root:    -               reduce using rule 224 (factor -> NOT primary .)
INFO:root:    &               reduce using rule 224 (factor -> NOT primary .)
INFO:root:    AND             reduce using rule 224 (factor -> NOT primary .)
INFO:root:    OR              reduce using rule 224 (factor -> NOT primary .)
INFO:root:    XOR             reduce using rule 224 (factor -> NOT primary .)
INFO:root:    ;               reduce using rule 224 (factor -> NOT primary .)
INFO:root:    IS              reduce using rule 224 (factor -> NOT primary .)
INFO:root:    LOOP            reduce using rule 224 (factor -> NOT primary .)
INFO:root:    DOTDOT          reduce using rule 224 (factor -> NOT primary .)
INFO:root:    ARROW           reduce using rule 224 (factor -> NOT primary .)
INFO:root:    |               reduce using rule 224 (factor -> NOT primary .)
INFO:root:    DIGITS          reduce using rule 224 (factor -> NOT primary .)
INFO:root:    RANGE           reduce using rule 224 (factor -> NOT primary .)
INFO:root:    )               reduce using rule 224 (factor -> NOT primary .)
INFO:root:    ,               reduce using rule 224 (factor -> NOT primary .)
INFO:root:    WITH            reduce using rule 224 (factor -> NOT primary .)
INFO:root:    THEN            reduce using rule 224 (factor -> NOT primary .)
INFO:root:    RENAMES         reduce using rule 224 (factor -> NOT primary .)
INFO:root:    ASSIGN          reduce using rule 224 (factor -> NOT primary .)
INFO:root:
INFO:root:
INFO:root:state 232
INFO:root:
INFO:root:    (225) factor -> ABS primary .
INFO:root:
INFO:root:    *               reduce using rule 225 (factor -> ABS primary .)
INFO:root:    /               reduce using rule 225 (factor -> ABS primary .)
INFO:root:    MOD             reduce using rule 225 (factor -> ABS primary .)
INFO:root:    REM             reduce using rule 225 (factor -> ABS primary .)
INFO:root:    STARSTAR        reduce using rule 225 (factor -> ABS primary .)
INFO:root:    =               reduce using rule 225 (factor -> ABS primary .)
INFO:root:    NEQ             reduce using rule 225 (factor -> ABS primary .)
INFO:root:    <               reduce using rule 225 (factor -> ABS primary .)
INFO:root:    LEQ             reduce using rule 225 (factor -> ABS primary .)
INFO:root:    >               reduce using rule 225 (factor -> ABS primary .)
INFO:root:    GEQ             reduce using rule 225 (factor -> ABS primary .)
INFO:root:    IN              reduce using rule 225 (factor -> ABS primary .)
INFO:root:    NOT             reduce using rule 225 (factor -> ABS primary .)
INFO:root:    +               reduce using rule 225 (factor -> ABS primary .)
INFO:root:    -               reduce using rule 225 (factor -> ABS primary .)
INFO:root:    &               reduce using rule 225 (factor -> ABS primary .)
INFO:root:    AND             reduce using rule 225 (factor -> ABS primary .)
INFO:root:    OR              reduce using rule 225 (factor -> ABS primary .)
INFO:root:    XOR             reduce using rule 225 (factor -> ABS primary .)
INFO:root:    ;               reduce using rule 225 (factor -> ABS primary .)
INFO:root:    IS              reduce using rule 225 (factor -> ABS primary .)
INFO:root:    LOOP            reduce using rule 225 (factor -> ABS primary .)
INFO:root:    DOTDOT          reduce using rule 225 (factor -> ABS primary .)
INFO:root:    ARROW           reduce using rule 225 (factor -> ABS primary .)
INFO:root:    |               reduce using rule 225 (factor -> ABS primary .)
INFO:root:    DIGITS          reduce using rule 225 (factor -> ABS primary .)
INFO:root:    RANGE           reduce using rule 225 (factor -> ABS primary .)
INFO:root:    )               reduce using rule 225 (factor -> ABS primary .)
INFO:root:    ,               reduce using rule 225 (factor -> ABS primary .)
INFO:root:    WITH            reduce using rule 225 (factor -> ABS primary .)
INFO:root:    THEN            reduce using rule 225 (factor -> ABS primary .)
INFO:root:    RENAMES         reduce using rule 225 (factor -> ABS primary .)
INFO:root:    ASSIGN          reduce using rule 225 (factor -> ABS primary .)
INFO:root:
INFO:root:
INFO:root:state 233
INFO:root:
INFO:root:    (235) allocator -> NEW qualified .
INFO:root:
INFO:root:    *               reduce using rule 235 (allocator -> NEW qualified .)
INFO:root:    /               reduce using rule 235 (allocator -> NEW qualified .)
INFO:root:    MOD             reduce using rule 235 (allocator -> NEW qualified .)
INFO:root:    REM             reduce using rule 235 (allocator -> NEW qualified .)
INFO:root:    STARSTAR        reduce using rule 235 (allocator -> NEW qualified .)
INFO:root:    =               reduce using rule 235 (allocator -> NEW qualified .)
INFO:root:    NEQ             reduce using rule 235 (allocator -> NEW qualified .)
INFO:root:    <               reduce using rule 235 (allocator -> NEW qualified .)
INFO:root:    LEQ             reduce using rule 235 (allocator -> NEW qualified .)
INFO:root:    >               reduce using rule 235 (allocator -> NEW qualified .)
INFO:root:    GEQ             reduce using rule 235 (allocator -> NEW qualified .)
INFO:root:    IN              reduce using rule 235 (allocator -> NEW qualified .)
INFO:root:    NOT             reduce using rule 235 (allocator -> NEW qualified .)
INFO:root:    +               reduce using rule 235 (allocator -> NEW qualified .)
INFO:root:    -               reduce using rule 235 (allocator -> NEW qualified .)
INFO:root:    &               reduce using rule 235 (allocator -> NEW qualified .)
INFO:root:    AND             reduce using rule 235 (allocator -> NEW qualified .)
INFO:root:    OR              reduce using rule 235 (allocator -> NEW qualified .)
INFO:root:    XOR             reduce using rule 235 (allocator -> NEW qualified .)
INFO:root:    )               reduce using rule 235 (allocator -> NEW qualified .)
INFO:root:    ,               reduce using rule 235 (allocator -> NEW qualified .)
INFO:root:    DOTDOT          reduce using rule 235 (allocator -> NEW qualified .)
INFO:root:    WITH            reduce using rule 235 (allocator -> NEW qualified .)
INFO:root:    ARROW           reduce using rule 235 (allocator -> NEW qualified .)
INFO:root:    |               reduce using rule 235 (allocator -> NEW qualified .)
INFO:root:    ;               reduce using rule 235 (allocator -> NEW qualified .)
INFO:root:    IS              reduce using rule 235 (allocator -> NEW qualified .)
INFO:root:    THEN            reduce using rule 235 (allocator -> NEW qualified .)
INFO:root:    LOOP            reduce using rule 235 (allocator -> NEW qualified .)
INFO:root:    RANGE           reduce using rule 235 (allocator -> NEW qualified .)
INFO:root:    DIGITS          reduce using rule 235 (allocator -> NEW qualified .)
INFO:root:    RENAMES         reduce using rule 235 (allocator -> NEW qualified .)
INFO:root:    ASSIGN          reduce using rule 235 (allocator -> NEW qualified .)
INFO:root:
INFO:root:
INFO:root:state 234
INFO:root:
INFO:root:    (234) allocator -> NEW name .
INFO:root:    (233) qualified -> name . TICK parenthesized_primary
INFO:root:    (164) indexed_comp -> name . ( value_s )
INFO:root:    (171) selected_comp -> name . . simple_name
INFO:root:    (172) selected_comp -> name . . used_char
INFO:root:    (173) selected_comp -> name . . operator_symbol
INFO:root:    (174) selected_comp -> name . . ALL
INFO:root:    (175) attribute -> name . TICK attribute_id
INFO:root:
INFO:root:    *               reduce using rule 234 (allocator -> NEW name .)
INFO:root:    /               reduce using rule 234 (allocator -> NEW name .)
INFO:root:    MOD             reduce using rule 234 (allocator -> NEW name .)
INFO:root:    REM             reduce using rule 234 (allocator -> NEW name .)
INFO:root:    STARSTAR        reduce using rule 234 (allocator -> NEW name .)
INFO:root:    =               reduce using rule 234 (allocator -> NEW name .)
INFO:root:    NEQ             reduce using rule 234 (allocator -> NEW name .)
INFO:root:    <               reduce using rule 234 (allocator -> NEW name .)
INFO:root:    LEQ             reduce using rule 234 (allocator -> NEW name .)
INFO:root:    >               reduce using rule 234 (allocator -> NEW name .)
INFO:root:    GEQ             reduce using rule 234 (allocator -> NEW name .)
INFO:root:    IN              reduce using rule 234 (allocator -> NEW name .)
INFO:root:    NOT             reduce using rule 234 (allocator -> NEW name .)
INFO:root:    +               reduce using rule 234 (allocator -> NEW name .)
INFO:root:    -               reduce using rule 234 (allocator -> NEW name .)
INFO:root:    &               reduce using rule 234 (allocator -> NEW name .)
INFO:root:    AND             reduce using rule 234 (allocator -> NEW name .)
INFO:root:    OR              reduce using rule 234 (allocator -> NEW name .)
INFO:root:    XOR             reduce using rule 234 (allocator -> NEW name .)
INFO:root:    )               reduce using rule 234 (allocator -> NEW name .)
INFO:root:    ,               reduce using rule 234 (allocator -> NEW name .)
INFO:root:    DOTDOT          reduce using rule 234 (allocator -> NEW name .)
INFO:root:    WITH            reduce using rule 234 (allocator -> NEW name .)
INFO:root:    ARROW           reduce using rule 234 (allocator -> NEW name .)
INFO:root:    |               reduce using rule 234 (allocator -> NEW name .)
INFO:root:    ;               reduce using rule 234 (allocator -> NEW name .)
INFO:root:    IS              reduce using rule 234 (allocator -> NEW name .)
INFO:root:    THEN            reduce using rule 234 (allocator -> NEW name .)
INFO:root:    LOOP            reduce using rule 234 (allocator -> NEW name .)
INFO:root:    RANGE           reduce using rule 234 (allocator -> NEW name .)
INFO:root:    DIGITS          reduce using rule 234 (allocator -> NEW name .)
INFO:root:    RENAMES         reduce using rule 234 (allocator -> NEW name .)
INFO:root:    ASSIGN          reduce using rule 234 (allocator -> NEW name .)
INFO:root:    TICK            shift and go to state 238
INFO:root:    (               shift and go to state 237
INFO:root:    .               shift and go to state 239
INFO:root:
INFO:root:
INFO:root:state 235
INFO:root:
INFO:root:    (3) pragma -> PRAGMA simple_name ( pragma_arg_s ) . ;
INFO:root:
INFO:root:    ;               shift and go to state 370
INFO:root:
INFO:root:
INFO:root:state 236
INFO:root:
INFO:root:    (5) pragma_arg_s -> pragma_arg_s , . pragma_arg
INFO:root:    (6) pragma_arg -> . expression
INFO:root:    (7) pragma_arg -> . simple_name ARROW expression
INFO:root:    (188) expression -> . relation
INFO:root:    (189) expression -> . expression logical relation
INFO:root:    (190) expression -> . expression short_circuit relation
INFO:root:    (157) simple_name -> . IDENTIFIER
INFO:root:    (196) relation -> . simple_expression
INFO:root:    (197) relation -> . simple_expression relational simple_expression
INFO:root:    (198) relation -> . simple_expression membership range
INFO:root:    (199) relation -> . simple_expression membership name
INFO:root:    (208) simple_expression -> . unary term
INFO:root:    (209) simple_expression -> . term
INFO:root:    (210) simple_expression -> . simple_expression adding term
INFO:root:    (211) unary -> . +
INFO:root:    (212) unary -> . -
INFO:root:    (216) term -> . factor
INFO:root:    (217) term -> . term multiplying factor
INFO:root:    (223) factor -> . primary
INFO:root:    (224) factor -> . NOT primary
INFO:root:    (225) factor -> . ABS primary
INFO:root:    (226) primary -> . literal
INFO:root:    (227) primary -> . name
INFO:root:    (228) primary -> . allocator
INFO:root:    (229) primary -> . qualified
INFO:root:    (230) primary -> . parenthesized_primary
INFO:root:    (180) literal -> . INT
INFO:root:    (181) literal -> . FLOAT
INFO:root:    (182) literal -> . NuLL
INFO:root:    (149) name -> . simple_name
INFO:root:    (150) name -> . indexed_comp
INFO:root:    (151) name -> . selected_comp
INFO:root:    (152) name -> . attribute
INFO:root:    (153) name -> . operator_symbol
INFO:root:    (234) allocator -> . NEW name
INFO:root:    (235) allocator -> . NEW qualified
INFO:root:    (233) qualified -> . name TICK parenthesized_primary
INFO:root:    (231) parenthesized_primary -> . aggregate
INFO:root:    (232) parenthesized_primary -> . ( expression )
INFO:root:    (164) indexed_comp -> . name ( value_s )
INFO:root:    (171) selected_comp -> . name . simple_name
INFO:root:    (172) selected_comp -> . name . used_char
INFO:root:    (173) selected_comp -> . name . operator_symbol
INFO:root:    (174) selected_comp -> . name . ALL
INFO:root:    (175) attribute -> . name TICK attribute_id
INFO:root:    (163) operator_symbol -> . STRING
INFO:root:    (183) aggregate -> . ( comp_assoc )
INFO:root:    (184) aggregate -> . ( expression WITH value_s )
INFO:root:    (185) aggregate -> . ( expression WITH NuLL RECORD )
INFO:root:    (186) aggregate -> . ( NuLL RECORD )
INFO:root:
INFO:root:    IDENTIFIER      shift and go to state 33
INFO:root:    +               shift and go to state 148
INFO:root:    -               shift and go to state 136
INFO:root:    NOT             shift and go to state 131
INFO:root:    ABS             shift and go to state 132
INFO:root:    INT             shift and go to state 120
INFO:root:    FLOAT           shift and go to state 128
INFO:root:    NuLL            shift and go to state 130
INFO:root:    NEW             shift and go to state 137
INFO:root:    (               shift and go to state 125
INFO:root:    STRING          shift and go to state 149
INFO:root:
INFO:root:    literal                        shift and go to state 121
INFO:root:    allocator                      shift and go to state 122
INFO:root:    simple_name                    shift and go to state 123
INFO:root:    indexed_comp                   shift and go to state 140
INFO:root:    name                           shift and go to state 142
INFO:root:    pragma_arg                     shift and go to state 371
INFO:root:    selected_comp                  shift and go to state 139
INFO:root:    factor                         shift and go to state 126
INFO:root:    expression                     shift and go to state 127
INFO:root:    unary                          shift and go to state 144
INFO:root:    qualified                      shift and go to state 145
INFO:root:    aggregate                      shift and go to state 143
INFO:root:    simple_expression              shift and go to state 129
INFO:root:    term                           shift and go to state 146
INFO:root:    operator_symbol                shift and go to state 133
INFO:root:    parenthesized_primary          shift and go to state 147
INFO:root:    attribute                      shift and go to state 134
INFO:root:    primary                        shift and go to state 135
INFO:root:    relation                       shift and go to state 138
INFO:root:
INFO:root:state 237
INFO:root:
INFO:root:    (164) indexed_comp -> name ( . value_s )
INFO:root:    (165) value_s -> . value
INFO:root:    (166) value_s -> . value_s , value
INFO:root:    (167) value -> . expression
INFO:root:    (168) value -> . comp_assoc
INFO:root:    (169) value -> . discrete_with_range
INFO:root:    (170) value -> . error
INFO:root:    (188) expression -> . relation
INFO:root:    (189) expression -> . expression logical relation
INFO:root:    (190) expression -> . expression short_circuit relation
INFO:root:    (187) comp_assoc -> . choice_s ARROW expression
INFO:root:    (126) discrete_with_range -> . name range_constraint
INFO:root:    (127) discrete_with_range -> . range
INFO:root:    (196) relation -> . simple_expression
INFO:root:    (197) relation -> . simple_expression relational simple_expression
INFO:root:    (198) relation -> . simple_expression membership range
INFO:root:    (199) relation -> . simple_expression membership name
INFO:root:    (121) choice_s -> . choice
INFO:root:    (122) choice_s -> . choice_s | choice
INFO:root:    (149) name -> . simple_name
INFO:root:    (150) name -> . indexed_comp
INFO:root:    (151) name -> . selected_comp
INFO:root:    (152) name -> . attribute
INFO:root:    (153) name -> . operator_symbol
INFO:root:    (62) range -> . simple_expression DOTDOT simple_expression
INFO:root:    (208) simple_expression -> . unary term
INFO:root:    (209) simple_expression -> . term
INFO:root:    (210) simple_expression -> . simple_expression adding term
INFO:root:    (123) choice -> . expression
INFO:root:    (124) choice -> . discrete_with_range
INFO:root:    (125) choice -> . OTHERS
INFO:root:    (157) simple_name -> . IDENTIFIER
INFO:root:    (164) indexed_comp -> . name ( value_s )
INFO:root:    (171) selected_comp -> . name . simple_name
INFO:root:    (172) selected_comp -> . name . used_char
INFO:root:    (173) selected_comp -> . name . operator_symbol
INFO:root:    (174) selected_comp -> . name . ALL
INFO:root:    (175) attribute -> . name TICK attribute_id
INFO:root:    (163) operator_symbol -> . STRING
INFO:root:    (211) unary -> . +
INFO:root:    (212) unary -> . -
INFO:root:    (216) term -> . factor
INFO:root:    (217) term -> . term multiplying factor
INFO:root:    (223) factor -> . primary
INFO:root:    (224) factor -> . NOT primary
INFO:root:    (225) factor -> . ABS primary
INFO:root:    (226) primary -> . literal
INFO:root:    (227) primary -> . name
INFO:root:    (228) primary -> . allocator
INFO:root:    (229) primary -> . qualified
INFO:root:    (230) primary -> . parenthesized_primary
INFO:root:    (180) literal -> . INT
INFO:root:    (181) literal -> . FLOAT
INFO:root:    (182) literal -> . NuLL
INFO:root:    (234) allocator -> . NEW name
INFO:root:    (235) allocator -> . NEW qualified
INFO:root:    (233) qualified -> . name TICK parenthesized_primary
INFO:root:    (231) parenthesized_primary -> . aggregate
INFO:root:    (232) parenthesized_primary -> . ( expression )
INFO:root:    (183) aggregate -> . ( comp_assoc )
INFO:root:    (184) aggregate -> . ( expression WITH value_s )
INFO:root:    (185) aggregate -> . ( expression WITH NuLL RECORD )
INFO:root:    (186) aggregate -> . ( NuLL RECORD )
INFO:root:
INFO:root:    error           shift and go to state 379
INFO:root:    OTHERS          shift and go to state 204
INFO:root:    IDENTIFIER      shift and go to state 33
INFO:root:    STRING          shift and go to state 149
INFO:root:    +               shift and go to state 148
INFO:root:    -               shift and go to state 136
INFO:root:    NOT             shift and go to state 131
INFO:root:    ABS             shift and go to state 132
INFO:root:    INT             shift and go to state 120
INFO:root:    FLOAT           shift and go to state 128
INFO:root:    NuLL            shift and go to state 130
INFO:root:    NEW             shift and go to state 137
INFO:root:    (               shift and go to state 125
INFO:root:
INFO:root:    value                          shift and go to state 372
INFO:root:    comp_assoc                     shift and go to state 376
INFO:root:    factor                         shift and go to state 126
INFO:root:    indexed_comp                   shift and go to state 140
INFO:root:    name                           shift and go to state 377
INFO:root:    literal                        shift and go to state 121
INFO:root:    selected_comp                  shift and go to state 139
INFO:root:    simple_name                    shift and go to state 163
INFO:root:    expression                     shift and go to state 373
INFO:root:    discrete_with_range            shift and go to state 378
INFO:root:    parenthesized_primary          shift and go to state 147
INFO:root:    unary                          shift and go to state 144
INFO:root:    term                           shift and go to state 146
INFO:root:    aggregate                      shift and go to state 143
INFO:root:    simple_expression              shift and go to state 374
INFO:root:    value_s                        shift and go to state 375
INFO:root:    operator_symbol                shift and go to state 133
INFO:root:    qualified                      shift and go to state 145
INFO:root:    choice_s                       shift and go to state 202
INFO:root:    primary                        shift and go to state 135
INFO:root:    attribute                      shift and go to state 134
INFO:root:    relation                       shift and go to state 138
INFO:root:    range                          shift and go to state 211
INFO:root:    allocator                      shift and go to state 122
INFO:root:    choice                         shift and go to state 207
INFO:root:
INFO:root:state 238
INFO:root:
INFO:root:    (233) qualified -> name TICK . parenthesized_primary
INFO:root:    (175) attribute -> name TICK . attribute_id
INFO:root:    (231) parenthesized_primary -> . aggregate
INFO:root:    (232) parenthesized_primary -> . ( expression )
INFO:root:    (176) attribute_id -> . IDENTIFIER
INFO:root:    (177) attribute_id -> . DIGITS
INFO:root:    (178) attribute_id -> . DELTA
INFO:root:    (179) attribute_id -> . ACCESS
INFO:root:    (183) aggregate -> . ( comp_assoc )
INFO:root:    (184) aggregate -> . ( expression WITH value_s )
INFO:root:    (185) aggregate -> . ( expression WITH NuLL RECORD )
INFO:root:    (186) aggregate -> . ( NuLL RECORD )
INFO:root:
INFO:root:    (               shift and go to state 125
INFO:root:    IDENTIFIER      shift and go to state 380
INFO:root:    DIGITS          shift and go to state 385
INFO:root:    DELTA           shift and go to state 382
INFO:root:    ACCESS          shift and go to state 381
INFO:root:
INFO:root:    aggregate                      shift and go to state 143
INFO:root:    attribute_id                   shift and go to state 383
INFO:root:    parenthesized_primary          shift and go to state 384
INFO:root:
INFO:root:state 239
INFO:root:
INFO:root:    (171) selected_comp -> name . . simple_name
INFO:root:    (172) selected_comp -> name . . used_char
INFO:root:    (173) selected_comp -> name . . operator_symbol
INFO:root:    (174) selected_comp -> name . . ALL
INFO:root:    (157) simple_name -> . IDENTIFIER
INFO:root:    (162) used_char -> . CHAR
INFO:root:    (163) operator_symbol -> . STRING
INFO:root:
INFO:root:    ALL             shift and go to state 386
INFO:root:    IDENTIFIER      shift and go to state 33
INFO:root:    CHAR            shift and go to state 388
INFO:root:    STRING          shift and go to state 149
INFO:root:
INFO:root:    used_char                      shift and go to state 390
INFO:root:    simple_name                    shift and go to state 387
INFO:root:    operator_symbol                shift and go to state 389
INFO:root:
INFO:root:state 240
INFO:root:
INFO:root:    (208) simple_expression -> unary term .
INFO:root:    (217) term -> term . multiplying factor
INFO:root:    (218) multiplying -> . *
INFO:root:    (219) multiplying -> . /
INFO:root:    (220) multiplying -> . MOD
INFO:root:    (221) multiplying -> . REM
INFO:root:    (222) multiplying -> . STARSTAR
INFO:root:
INFO:root:    DOTDOT          reduce using rule 208 (simple_expression -> unary term .)
INFO:root:    +               reduce using rule 208 (simple_expression -> unary term .)
INFO:root:    -               reduce using rule 208 (simple_expression -> unary term .)
INFO:root:    &               reduce using rule 208 (simple_expression -> unary term .)
INFO:root:    =               reduce using rule 208 (simple_expression -> unary term .)
INFO:root:    NEQ             reduce using rule 208 (simple_expression -> unary term .)
INFO:root:    <               reduce using rule 208 (simple_expression -> unary term .)
INFO:root:    LEQ             reduce using rule 208 (simple_expression -> unary term .)
INFO:root:    >               reduce using rule 208 (simple_expression -> unary term .)
INFO:root:    GEQ             reduce using rule 208 (simple_expression -> unary term .)
INFO:root:    IN              reduce using rule 208 (simple_expression -> unary term .)
INFO:root:    NOT             reduce using rule 208 (simple_expression -> unary term .)
INFO:root:    DIGITS          reduce using rule 208 (simple_expression -> unary term .)
INFO:root:    AND             reduce using rule 208 (simple_expression -> unary term .)
INFO:root:    OR              reduce using rule 208 (simple_expression -> unary term .)
INFO:root:    XOR             reduce using rule 208 (simple_expression -> unary term .)
INFO:root:    RANGE           reduce using rule 208 (simple_expression -> unary term .)
INFO:root:    ARROW           reduce using rule 208 (simple_expression -> unary term .)
INFO:root:    |               reduce using rule 208 (simple_expression -> unary term .)
INFO:root:    )               reduce using rule 208 (simple_expression -> unary term .)
INFO:root:    ,               reduce using rule 208 (simple_expression -> unary term .)
INFO:root:    WITH            reduce using rule 208 (simple_expression -> unary term .)
INFO:root:    ;               reduce using rule 208 (simple_expression -> unary term .)
INFO:root:    IS              reduce using rule 208 (simple_expression -> unary term .)
INFO:root:    THEN            reduce using rule 208 (simple_expression -> unary term .)
INFO:root:    LOOP            reduce using rule 208 (simple_expression -> unary term .)
INFO:root:    RENAMES         reduce using rule 208 (simple_expression -> unary term .)
INFO:root:    ASSIGN          reduce using rule 208 (simple_expression -> unary term .)
INFO:root:    *               shift and go to state 243
INFO:root:    /               shift and go to state 246
INFO:root:    MOD             shift and go to state 241
INFO:root:    REM             shift and go to state 242
INFO:root:    STARSTAR        shift and go to state 245
INFO:root:
INFO:root:    multiplying                    shift and go to state 244
INFO:root:
INFO:root:state 241
INFO:root:
INFO:root:    (220) multiplying -> MOD .
INFO:root:
INFO:root:    NOT             reduce using rule 220 (multiplying -> MOD .)
INFO:root:    ABS             reduce using rule 220 (multiplying -> MOD .)
INFO:root:    INT             reduce using rule 220 (multiplying -> MOD .)
INFO:root:    FLOAT           reduce using rule 220 (multiplying -> MOD .)
INFO:root:    NuLL            reduce using rule 220 (multiplying -> MOD .)
INFO:root:    NEW             reduce using rule 220 (multiplying -> MOD .)
INFO:root:    (               reduce using rule 220 (multiplying -> MOD .)
INFO:root:    IDENTIFIER      reduce using rule 220 (multiplying -> MOD .)
INFO:root:    STRING          reduce using rule 220 (multiplying -> MOD .)
INFO:root:
INFO:root:
INFO:root:state 242
INFO:root:
INFO:root:    (221) multiplying -> REM .
INFO:root:
INFO:root:    NOT             reduce using rule 221 (multiplying -> REM .)
INFO:root:    ABS             reduce using rule 221 (multiplying -> REM .)
INFO:root:    INT             reduce using rule 221 (multiplying -> REM .)
INFO:root:    FLOAT           reduce using rule 221 (multiplying -> REM .)
INFO:root:    NuLL            reduce using rule 221 (multiplying -> REM .)
INFO:root:    NEW             reduce using rule 221 (multiplying -> REM .)
INFO:root:    (               reduce using rule 221 (multiplying -> REM .)
INFO:root:    IDENTIFIER      reduce using rule 221 (multiplying -> REM .)
INFO:root:    STRING          reduce using rule 221 (multiplying -> REM .)
INFO:root:
INFO:root:
INFO:root:state 243
INFO:root:
INFO:root:    (218) multiplying -> * .
INFO:root:
INFO:root:    NOT             reduce using rule 218 (multiplying -> * .)
INFO:root:    ABS             reduce using rule 218 (multiplying -> * .)
INFO:root:    INT             reduce using rule 218 (multiplying -> * .)
INFO:root:    FLOAT           reduce using rule 218 (multiplying -> * .)
INFO:root:    NuLL            reduce using rule 218 (multiplying -> * .)
INFO:root:    NEW             reduce using rule 218 (multiplying -> * .)
INFO:root:    (               reduce using rule 218 (multiplying -> * .)
INFO:root:    IDENTIFIER      reduce using rule 218 (multiplying -> * .)
INFO:root:    STRING          reduce using rule 218 (multiplying -> * .)
INFO:root:
INFO:root:
INFO:root:state 244
INFO:root:
INFO:root:    (217) term -> term multiplying . factor
INFO:root:    (223) factor -> . primary
INFO:root:    (224) factor -> . NOT primary
INFO:root:    (225) factor -> . ABS primary
INFO:root:    (226) primary -> . literal
INFO:root:    (227) primary -> . name
INFO:root:    (228) primary -> . allocator
INFO:root:    (229) primary -> . qualified
INFO:root:    (230) primary -> . parenthesized_primary
INFO:root:    (180) literal -> . INT
INFO:root:    (181) literal -> . FLOAT
INFO:root:    (182) literal -> . NuLL
INFO:root:    (149) name -> . simple_name
INFO:root:    (150) name -> . indexed_comp
INFO:root:    (151) name -> . selected_comp
INFO:root:    (152) name -> . attribute
INFO:root:    (153) name -> . operator_symbol
INFO:root:    (234) allocator -> . NEW name
INFO:root:    (235) allocator -> . NEW qualified
INFO:root:    (233) qualified -> . name TICK parenthesized_primary
INFO:root:    (231) parenthesized_primary -> . aggregate
INFO:root:    (232) parenthesized_primary -> . ( expression )
INFO:root:    (157) simple_name -> . IDENTIFIER
INFO:root:    (164) indexed_comp -> . name ( value_s )
INFO:root:    (171) selected_comp -> . name . simple_name
INFO:root:    (172) selected_comp -> . name . used_char
INFO:root:    (173) selected_comp -> . name . operator_symbol
INFO:root:    (174) selected_comp -> . name . ALL
INFO:root:    (175) attribute -> . name TICK attribute_id
INFO:root:    (163) operator_symbol -> . STRING
INFO:root:    (183) aggregate -> . ( comp_assoc )
INFO:root:    (184) aggregate -> . ( expression WITH value_s )
INFO:root:    (185) aggregate -> . ( expression WITH NuLL RECORD )
INFO:root:    (186) aggregate -> . ( NuLL RECORD )
INFO:root:
INFO:root:    NOT             shift and go to state 131
INFO:root:    ABS             shift and go to state 132
INFO:root:    INT             shift and go to state 120
INFO:root:    FLOAT           shift and go to state 128
INFO:root:    NuLL            shift and go to state 130
INFO:root:    NEW             shift and go to state 137
INFO:root:    (               shift and go to state 125
INFO:root:    IDENTIFIER      shift and go to state 33
INFO:root:    STRING          shift and go to state 149
INFO:root:
INFO:root:    literal                        shift and go to state 121
INFO:root:    allocator                      shift and go to state 122
INFO:root:    indexed_comp                   shift and go to state 140
INFO:root:    attribute                      shift and go to state 134
INFO:root:    name                           shift and go to state 142
INFO:root:    operator_symbol                shift and go to state 133
INFO:root:    parenthesized_primary          shift and go to state 147
INFO:root:    primary                        shift and go to state 135
INFO:root:    selected_comp                  shift and go to state 139
INFO:root:    factor                         shift and go to state 391
INFO:root:    simple_name                    shift and go to state 163
INFO:root:    aggregate                      shift and go to state 143
INFO:root:    qualified                      shift and go to state 145
INFO:root:
INFO:root:state 245
INFO:root:
INFO:root:    (222) multiplying -> STARSTAR .
INFO:root:
INFO:root:    NOT             reduce using rule 222 (multiplying -> STARSTAR .)
INFO:root:    ABS             reduce using rule 222 (multiplying -> STARSTAR .)
INFO:root:    INT             reduce using rule 222 (multiplying -> STARSTAR .)
INFO:root:    FLOAT           reduce using rule 222 (multiplying -> STARSTAR .)
INFO:root:    NuLL            reduce using rule 222 (multiplying -> STARSTAR .)
INFO:root:    NEW             reduce using rule 222 (multiplying -> STARSTAR .)
INFO:root:    (               reduce using rule 222 (multiplying -> STARSTAR .)
INFO:root:    IDENTIFIER      reduce using rule 222 (multiplying -> STARSTAR .)
INFO:root:    STRING          reduce using rule 222 (multiplying -> STARSTAR .)
INFO:root:
INFO:root:
INFO:root:state 246
INFO:root:
INFO:root:    (219) multiplying -> / .
INFO:root:
INFO:root:    NOT             reduce using rule 219 (multiplying -> / .)
INFO:root:    ABS             reduce using rule 219 (multiplying -> / .)
INFO:root:    INT             reduce using rule 219 (multiplying -> / .)
INFO:root:    FLOAT           reduce using rule 219 (multiplying -> / .)
INFO:root:    NuLL            reduce using rule 219 (multiplying -> / .)
INFO:root:    NEW             reduce using rule 219 (multiplying -> / .)
INFO:root:    (               reduce using rule 219 (multiplying -> / .)
INFO:root:    IDENTIFIER      reduce using rule 219 (multiplying -> / .)
INFO:root:    STRING          reduce using rule 219 (multiplying -> / .)
INFO:root:
INFO:root:
INFO:root:state 247
INFO:root:
INFO:root:    (311) formal_part -> ( param_s . )
INFO:root:    (313) param_s -> param_s . ; param
INFO:root:
INFO:root:    )               shift and go to state 393
INFO:root:    ;               shift and go to state 392
INFO:root:
INFO:root:
INFO:root:state 248
INFO:root:
INFO:root:    (312) param_s -> param .
INFO:root:
INFO:root:    )               reduce using rule 312 (param_s -> param .)
INFO:root:    ;               reduce using rule 312 (param_s -> param .)
INFO:root:
INFO:root:
INFO:root:state 249
INFO:root:
INFO:root:    (465) generic_formal -> WITH FUNCTION designator . formal_part_opt RETURN name subp_default ;
INFO:root:    (309) formal_part_opt -> .
INFO:root:    (310) formal_part_opt -> . formal_part
INFO:root:    (311) formal_part -> . ( param_s )
INFO:root:
INFO:root:    RETURN          reduce using rule 309 (formal_part_opt -> .)
INFO:root:    (               shift and go to state 151
INFO:root:
INFO:root:    formal_part_opt                shift and go to state 394
INFO:root:    formal_part                    shift and go to state 152
INFO:root:
INFO:root:state 250
INFO:root:
INFO:root:    (464) generic_formal -> WITH PROCEDURE simple_name . formal_part_opt subp_default ;
INFO:root:    (309) formal_part_opt -> .
INFO:root:    (310) formal_part_opt -> . formal_part
INFO:root:    (311) formal_part -> . ( param_s )
INFO:root:
INFO:root:    IS              reduce using rule 309 (formal_part_opt -> .)
INFO:root:    ;               reduce using rule 309 (formal_part_opt -> .)
INFO:root:    (               shift and go to state 151
INFO:root:
INFO:root:    formal_part                    shift and go to state 152
INFO:root:    formal_part_opt                shift and go to state 395
INFO:root:
INFO:root:state 251
INFO:root:
INFO:root:    (466) generic_formal -> WITH PACKAGE simple_name . IS NEW name ( BOX ) ;
INFO:root:    (467) generic_formal -> WITH PACKAGE simple_name . IS NEW name ;
INFO:root:
INFO:root:    IS              shift and go to state 396
INFO:root:
INFO:root:
INFO:root:state 252
INFO:root:
INFO:root:    (346) rename_unit -> generic_formal_part PACKAGE compound_name renames . ;
INFO:root:
INFO:root:    ;               shift and go to state 397
INFO:root:
INFO:root:
INFO:root:state 253
INFO:root:
INFO:root:    (326) pkg_spec -> PACKAGE compound_name IS . decl_item_s private_part END c_id_opt
INFO:root:    (133) decl_item_s -> .
INFO:root:    (134) decl_item_s -> . decl_item_s1
INFO:root:    (135) decl_item_s1 -> . decl_item
INFO:root:    (136) decl_item_s1 -> . decl_item_s1 decl_item
INFO:root:    (137) decl_item -> . decl
INFO:root:    (138) decl_item -> . use_clause
INFO:root:    (139) decl_item -> . rep_spec
INFO:root:    (140) decl_item -> . pragma
INFO:root:    (10) decl -> . object_decl
INFO:root:    (11) decl -> . number_decl
INFO:root:    (12) decl -> . type_decl
INFO:root:    (13) decl -> . subtype_decl
INFO:root:    (14) decl -> . subprog_decl
INFO:root:    (15) decl -> . pkg_decl
INFO:root:    (16) decl -> . task_decl
INFO:root:    (17) decl -> . prot_decl
INFO:root:    (18) decl -> . exception_decl
INFO:root:    (19) decl -> . rename_decl
INFO:root:    (20) decl -> . generic_decl
INFO:root:    (21) decl -> . body_stub
INFO:root:    (22) decl -> . error ;
INFO:root:    (337) use_clause -> . USE name_s ;
INFO:root:    (338) use_clause -> . USE TYPE name_s ;
INFO:root:    (491) rep_spec -> . attrib_def
INFO:root:    (492) rep_spec -> . record_type_spec
INFO:root:    (493) rep_spec -> . address_spec
INFO:root:    (2) pragma -> . PRAGMA IDENTIFIER ;
INFO:root:    (3) pragma -> . PRAGMA simple_name ( pragma_arg_s ) ;
INFO:root:    (23) object_decl -> . def_id_s : object_qualifier_opt object_subtype_def init_opt ;
INFO:root:    (35) number_decl -> . def_id_s : CONSTANT ASSIGN expression ;
INFO:root:    (36) type_decl -> . TYPE IDENTIFIER discrim_part_opt type_completion ;
INFO:root:    (50) subtype_decl -> . SUBTYPE IDENTIFIER IS subtype_ind ;
INFO:root:    (301) subprog_decl -> . subprog_spec ;
INFO:root:    (302) subprog_decl -> . generic_subp_inst ;
INFO:root:    (303) subprog_decl -> . subprog_spec_is_push ABSTRACT ;
INFO:root:    (324) pkg_decl -> . pkg_spec ;
INFO:root:    (325) pkg_decl -> . generic_pkg_inst ;
INFO:root:    (349) task_decl -> . task_spec ;
INFO:root:    (357) prot_decl -> . prot_spec ;
INFO:root:    (446) exception_decl -> . def_id_s : EXCEPTION ;
INFO:root:    (341) rename_decl -> . def_id_s : object_qualifier_opt subtype_ind renames ;
INFO:root:    (342) rename_decl -> . def_id_s : EXCEPTION renames ;
INFO:root:    (343) rename_decl -> . rename_unit
INFO:root:    (458) generic_decl -> . generic_formal_part subprog_spec ;
INFO:root:    (459) generic_decl -> . generic_formal_part pkg_spec ;
INFO:root:    (442) body_stub -> . TASK BODY simple_name IS SEPARATE ;
INFO:root:    (443) body_stub -> . PACKAGE BODY compound_name IS SEPARATE ;
INFO:root:    (444) body_stub -> . subprog_spec IS SEPARATE ;
INFO:root:    (445) body_stub -> . PROTECTED BODY simple_name IS SEPARATE ;
INFO:root:    (494) attrib_def -> . FOR mark USE expression ;
INFO:root:    (495) record_type_spec -> . FOR mark USE RECORD align_opt comp_loc_s END RECORD ;
INFO:root:    (500) address_spec -> . FOR mark USE AT expression ;
INFO:root:    (24) def_id_s -> . def_id
INFO:root:    (25) def_id_s -> . def_id_s , def_id
INFO:root:    (304) subprog_spec -> . PROCEDURE compound_name formal_part_opt
INFO:root:    (305) subprog_spec -> . FUNCTION designator formal_part_opt RETURN name
INFO:root:    (306) subprog_spec -> . FUNCTION designator
INFO:root:    (488) generic_subp_inst -> . subprog_spec IS generic_inst
INFO:root:    (321) subprog_spec_is_push -> . subprog_spec IS
INFO:root:    (326) pkg_spec -> . PACKAGE compound_name IS decl_item_s private_part END c_id_opt
INFO:root:    (489) generic_pkg_inst -> . PACKAGE compound_name IS generic_inst
INFO:root:    (350) task_spec -> . TASK simple_name task_def
INFO:root:    (351) task_spec -> . TASK TYPE simple_name discrim_part_opt task_def
INFO:root:    (358) prot_spec -> . PROTECTED IDENTIFIER prot_def
INFO:root:    (359) prot_spec -> . PROTECTED TYPE simple_name discrim_part_opt prot_def
INFO:root:    (344) rename_unit -> . PACKAGE compound_name renames ;
INFO:root:    (345) rename_unit -> . subprog_spec renames ;
INFO:root:    (346) rename_unit -> . generic_formal_part PACKAGE compound_name renames ;
INFO:root:    (347) rename_unit -> . generic_formal_part subprog_spec renames ;
INFO:root:    (460) generic_formal_part -> . GENERIC
INFO:root:    (461) generic_formal_part -> . generic_formal_part generic_formal
INFO:root:    (26) def_id -> . IDENTIFIER
INFO:root:
INFO:root:    PRIVATE         reduce using rule 133 (decl_item_s -> .)
INFO:root:    END             reduce using rule 133 (decl_item_s -> .)
INFO:root:    error           shift and go to state 107
INFO:root:    USE             shift and go to state 53
INFO:root:    PRAGMA          shift and go to state 2
INFO:root:    TYPE            shift and go to state 74
INFO:root:    SUBTYPE         shift and go to state 110
INFO:root:    TASK            shift and go to state 275
INFO:root:    PACKAGE         shift and go to state 271
INFO:root:    PROTECTED       shift and go to state 277
INFO:root:    FOR             shift and go to state 102
INFO:root:    PROCEDURE       shift and go to state 17
INFO:root:    FUNCTION        shift and go to state 23
INFO:root:    GENERIC         shift and go to state 26
INFO:root:    IDENTIFIER      shift and go to state 52
INFO:root:
INFO:root:    generic_formal_part            shift and go to state 20
INFO:root:    pkg_decl                       shift and go to state 93
INFO:root:    pragma                         shift and go to state 94
INFO:root:    prot_decl                      shift and go to state 95
INFO:root:    task_decl                      shift and go to state 76
INFO:root:    generic_decl                   shift and go to state 88
INFO:root:    subprog_decl                   shift and go to state 77
INFO:root:    type_decl                      shift and go to state 81
INFO:root:    def_id_s                       shift and go to state 79
INFO:root:    generic_pkg_inst               shift and go to state 19
INFO:root:    def_id                         shift and go to state 57
INFO:root:    rep_spec                       shift and go to state 72
INFO:root:    use_clause                     shift and go to state 97
INFO:root:    decl_item_s1                   shift and go to state 276
INFO:root:    rename_decl                    shift and go to state 98
INFO:root:    body_stub                      shift and go to state 80
INFO:root:    address_spec                   shift and go to state 83
INFO:root:    task_spec                      shift and go to state 82
INFO:root:    exception_decl                 shift and go to state 91
INFO:root:    number_decl                    shift and go to state 101
INFO:root:    generic_subp_inst              shift and go to state 24
INFO:root:    decl_item_s                    shift and go to state 278
INFO:root:    prot_spec                      shift and go to state 85
INFO:root:    rename_unit                    shift and go to state 104
INFO:root:    subprog_spec                   shift and go to state 273
INFO:root:    object_decl                    shift and go to state 87
INFO:root:    subtype_decl                   shift and go to state 105
INFO:root:    pkg_spec                       shift and go to state 16
INFO:root:    record_type_spec               shift and go to state 108
INFO:root:    decl                           shift and go to state 109
INFO:root:    decl_item                      shift and go to state 272
INFO:root:    attrib_def                     shift and go to state 92
INFO:root:    subprog_spec_is_push           shift and go to state 279
INFO:root:
INFO:root:state 254
INFO:root:
INFO:root:    (471) generic_discrim_part_opt -> ( . BOX )
INFO:root:    (110) discrim_part -> ( . discrim_spec_s )
INFO:root:    (111) discrim_spec_s -> . discrim_spec
INFO:root:    (112) discrim_spec_s -> . discrim_spec_s ; discrim_spec
INFO:root:    (113) discrim_spec -> . def_id_s : access_opt mark init_opt
INFO:root:    (114) discrim_spec -> . error
INFO:root:    (24) def_id_s -> . def_id
INFO:root:    (25) def_id_s -> . def_id_s , def_id
INFO:root:    (26) def_id -> . IDENTIFIER
INFO:root:
INFO:root:    BOX             shift and go to state 398
INFO:root:    error           shift and go to state 399
INFO:root:    IDENTIFIER      shift and go to state 52
INFO:root:
INFO:root:    def_id                         shift and go to state 57
INFO:root:    def_id_s                       shift and go to state 400
INFO:root:    discrim_spec                   shift and go to state 401
INFO:root:    discrim_spec_s                 shift and go to state 402
INFO:root:
INFO:root:state 255
INFO:root:
INFO:root:    (470) generic_discrim_part_opt -> discrim_part .
INFO:root:
INFO:root:    IS              reduce using rule 470 (generic_discrim_part_opt -> discrim_part .)
INFO:root:
INFO:root:
INFO:root:state 256
INFO:root:
INFO:root:    (463) generic_formal -> TYPE simple_name generic_discrim_part_opt . IS generic_type_def ;
INFO:root:
INFO:root:    IS              shift and go to state 403
INFO:root:
INFO:root:
INFO:root:state 257
INFO:root:
INFO:root:    (347) rename_unit -> generic_formal_part subprog_spec renames ; .
INFO:root:
INFO:root:    error           reduce using rule 347 (rename_unit -> generic_formal_part subprog_spec renames ; .)
INFO:root:    USE             reduce using rule 347 (rename_unit -> generic_formal_part subprog_spec renames ; .)
INFO:root:    PRAGMA          reduce using rule 347 (rename_unit -> generic_formal_part subprog_spec renames ; .)
INFO:root:    TYPE            reduce using rule 347 (rename_unit -> generic_formal_part subprog_spec renames ; .)
INFO:root:    SUBTYPE         reduce using rule 347 (rename_unit -> generic_formal_part subprog_spec renames ; .)
INFO:root:    TASK            reduce using rule 347 (rename_unit -> generic_formal_part subprog_spec renames ; .)
INFO:root:    PACKAGE         reduce using rule 347 (rename_unit -> generic_formal_part subprog_spec renames ; .)
INFO:root:    PROTECTED       reduce using rule 347 (rename_unit -> generic_formal_part subprog_spec renames ; .)
INFO:root:    FOR             reduce using rule 347 (rename_unit -> generic_formal_part subprog_spec renames ; .)
INFO:root:    PROCEDURE       reduce using rule 347 (rename_unit -> generic_formal_part subprog_spec renames ; .)
INFO:root:    FUNCTION        reduce using rule 347 (rename_unit -> generic_formal_part subprog_spec renames ; .)
INFO:root:    GENERIC         reduce using rule 347 (rename_unit -> generic_formal_part subprog_spec renames ; .)
INFO:root:    IDENTIFIER      reduce using rule 347 (rename_unit -> generic_formal_part subprog_spec renames ; .)
INFO:root:    END             reduce using rule 347 (rename_unit -> generic_formal_part subprog_spec renames ; .)
INFO:root:    BEGIN           reduce using rule 347 (rename_unit -> generic_formal_part subprog_spec renames ; .)
INFO:root:    PRIVATE         reduce using rule 347 (rename_unit -> generic_formal_part subprog_spec renames ; .)
INFO:root:    WITH            reduce using rule 347 (rename_unit -> generic_formal_part subprog_spec renames ; .)
INFO:root:    SEPARATE        reduce using rule 347 (rename_unit -> generic_formal_part subprog_spec renames ; .)
INFO:root:    $end            reduce using rule 347 (rename_unit -> generic_formal_part subprog_spec renames ; .)
INFO:root:
INFO:root:
INFO:root:state 258
INFO:root:
INFO:root:    (340) name_s -> name_s , . name
INFO:root:    (149) name -> . simple_name
INFO:root:    (150) name -> . indexed_comp
INFO:root:    (151) name -> . selected_comp
INFO:root:    (152) name -> . attribute
INFO:root:    (153) name -> . operator_symbol
INFO:root:    (157) simple_name -> . IDENTIFIER
INFO:root:    (164) indexed_comp -> . name ( value_s )
INFO:root:    (171) selected_comp -> . name . simple_name
INFO:root:    (172) selected_comp -> . name . used_char
INFO:root:    (173) selected_comp -> . name . operator_symbol
INFO:root:    (174) selected_comp -> . name . ALL
INFO:root:    (175) attribute -> . name TICK attribute_id
INFO:root:    (163) operator_symbol -> . STRING
INFO:root:
INFO:root:    IDENTIFIER      shift and go to state 33
INFO:root:    STRING          shift and go to state 149
INFO:root:
INFO:root:    selected_comp                  shift and go to state 139
INFO:root:    simple_name                    shift and go to state 163
INFO:root:    indexed_comp                   shift and go to state 140
INFO:root:    attribute                      shift and go to state 134
INFO:root:    name                           shift and go to state 404
INFO:root:    operator_symbol                shift and go to state 133
INFO:root:
INFO:root:state 259
INFO:root:
INFO:root:    (337) use_clause -> USE name_s ; .
INFO:root:
INFO:root:    PACKAGE         reduce using rule 337 (use_clause -> USE name_s ; .)
INFO:root:    TASK            reduce using rule 337 (use_clause -> USE name_s ; .)
INFO:root:    PROTECTED       reduce using rule 337 (use_clause -> USE name_s ; .)
INFO:root:    error           reduce using rule 337 (use_clause -> USE name_s ; .)
INFO:root:    USE             reduce using rule 337 (use_clause -> USE name_s ; .)
INFO:root:    PRAGMA          reduce using rule 337 (use_clause -> USE name_s ; .)
INFO:root:    TYPE            reduce using rule 337 (use_clause -> USE name_s ; .)
INFO:root:    SUBTYPE         reduce using rule 337 (use_clause -> USE name_s ; .)
INFO:root:    FOR             reduce using rule 337 (use_clause -> USE name_s ; .)
INFO:root:    PROCEDURE       reduce using rule 337 (use_clause -> USE name_s ; .)
INFO:root:    FUNCTION        reduce using rule 337 (use_clause -> USE name_s ; .)
INFO:root:    GENERIC         reduce using rule 337 (use_clause -> USE name_s ; .)
INFO:root:    IDENTIFIER      reduce using rule 337 (use_clause -> USE name_s ; .)
INFO:root:    BEGIN           reduce using rule 337 (use_clause -> USE name_s ; .)
INFO:root:    END             reduce using rule 337 (use_clause -> USE name_s ; .)
INFO:root:    PRIVATE         reduce using rule 337 (use_clause -> USE name_s ; .)
INFO:root:    WITH            reduce using rule 337 (use_clause -> USE name_s ; .)
INFO:root:    SEPARATE        reduce using rule 337 (use_clause -> USE name_s ; .)
INFO:root:
INFO:root:
INFO:root:state 260
INFO:root:
INFO:root:    (175) attribute -> name TICK . attribute_id
INFO:root:    (176) attribute_id -> . IDENTIFIER
INFO:root:    (177) attribute_id -> . DIGITS
INFO:root:    (178) attribute_id -> . DELTA
INFO:root:    (179) attribute_id -> . ACCESS
INFO:root:
INFO:root:    IDENTIFIER      shift and go to state 380
INFO:root:    DIGITS          shift and go to state 385
INFO:root:    DELTA           shift and go to state 382
INFO:root:    ACCESS          shift and go to state 381
INFO:root:
INFO:root:    attribute_id                   shift and go to state 383
INFO:root:
INFO:root:state 261
INFO:root:
INFO:root:    (338) use_clause -> USE TYPE name_s . ;
INFO:root:    (340) name_s -> name_s . , name
INFO:root:
INFO:root:    ;               shift and go to state 405
INFO:root:    ,               shift and go to state 258
INFO:root:
INFO:root:
INFO:root:state 262
INFO:root:
INFO:root:    (25) def_id_s -> def_id_s , def_id .
INFO:root:
INFO:root:    :               reduce using rule 25 (def_id_s -> def_id_s , def_id .)
INFO:root:    ,               reduce using rule 25 (def_id_s -> def_id_s , def_id .)
INFO:root:
INFO:root:
INFO:root:state 263
INFO:root:
INFO:root:    (320) mode -> ACCESS .
INFO:root:
INFO:root:    IDENTIFIER      reduce using rule 320 (mode -> ACCESS .)
INFO:root:
INFO:root:
INFO:root:state 264
INFO:root:
INFO:root:    (314) param -> def_id_s : mode . mark init_opt
INFO:root:    (154) mark -> . simple_name
INFO:root:    (155) mark -> . mark TICK attribute_id
INFO:root:    (156) mark -> . mark . simple_name
INFO:root:    (157) simple_name -> . IDENTIFIER
INFO:root:
INFO:root:    IDENTIFIER      shift and go to state 33
INFO:root:
INFO:root:    mark                           shift and go to state 406
INFO:root:    simple_name                    shift and go to state 192
INFO:root:
INFO:root:state 265
INFO:root:
INFO:root:    (317) mode -> IN .
INFO:root:    (319) mode -> IN . OUT
INFO:root:
INFO:root:    IDENTIFIER      reduce using rule 317 (mode -> IN .)
INFO:root:    OUT             shift and go to state 407
INFO:root:
INFO:root:
INFO:root:state 266
INFO:root:
INFO:root:    (318) mode -> OUT .
INFO:root:
INFO:root:    IDENTIFIER      reduce using rule 318 (mode -> OUT .)
INFO:root:
INFO:root:
INFO:root:state 267
INFO:root:
INFO:root:    (437) subunit -> SEPARATE ( compound_name ) . subunit_body
INFO:root:    (438) subunit_body -> . subprog_body
INFO:root:    (439) subunit_body -> . pkg_body
INFO:root:    (440) subunit_body -> . task_body
INFO:root:    (441) subunit_body -> . prot_body
INFO:root:    (322) subprog_body -> . subprog_spec_is_push decl_part block_body END id_opt ;
INFO:root:    (331) pkg_body -> . PACKAGE BODY compound_name IS decl_part body_opt END c_id_opt ;
INFO:root:    (356) task_body -> . TASK BODY simple_name IS decl_part block_body END id_opt ;
INFO:root:    (373) prot_body -> . PROTECTED BODY simple_name IS prot_op_body_s END id_opt ;
INFO:root:    (321) subprog_spec_is_push -> . subprog_spec IS
INFO:root:    (304) subprog_spec -> . PROCEDURE compound_name formal_part_opt
INFO:root:    (305) subprog_spec -> . FUNCTION designator formal_part_opt RETURN name
INFO:root:    (306) subprog_spec -> . FUNCTION designator
INFO:root:
INFO:root:    PACKAGE         shift and go to state 408
INFO:root:    TASK            shift and go to state 411
INFO:root:    PROTECTED       shift and go to state 417
INFO:root:    PROCEDURE       shift and go to state 17
INFO:root:    FUNCTION        shift and go to state 23
INFO:root:
INFO:root:    subunit_body                   shift and go to state 413
INFO:root:    subprog_spec                   shift and go to state 409
INFO:root:    subprog_body                   shift and go to state 414
INFO:root:    subprog_spec_is_push           shift and go to state 415
INFO:root:    prot_body                      shift and go to state 416
INFO:root:    task_body                      shift and go to state 410
INFO:root:    pkg_body                       shift and go to state 412
INFO:root:
INFO:root:state 268
INFO:root:
INFO:root:    (305) subprog_spec -> FUNCTION designator formal_part_opt RETURN . name
INFO:root:    (149) name -> . simple_name
INFO:root:    (150) name -> . indexed_comp
INFO:root:    (151) name -> . selected_comp
INFO:root:    (152) name -> . attribute
INFO:root:    (153) name -> . operator_symbol
INFO:root:    (157) simple_name -> . IDENTIFIER
INFO:root:    (164) indexed_comp -> . name ( value_s )
INFO:root:    (171) selected_comp -> . name . simple_name
INFO:root:    (172) selected_comp -> . name . used_char
INFO:root:    (173) selected_comp -> . name . operator_symbol
INFO:root:    (174) selected_comp -> . name . ALL
INFO:root:    (175) attribute -> . name TICK attribute_id
INFO:root:    (163) operator_symbol -> . STRING
INFO:root:
INFO:root:    IDENTIFIER      shift and go to state 33
INFO:root:    STRING          shift and go to state 149
INFO:root:
INFO:root:    selected_comp                  shift and go to state 139
INFO:root:    simple_name                    shift and go to state 163
INFO:root:    indexed_comp                   shift and go to state 140
INFO:root:    attribute                      shift and go to state 134
INFO:root:    name                           shift and go to state 418
INFO:root:    operator_symbol                shift and go to state 133
INFO:root:
INFO:root:state 269
INFO:root:
INFO:root:    (490) generic_inst -> NEW name .
INFO:root:    (164) indexed_comp -> name . ( value_s )
INFO:root:    (171) selected_comp -> name . . simple_name
INFO:root:    (172) selected_comp -> name . . used_char
INFO:root:    (173) selected_comp -> name . . operator_symbol
INFO:root:    (174) selected_comp -> name . . ALL
INFO:root:    (175) attribute -> name . TICK attribute_id
INFO:root:
INFO:root:    ;               reduce using rule 490 (generic_inst -> NEW name .)
INFO:root:    (               shift and go to state 237
INFO:root:    .               shift and go to state 239
INFO:root:    TICK            shift and go to state 260
INFO:root:
INFO:root:
INFO:root:state 270
INFO:root:
INFO:root:    (344) rename_unit -> PACKAGE compound_name renames ; .
INFO:root:
INFO:root:    error           reduce using rule 344 (rename_unit -> PACKAGE compound_name renames ; .)
INFO:root:    USE             reduce using rule 344 (rename_unit -> PACKAGE compound_name renames ; .)
INFO:root:    PRAGMA          reduce using rule 344 (rename_unit -> PACKAGE compound_name renames ; .)
INFO:root:    TYPE            reduce using rule 344 (rename_unit -> PACKAGE compound_name renames ; .)
INFO:root:    SUBTYPE         reduce using rule 344 (rename_unit -> PACKAGE compound_name renames ; .)
INFO:root:    TASK            reduce using rule 344 (rename_unit -> PACKAGE compound_name renames ; .)
INFO:root:    PACKAGE         reduce using rule 344 (rename_unit -> PACKAGE compound_name renames ; .)
INFO:root:    PROTECTED       reduce using rule 344 (rename_unit -> PACKAGE compound_name renames ; .)
INFO:root:    FOR             reduce using rule 344 (rename_unit -> PACKAGE compound_name renames ; .)
INFO:root:    PROCEDURE       reduce using rule 344 (rename_unit -> PACKAGE compound_name renames ; .)
INFO:root:    FUNCTION        reduce using rule 344 (rename_unit -> PACKAGE compound_name renames ; .)
INFO:root:    GENERIC         reduce using rule 344 (rename_unit -> PACKAGE compound_name renames ; .)
INFO:root:    IDENTIFIER      reduce using rule 344 (rename_unit -> PACKAGE compound_name renames ; .)
INFO:root:    END             reduce using rule 344 (rename_unit -> PACKAGE compound_name renames ; .)
INFO:root:    BEGIN           reduce using rule 344 (rename_unit -> PACKAGE compound_name renames ; .)
INFO:root:    PRIVATE         reduce using rule 344 (rename_unit -> PACKAGE compound_name renames ; .)
INFO:root:    WITH            reduce using rule 344 (rename_unit -> PACKAGE compound_name renames ; .)
INFO:root:    SEPARATE        reduce using rule 344 (rename_unit -> PACKAGE compound_name renames ; .)
INFO:root:    $end            reduce using rule 344 (rename_unit -> PACKAGE compound_name renames ; .)
INFO:root:
INFO:root:
INFO:root:state 271
INFO:root:
INFO:root:    (443) body_stub -> PACKAGE . BODY compound_name IS SEPARATE ;
INFO:root:    (326) pkg_spec -> PACKAGE . compound_name IS decl_item_s private_part END c_id_opt
INFO:root:    (489) generic_pkg_inst -> PACKAGE . compound_name IS generic_inst
INFO:root:    (344) rename_unit -> PACKAGE . compound_name renames ;
INFO:root:    (158) compound_name -> . simple_name
INFO:root:    (159) compound_name -> . compound_name . simple_name
INFO:root:    (157) simple_name -> . IDENTIFIER
INFO:root:
INFO:root:    BODY            shift and go to state 419
INFO:root:    IDENTIFIER      shift and go to state 33
INFO:root:
INFO:root:    simple_name                    shift and go to state 34
INFO:root:    compound_name                  shift and go to state 177
INFO:root:
INFO:root:state 272
INFO:root:
INFO:root:    (135) decl_item_s1 -> decl_item .
INFO:root:
INFO:root:    error           reduce using rule 135 (decl_item_s1 -> decl_item .)
INFO:root:    USE             reduce using rule 135 (decl_item_s1 -> decl_item .)
INFO:root:    PRAGMA          reduce using rule 135 (decl_item_s1 -> decl_item .)
INFO:root:    TYPE            reduce using rule 135 (decl_item_s1 -> decl_item .)
INFO:root:    SUBTYPE         reduce using rule 135 (decl_item_s1 -> decl_item .)
INFO:root:    TASK            reduce using rule 135 (decl_item_s1 -> decl_item .)
INFO:root:    PACKAGE         reduce using rule 135 (decl_item_s1 -> decl_item .)
INFO:root:    PROTECTED       reduce using rule 135 (decl_item_s1 -> decl_item .)
INFO:root:    FOR             reduce using rule 135 (decl_item_s1 -> decl_item .)
INFO:root:    PROCEDURE       reduce using rule 135 (decl_item_s1 -> decl_item .)
INFO:root:    FUNCTION        reduce using rule 135 (decl_item_s1 -> decl_item .)
INFO:root:    GENERIC         reduce using rule 135 (decl_item_s1 -> decl_item .)
INFO:root:    IDENTIFIER      reduce using rule 135 (decl_item_s1 -> decl_item .)
INFO:root:    PRIVATE         reduce using rule 135 (decl_item_s1 -> decl_item .)
INFO:root:    END             reduce using rule 135 (decl_item_s1 -> decl_item .)
INFO:root:
INFO:root:
INFO:root:state 273
INFO:root:
INFO:root:    (301) subprog_decl -> subprog_spec . ;
INFO:root:    (444) body_stub -> subprog_spec . IS SEPARATE ;
INFO:root:    (488) generic_subp_inst -> subprog_spec . IS generic_inst
INFO:root:    (321) subprog_spec_is_push -> subprog_spec . IS
INFO:root:    (345) rename_unit -> subprog_spec . renames ;
INFO:root:    (348) renames -> . RENAMES name
INFO:root:
INFO:root:    ;               shift and go to state 69
INFO:root:    IS              shift and go to state 420
INFO:root:    RENAMES         shift and go to state 66
INFO:root:
INFO:root:    renames                        shift and go to state 67
INFO:root:
INFO:root:state 274
INFO:root:
INFO:root:    (489) generic_pkg_inst -> PACKAGE compound_name IS generic_inst .
INFO:root:
INFO:root:    ;               reduce using rule 489 (generic_pkg_inst -> PACKAGE compound_name IS generic_inst .)
INFO:root:
INFO:root:
INFO:root:state 275
INFO:root:
INFO:root:    (442) body_stub -> TASK . BODY simple_name IS SEPARATE ;
INFO:root:    (350) task_spec -> TASK . simple_name task_def
INFO:root:    (351) task_spec -> TASK . TYPE simple_name discrim_part_opt task_def
INFO:root:    (157) simple_name -> . IDENTIFIER
INFO:root:
INFO:root:    BODY            shift and go to state 421
INFO:root:    TYPE            shift and go to state 182
INFO:root:    IDENTIFIER      shift and go to state 33
INFO:root:
INFO:root:    simple_name                    shift and go to state 184
INFO:root:
INFO:root:state 276
INFO:root:
INFO:root:    (134) decl_item_s -> decl_item_s1 .
INFO:root:    (136) decl_item_s1 -> decl_item_s1 . decl_item
INFO:root:    (137) decl_item -> . decl
INFO:root:    (138) decl_item -> . use_clause
INFO:root:    (139) decl_item -> . rep_spec
INFO:root:    (140) decl_item -> . pragma
INFO:root:    (10) decl -> . object_decl
INFO:root:    (11) decl -> . number_decl
INFO:root:    (12) decl -> . type_decl
INFO:root:    (13) decl -> . subtype_decl
INFO:root:    (14) decl -> . subprog_decl
INFO:root:    (15) decl -> . pkg_decl
INFO:root:    (16) decl -> . task_decl
INFO:root:    (17) decl -> . prot_decl
INFO:root:    (18) decl -> . exception_decl
INFO:root:    (19) decl -> . rename_decl
INFO:root:    (20) decl -> . generic_decl
INFO:root:    (21) decl -> . body_stub
INFO:root:    (22) decl -> . error ;
INFO:root:    (337) use_clause -> . USE name_s ;
INFO:root:    (338) use_clause -> . USE TYPE name_s ;
INFO:root:    (491) rep_spec -> . attrib_def
INFO:root:    (492) rep_spec -> . record_type_spec
INFO:root:    (493) rep_spec -> . address_spec
INFO:root:    (2) pragma -> . PRAGMA IDENTIFIER ;
INFO:root:    (3) pragma -> . PRAGMA simple_name ( pragma_arg_s ) ;
INFO:root:    (23) object_decl -> . def_id_s : object_qualifier_opt object_subtype_def init_opt ;
INFO:root:    (35) number_decl -> . def_id_s : CONSTANT ASSIGN expression ;
INFO:root:    (36) type_decl -> . TYPE IDENTIFIER discrim_part_opt type_completion ;
INFO:root:    (50) subtype_decl -> . SUBTYPE IDENTIFIER IS subtype_ind ;
INFO:root:    (301) subprog_decl -> . subprog_spec ;
INFO:root:    (302) subprog_decl -> . generic_subp_inst ;
INFO:root:    (303) subprog_decl -> . subprog_spec_is_push ABSTRACT ;
INFO:root:    (324) pkg_decl -> . pkg_spec ;
INFO:root:    (325) pkg_decl -> . generic_pkg_inst ;
INFO:root:    (349) task_decl -> . task_spec ;
INFO:root:    (357) prot_decl -> . prot_spec ;
INFO:root:    (446) exception_decl -> . def_id_s : EXCEPTION ;
INFO:root:    (341) rename_decl -> . def_id_s : object_qualifier_opt subtype_ind renames ;
INFO:root:    (342) rename_decl -> . def_id_s : EXCEPTION renames ;
INFO:root:    (343) rename_decl -> . rename_unit
INFO:root:    (458) generic_decl -> . generic_formal_part subprog_spec ;
INFO:root:    (459) generic_decl -> . generic_formal_part pkg_spec ;
INFO:root:    (442) body_stub -> . TASK BODY simple_name IS SEPARATE ;
INFO:root:    (443) body_stub -> . PACKAGE BODY compound_name IS SEPARATE ;
INFO:root:    (444) body_stub -> . subprog_spec IS SEPARATE ;
INFO:root:    (445) body_stub -> . PROTECTED BODY simple_name IS SEPARATE ;
INFO:root:    (494) attrib_def -> . FOR mark USE expression ;
INFO:root:    (495) record_type_spec -> . FOR mark USE RECORD align_opt comp_loc_s END RECORD ;
INFO:root:    (500) address_spec -> . FOR mark USE AT expression ;
INFO:root:    (24) def_id_s -> . def_id
INFO:root:    (25) def_id_s -> . def_id_s , def_id
INFO:root:    (304) subprog_spec -> . PROCEDURE compound_name formal_part_opt
INFO:root:    (305) subprog_spec -> . FUNCTION designator formal_part_opt RETURN name
INFO:root:    (306) subprog_spec -> . FUNCTION designator
INFO:root:    (488) generic_subp_inst -> . subprog_spec IS generic_inst
INFO:root:    (321) subprog_spec_is_push -> . subprog_spec IS
INFO:root:    (326) pkg_spec -> . PACKAGE compound_name IS decl_item_s private_part END c_id_opt
INFO:root:    (489) generic_pkg_inst -> . PACKAGE compound_name IS generic_inst
INFO:root:    (350) task_spec -> . TASK simple_name task_def
INFO:root:    (351) task_spec -> . TASK TYPE simple_name discrim_part_opt task_def
INFO:root:    (358) prot_spec -> . PROTECTED IDENTIFIER prot_def
INFO:root:    (359) prot_spec -> . PROTECTED TYPE simple_name discrim_part_opt prot_def
INFO:root:    (344) rename_unit -> . PACKAGE compound_name renames ;
INFO:root:    (345) rename_unit -> . subprog_spec renames ;
INFO:root:    (346) rename_unit -> . generic_formal_part PACKAGE compound_name renames ;
INFO:root:    (347) rename_unit -> . generic_formal_part subprog_spec renames ;
INFO:root:    (460) generic_formal_part -> . GENERIC
INFO:root:    (461) generic_formal_part -> . generic_formal_part generic_formal
INFO:root:    (26) def_id -> . IDENTIFIER
INFO:root:
INFO:root:    PRIVATE         reduce using rule 134 (decl_item_s -> decl_item_s1 .)
INFO:root:    END             reduce using rule 134 (decl_item_s -> decl_item_s1 .)
INFO:root:    error           shift and go to state 107
INFO:root:    USE             shift and go to state 53
INFO:root:    PRAGMA          shift and go to state 2
INFO:root:    TYPE            shift and go to state 74
INFO:root:    SUBTYPE         shift and go to state 110
INFO:root:    TASK            shift and go to state 275
INFO:root:    PACKAGE         shift and go to state 271
INFO:root:    PROTECTED       shift and go to state 277
INFO:root:    FOR             shift and go to state 102
INFO:root:    PROCEDURE       shift and go to state 17
INFO:root:    FUNCTION        shift and go to state 23
INFO:root:    GENERIC         shift and go to state 26
INFO:root:    IDENTIFIER      shift and go to state 52
INFO:root:
INFO:root:    rep_spec                       shift and go to state 72
INFO:root:    pkg_decl                       shift and go to state 93
INFO:root:    pragma                         shift and go to state 94
INFO:root:    prot_decl                      shift and go to state 95
INFO:root:    task_decl                      shift and go to state 76
INFO:root:    subprog_decl                   shift and go to state 77
INFO:root:    type_decl                      shift and go to state 81
INFO:root:    def_id_s                       shift and go to state 79
INFO:root:    generic_pkg_inst               shift and go to state 19
INFO:root:    def_id                         shift and go to state 57
INFO:root:    generic_formal_part            shift and go to state 20
INFO:root:    use_clause                     shift and go to state 97
INFO:root:    rename_decl                    shift and go to state 98
INFO:root:    body_stub                      shift and go to state 80
INFO:root:    address_spec                   shift and go to state 83
INFO:root:    task_spec                      shift and go to state 82
INFO:root:    exception_decl                 shift and go to state 91
INFO:root:    number_decl                    shift and go to state 101
INFO:root:    generic_subp_inst              shift and go to state 24
INFO:root:    prot_spec                      shift and go to state 85
INFO:root:    rename_unit                    shift and go to state 104
INFO:root:    subprog_spec                   shift and go to state 273
INFO:root:    object_decl                    shift and go to state 87
INFO:root:    generic_decl                   shift and go to state 88
INFO:root:    pkg_spec                       shift and go to state 16
INFO:root:    record_type_spec               shift and go to state 108
INFO:root:    decl                           shift and go to state 109
INFO:root:    decl_item                      shift and go to state 422
INFO:root:    attrib_def                     shift and go to state 92
INFO:root:    subprog_spec_is_push           shift and go to state 279
INFO:root:    subtype_decl                   shift and go to state 105
INFO:root:
INFO:root:state 277
INFO:root:
INFO:root:    (445) body_stub -> PROTECTED . BODY simple_name IS SEPARATE ;
INFO:root:    (358) prot_spec -> PROTECTED . IDENTIFIER prot_def
INFO:root:    (359) prot_spec -> PROTECTED . TYPE simple_name discrim_part_opt prot_def
INFO:root:
INFO:root:    BODY            shift and go to state 423
INFO:root:    IDENTIFIER      shift and go to state 190
INFO:root:    TYPE            shift and go to state 189
INFO:root:
INFO:root:
INFO:root:state 278
INFO:root:
INFO:root:    (326) pkg_spec -> PACKAGE compound_name IS decl_item_s . private_part END c_id_opt
INFO:root:    (327) private_part -> .
INFO:root:    (328) private_part -> . PRIVATE decl_item_s
INFO:root:
INFO:root:    END             reduce using rule 327 (private_part -> .)
INFO:root:    PRIVATE         shift and go to state 425
INFO:root:
INFO:root:    private_part                   shift and go to state 424
INFO:root:
INFO:root:state 279
INFO:root:
INFO:root:    (303) subprog_decl -> subprog_spec_is_push . ABSTRACT ;
INFO:root:
INFO:root:    ABSTRACT        shift and go to state 89
INFO:root:
INFO:root:
INFO:root:state 280
INFO:root:
INFO:root:    (331) pkg_body -> PACKAGE BODY compound_name IS . decl_part body_opt END c_id_opt ;
INFO:root:    (131) decl_part -> .
INFO:root:    (132) decl_part -> . decl_item_or_body_s1
INFO:root:    (141) decl_item_or_body_s1 -> . decl_item_or_body
INFO:root:    (142) decl_item_or_body_s1 -> . decl_item_or_body_s1 decl_item_or_body
INFO:root:    (143) decl_item_or_body -> . body
INFO:root:    (144) decl_item_or_body -> . decl_item
INFO:root:    (145) body -> . subprog_body
INFO:root:    (146) body -> . pkg_body
INFO:root:    (147) body -> . task_body
INFO:root:    (148) body -> . prot_body
INFO:root:    (137) decl_item -> . decl
INFO:root:    (138) decl_item -> . use_clause
INFO:root:    (139) decl_item -> . rep_spec
INFO:root:    (140) decl_item -> . pragma
INFO:root:    (322) subprog_body -> . subprog_spec_is_push decl_part block_body END id_opt ;
INFO:root:    (331) pkg_body -> . PACKAGE BODY compound_name IS decl_part body_opt END c_id_opt ;
INFO:root:    (356) task_body -> . TASK BODY simple_name IS decl_part block_body END id_opt ;
INFO:root:    (373) prot_body -> . PROTECTED BODY simple_name IS prot_op_body_s END id_opt ;
INFO:root:    (10) decl -> . object_decl
INFO:root:    (11) decl -> . number_decl
INFO:root:    (12) decl -> . type_decl
INFO:root:    (13) decl -> . subtype_decl
INFO:root:    (14) decl -> . subprog_decl
INFO:root:    (15) decl -> . pkg_decl
INFO:root:    (16) decl -> . task_decl
INFO:root:    (17) decl -> . prot_decl
INFO:root:    (18) decl -> . exception_decl
INFO:root:    (19) decl -> . rename_decl
INFO:root:    (20) decl -> . generic_decl
INFO:root:    (21) decl -> . body_stub
INFO:root:    (22) decl -> . error ;
INFO:root:    (337) use_clause -> . USE name_s ;
INFO:root:    (338) use_clause -> . USE TYPE name_s ;
INFO:root:    (491) rep_spec -> . attrib_def
INFO:root:    (492) rep_spec -> . record_type_spec
INFO:root:    (493) rep_spec -> . address_spec
INFO:root:    (2) pragma -> . PRAGMA IDENTIFIER ;
INFO:root:    (3) pragma -> . PRAGMA simple_name ( pragma_arg_s ) ;
INFO:root:    (321) subprog_spec_is_push -> . subprog_spec IS
INFO:root:    (23) object_decl -> . def_id_s : object_qualifier_opt object_subtype_def init_opt ;
INFO:root:    (35) number_decl -> . def_id_s : CONSTANT ASSIGN expression ;
INFO:root:    (36) type_decl -> . TYPE IDENTIFIER discrim_part_opt type_completion ;
INFO:root:    (50) subtype_decl -> . SUBTYPE IDENTIFIER IS subtype_ind ;
INFO:root:    (301) subprog_decl -> . subprog_spec ;
INFO:root:    (302) subprog_decl -> . generic_subp_inst ;
INFO:root:    (303) subprog_decl -> . subprog_spec_is_push ABSTRACT ;
INFO:root:    (324) pkg_decl -> . pkg_spec ;
INFO:root:    (325) pkg_decl -> . generic_pkg_inst ;
INFO:root:    (349) task_decl -> . task_spec ;
INFO:root:    (357) prot_decl -> . prot_spec ;
INFO:root:    (446) exception_decl -> . def_id_s : EXCEPTION ;
INFO:root:    (341) rename_decl -> . def_id_s : object_qualifier_opt subtype_ind renames ;
INFO:root:    (342) rename_decl -> . def_id_s : EXCEPTION renames ;
INFO:root:    (343) rename_decl -> . rename_unit
INFO:root:    (458) generic_decl -> . generic_formal_part subprog_spec ;
INFO:root:    (459) generic_decl -> . generic_formal_part pkg_spec ;
INFO:root:    (442) body_stub -> . TASK BODY simple_name IS SEPARATE ;
INFO:root:    (443) body_stub -> . PACKAGE BODY compound_name IS SEPARATE ;
INFO:root:    (444) body_stub -> . subprog_spec IS SEPARATE ;
INFO:root:    (445) body_stub -> . PROTECTED BODY simple_name IS SEPARATE ;
INFO:root:    (494) attrib_def -> . FOR mark USE expression ;
INFO:root:    (495) record_type_spec -> . FOR mark USE RECORD align_opt comp_loc_s END RECORD ;
INFO:root:    (500) address_spec -> . FOR mark USE AT expression ;
INFO:root:    (304) subprog_spec -> . PROCEDURE compound_name formal_part_opt
INFO:root:    (305) subprog_spec -> . FUNCTION designator formal_part_opt RETURN name
INFO:root:    (306) subprog_spec -> . FUNCTION designator
INFO:root:    (24) def_id_s -> . def_id
INFO:root:    (25) def_id_s -> . def_id_s , def_id
INFO:root:    (488) generic_subp_inst -> . subprog_spec IS generic_inst
INFO:root:    (326) pkg_spec -> . PACKAGE compound_name IS decl_item_s private_part END c_id_opt
INFO:root:    (489) generic_pkg_inst -> . PACKAGE compound_name IS generic_inst
INFO:root:    (350) task_spec -> . TASK simple_name task_def
INFO:root:    (351) task_spec -> . TASK TYPE simple_name discrim_part_opt task_def
INFO:root:    (358) prot_spec -> . PROTECTED IDENTIFIER prot_def
INFO:root:    (359) prot_spec -> . PROTECTED TYPE simple_name discrim_part_opt prot_def
INFO:root:    (344) rename_unit -> . PACKAGE compound_name renames ;
INFO:root:    (345) rename_unit -> . subprog_spec renames ;
INFO:root:    (346) rename_unit -> . generic_formal_part PACKAGE compound_name renames ;
INFO:root:    (347) rename_unit -> . generic_formal_part subprog_spec renames ;
INFO:root:    (460) generic_formal_part -> . GENERIC
INFO:root:    (461) generic_formal_part -> . generic_formal_part generic_formal
INFO:root:    (26) def_id -> . IDENTIFIER
INFO:root:
INFO:root:    BEGIN           reduce using rule 131 (decl_part -> .)
INFO:root:    END             reduce using rule 131 (decl_part -> .)
INFO:root:    PACKAGE         shift and go to state 73
INFO:root:    TASK            shift and go to state 84
INFO:root:    PROTECTED       shift and go to state 99
INFO:root:    error           shift and go to state 107
INFO:root:    USE             shift and go to state 53
INFO:root:    PRAGMA          shift and go to state 2
INFO:root:    TYPE            shift and go to state 74
INFO:root:    SUBTYPE         shift and go to state 110
INFO:root:    FOR             shift and go to state 102
INFO:root:    PROCEDURE       shift and go to state 17
INFO:root:    FUNCTION        shift and go to state 23
INFO:root:    GENERIC         shift and go to state 26
INFO:root:    IDENTIFIER      shift and go to state 52
INFO:root:
INFO:root:    generic_formal_part            shift and go to state 20
INFO:root:    pkg_decl                       shift and go to state 93
INFO:root:    pragma                         shift and go to state 94
INFO:root:    generic_pkg_inst               shift and go to state 19
INFO:root:    prot_decl                      shift and go to state 95
INFO:root:    body                           shift and go to state 75
INFO:root:    task_decl                      shift and go to state 76
INFO:root:    generic_decl                   shift and go to state 88
INFO:root:    subprog_decl                   shift and go to state 77
INFO:root:    type_decl                      shift and go to state 81
INFO:root:    def_id_s                       shift and go to state 79
INFO:root:    def_id                         shift and go to state 57
INFO:root:    rep_spec                       shift and go to state 72
INFO:root:    use_clause                     shift and go to state 97
INFO:root:    rename_decl                    shift and go to state 98
INFO:root:    body_stub                      shift and go to state 80
INFO:root:    address_spec                   shift and go to state 83
INFO:root:    task_spec                      shift and go to state 82
INFO:root:    number_decl                    shift and go to state 101
INFO:root:    generic_subp_inst              shift and go to state 24
INFO:root:    decl_item_or_body_s1           shift and go to state 103
INFO:root:    prot_spec                      shift and go to state 85
INFO:root:    rename_unit                    shift and go to state 104
INFO:root:    subprog_spec                   shift and go to state 86
INFO:root:    object_decl                    shift and go to state 87
INFO:root:    subtype_decl                   shift and go to state 105
INFO:root:    task_body                      shift and go to state 96
INFO:root:    prot_body                      shift and go to state 100
INFO:root:    pkg_body                       shift and go to state 90
INFO:root:    decl_part                      shift and go to state 426
INFO:root:    pkg_spec                       shift and go to state 16
INFO:root:    record_type_spec               shift and go to state 108
INFO:root:    decl                           shift and go to state 109
INFO:root:    decl_item                      shift and go to state 78
INFO:root:    exception_decl                 shift and go to state 91
INFO:root:    subprog_body                   shift and go to state 113
INFO:root:    attrib_def                     shift and go to state 92
INFO:root:    subprog_spec_is_push           shift and go to state 111
INFO:root:    decl_item_or_body              shift and go to state 112
INFO:root:
INFO:root:state 281
INFO:root:
INFO:root:    (331) pkg_body -> PACKAGE BODY compound_name . IS decl_part body_opt END c_id_opt ;
INFO:root:    (443) body_stub -> PACKAGE BODY compound_name . IS SEPARATE ;
INFO:root:    (159) compound_name -> compound_name . . simple_name
INFO:root:
INFO:root:    IS              shift and go to state 427
INFO:root:    .               shift and go to state 116
INFO:root:
INFO:root:
INFO:root:state 282
INFO:root:
INFO:root:    (36) type_decl -> TYPE IDENTIFIER discrim_part_opt . type_completion ;
INFO:root:    (40) type_completion -> .
INFO:root:    (41) type_completion -> . IS type_def
INFO:root:
INFO:root:    ;               reduce using rule 40 (type_completion -> .)
INFO:root:    IS              shift and go to state 429
INFO:root:
INFO:root:    type_completion                shift and go to state 428
INFO:root:
INFO:root:state 283
INFO:root:
INFO:root:    (39) discrim_part_opt -> ( . BOX )
INFO:root:    (110) discrim_part -> ( . discrim_spec_s )
INFO:root:    (111) discrim_spec_s -> . discrim_spec
INFO:root:    (112) discrim_spec_s -> . discrim_spec_s ; discrim_spec
INFO:root:    (113) discrim_spec -> . def_id_s : access_opt mark init_opt
INFO:root:    (114) discrim_spec -> . error
INFO:root:    (24) def_id_s -> . def_id
INFO:root:    (25) def_id_s -> . def_id_s , def_id
INFO:root:    (26) def_id -> . IDENTIFIER
INFO:root:
INFO:root:    BOX             shift and go to state 430
INFO:root:    error           shift and go to state 399
INFO:root:    IDENTIFIER      shift and go to state 52
INFO:root:
INFO:root:    def_id                         shift and go to state 57
INFO:root:    def_id_s                       shift and go to state 400
INFO:root:    discrim_spec                   shift and go to state 401
INFO:root:    discrim_spec_s                 shift and go to state 402
INFO:root:
INFO:root:state 284
INFO:root:
INFO:root:    (38) discrim_part_opt -> discrim_part .
INFO:root:
INFO:root:    IS              reduce using rule 38 (discrim_part_opt -> discrim_part .)
INFO:root:    ;               reduce using rule 38 (discrim_part_opt -> discrim_part .)
INFO:root:
INFO:root:
INFO:root:state 285
INFO:root:
INFO:root:    (23) object_decl -> def_id_s : object_qualifier_opt . object_subtype_def init_opt ;
INFO:root:    (341) rename_decl -> def_id_s : object_qualifier_opt . subtype_ind renames ;
INFO:root:    (31) object_subtype_def -> . subtype_ind
INFO:root:    (32) object_subtype_def -> . array_type
INFO:root:    (51) subtype_ind -> . name constraint
INFO:root:    (52) subtype_ind -> . name
INFO:root:    (78) array_type -> . unconstr_array_type
INFO:root:    (79) array_type -> . constr_array_type
INFO:root:    (149) name -> . simple_name
INFO:root:    (150) name -> . indexed_comp
INFO:root:    (151) name -> . selected_comp
INFO:root:    (152) name -> . attribute
INFO:root:    (153) name -> . operator_symbol
INFO:root:    (80) unconstr_array_type -> . ARRAY ( index_s ) OF component_subtype_def
INFO:root:    (81) constr_array_type -> . ARRAY iter_index_constraint OF component_subtype_def
INFO:root:    (157) simple_name -> . IDENTIFIER
INFO:root:    (164) indexed_comp -> . name ( value_s )
INFO:root:    (171) selected_comp -> . name . simple_name
INFO:root:    (172) selected_comp -> . name . used_char
INFO:root:    (173) selected_comp -> . name . operator_symbol
INFO:root:    (174) selected_comp -> . name . ALL
INFO:root:    (175) attribute -> . name TICK attribute_id
INFO:root:    (163) operator_symbol -> . STRING
INFO:root:
INFO:root:    ARRAY           shift and go to state 431
INFO:root:    IDENTIFIER      shift and go to state 33
INFO:root:    STRING          shift and go to state 149
INFO:root:
INFO:root:    selected_comp                  shift and go to state 139
INFO:root:    indexed_comp                   shift and go to state 140
INFO:root:    attribute                      shift and go to state 134
INFO:root:    name                           shift and go to state 432
INFO:root:    subtype_ind                    shift and go to state 433
INFO:root:    simple_name                    shift and go to state 163
INFO:root:    unconstr_array_type            shift and go to state 434
INFO:root:    array_type                     shift and go to state 435
INFO:root:    operator_symbol                shift and go to state 133
INFO:root:    constr_array_type              shift and go to state 436
INFO:root:    object_subtype_def             shift and go to state 437
INFO:root:
INFO:root:state 286
INFO:root:
INFO:root:    (35) number_decl -> def_id_s : CONSTANT . ASSIGN expression ;
INFO:root:    (29) object_qualifier_opt -> CONSTANT .
INFO:root:
INFO:root:    ASSIGN          shift and go to state 438
INFO:root:    ARRAY           reduce using rule 29 (object_qualifier_opt -> CONSTANT .)
INFO:root:    IDENTIFIER      reduce using rule 29 (object_qualifier_opt -> CONSTANT .)
INFO:root:    STRING          reduce using rule 29 (object_qualifier_opt -> CONSTANT .)
INFO:root:
INFO:root:
INFO:root:state 287
INFO:root:
INFO:root:    (446) exception_decl -> def_id_s : EXCEPTION . ;
INFO:root:    (342) rename_decl -> def_id_s : EXCEPTION . renames ;
INFO:root:    (348) renames -> . RENAMES name
INFO:root:
INFO:root:    ;               shift and go to state 440
INFO:root:    RENAMES         shift and go to state 66
INFO:root:
INFO:root:    renames                        shift and go to state 439
INFO:root:
INFO:root:state 288
INFO:root:
INFO:root:    (28) object_qualifier_opt -> ALIASED .
INFO:root:    (30) object_qualifier_opt -> ALIASED . CONSTANT
INFO:root:
INFO:root:    ARRAY           reduce using rule 28 (object_qualifier_opt -> ALIASED .)
INFO:root:    IDENTIFIER      reduce using rule 28 (object_qualifier_opt -> ALIASED .)
INFO:root:    STRING          reduce using rule 28 (object_qualifier_opt -> ALIASED .)
INFO:root:    CONSTANT        shift and go to state 441
INFO:root:
INFO:root:
INFO:root:state 289
INFO:root:
INFO:root:    (351) task_spec -> TASK TYPE simple_name . discrim_part_opt task_def
INFO:root:    (37) discrim_part_opt -> .
INFO:root:    (38) discrim_part_opt -> . discrim_part
INFO:root:    (39) discrim_part_opt -> . ( BOX )
INFO:root:    (110) discrim_part -> . ( discrim_spec_s )
INFO:root:
INFO:root:    IS              reduce using rule 37 (discrim_part_opt -> .)
INFO:root:    ;               reduce using rule 37 (discrim_part_opt -> .)
INFO:root:    (               shift and go to state 283
INFO:root:
INFO:root:    discrim_part_opt               shift and go to state 442
INFO:root:    discrim_part                   shift and go to state 284
INFO:root:
INFO:root:state 290
INFO:root:
INFO:root:    (356) task_body -> TASK BODY simple_name . IS decl_part block_body END id_opt ;
INFO:root:    (442) body_stub -> TASK BODY simple_name . IS SEPARATE ;
INFO:root:
INFO:root:    IS              shift and go to state 443
INFO:root:
INFO:root:
INFO:root:state 291
INFO:root:
INFO:root:    (350) task_spec -> TASK simple_name task_def .
INFO:root:
INFO:root:    ;               reduce using rule 350 (task_spec -> TASK simple_name task_def .)
INFO:root:
INFO:root:
INFO:root:state 292
INFO:root:
INFO:root:    (353) task_def -> IS . entry_decl_s rep_spec_s task_private_opt END id_opt
INFO:root:    (379) entry_decl_s -> . pragma_s
INFO:root:    (380) entry_decl_s -> . entry_decl_s entry_decl pragma_s
INFO:root:    (8) pragma_s -> .
INFO:root:    (9) pragma_s -> . pragma_s pragma
INFO:root:
INFO:root:    PRAGMA          reduce using rule 8 (pragma_s -> .)
INFO:root:    ENTRY           reduce using rule 8 (pragma_s -> .)
INFO:root:    PRIVATE         reduce using rule 8 (pragma_s -> .)
INFO:root:    FOR             reduce using rule 8 (pragma_s -> .)
INFO:root:    END             reduce using rule 8 (pragma_s -> .)
INFO:root:
INFO:root:    pragma_s                       shift and go to state 445
INFO:root:    entry_decl_s                   shift and go to state 444
INFO:root:
INFO:root:state 293
INFO:root:
INFO:root:    (444) body_stub -> subprog_spec IS SEPARATE . ;
INFO:root:
INFO:root:    ;               shift and go to state 446
INFO:root:
INFO:root:
INFO:root:state 294
INFO:root:
INFO:root:    (373) prot_body -> PROTECTED BODY simple_name . IS prot_op_body_s END id_opt ;
INFO:root:    (445) body_stub -> PROTECTED BODY simple_name . IS SEPARATE ;
INFO:root:
INFO:root:    IS              shift and go to state 447
INFO:root:
INFO:root:
INFO:root:state 295
INFO:root:
INFO:root:    (359) prot_spec -> PROTECTED TYPE simple_name . discrim_part_opt prot_def
INFO:root:    (37) discrim_part_opt -> .
INFO:root:    (38) discrim_part_opt -> . discrim_part
INFO:root:    (39) discrim_part_opt -> . ( BOX )
INFO:root:    (110) discrim_part -> . ( discrim_spec_s )
INFO:root:
INFO:root:    IS              reduce using rule 37 (discrim_part_opt -> .)
INFO:root:    (               shift and go to state 283
INFO:root:
INFO:root:    discrim_part_opt               shift and go to state 448
INFO:root:    discrim_part                   shift and go to state 284
INFO:root:
INFO:root:state 296
INFO:root:
INFO:root:    (358) prot_spec -> PROTECTED IDENTIFIER prot_def .
INFO:root:
INFO:root:    ;               reduce using rule 358 (prot_spec -> PROTECTED IDENTIFIER prot_def .)
INFO:root:
INFO:root:
INFO:root:state 297
INFO:root:
INFO:root:    (360) prot_def -> IS . prot_op_decl_s prot_private_opt END id_opt
INFO:root:    (363) prot_op_decl_s -> .
INFO:root:    (364) prot_op_decl_s -> . prot_op_decl_s prot_op_decl
INFO:root:
INFO:root:    PRIVATE         reduce using rule 363 (prot_op_decl_s -> .)
INFO:root:    ENTRY           reduce using rule 363 (prot_op_decl_s -> .)
INFO:root:    PROCEDURE       reduce using rule 363 (prot_op_decl_s -> .)
INFO:root:    FUNCTION        reduce using rule 363 (prot_op_decl_s -> .)
INFO:root:    PRAGMA          reduce using rule 363 (prot_op_decl_s -> .)
INFO:root:    FOR             reduce using rule 363 (prot_op_decl_s -> .)
INFO:root:    END             reduce using rule 363 (prot_op_decl_s -> .)
INFO:root:
INFO:root:    prot_op_decl_s                 shift and go to state 449
INFO:root:
INFO:root:state 298
INFO:root:
INFO:root:    (156) mark -> mark . . simple_name
INFO:root:    (157) simple_name -> . IDENTIFIER
INFO:root:
INFO:root:    IDENTIFIER      shift and go to state 33
INFO:root:
INFO:root:    simple_name                    shift and go to state 450
INFO:root:
INFO:root:state 299
INFO:root:
INFO:root:    (494) attrib_def -> FOR mark USE . expression ;
INFO:root:    (495) record_type_spec -> FOR mark USE . RECORD align_opt comp_loc_s END RECORD ;
INFO:root:    (500) address_spec -> FOR mark USE . AT expression ;
INFO:root:    (188) expression -> . relation
INFO:root:    (189) expression -> . expression logical relation
INFO:root:    (190) expression -> . expression short_circuit relation
INFO:root:    (196) relation -> . simple_expression
INFO:root:    (197) relation -> . simple_expression relational simple_expression
INFO:root:    (198) relation -> . simple_expression membership range
INFO:root:    (199) relation -> . simple_expression membership name
INFO:root:    (208) simple_expression -> . unary term
INFO:root:    (209) simple_expression -> . term
INFO:root:    (210) simple_expression -> . simple_expression adding term
INFO:root:    (211) unary -> . +
INFO:root:    (212) unary -> . -
INFO:root:    (216) term -> . factor
INFO:root:    (217) term -> . term multiplying factor
INFO:root:    (223) factor -> . primary
INFO:root:    (224) factor -> . NOT primary
INFO:root:    (225) factor -> . ABS primary
INFO:root:    (226) primary -> . literal
INFO:root:    (227) primary -> . name
INFO:root:    (228) primary -> . allocator
INFO:root:    (229) primary -> . qualified
INFO:root:    (230) primary -> . parenthesized_primary
INFO:root:    (180) literal -> . INT
INFO:root:    (181) literal -> . FLOAT
INFO:root:    (182) literal -> . NuLL
INFO:root:    (149) name -> . simple_name
INFO:root:    (150) name -> . indexed_comp
INFO:root:    (151) name -> . selected_comp
INFO:root:    (152) name -> . attribute
INFO:root:    (153) name -> . operator_symbol
INFO:root:    (234) allocator -> . NEW name
INFO:root:    (235) allocator -> . NEW qualified
INFO:root:    (233) qualified -> . name TICK parenthesized_primary
INFO:root:    (231) parenthesized_primary -> . aggregate
INFO:root:    (232) parenthesized_primary -> . ( expression )
INFO:root:    (157) simple_name -> . IDENTIFIER
INFO:root:    (164) indexed_comp -> . name ( value_s )
INFO:root:    (171) selected_comp -> . name . simple_name
INFO:root:    (172) selected_comp -> . name . used_char
INFO:root:    (173) selected_comp -> . name . operator_symbol
INFO:root:    (174) selected_comp -> . name . ALL
INFO:root:    (175) attribute -> . name TICK attribute_id
INFO:root:    (163) operator_symbol -> . STRING
INFO:root:    (183) aggregate -> . ( comp_assoc )
INFO:root:    (184) aggregate -> . ( expression WITH value_s )
INFO:root:    (185) aggregate -> . ( expression WITH NuLL RECORD )
INFO:root:    (186) aggregate -> . ( NuLL RECORD )
INFO:root:
INFO:root:    RECORD          shift and go to state 453
INFO:root:    AT              shift and go to state 452
INFO:root:    +               shift and go to state 148
INFO:root:    -               shift and go to state 136
INFO:root:    NOT             shift and go to state 131
INFO:root:    ABS             shift and go to state 132
INFO:root:    INT             shift and go to state 120
INFO:root:    FLOAT           shift and go to state 128
INFO:root:    NuLL            shift and go to state 130
INFO:root:    NEW             shift and go to state 137
INFO:root:    (               shift and go to state 125
INFO:root:    IDENTIFIER      shift and go to state 33
INFO:root:    STRING          shift and go to state 149
INFO:root:
INFO:root:    literal                        shift and go to state 121
INFO:root:    allocator                      shift and go to state 122
INFO:root:    simple_name                    shift and go to state 163
INFO:root:    name                           shift and go to state 142
INFO:root:    selected_comp                  shift and go to state 139
INFO:root:    factor                         shift and go to state 126
INFO:root:    expression                     shift and go to state 451
INFO:root:    unary                          shift and go to state 144
INFO:root:    qualified                      shift and go to state 145
INFO:root:    aggregate                      shift and go to state 143
INFO:root:    simple_expression              shift and go to state 129
INFO:root:    term                           shift and go to state 146
INFO:root:    indexed_comp                   shift and go to state 140
INFO:root:    operator_symbol                shift and go to state 133
INFO:root:    parenthesized_primary          shift and go to state 147
INFO:root:    attribute                      shift and go to state 134
INFO:root:    primary                        shift and go to state 135
INFO:root:    relation                       shift and go to state 138
INFO:root:
INFO:root:state 300
INFO:root:
INFO:root:    (155) mark -> mark TICK . attribute_id
INFO:root:    (176) attribute_id -> . IDENTIFIER
INFO:root:    (177) attribute_id -> . DIGITS
INFO:root:    (178) attribute_id -> . DELTA
INFO:root:    (179) attribute_id -> . ACCESS
INFO:root:
INFO:root:    IDENTIFIER      shift and go to state 380
INFO:root:    DIGITS          shift and go to state 385
INFO:root:    DELTA           shift and go to state 382
INFO:root:    ACCESS          shift and go to state 381
INFO:root:
INFO:root:    attribute_id                   shift and go to state 454
INFO:root:
INFO:root:state 301
INFO:root:
INFO:root:    (322) subprog_body -> subprog_spec_is_push decl_part block_body END . id_opt ;
INFO:root:    (285) id_opt -> .
INFO:root:    (286) id_opt -> . designator
INFO:root:    (307) designator -> . compound_name
INFO:root:    (308) designator -> . STRING
INFO:root:    (158) compound_name -> . simple_name
INFO:root:    (159) compound_name -> . compound_name . simple_name
INFO:root:    (157) simple_name -> . IDENTIFIER
INFO:root:
INFO:root:    ;               reduce using rule 285 (id_opt -> .)
INFO:root:    STRING          shift and go to state 62
INFO:root:    IDENTIFIER      shift and go to state 33
INFO:root:
INFO:root:    designator                     shift and go to state 455
INFO:root:    id_opt                         shift and go to state 456
INFO:root:    simple_name                    shift and go to state 34
INFO:root:    compound_name                  shift and go to state 64
INFO:root:
INFO:root:state 302
INFO:root:
INFO:root:    (240) unlabeled -> simple_stmt .
INFO:root:
INFO:root:    EXCEPTION       reduce using rule 240 (unlabeled -> simple_stmt .)
INFO:root:    LL              reduce using rule 240 (unlabeled -> simple_stmt .)
INFO:root:    error           reduce using rule 240 (unlabeled -> simple_stmt .)
INFO:root:    NuLL            reduce using rule 240 (unlabeled -> simple_stmt .)
INFO:root:    EXIT            reduce using rule 240 (unlabeled -> simple_stmt .)
INFO:root:    RETURN          reduce using rule 240 (unlabeled -> simple_stmt .)
INFO:root:    DELAY           reduce using rule 240 (unlabeled -> simple_stmt .)
INFO:root:    ABORT           reduce using rule 240 (unlabeled -> simple_stmt .)
INFO:root:    RAISE           reduce using rule 240 (unlabeled -> simple_stmt .)
INFO:root:    REQUEUE         reduce using rule 240 (unlabeled -> simple_stmt .)
INFO:root:    IF              reduce using rule 240 (unlabeled -> simple_stmt .)
INFO:root:    CASE            reduce using rule 240 (unlabeled -> simple_stmt .)
INFO:root:    IDENTIFIER      reduce using rule 240 (unlabeled -> simple_stmt .)
INFO:root:    ACCEPT          reduce using rule 240 (unlabeled -> simple_stmt .)
INFO:root:    SELECT          reduce using rule 240 (unlabeled -> simple_stmt .)
INFO:root:    STRING          reduce using rule 240 (unlabeled -> simple_stmt .)
INFO:root:    WHILE           reduce using rule 240 (unlabeled -> simple_stmt .)
INFO:root:    DECLARE         reduce using rule 240 (unlabeled -> simple_stmt .)
INFO:root:    FOR             reduce using rule 240 (unlabeled -> simple_stmt .)
INFO:root:    LOOP            reduce using rule 240 (unlabeled -> simple_stmt .)
INFO:root:    BEGIN           reduce using rule 240 (unlabeled -> simple_stmt .)
INFO:root:    END             reduce using rule 240 (unlabeled -> simple_stmt .)
INFO:root:    OR              reduce using rule 240 (unlabeled -> simple_stmt .)
INFO:root:    ELSE            reduce using rule 240 (unlabeled -> simple_stmt .)
INFO:root:    THEN            reduce using rule 240 (unlabeled -> simple_stmt .)
INFO:root:    ELSIF           reduce using rule 240 (unlabeled -> simple_stmt .)
INFO:root:    WHEN            reduce using rule 240 (unlabeled -> simple_stmt .)
INFO:root:
INFO:root:
INFO:root:state 303
INFO:root:
INFO:root:    (299) return_stmt -> RETURN . ;
INFO:root:    (300) return_stmt -> RETURN . expression ;
INFO:root:    (188) expression -> . relation
INFO:root:    (189) expression -> . expression logical relation
INFO:root:    (190) expression -> . expression short_circuit relation
INFO:root:    (196) relation -> . simple_expression
INFO:root:    (197) relation -> . simple_expression relational simple_expression
INFO:root:    (198) relation -> . simple_expression membership range
INFO:root:    (199) relation -> . simple_expression membership name
INFO:root:    (208) simple_expression -> . unary term
INFO:root:    (209) simple_expression -> . term
INFO:root:    (210) simple_expression -> . simple_expression adding term
INFO:root:    (211) unary -> . +
INFO:root:    (212) unary -> . -
INFO:root:    (216) term -> . factor
INFO:root:    (217) term -> . term multiplying factor
INFO:root:    (223) factor -> . primary
INFO:root:    (224) factor -> . NOT primary
INFO:root:    (225) factor -> . ABS primary
INFO:root:    (226) primary -> . literal
INFO:root:    (227) primary -> . name
INFO:root:    (228) primary -> . allocator
INFO:root:    (229) primary -> . qualified
INFO:root:    (230) primary -> . parenthesized_primary
INFO:root:    (180) literal -> . INT
INFO:root:    (181) literal -> . FLOAT
INFO:root:    (182) literal -> . NuLL
INFO:root:    (149) name -> . simple_name
INFO:root:    (150) name -> . indexed_comp
INFO:root:    (151) name -> . selected_comp
INFO:root:    (152) name -> . attribute
INFO:root:    (153) name -> . operator_symbol
INFO:root:    (234) allocator -> . NEW name
INFO:root:    (235) allocator -> . NEW qualified
INFO:root:    (233) qualified -> . name TICK parenthesized_primary
INFO:root:    (231) parenthesized_primary -> . aggregate
INFO:root:    (232) parenthesized_primary -> . ( expression )
INFO:root:    (157) simple_name -> . IDENTIFIER
INFO:root:    (164) indexed_comp -> . name ( value_s )
INFO:root:    (171) selected_comp -> . name . simple_name
INFO:root:    (172) selected_comp -> . name . used_char
INFO:root:    (173) selected_comp -> . name . operator_symbol
INFO:root:    (174) selected_comp -> . name . ALL
INFO:root:    (175) attribute -> . name TICK attribute_id
INFO:root:    (163) operator_symbol -> . STRING
INFO:root:    (183) aggregate -> . ( comp_assoc )
INFO:root:    (184) aggregate -> . ( expression WITH value_s )
INFO:root:    (185) aggregate -> . ( expression WITH NuLL RECORD )
INFO:root:    (186) aggregate -> . ( NuLL RECORD )
INFO:root:
INFO:root:    ;               shift and go to state 458
INFO:root:    +               shift and go to state 148
INFO:root:    -               shift and go to state 136
INFO:root:    NOT             shift and go to state 131
INFO:root:    ABS             shift and go to state 132
INFO:root:    INT             shift and go to state 120
INFO:root:    FLOAT           shift and go to state 128
INFO:root:    NuLL            shift and go to state 130
INFO:root:    NEW             shift and go to state 137
INFO:root:    (               shift and go to state 125
INFO:root:    IDENTIFIER      shift and go to state 33
INFO:root:    STRING          shift and go to state 149
INFO:root:
INFO:root:    literal                        shift and go to state 121
INFO:root:    allocator                      shift and go to state 122
INFO:root:    simple_name                    shift and go to state 163
INFO:root:    indexed_comp                   shift and go to state 140
INFO:root:    name                           shift and go to state 142
INFO:root:    selected_comp                  shift and go to state 139
INFO:root:    factor                         shift and go to state 126
INFO:root:    expression                     shift and go to state 457
INFO:root:    unary                          shift and go to state 144
INFO:root:    qualified                      shift and go to state 145
INFO:root:    aggregate                      shift and go to state 143
INFO:root:    simple_expression              shift and go to state 129
INFO:root:    term                           shift and go to state 146
INFO:root:    operator_symbol                shift and go to state 133
INFO:root:    parenthesized_primary          shift and go to state 147
INFO:root:    attribute                      shift and go to state 134
INFO:root:    primary                        shift and go to state 135
INFO:root:    relation                       shift and go to state 138
INFO:root:
INFO:root:state 304
INFO:root:
INFO:root:    (253) compound_stmt -> if_stmt .
INFO:root:
INFO:root:    LL              reduce using rule 253 (compound_stmt -> if_stmt .)
INFO:root:    error           reduce using rule 253 (compound_stmt -> if_stmt .)
INFO:root:    NuLL            reduce using rule 253 (compound_stmt -> if_stmt .)
INFO:root:    EXIT            reduce using rule 253 (compound_stmt -> if_stmt .)
INFO:root:    RETURN          reduce using rule 253 (compound_stmt -> if_stmt .)
INFO:root:    DELAY           reduce using rule 253 (compound_stmt -> if_stmt .)
INFO:root:    ABORT           reduce using rule 253 (compound_stmt -> if_stmt .)
INFO:root:    RAISE           reduce using rule 253 (compound_stmt -> if_stmt .)
INFO:root:    REQUEUE         reduce using rule 253 (compound_stmt -> if_stmt .)
INFO:root:    IF              reduce using rule 253 (compound_stmt -> if_stmt .)
INFO:root:    CASE            reduce using rule 253 (compound_stmt -> if_stmt .)
INFO:root:    IDENTIFIER      reduce using rule 253 (compound_stmt -> if_stmt .)
INFO:root:    ACCEPT          reduce using rule 253 (compound_stmt -> if_stmt .)
INFO:root:    SELECT          reduce using rule 253 (compound_stmt -> if_stmt .)
INFO:root:    STRING          reduce using rule 253 (compound_stmt -> if_stmt .)
INFO:root:    WHILE           reduce using rule 253 (compound_stmt -> if_stmt .)
INFO:root:    DECLARE         reduce using rule 253 (compound_stmt -> if_stmt .)
INFO:root:    FOR             reduce using rule 253 (compound_stmt -> if_stmt .)
INFO:root:    LOOP            reduce using rule 253 (compound_stmt -> if_stmt .)
INFO:root:    BEGIN           reduce using rule 253 (compound_stmt -> if_stmt .)
INFO:root:    WHEN            reduce using rule 253 (compound_stmt -> if_stmt .)
INFO:root:    END             reduce using rule 253 (compound_stmt -> if_stmt .)
INFO:root:    OR              reduce using rule 253 (compound_stmt -> if_stmt .)
INFO:root:    ELSE            reduce using rule 253 (compound_stmt -> if_stmt .)
INFO:root:    ELSIF           reduce using rule 253 (compound_stmt -> if_stmt .)
INFO:root:    EXCEPTION       reduce using rule 253 (compound_stmt -> if_stmt .)
INFO:root:    THEN            reduce using rule 253 (compound_stmt -> if_stmt .)
INFO:root:
INFO:root:
INFO:root:state 305
INFO:root:
INFO:root:    (246) simple_stmt -> procedure_call .
INFO:root:
INFO:root:    END             reduce using rule 246 (simple_stmt -> procedure_call .)
INFO:root:    LL              reduce using rule 246 (simple_stmt -> procedure_call .)
INFO:root:    error           reduce using rule 246 (simple_stmt -> procedure_call .)
INFO:root:    NuLL            reduce using rule 246 (simple_stmt -> procedure_call .)
INFO:root:    EXIT            reduce using rule 246 (simple_stmt -> procedure_call .)
INFO:root:    RETURN          reduce using rule 246 (simple_stmt -> procedure_call .)
INFO:root:    DELAY           reduce using rule 246 (simple_stmt -> procedure_call .)
INFO:root:    ABORT           reduce using rule 246 (simple_stmt -> procedure_call .)
INFO:root:    RAISE           reduce using rule 246 (simple_stmt -> procedure_call .)
INFO:root:    REQUEUE         reduce using rule 246 (simple_stmt -> procedure_call .)
INFO:root:    IF              reduce using rule 246 (simple_stmt -> procedure_call .)
INFO:root:    CASE            reduce using rule 246 (simple_stmt -> procedure_call .)
INFO:root:    IDENTIFIER      reduce using rule 246 (simple_stmt -> procedure_call .)
INFO:root:    ACCEPT          reduce using rule 246 (simple_stmt -> procedure_call .)
INFO:root:    SELECT          reduce using rule 246 (simple_stmt -> procedure_call .)
INFO:root:    STRING          reduce using rule 246 (simple_stmt -> procedure_call .)
INFO:root:    WHILE           reduce using rule 246 (simple_stmt -> procedure_call .)
INFO:root:    DECLARE         reduce using rule 246 (simple_stmt -> procedure_call .)
INFO:root:    FOR             reduce using rule 246 (simple_stmt -> procedure_call .)
INFO:root:    LOOP            reduce using rule 246 (simple_stmt -> procedure_call .)
INFO:root:    BEGIN           reduce using rule 246 (simple_stmt -> procedure_call .)
INFO:root:    EXCEPTION       reduce using rule 246 (simple_stmt -> procedure_call .)
INFO:root:    OR              reduce using rule 246 (simple_stmt -> procedure_call .)
INFO:root:    ELSE            reduce using rule 246 (simple_stmt -> procedure_call .)
INFO:root:    THEN            reduce using rule 246 (simple_stmt -> procedure_call .)
INFO:root:    ELSIF           reduce using rule 246 (simple_stmt -> procedure_call .)
INFO:root:    WHEN            reduce using rule 246 (simple_stmt -> procedure_call .)
INFO:root:
INFO:root:
INFO:root:state 306
INFO:root:
INFO:root:    (244) simple_stmt -> exit_stmt .
INFO:root:
INFO:root:    END             reduce using rule 244 (simple_stmt -> exit_stmt .)
INFO:root:    LL              reduce using rule 244 (simple_stmt -> exit_stmt .)
INFO:root:    error           reduce using rule 244 (simple_stmt -> exit_stmt .)
INFO:root:    NuLL            reduce using rule 244 (simple_stmt -> exit_stmt .)
INFO:root:    EXIT            reduce using rule 244 (simple_stmt -> exit_stmt .)
INFO:root:    RETURN          reduce using rule 244 (simple_stmt -> exit_stmt .)
INFO:root:    DELAY           reduce using rule 244 (simple_stmt -> exit_stmt .)
INFO:root:    ABORT           reduce using rule 244 (simple_stmt -> exit_stmt .)
INFO:root:    RAISE           reduce using rule 244 (simple_stmt -> exit_stmt .)
INFO:root:    REQUEUE         reduce using rule 244 (simple_stmt -> exit_stmt .)
INFO:root:    IF              reduce using rule 244 (simple_stmt -> exit_stmt .)
INFO:root:    CASE            reduce using rule 244 (simple_stmt -> exit_stmt .)
INFO:root:    IDENTIFIER      reduce using rule 244 (simple_stmt -> exit_stmt .)
INFO:root:    ACCEPT          reduce using rule 244 (simple_stmt -> exit_stmt .)
INFO:root:    SELECT          reduce using rule 244 (simple_stmt -> exit_stmt .)
INFO:root:    STRING          reduce using rule 244 (simple_stmt -> exit_stmt .)
INFO:root:    WHILE           reduce using rule 244 (simple_stmt -> exit_stmt .)
INFO:root:    DECLARE         reduce using rule 244 (simple_stmt -> exit_stmt .)
INFO:root:    FOR             reduce using rule 244 (simple_stmt -> exit_stmt .)
INFO:root:    LOOP            reduce using rule 244 (simple_stmt -> exit_stmt .)
INFO:root:    BEGIN           reduce using rule 244 (simple_stmt -> exit_stmt .)
INFO:root:    EXCEPTION       reduce using rule 244 (simple_stmt -> exit_stmt .)
INFO:root:    OR              reduce using rule 244 (simple_stmt -> exit_stmt .)
INFO:root:    ELSE            reduce using rule 244 (simple_stmt -> exit_stmt .)
INFO:root:    THEN            reduce using rule 244 (simple_stmt -> exit_stmt .)
INFO:root:    ELSIF           reduce using rule 244 (simple_stmt -> exit_stmt .)
INFO:root:    WHEN            reduce using rule 244 (simple_stmt -> exit_stmt .)
INFO:root:
INFO:root:
INFO:root:state 307
INFO:root:
INFO:root:    (399) select_stmt -> timed_entry_call .
INFO:root:
INFO:root:    LL              reduce using rule 399 (select_stmt -> timed_entry_call .)
INFO:root:    error           reduce using rule 399 (select_stmt -> timed_entry_call .)
INFO:root:    NuLL            reduce using rule 399 (select_stmt -> timed_entry_call .)
INFO:root:    EXIT            reduce using rule 399 (select_stmt -> timed_entry_call .)
INFO:root:    RETURN          reduce using rule 399 (select_stmt -> timed_entry_call .)
INFO:root:    DELAY           reduce using rule 399 (select_stmt -> timed_entry_call .)
INFO:root:    ABORT           reduce using rule 399 (select_stmt -> timed_entry_call .)
INFO:root:    RAISE           reduce using rule 399 (select_stmt -> timed_entry_call .)
INFO:root:    REQUEUE         reduce using rule 399 (select_stmt -> timed_entry_call .)
INFO:root:    IF              reduce using rule 399 (select_stmt -> timed_entry_call .)
INFO:root:    CASE            reduce using rule 399 (select_stmt -> timed_entry_call .)
INFO:root:    IDENTIFIER      reduce using rule 399 (select_stmt -> timed_entry_call .)
INFO:root:    ACCEPT          reduce using rule 399 (select_stmt -> timed_entry_call .)
INFO:root:    SELECT          reduce using rule 399 (select_stmt -> timed_entry_call .)
INFO:root:    STRING          reduce using rule 399 (select_stmt -> timed_entry_call .)
INFO:root:    WHILE           reduce using rule 399 (select_stmt -> timed_entry_call .)
INFO:root:    DECLARE         reduce using rule 399 (select_stmt -> timed_entry_call .)
INFO:root:    FOR             reduce using rule 399 (select_stmt -> timed_entry_call .)
INFO:root:    LOOP            reduce using rule 399 (select_stmt -> timed_entry_call .)
INFO:root:    BEGIN           reduce using rule 399 (select_stmt -> timed_entry_call .)
INFO:root:    END             reduce using rule 399 (select_stmt -> timed_entry_call .)
INFO:root:    WHEN            reduce using rule 399 (select_stmt -> timed_entry_call .)
INFO:root:    ELSIF           reduce using rule 399 (select_stmt -> timed_entry_call .)
INFO:root:    ELSE            reduce using rule 399 (select_stmt -> timed_entry_call .)
INFO:root:    EXCEPTION       reduce using rule 399 (select_stmt -> timed_entry_call .)
INFO:root:    OR              reduce using rule 399 (select_stmt -> timed_entry_call .)
INFO:root:    THEN            reduce using rule 399 (select_stmt -> timed_entry_call .)
INFO:root:
INFO:root:
INFO:root:state 308
INFO:root:
INFO:root:    (236) statement_s -> statement .
INFO:root:
INFO:root:    LL              reduce using rule 236 (statement_s -> statement .)
INFO:root:    error           reduce using rule 236 (statement_s -> statement .)
INFO:root:    NuLL            reduce using rule 236 (statement_s -> statement .)
INFO:root:    EXIT            reduce using rule 236 (statement_s -> statement .)
INFO:root:    RETURN          reduce using rule 236 (statement_s -> statement .)
INFO:root:    DELAY           reduce using rule 236 (statement_s -> statement .)
INFO:root:    ABORT           reduce using rule 236 (statement_s -> statement .)
INFO:root:    RAISE           reduce using rule 236 (statement_s -> statement .)
INFO:root:    REQUEUE         reduce using rule 236 (statement_s -> statement .)
INFO:root:    IF              reduce using rule 236 (statement_s -> statement .)
INFO:root:    CASE            reduce using rule 236 (statement_s -> statement .)
INFO:root:    IDENTIFIER      reduce using rule 236 (statement_s -> statement .)
INFO:root:    ACCEPT          reduce using rule 236 (statement_s -> statement .)
INFO:root:    SELECT          reduce using rule 236 (statement_s -> statement .)
INFO:root:    STRING          reduce using rule 236 (statement_s -> statement .)
INFO:root:    WHILE           reduce using rule 236 (statement_s -> statement .)
INFO:root:    DECLARE         reduce using rule 236 (statement_s -> statement .)
INFO:root:    FOR             reduce using rule 236 (statement_s -> statement .)
INFO:root:    LOOP            reduce using rule 236 (statement_s -> statement .)
INFO:root:    BEGIN           reduce using rule 236 (statement_s -> statement .)
INFO:root:    END             reduce using rule 236 (statement_s -> statement .)
INFO:root:    WHEN            reduce using rule 236 (statement_s -> statement .)
INFO:root:    THEN            reduce using rule 236 (statement_s -> statement .)
INFO:root:    OR              reduce using rule 236 (statement_s -> statement .)
INFO:root:    ELSE            reduce using rule 236 (statement_s -> statement .)
INFO:root:    EXCEPTION       reduce using rule 236 (statement_s -> statement .)
INFO:root:    ELSIF           reduce using rule 236 (statement_s -> statement .)
INFO:root:
INFO:root:
INFO:root:state 309
INFO:root:
INFO:root:    (241) unlabeled -> compound_stmt .
INFO:root:
INFO:root:    EXCEPTION       reduce using rule 241 (unlabeled -> compound_stmt .)
INFO:root:    LL              reduce using rule 241 (unlabeled -> compound_stmt .)
INFO:root:    error           reduce using rule 241 (unlabeled -> compound_stmt .)
INFO:root:    NuLL            reduce using rule 241 (unlabeled -> compound_stmt .)
INFO:root:    EXIT            reduce using rule 241 (unlabeled -> compound_stmt .)
INFO:root:    RETURN          reduce using rule 241 (unlabeled -> compound_stmt .)
INFO:root:    DELAY           reduce using rule 241 (unlabeled -> compound_stmt .)
INFO:root:    ABORT           reduce using rule 241 (unlabeled -> compound_stmt .)
INFO:root:    RAISE           reduce using rule 241 (unlabeled -> compound_stmt .)
INFO:root:    REQUEUE         reduce using rule 241 (unlabeled -> compound_stmt .)
INFO:root:    IF              reduce using rule 241 (unlabeled -> compound_stmt .)
INFO:root:    CASE            reduce using rule 241 (unlabeled -> compound_stmt .)
INFO:root:    IDENTIFIER      reduce using rule 241 (unlabeled -> compound_stmt .)
INFO:root:    ACCEPT          reduce using rule 241 (unlabeled -> compound_stmt .)
INFO:root:    SELECT          reduce using rule 241 (unlabeled -> compound_stmt .)
INFO:root:    STRING          reduce using rule 241 (unlabeled -> compound_stmt .)
INFO:root:    WHILE           reduce using rule 241 (unlabeled -> compound_stmt .)
INFO:root:    DECLARE         reduce using rule 241 (unlabeled -> compound_stmt .)
INFO:root:    FOR             reduce using rule 241 (unlabeled -> compound_stmt .)
INFO:root:    LOOP            reduce using rule 241 (unlabeled -> compound_stmt .)
INFO:root:    BEGIN           reduce using rule 241 (unlabeled -> compound_stmt .)
INFO:root:    END             reduce using rule 241 (unlabeled -> compound_stmt .)
INFO:root:    OR              reduce using rule 241 (unlabeled -> compound_stmt .)
INFO:root:    ELSE            reduce using rule 241 (unlabeled -> compound_stmt .)
INFO:root:    THEN            reduce using rule 241 (unlabeled -> compound_stmt .)
INFO:root:    ELSIF           reduce using rule 241 (unlabeled -> compound_stmt .)
INFO:root:    WHEN            reduce using rule 241 (unlabeled -> compound_stmt .)
INFO:root:
INFO:root:
INFO:root:state 310
INFO:root:
INFO:root:    (392) accept_hdr -> ACCEPT . entry_name formal_part_opt
INFO:root:    (393) entry_name -> . simple_name
INFO:root:    (394) entry_name -> . entry_name ( expression )
INFO:root:    (157) simple_name -> . IDENTIFIER
INFO:root:
INFO:root:    IDENTIFIER      shift and go to state 33
INFO:root:
INFO:root:    entry_name                     shift and go to state 460
INFO:root:    simple_name                    shift and go to state 459
INFO:root:
INFO:root:state 311
INFO:root:
INFO:root:    (258) compound_stmt -> select_stmt .
INFO:root:
INFO:root:    LL              reduce using rule 258 (compound_stmt -> select_stmt .)
INFO:root:    error           reduce using rule 258 (compound_stmt -> select_stmt .)
INFO:root:    NuLL            reduce using rule 258 (compound_stmt -> select_stmt .)
INFO:root:    EXIT            reduce using rule 258 (compound_stmt -> select_stmt .)
INFO:root:    RETURN          reduce using rule 258 (compound_stmt -> select_stmt .)
INFO:root:    DELAY           reduce using rule 258 (compound_stmt -> select_stmt .)
INFO:root:    ABORT           reduce using rule 258 (compound_stmt -> select_stmt .)
INFO:root:    RAISE           reduce using rule 258 (compound_stmt -> select_stmt .)
INFO:root:    REQUEUE         reduce using rule 258 (compound_stmt -> select_stmt .)
INFO:root:    IF              reduce using rule 258 (compound_stmt -> select_stmt .)
INFO:root:    CASE            reduce using rule 258 (compound_stmt -> select_stmt .)
INFO:root:    IDENTIFIER      reduce using rule 258 (compound_stmt -> select_stmt .)
INFO:root:    ACCEPT          reduce using rule 258 (compound_stmt -> select_stmt .)
INFO:root:    SELECT          reduce using rule 258 (compound_stmt -> select_stmt .)
INFO:root:    STRING          reduce using rule 258 (compound_stmt -> select_stmt .)
INFO:root:    WHILE           reduce using rule 258 (compound_stmt -> select_stmt .)
INFO:root:    DECLARE         reduce using rule 258 (compound_stmt -> select_stmt .)
INFO:root:    FOR             reduce using rule 258 (compound_stmt -> select_stmt .)
INFO:root:    LOOP            reduce using rule 258 (compound_stmt -> select_stmt .)
INFO:root:    BEGIN           reduce using rule 258 (compound_stmt -> select_stmt .)
INFO:root:    WHEN            reduce using rule 258 (compound_stmt -> select_stmt .)
INFO:root:    END             reduce using rule 258 (compound_stmt -> select_stmt .)
INFO:root:    OR              reduce using rule 258 (compound_stmt -> select_stmt .)
INFO:root:    ELSE            reduce using rule 258 (compound_stmt -> select_stmt .)
INFO:root:    ELSIF           reduce using rule 258 (compound_stmt -> select_stmt .)
INFO:root:    EXCEPTION       reduce using rule 258 (compound_stmt -> select_stmt .)
INFO:root:    THEN            reduce using rule 258 (compound_stmt -> select_stmt .)
INFO:root:
INFO:root:
INFO:root:state 312
INFO:root:
INFO:root:    (271) case_hdr -> CASE . expression IS
INFO:root:    (188) expression -> . relation
INFO:root:    (189) expression -> . expression logical relation
INFO:root:    (190) expression -> . expression short_circuit relation
INFO:root:    (196) relation -> . simple_expression
INFO:root:    (197) relation -> . simple_expression relational simple_expression
INFO:root:    (198) relation -> . simple_expression membership range
INFO:root:    (199) relation -> . simple_expression membership name
INFO:root:    (208) simple_expression -> . unary term
INFO:root:    (209) simple_expression -> . term
INFO:root:    (210) simple_expression -> . simple_expression adding term
INFO:root:    (211) unary -> . +
INFO:root:    (212) unary -> . -
INFO:root:    (216) term -> . factor
INFO:root:    (217) term -> . term multiplying factor
INFO:root:    (223) factor -> . primary
INFO:root:    (224) factor -> . NOT primary
INFO:root:    (225) factor -> . ABS primary
INFO:root:    (226) primary -> . literal
INFO:root:    (227) primary -> . name
INFO:root:    (228) primary -> . allocator
INFO:root:    (229) primary -> . qualified
INFO:root:    (230) primary -> . parenthesized_primary
INFO:root:    (180) literal -> . INT
INFO:root:    (181) literal -> . FLOAT
INFO:root:    (182) literal -> . NuLL
INFO:root:    (149) name -> . simple_name
INFO:root:    (150) name -> . indexed_comp
INFO:root:    (151) name -> . selected_comp
INFO:root:    (152) name -> . attribute
INFO:root:    (153) name -> . operator_symbol
INFO:root:    (234) allocator -> . NEW name
INFO:root:    (235) allocator -> . NEW qualified
INFO:root:    (233) qualified -> . name TICK parenthesized_primary
INFO:root:    (231) parenthesized_primary -> . aggregate
INFO:root:    (232) parenthesized_primary -> . ( expression )
INFO:root:    (157) simple_name -> . IDENTIFIER
INFO:root:    (164) indexed_comp -> . name ( value_s )
INFO:root:    (171) selected_comp -> . name . simple_name
INFO:root:    (172) selected_comp -> . name . used_char
INFO:root:    (173) selected_comp -> . name . operator_symbol
INFO:root:    (174) selected_comp -> . name . ALL
INFO:root:    (175) attribute -> . name TICK attribute_id
INFO:root:    (163) operator_symbol -> . STRING
INFO:root:    (183) aggregate -> . ( comp_assoc )
INFO:root:    (184) aggregate -> . ( expression WITH value_s )
INFO:root:    (185) aggregate -> . ( expression WITH NuLL RECORD )
INFO:root:    (186) aggregate -> . ( NuLL RECORD )
INFO:root:
INFO:root:    +               shift and go to state 148
INFO:root:    -               shift and go to state 136
INFO:root:    NOT             shift and go to state 131
INFO:root:    ABS             shift and go to state 132
INFO:root:    INT             shift and go to state 120
INFO:root:    FLOAT           shift and go to state 128
INFO:root:    NuLL            shift and go to state 130
INFO:root:    NEW             shift and go to state 137
INFO:root:    (               shift and go to state 125
INFO:root:    IDENTIFIER      shift and go to state 33
INFO:root:    STRING          shift and go to state 149
INFO:root:
INFO:root:    literal                        shift and go to state 121
INFO:root:    allocator                      shift and go to state 122
INFO:root:    simple_name                    shift and go to state 163
INFO:root:    indexed_comp                   shift and go to state 140
INFO:root:    name                           shift and go to state 142
INFO:root:    selected_comp                  shift and go to state 139
INFO:root:    factor                         shift and go to state 126
INFO:root:    expression                     shift and go to state 461
INFO:root:    unary                          shift and go to state 144
INFO:root:    qualified                      shift and go to state 145
INFO:root:    aggregate                      shift and go to state 143
INFO:root:    simple_expression              shift and go to state 129
INFO:root:    term                           shift and go to state 146
INFO:root:    operator_symbol                shift and go to state 133
INFO:root:    parenthesized_primary          shift and go to state 147
INFO:root:    attribute                      shift and go to state 134
INFO:root:    primary                        shift and go to state 135
INFO:root:    relation                       shift and go to state 138
INFO:root:
INFO:root:state 313
INFO:root:
INFO:root:    (275) loop_stmt -> label_opt . iteration basic_loop id_opt ;
INFO:root:    (287) block -> label_opt . block_decl block_body END id_opt ;
INFO:root:    (278) iteration -> .
INFO:root:    (279) iteration -> . WHILE condition
INFO:root:    (280) iteration -> . iter_part reverse_opt discrete_range
INFO:root:    (288) block_decl -> .
INFO:root:    (289) block_decl -> . DECLARE decl_part
INFO:root:    (281) iter_part -> . FOR IDENTIFIER IN
INFO:root:
INFO:root:    LOOP            reduce using rule 278 (iteration -> .)
INFO:root:    WHILE           shift and go to state 465
INFO:root:    BEGIN           reduce using rule 288 (block_decl -> .)
INFO:root:    DECLARE         shift and go to state 466
INFO:root:    FOR             shift and go to state 464
INFO:root:
INFO:root:    iteration                      shift and go to state 462
INFO:root:    iter_part                      shift and go to state 467
INFO:root:    block_decl                     shift and go to state 463
INFO:root:
INFO:root:state 314
INFO:root:
INFO:root:    (455) raise_stmt -> RAISE . name_opt ;
INFO:root:    (295) name_opt -> .
INFO:root:    (296) name_opt -> . name
INFO:root:    (149) name -> . simple_name
INFO:root:    (150) name -> . indexed_comp
INFO:root:    (151) name -> . selected_comp
INFO:root:    (152) name -> . attribute
INFO:root:    (153) name -> . operator_symbol
INFO:root:    (157) simple_name -> . IDENTIFIER
INFO:root:    (164) indexed_comp -> . name ( value_s )
INFO:root:    (171) selected_comp -> . name . simple_name
INFO:root:    (172) selected_comp -> . name . used_char
INFO:root:    (173) selected_comp -> . name . operator_symbol
INFO:root:    (174) selected_comp -> . name . ALL
INFO:root:    (175) attribute -> . name TICK attribute_id
INFO:root:    (163) operator_symbol -> . STRING
INFO:root:
INFO:root:    ;               reduce using rule 295 (name_opt -> .)
INFO:root:    IDENTIFIER      shift and go to state 33
INFO:root:    STRING          shift and go to state 149
INFO:root:
INFO:root:    attribute                      shift and go to state 134
INFO:root:    selected_comp                  shift and go to state 139
INFO:root:    simple_name                    shift and go to state 163
INFO:root:    indexed_comp                   shift and go to state 140
INFO:root:    name_opt                       shift and go to state 469
INFO:root:    name                           shift and go to state 468
INFO:root:    operator_symbol                shift and go to state 133
INFO:root:
INFO:root:state 315
INFO:root:
INFO:root:    (248) simple_stmt -> abort_stmt .
INFO:root:
INFO:root:    END             reduce using rule 248 (simple_stmt -> abort_stmt .)
INFO:root:    LL              reduce using rule 248 (simple_stmt -> abort_stmt .)
INFO:root:    error           reduce using rule 248 (simple_stmt -> abort_stmt .)
INFO:root:    NuLL            reduce using rule 248 (simple_stmt -> abort_stmt .)
INFO:root:    EXIT            reduce using rule 248 (simple_stmt -> abort_stmt .)
INFO:root:    RETURN          reduce using rule 248 (simple_stmt -> abort_stmt .)
INFO:root:    DELAY           reduce using rule 248 (simple_stmt -> abort_stmt .)
INFO:root:    ABORT           reduce using rule 248 (simple_stmt -> abort_stmt .)
INFO:root:    RAISE           reduce using rule 248 (simple_stmt -> abort_stmt .)
INFO:root:    REQUEUE         reduce using rule 248 (simple_stmt -> abort_stmt .)
INFO:root:    IF              reduce using rule 248 (simple_stmt -> abort_stmt .)
INFO:root:    CASE            reduce using rule 248 (simple_stmt -> abort_stmt .)
INFO:root:    IDENTIFIER      reduce using rule 248 (simple_stmt -> abort_stmt .)
INFO:root:    ACCEPT          reduce using rule 248 (simple_stmt -> abort_stmt .)
INFO:root:    SELECT          reduce using rule 248 (simple_stmt -> abort_stmt .)
INFO:root:    STRING          reduce using rule 248 (simple_stmt -> abort_stmt .)
INFO:root:    WHILE           reduce using rule 248 (simple_stmt -> abort_stmt .)
INFO:root:    DECLARE         reduce using rule 248 (simple_stmt -> abort_stmt .)
INFO:root:    FOR             reduce using rule 248 (simple_stmt -> abort_stmt .)
INFO:root:    LOOP            reduce using rule 248 (simple_stmt -> abort_stmt .)
INFO:root:    BEGIN           reduce using rule 248 (simple_stmt -> abort_stmt .)
INFO:root:    EXCEPTION       reduce using rule 248 (simple_stmt -> abort_stmt .)
INFO:root:    OR              reduce using rule 248 (simple_stmt -> abort_stmt .)
INFO:root:    ELSE            reduce using rule 248 (simple_stmt -> abort_stmt .)
INFO:root:    THEN            reduce using rule 248 (simple_stmt -> abort_stmt .)
INFO:root:    ELSIF           reduce using rule 248 (simple_stmt -> abort_stmt .)
INFO:root:    WHEN            reduce using rule 248 (simple_stmt -> abort_stmt .)
INFO:root:
INFO:root:
INFO:root:state 316
INFO:root:
INFO:root:    (261) assign_stmt -> name . ASSIGN expression ;
INFO:root:    (323) procedure_call -> name . ;
INFO:root:    (233) qualified -> name . TICK parenthesized_primary
INFO:root:    (164) indexed_comp -> name . ( value_s )
INFO:root:    (171) selected_comp -> name . . simple_name
INFO:root:    (172) selected_comp -> name . . used_char
INFO:root:    (173) selected_comp -> name . . operator_symbol
INFO:root:    (174) selected_comp -> name . . ALL
INFO:root:    (175) attribute -> name . TICK attribute_id
INFO:root:
INFO:root:    ASSIGN          shift and go to state 471
INFO:root:    ;               shift and go to state 470
INFO:root:    TICK            shift and go to state 238
INFO:root:    (               shift and go to state 237
INFO:root:    .               shift and go to state 239
INFO:root:
INFO:root:
INFO:root:state 317
INFO:root:
INFO:root:    (456) requeue_stmt -> REQUEUE . name ;
INFO:root:    (457) requeue_stmt -> REQUEUE . name WITH ABORT ;
INFO:root:    (149) name -> . simple_name
INFO:root:    (150) name -> . indexed_comp
INFO:root:    (151) name -> . selected_comp
INFO:root:    (152) name -> . attribute
INFO:root:    (153) name -> . operator_symbol
INFO:root:    (157) simple_name -> . IDENTIFIER
INFO:root:    (164) indexed_comp -> . name ( value_s )
INFO:root:    (171) selected_comp -> . name . simple_name
INFO:root:    (172) selected_comp -> . name . used_char
INFO:root:    (173) selected_comp -> . name . operator_symbol
INFO:root:    (174) selected_comp -> . name . ALL
INFO:root:    (175) attribute -> . name TICK attribute_id
INFO:root:    (163) operator_symbol -> . STRING
INFO:root:
INFO:root:    IDENTIFIER      shift and go to state 33
INFO:root:    STRING          shift and go to state 149
INFO:root:
INFO:root:    selected_comp                  shift and go to state 139
INFO:root:    simple_name                    shift and go to state 163
INFO:root:    indexed_comp                   shift and go to state 140
INFO:root:    attribute                      shift and go to state 134
INFO:root:    name                           shift and go to state 472
INFO:root:    operator_symbol                shift and go to state 133
INFO:root:
INFO:root:state 318
INFO:root:
INFO:root:    (390) accept_stmt -> accept_hdr . ;
INFO:root:    (391) accept_stmt -> accept_hdr . DO handled_stmt_s END id_opt ;
INFO:root:
INFO:root:    ;               shift and go to state 474
INFO:root:    DO              shift and go to state 473
INFO:root:
INFO:root:
INFO:root:state 319
INFO:root:
INFO:root:    (270) case_stmt -> case_hdr . pragma_s alternative_s END CASE ;
INFO:root:    (8) pragma_s -> .
INFO:root:    (9) pragma_s -> . pragma_s pragma
INFO:root:
INFO:root:    PRAGMA          reduce using rule 8 (pragma_s -> .)
INFO:root:    END             reduce using rule 8 (pragma_s -> .)
INFO:root:    WHEN            reduce using rule 8 (pragma_s -> .)
INFO:root:
INFO:root:    pragma_s                       shift and go to state 475
INFO:root:
INFO:root:state 320
INFO:root:
INFO:root:    (401) select_wait -> SELECT . guarded_select_alt or_select else_opt END SELECT ;
INFO:root:    (411) async_select -> SELECT . delay_or_entry_alt THEN ABORT statement_s END SELECT ;
INFO:root:    (412) timed_entry_call -> SELECT . entry_call stmts_opt OR delay_stmt stmts_opt END SELECT ;
INFO:root:    (413) cond_entry_call -> SELECT . entry_call stmts_opt ELSE statement_s END SELECT ;
INFO:root:    (402) guarded_select_alt -> . select_alt
INFO:root:    (403) guarded_select_alt -> . WHEN condition ARROW select_alt
INFO:root:    (409) delay_or_entry_alt -> . delay_stmt stmts_opt
INFO:root:    (410) delay_or_entry_alt -> . entry_call stmts_opt
INFO:root:    (389) entry_call -> . procedure_call
INFO:root:    (406) select_alt -> . accept_stmt stmts_opt
INFO:root:    (407) select_alt -> . delay_stmt stmts_opt
INFO:root:    (408) select_alt -> . TERMINATE ;
INFO:root:    (395) delay_stmt -> . DELAY expression ;
INFO:root:    (396) delay_stmt -> . DELAY UNTIL expression ;
INFO:root:    (323) procedure_call -> . name ;
INFO:root:    (390) accept_stmt -> . accept_hdr ;
INFO:root:    (391) accept_stmt -> . accept_hdr DO handled_stmt_s END id_opt ;
INFO:root:    (149) name -> . simple_name
INFO:root:    (150) name -> . indexed_comp
INFO:root:    (151) name -> . selected_comp
INFO:root:    (152) name -> . attribute
INFO:root:    (153) name -> . operator_symbol
INFO:root:    (392) accept_hdr -> . ACCEPT entry_name formal_part_opt
INFO:root:    (157) simple_name -> . IDENTIFIER
INFO:root:    (164) indexed_comp -> . name ( value_s )
INFO:root:    (171) selected_comp -> . name . simple_name
INFO:root:    (172) selected_comp -> . name . used_char
INFO:root:    (173) selected_comp -> . name . operator_symbol
INFO:root:    (174) selected_comp -> . name . ALL
INFO:root:    (175) attribute -> . name TICK attribute_id
INFO:root:    (163) operator_symbol -> . STRING
INFO:root:
INFO:root:    WHEN            shift and go to state 484
INFO:root:    TERMINATE       shift and go to state 479
INFO:root:    DELAY           shift and go to state 332
INFO:root:    ACCEPT          shift and go to state 310
INFO:root:    IDENTIFIER      shift and go to state 33
INFO:root:    STRING          shift and go to state 149
INFO:root:
INFO:root:    selected_comp                  shift and go to state 139
INFO:root:    delay_or_entry_alt             shift and go to state 480
INFO:root:    indexed_comp                   shift and go to state 140
INFO:root:    name                           shift and go to state 481
INFO:root:    accept_hdr                     shift and go to state 318
INFO:root:    simple_name                    shift and go to state 163
INFO:root:    accept_stmt                    shift and go to state 482
INFO:root:    delay_stmt                     shift and go to state 483
INFO:root:    procedure_call                 shift and go to state 477
INFO:root:    entry_call                     shift and go to state 476
INFO:root:    operator_symbol                shift and go to state 133
INFO:root:    attribute                      shift and go to state 134
INFO:root:    select_alt                     shift and go to state 485
INFO:root:    guarded_select_alt             shift and go to state 478
INFO:root:
INFO:root:state 321
INFO:root:
INFO:root:    (501) code_stmt -> qualified . ;
INFO:root:
INFO:root:    ;               shift and go to state 486
INFO:root:
INFO:root:
INFO:root:state 322
INFO:root:
INFO:root:    (277) label_opt -> IDENTIFIER . :
INFO:root:    (157) simple_name -> IDENTIFIER .
INFO:root:
INFO:root:    :               shift and go to state 487
INFO:root:    ASSIGN          reduce using rule 157 (simple_name -> IDENTIFIER .)
INFO:root:    ;               reduce using rule 157 (simple_name -> IDENTIFIER .)
INFO:root:    TICK            reduce using rule 157 (simple_name -> IDENTIFIER .)
INFO:root:    (               reduce using rule 157 (simple_name -> IDENTIFIER .)
INFO:root:    .               reduce using rule 157 (simple_name -> IDENTIFIER .)
INFO:root:
INFO:root:
INFO:root:state 323
INFO:root:
INFO:root:    (245) simple_stmt -> return_stmt .
INFO:root:
INFO:root:    END             reduce using rule 245 (simple_stmt -> return_stmt .)
INFO:root:    LL              reduce using rule 245 (simple_stmt -> return_stmt .)
INFO:root:    error           reduce using rule 245 (simple_stmt -> return_stmt .)
INFO:root:    NuLL            reduce using rule 245 (simple_stmt -> return_stmt .)
INFO:root:    EXIT            reduce using rule 245 (simple_stmt -> return_stmt .)
INFO:root:    RETURN          reduce using rule 245 (simple_stmt -> return_stmt .)
INFO:root:    DELAY           reduce using rule 245 (simple_stmt -> return_stmt .)
INFO:root:    ABORT           reduce using rule 245 (simple_stmt -> return_stmt .)
INFO:root:    RAISE           reduce using rule 245 (simple_stmt -> return_stmt .)
INFO:root:    REQUEUE         reduce using rule 245 (simple_stmt -> return_stmt .)
INFO:root:    IF              reduce using rule 245 (simple_stmt -> return_stmt .)
INFO:root:    CASE            reduce using rule 245 (simple_stmt -> return_stmt .)
INFO:root:    IDENTIFIER      reduce using rule 245 (simple_stmt -> return_stmt .)
INFO:root:    ACCEPT          reduce using rule 245 (simple_stmt -> return_stmt .)
INFO:root:    SELECT          reduce using rule 245 (simple_stmt -> return_stmt .)
INFO:root:    STRING          reduce using rule 245 (simple_stmt -> return_stmt .)
INFO:root:    WHILE           reduce using rule 245 (simple_stmt -> return_stmt .)
INFO:root:    DECLARE         reduce using rule 245 (simple_stmt -> return_stmt .)
INFO:root:    FOR             reduce using rule 245 (simple_stmt -> return_stmt .)
INFO:root:    LOOP            reduce using rule 245 (simple_stmt -> return_stmt .)
INFO:root:    BEGIN           reduce using rule 245 (simple_stmt -> return_stmt .)
INFO:root:    EXCEPTION       reduce using rule 245 (simple_stmt -> return_stmt .)
INFO:root:    OR              reduce using rule 245 (simple_stmt -> return_stmt .)
INFO:root:    ELSE            reduce using rule 245 (simple_stmt -> return_stmt .)
INFO:root:    THEN            reduce using rule 245 (simple_stmt -> return_stmt .)
INFO:root:    ELSIF           reduce using rule 245 (simple_stmt -> return_stmt .)
INFO:root:    WHEN            reduce using rule 245 (simple_stmt -> return_stmt .)
INFO:root:
INFO:root:
INFO:root:state 324
INFO:root:
INFO:root:    (254) compound_stmt -> case_stmt .
INFO:root:
INFO:root:    LL              reduce using rule 254 (compound_stmt -> case_stmt .)
INFO:root:    error           reduce using rule 254 (compound_stmt -> case_stmt .)
INFO:root:    NuLL            reduce using rule 254 (compound_stmt -> case_stmt .)
INFO:root:    EXIT            reduce using rule 254 (compound_stmt -> case_stmt .)
INFO:root:    RETURN          reduce using rule 254 (compound_stmt -> case_stmt .)
INFO:root:    DELAY           reduce using rule 254 (compound_stmt -> case_stmt .)
INFO:root:    ABORT           reduce using rule 254 (compound_stmt -> case_stmt .)
INFO:root:    RAISE           reduce using rule 254 (compound_stmt -> case_stmt .)
INFO:root:    REQUEUE         reduce using rule 254 (compound_stmt -> case_stmt .)
INFO:root:    IF              reduce using rule 254 (compound_stmt -> case_stmt .)
INFO:root:    CASE            reduce using rule 254 (compound_stmt -> case_stmt .)
INFO:root:    IDENTIFIER      reduce using rule 254 (compound_stmt -> case_stmt .)
INFO:root:    ACCEPT          reduce using rule 254 (compound_stmt -> case_stmt .)
INFO:root:    SELECT          reduce using rule 254 (compound_stmt -> case_stmt .)
INFO:root:    STRING          reduce using rule 254 (compound_stmt -> case_stmt .)
INFO:root:    WHILE           reduce using rule 254 (compound_stmt -> case_stmt .)
INFO:root:    DECLARE         reduce using rule 254 (compound_stmt -> case_stmt .)
INFO:root:    FOR             reduce using rule 254 (compound_stmt -> case_stmt .)
INFO:root:    LOOP            reduce using rule 254 (compound_stmt -> case_stmt .)
INFO:root:    BEGIN           reduce using rule 254 (compound_stmt -> case_stmt .)
INFO:root:    WHEN            reduce using rule 254 (compound_stmt -> case_stmt .)
INFO:root:    END             reduce using rule 254 (compound_stmt -> case_stmt .)
INFO:root:    OR              reduce using rule 254 (compound_stmt -> case_stmt .)
INFO:root:    ELSE            reduce using rule 254 (compound_stmt -> case_stmt .)
INFO:root:    ELSIF           reduce using rule 254 (compound_stmt -> case_stmt .)
INFO:root:    EXCEPTION       reduce using rule 254 (compound_stmt -> case_stmt .)
INFO:root:    THEN            reduce using rule 254 (compound_stmt -> case_stmt .)
INFO:root:
INFO:root:
INFO:root:state 325
INFO:root:
INFO:root:    (256) compound_stmt -> block .
INFO:root:
INFO:root:    LL              reduce using rule 256 (compound_stmt -> block .)
INFO:root:    error           reduce using rule 256 (compound_stmt -> block .)
INFO:root:    NuLL            reduce using rule 256 (compound_stmt -> block .)
INFO:root:    EXIT            reduce using rule 256 (compound_stmt -> block .)
INFO:root:    RETURN          reduce using rule 256 (compound_stmt -> block .)
INFO:root:    DELAY           reduce using rule 256 (compound_stmt -> block .)
INFO:root:    ABORT           reduce using rule 256 (compound_stmt -> block .)
INFO:root:    RAISE           reduce using rule 256 (compound_stmt -> block .)
INFO:root:    REQUEUE         reduce using rule 256 (compound_stmt -> block .)
INFO:root:    IF              reduce using rule 256 (compound_stmt -> block .)
INFO:root:    CASE            reduce using rule 256 (compound_stmt -> block .)
INFO:root:    IDENTIFIER      reduce using rule 256 (compound_stmt -> block .)
INFO:root:    ACCEPT          reduce using rule 256 (compound_stmt -> block .)
INFO:root:    SELECT          reduce using rule 256 (compound_stmt -> block .)
INFO:root:    STRING          reduce using rule 256 (compound_stmt -> block .)
INFO:root:    WHILE           reduce using rule 256 (compound_stmt -> block .)
INFO:root:    DECLARE         reduce using rule 256 (compound_stmt -> block .)
INFO:root:    FOR             reduce using rule 256 (compound_stmt -> block .)
INFO:root:    LOOP            reduce using rule 256 (compound_stmt -> block .)
INFO:root:    BEGIN           reduce using rule 256 (compound_stmt -> block .)
INFO:root:    WHEN            reduce using rule 256 (compound_stmt -> block .)
INFO:root:    END             reduce using rule 256 (compound_stmt -> block .)
INFO:root:    OR              reduce using rule 256 (compound_stmt -> block .)
INFO:root:    ELSE            reduce using rule 256 (compound_stmt -> block .)
INFO:root:    ELSIF           reduce using rule 256 (compound_stmt -> block .)
INFO:root:    EXCEPTION       reduce using rule 256 (compound_stmt -> block .)
INFO:root:    THEN            reduce using rule 256 (compound_stmt -> block .)
INFO:root:
INFO:root:
INFO:root:state 326
INFO:root:
INFO:root:    (416) abort_stmt -> ABORT . name_s ;
INFO:root:    (339) name_s -> . name
INFO:root:    (340) name_s -> . name_s , name
INFO:root:    (149) name -> . simple_name
INFO:root:    (150) name -> . indexed_comp
INFO:root:    (151) name -> . selected_comp
INFO:root:    (152) name -> . attribute
INFO:root:    (153) name -> . operator_symbol
INFO:root:    (157) simple_name -> . IDENTIFIER
INFO:root:    (164) indexed_comp -> . name ( value_s )
INFO:root:    (171) selected_comp -> . name . simple_name
INFO:root:    (172) selected_comp -> . name . used_char
INFO:root:    (173) selected_comp -> . name . operator_symbol
INFO:root:    (174) selected_comp -> . name . ALL
INFO:root:    (175) attribute -> . name TICK attribute_id
INFO:root:    (163) operator_symbol -> . STRING
INFO:root:
INFO:root:    IDENTIFIER      shift and go to state 33
INFO:root:    STRING          shift and go to state 149
INFO:root:
INFO:root:    selected_comp                  shift and go to state 139
INFO:root:    simple_name                    shift and go to state 163
INFO:root:    indexed_comp                   shift and go to state 140
INFO:root:    attribute                      shift and go to state 134
INFO:root:    name                           shift and go to state 161
INFO:root:    name_s                         shift and go to state 488
INFO:root:    operator_symbol                shift and go to state 133
INFO:root:
INFO:root:state 327
INFO:root:
INFO:root:    (262) if_stmt -> IF . cond_clause_s else_opt END IF ;
INFO:root:    (263) cond_clause_s -> . cond_clause
INFO:root:    (264) cond_clause_s -> . cond_clause_s ELSIF cond_clause
INFO:root:    (265) cond_clause -> . cond_part statement_s
INFO:root:    (266) cond_part -> . condition THEN
INFO:root:    (267) condition -> . expression
INFO:root:    (188) expression -> . relation
INFO:root:    (189) expression -> . expression logical relation
INFO:root:    (190) expression -> . expression short_circuit relation
INFO:root:    (196) relation -> . simple_expression
INFO:root:    (197) relation -> . simple_expression relational simple_expression
INFO:root:    (198) relation -> . simple_expression membership range
INFO:root:    (199) relation -> . simple_expression membership name
INFO:root:    (208) simple_expression -> . unary term
INFO:root:    (209) simple_expression -> . term
INFO:root:    (210) simple_expression -> . simple_expression adding term
INFO:root:    (211) unary -> . +
INFO:root:    (212) unary -> . -
INFO:root:    (216) term -> . factor
INFO:root:    (217) term -> . term multiplying factor
INFO:root:    (223) factor -> . primary
INFO:root:    (224) factor -> . NOT primary
INFO:root:    (225) factor -> . ABS primary
INFO:root:    (226) primary -> . literal
INFO:root:    (227) primary -> . name
INFO:root:    (228) primary -> . allocator
INFO:root:    (229) primary -> . qualified
INFO:root:    (230) primary -> . parenthesized_primary
INFO:root:    (180) literal -> . INT
INFO:root:    (181) literal -> . FLOAT
INFO:root:    (182) literal -> . NuLL
INFO:root:    (149) name -> . simple_name
INFO:root:    (150) name -> . indexed_comp
INFO:root:    (151) name -> . selected_comp
INFO:root:    (152) name -> . attribute
INFO:root:    (153) name -> . operator_symbol
INFO:root:    (234) allocator -> . NEW name
INFO:root:    (235) allocator -> . NEW qualified
INFO:root:    (233) qualified -> . name TICK parenthesized_primary
INFO:root:    (231) parenthesized_primary -> . aggregate
INFO:root:    (232) parenthesized_primary -> . ( expression )
INFO:root:    (157) simple_name -> . IDENTIFIER
INFO:root:    (164) indexed_comp -> . name ( value_s )
INFO:root:    (171) selected_comp -> . name . simple_name
INFO:root:    (172) selected_comp -> . name . used_char
INFO:root:    (173) selected_comp -> . name . operator_symbol
INFO:root:    (174) selected_comp -> . name . ALL
INFO:root:    (175) attribute -> . name TICK attribute_id
INFO:root:    (163) operator_symbol -> . STRING
INFO:root:    (183) aggregate -> . ( comp_assoc )
INFO:root:    (184) aggregate -> . ( expression WITH value_s )
INFO:root:    (185) aggregate -> . ( expression WITH NuLL RECORD )
INFO:root:    (186) aggregate -> . ( NuLL RECORD )
INFO:root:
INFO:root:    +               shift and go to state 148
INFO:root:    -               shift and go to state 136
INFO:root:    NOT             shift and go to state 131
INFO:root:    ABS             shift and go to state 132
INFO:root:    INT             shift and go to state 120
INFO:root:    FLOAT           shift and go to state 128
INFO:root:    NuLL            shift and go to state 130
INFO:root:    NEW             shift and go to state 137
INFO:root:    (               shift and go to state 125
INFO:root:    IDENTIFIER      shift and go to state 33
INFO:root:    STRING          shift and go to state 149
INFO:root:
INFO:root:    literal                        shift and go to state 121
INFO:root:    allocator                      shift and go to state 122
INFO:root:    simple_name                    shift and go to state 163
INFO:root:    name                           shift and go to state 142
INFO:root:    condition                      shift and go to state 492
INFO:root:    selected_comp                  shift and go to state 139
INFO:root:    factor                         shift and go to state 126
INFO:root:    expression                     shift and go to state 489
INFO:root:    parenthesized_primary          shift and go to state 147
INFO:root:    unary                          shift and go to state 144
INFO:root:    qualified                      shift and go to state 145
INFO:root:    aggregate                      shift and go to state 143
INFO:root:    cond_part                      shift and go to state 493
INFO:root:    simple_expression              shift and go to state 129
INFO:root:    term                           shift and go to state 146
INFO:root:    cond_clause                    shift and go to state 491
INFO:root:    indexed_comp                   shift and go to state 140
INFO:root:    operator_symbol                shift and go to state 133
INFO:root:    cond_clause_s                  shift and go to state 490
INFO:root:    attribute                      shift and go to state 134
INFO:root:    primary                        shift and go to state 135
INFO:root:    relation                       shift and go to state 138
INFO:root:
INFO:root:state 328
INFO:root:
INFO:root:    (398) select_stmt -> async_select .
INFO:root:
INFO:root:    LL              reduce using rule 398 (select_stmt -> async_select .)
INFO:root:    error           reduce using rule 398 (select_stmt -> async_select .)
INFO:root:    NuLL            reduce using rule 398 (select_stmt -> async_select .)
INFO:root:    EXIT            reduce using rule 398 (select_stmt -> async_select .)
INFO:root:    RETURN          reduce using rule 398 (select_stmt -> async_select .)
INFO:root:    DELAY           reduce using rule 398 (select_stmt -> async_select .)
INFO:root:    ABORT           reduce using rule 398 (select_stmt -> async_select .)
INFO:root:    RAISE           reduce using rule 398 (select_stmt -> async_select .)
INFO:root:    REQUEUE         reduce using rule 398 (select_stmt -> async_select .)
INFO:root:    IF              reduce using rule 398 (select_stmt -> async_select .)
INFO:root:    CASE            reduce using rule 398 (select_stmt -> async_select .)
INFO:root:    IDENTIFIER      reduce using rule 398 (select_stmt -> async_select .)
INFO:root:    ACCEPT          reduce using rule 398 (select_stmt -> async_select .)
INFO:root:    SELECT          reduce using rule 398 (select_stmt -> async_select .)
INFO:root:    STRING          reduce using rule 398 (select_stmt -> async_select .)
INFO:root:    WHILE           reduce using rule 398 (select_stmt -> async_select .)
INFO:root:    DECLARE         reduce using rule 398 (select_stmt -> async_select .)
INFO:root:    FOR             reduce using rule 398 (select_stmt -> async_select .)
INFO:root:    LOOP            reduce using rule 398 (select_stmt -> async_select .)
INFO:root:    BEGIN           reduce using rule 398 (select_stmt -> async_select .)
INFO:root:    END             reduce using rule 398 (select_stmt -> async_select .)
INFO:root:    WHEN            reduce using rule 398 (select_stmt -> async_select .)
INFO:root:    ELSIF           reduce using rule 398 (select_stmt -> async_select .)
INFO:root:    ELSE            reduce using rule 398 (select_stmt -> async_select .)
INFO:root:    EXCEPTION       reduce using rule 398 (select_stmt -> async_select .)
INFO:root:    OR              reduce using rule 398 (select_stmt -> async_select .)
INFO:root:    THEN            reduce using rule 398 (select_stmt -> async_select .)
INFO:root:
INFO:root:
INFO:root:state 329
INFO:root:
INFO:root:    (251) simple_stmt -> requeue_stmt .
INFO:root:
INFO:root:    END             reduce using rule 251 (simple_stmt -> requeue_stmt .)
INFO:root:    LL              reduce using rule 251 (simple_stmt -> requeue_stmt .)
INFO:root:    error           reduce using rule 251 (simple_stmt -> requeue_stmt .)
INFO:root:    NuLL            reduce using rule 251 (simple_stmt -> requeue_stmt .)
INFO:root:    EXIT            reduce using rule 251 (simple_stmt -> requeue_stmt .)
INFO:root:    RETURN          reduce using rule 251 (simple_stmt -> requeue_stmt .)
INFO:root:    DELAY           reduce using rule 251 (simple_stmt -> requeue_stmt .)
INFO:root:    ABORT           reduce using rule 251 (simple_stmt -> requeue_stmt .)
INFO:root:    RAISE           reduce using rule 251 (simple_stmt -> requeue_stmt .)
INFO:root:    REQUEUE         reduce using rule 251 (simple_stmt -> requeue_stmt .)
INFO:root:    IF              reduce using rule 251 (simple_stmt -> requeue_stmt .)
INFO:root:    CASE            reduce using rule 251 (simple_stmt -> requeue_stmt .)
INFO:root:    IDENTIFIER      reduce using rule 251 (simple_stmt -> requeue_stmt .)
INFO:root:    ACCEPT          reduce using rule 251 (simple_stmt -> requeue_stmt .)
INFO:root:    SELECT          reduce using rule 251 (simple_stmt -> requeue_stmt .)
INFO:root:    STRING          reduce using rule 251 (simple_stmt -> requeue_stmt .)
INFO:root:    WHILE           reduce using rule 251 (simple_stmt -> requeue_stmt .)
INFO:root:    DECLARE         reduce using rule 251 (simple_stmt -> requeue_stmt .)
INFO:root:    FOR             reduce using rule 251 (simple_stmt -> requeue_stmt .)
INFO:root:    LOOP            reduce using rule 251 (simple_stmt -> requeue_stmt .)
INFO:root:    BEGIN           reduce using rule 251 (simple_stmt -> requeue_stmt .)
INFO:root:    EXCEPTION       reduce using rule 251 (simple_stmt -> requeue_stmt .)
INFO:root:    OR              reduce using rule 251 (simple_stmt -> requeue_stmt .)
INFO:root:    ELSE            reduce using rule 251 (simple_stmt -> requeue_stmt .)
INFO:root:    THEN            reduce using rule 251 (simple_stmt -> requeue_stmt .)
INFO:root:    ELSIF           reduce using rule 251 (simple_stmt -> requeue_stmt .)
INFO:root:    WHEN            reduce using rule 251 (simple_stmt -> requeue_stmt .)
INFO:root:
INFO:root:
INFO:root:state 330
INFO:root:
INFO:root:    (397) select_stmt -> select_wait .
INFO:root:
INFO:root:    LL              reduce using rule 397 (select_stmt -> select_wait .)
INFO:root:    error           reduce using rule 397 (select_stmt -> select_wait .)
INFO:root:    NuLL            reduce using rule 397 (select_stmt -> select_wait .)
INFO:root:    EXIT            reduce using rule 397 (select_stmt -> select_wait .)
INFO:root:    RETURN          reduce using rule 397 (select_stmt -> select_wait .)
INFO:root:    DELAY           reduce using rule 397 (select_stmt -> select_wait .)
INFO:root:    ABORT           reduce using rule 397 (select_stmt -> select_wait .)
INFO:root:    RAISE           reduce using rule 397 (select_stmt -> select_wait .)
INFO:root:    REQUEUE         reduce using rule 397 (select_stmt -> select_wait .)
INFO:root:    IF              reduce using rule 397 (select_stmt -> select_wait .)
INFO:root:    CASE            reduce using rule 397 (select_stmt -> select_wait .)
INFO:root:    IDENTIFIER      reduce using rule 397 (select_stmt -> select_wait .)
INFO:root:    ACCEPT          reduce using rule 397 (select_stmt -> select_wait .)
INFO:root:    SELECT          reduce using rule 397 (select_stmt -> select_wait .)
INFO:root:    STRING          reduce using rule 397 (select_stmt -> select_wait .)
INFO:root:    WHILE           reduce using rule 397 (select_stmt -> select_wait .)
INFO:root:    DECLARE         reduce using rule 397 (select_stmt -> select_wait .)
INFO:root:    FOR             reduce using rule 397 (select_stmt -> select_wait .)
INFO:root:    LOOP            reduce using rule 397 (select_stmt -> select_wait .)
INFO:root:    BEGIN           reduce using rule 397 (select_stmt -> select_wait .)
INFO:root:    END             reduce using rule 397 (select_stmt -> select_wait .)
INFO:root:    WHEN            reduce using rule 397 (select_stmt -> select_wait .)
INFO:root:    ELSIF           reduce using rule 397 (select_stmt -> select_wait .)
INFO:root:    ELSE            reduce using rule 397 (select_stmt -> select_wait .)
INFO:root:    EXCEPTION       reduce using rule 397 (select_stmt -> select_wait .)
INFO:root:    OR              reduce using rule 397 (select_stmt -> select_wait .)
INFO:root:    THEN            reduce using rule 397 (select_stmt -> select_wait .)
INFO:root:
INFO:root:
INFO:root:state 331
INFO:root:
INFO:root:    (250) simple_stmt -> code_stmt .
INFO:root:
INFO:root:    END             reduce using rule 250 (simple_stmt -> code_stmt .)
INFO:root:    LL              reduce using rule 250 (simple_stmt -> code_stmt .)
INFO:root:    error           reduce using rule 250 (simple_stmt -> code_stmt .)
INFO:root:    NuLL            reduce using rule 250 (simple_stmt -> code_stmt .)
INFO:root:    EXIT            reduce using rule 250 (simple_stmt -> code_stmt .)
INFO:root:    RETURN          reduce using rule 250 (simple_stmt -> code_stmt .)
INFO:root:    DELAY           reduce using rule 250 (simple_stmt -> code_stmt .)
INFO:root:    ABORT           reduce using rule 250 (simple_stmt -> code_stmt .)
INFO:root:    RAISE           reduce using rule 250 (simple_stmt -> code_stmt .)
INFO:root:    REQUEUE         reduce using rule 250 (simple_stmt -> code_stmt .)
INFO:root:    IF              reduce using rule 250 (simple_stmt -> code_stmt .)
INFO:root:    CASE            reduce using rule 250 (simple_stmt -> code_stmt .)
INFO:root:    IDENTIFIER      reduce using rule 250 (simple_stmt -> code_stmt .)
INFO:root:    ACCEPT          reduce using rule 250 (simple_stmt -> code_stmt .)
INFO:root:    SELECT          reduce using rule 250 (simple_stmt -> code_stmt .)
INFO:root:    STRING          reduce using rule 250 (simple_stmt -> code_stmt .)
INFO:root:    WHILE           reduce using rule 250 (simple_stmt -> code_stmt .)
INFO:root:    DECLARE         reduce using rule 250 (simple_stmt -> code_stmt .)
INFO:root:    FOR             reduce using rule 250 (simple_stmt -> code_stmt .)
INFO:root:    LOOP            reduce using rule 250 (simple_stmt -> code_stmt .)
INFO:root:    BEGIN           reduce using rule 250 (simple_stmt -> code_stmt .)
INFO:root:    EXCEPTION       reduce using rule 250 (simple_stmt -> code_stmt .)
INFO:root:    OR              reduce using rule 250 (simple_stmt -> code_stmt .)
INFO:root:    ELSE            reduce using rule 250 (simple_stmt -> code_stmt .)
INFO:root:    THEN            reduce using rule 250 (simple_stmt -> code_stmt .)
INFO:root:    ELSIF           reduce using rule 250 (simple_stmt -> code_stmt .)
INFO:root:    WHEN            reduce using rule 250 (simple_stmt -> code_stmt .)
INFO:root:
INFO:root:
INFO:root:state 332
INFO:root:
INFO:root:    (395) delay_stmt -> DELAY . expression ;
INFO:root:    (396) delay_stmt -> DELAY . UNTIL expression ;
INFO:root:    (188) expression -> . relation
INFO:root:    (189) expression -> . expression logical relation
INFO:root:    (190) expression -> . expression short_circuit relation
INFO:root:    (196) relation -> . simple_expression
INFO:root:    (197) relation -> . simple_expression relational simple_expression
INFO:root:    (198) relation -> . simple_expression membership range
INFO:root:    (199) relation -> . simple_expression membership name
INFO:root:    (208) simple_expression -> . unary term
INFO:root:    (209) simple_expression -> . term
INFO:root:    (210) simple_expression -> . simple_expression adding term
INFO:root:    (211) unary -> . +
INFO:root:    (212) unary -> . -
INFO:root:    (216) term -> . factor
INFO:root:    (217) term -> . term multiplying factor
INFO:root:    (223) factor -> . primary
INFO:root:    (224) factor -> . NOT primary
INFO:root:    (225) factor -> . ABS primary
INFO:root:    (226) primary -> . literal
INFO:root:    (227) primary -> . name
INFO:root:    (228) primary -> . allocator
INFO:root:    (229) primary -> . qualified
INFO:root:    (230) primary -> . parenthesized_primary
INFO:root:    (180) literal -> . INT
INFO:root:    (181) literal -> . FLOAT
INFO:root:    (182) literal -> . NuLL
INFO:root:    (149) name -> . simple_name
INFO:root:    (150) name -> . indexed_comp
INFO:root:    (151) name -> . selected_comp
INFO:root:    (152) name -> . attribute
INFO:root:    (153) name -> . operator_symbol
INFO:root:    (234) allocator -> . NEW name
INFO:root:    (235) allocator -> . NEW qualified
INFO:root:    (233) qualified -> . name TICK parenthesized_primary
INFO:root:    (231) parenthesized_primary -> . aggregate
INFO:root:    (232) parenthesized_primary -> . ( expression )
INFO:root:    (157) simple_name -> . IDENTIFIER
INFO:root:    (164) indexed_comp -> . name ( value_s )
INFO:root:    (171) selected_comp -> . name . simple_name
INFO:root:    (172) selected_comp -> . name . used_char
INFO:root:    (173) selected_comp -> . name . operator_symbol
INFO:root:    (174) selected_comp -> . name . ALL
INFO:root:    (175) attribute -> . name TICK attribute_id
INFO:root:    (163) operator_symbol -> . STRING
INFO:root:    (183) aggregate -> . ( comp_assoc )
INFO:root:    (184) aggregate -> . ( expression WITH value_s )
INFO:root:    (185) aggregate -> . ( expression WITH NuLL RECORD )
INFO:root:    (186) aggregate -> . ( NuLL RECORD )
INFO:root:
INFO:root:    UNTIL           shift and go to state 495
INFO:root:    +               shift and go to state 148
INFO:root:    -               shift and go to state 136
INFO:root:    NOT             shift and go to state 131
INFO:root:    ABS             shift and go to state 132
INFO:root:    INT             shift and go to state 120
INFO:root:    FLOAT           shift and go to state 128
INFO:root:    NuLL            shift and go to state 130
INFO:root:    NEW             shift and go to state 137
INFO:root:    (               shift and go to state 125
INFO:root:    IDENTIFIER      shift and go to state 33
INFO:root:    STRING          shift and go to state 149
INFO:root:
INFO:root:    literal                        shift and go to state 121
INFO:root:    allocator                      shift and go to state 122
INFO:root:    simple_name                    shift and go to state 163
INFO:root:    indexed_comp                   shift and go to state 140
INFO:root:    name                           shift and go to state 142
INFO:root:    selected_comp                  shift and go to state 139
INFO:root:    factor                         shift and go to state 126
INFO:root:    expression                     shift and go to state 494
INFO:root:    unary                          shift and go to state 144
INFO:root:    qualified                      shift and go to state 145
INFO:root:    aggregate                      shift and go to state 143
INFO:root:    simple_expression              shift and go to state 129
INFO:root:    term                           shift and go to state 146
INFO:root:    operator_symbol                shift and go to state 133
INFO:root:    parenthesized_primary          shift and go to state 147
INFO:root:    attribute                      shift and go to state 134
INFO:root:    primary                        shift and go to state 135
INFO:root:    relation                       shift and go to state 138
INFO:root:
INFO:root:state 333
INFO:root:
INFO:root:    (255) compound_stmt -> loop_stmt .
INFO:root:
INFO:root:    LL              reduce using rule 255 (compound_stmt -> loop_stmt .)
INFO:root:    error           reduce using rule 255 (compound_stmt -> loop_stmt .)
INFO:root:    NuLL            reduce using rule 255 (compound_stmt -> loop_stmt .)
INFO:root:    EXIT            reduce using rule 255 (compound_stmt -> loop_stmt .)
INFO:root:    RETURN          reduce using rule 255 (compound_stmt -> loop_stmt .)
INFO:root:    DELAY           reduce using rule 255 (compound_stmt -> loop_stmt .)
INFO:root:    ABORT           reduce using rule 255 (compound_stmt -> loop_stmt .)
INFO:root:    RAISE           reduce using rule 255 (compound_stmt -> loop_stmt .)
INFO:root:    REQUEUE         reduce using rule 255 (compound_stmt -> loop_stmt .)
INFO:root:    IF              reduce using rule 255 (compound_stmt -> loop_stmt .)
INFO:root:    CASE            reduce using rule 255 (compound_stmt -> loop_stmt .)
INFO:root:    IDENTIFIER      reduce using rule 255 (compound_stmt -> loop_stmt .)
INFO:root:    ACCEPT          reduce using rule 255 (compound_stmt -> loop_stmt .)
INFO:root:    SELECT          reduce using rule 255 (compound_stmt -> loop_stmt .)
INFO:root:    STRING          reduce using rule 255 (compound_stmt -> loop_stmt .)
INFO:root:    WHILE           reduce using rule 255 (compound_stmt -> loop_stmt .)
INFO:root:    DECLARE         reduce using rule 255 (compound_stmt -> loop_stmt .)
INFO:root:    FOR             reduce using rule 255 (compound_stmt -> loop_stmt .)
INFO:root:    LOOP            reduce using rule 255 (compound_stmt -> loop_stmt .)
INFO:root:    BEGIN           reduce using rule 255 (compound_stmt -> loop_stmt .)
INFO:root:    WHEN            reduce using rule 255 (compound_stmt -> loop_stmt .)
INFO:root:    END             reduce using rule 255 (compound_stmt -> loop_stmt .)
INFO:root:    OR              reduce using rule 255 (compound_stmt -> loop_stmt .)
INFO:root:    ELSE            reduce using rule 255 (compound_stmt -> loop_stmt .)
INFO:root:    ELSIF           reduce using rule 255 (compound_stmt -> loop_stmt .)
INFO:root:    EXCEPTION       reduce using rule 255 (compound_stmt -> loop_stmt .)
INFO:root:    THEN            reduce using rule 255 (compound_stmt -> loop_stmt .)
INFO:root:
INFO:root:
INFO:root:state 334
INFO:root:
INFO:root:    (242) simple_stmt -> null_stmt .
INFO:root:
INFO:root:    END             reduce using rule 242 (simple_stmt -> null_stmt .)
INFO:root:    LL              reduce using rule 242 (simple_stmt -> null_stmt .)
INFO:root:    error           reduce using rule 242 (simple_stmt -> null_stmt .)
INFO:root:    NuLL            reduce using rule 242 (simple_stmt -> null_stmt .)
INFO:root:    EXIT            reduce using rule 242 (simple_stmt -> null_stmt .)
INFO:root:    RETURN          reduce using rule 242 (simple_stmt -> null_stmt .)
INFO:root:    DELAY           reduce using rule 242 (simple_stmt -> null_stmt .)
INFO:root:    ABORT           reduce using rule 242 (simple_stmt -> null_stmt .)
INFO:root:    RAISE           reduce using rule 242 (simple_stmt -> null_stmt .)
INFO:root:    REQUEUE         reduce using rule 242 (simple_stmt -> null_stmt .)
INFO:root:    IF              reduce using rule 242 (simple_stmt -> null_stmt .)
INFO:root:    CASE            reduce using rule 242 (simple_stmt -> null_stmt .)
INFO:root:    IDENTIFIER      reduce using rule 242 (simple_stmt -> null_stmt .)
INFO:root:    ACCEPT          reduce using rule 242 (simple_stmt -> null_stmt .)
INFO:root:    SELECT          reduce using rule 242 (simple_stmt -> null_stmt .)
INFO:root:    STRING          reduce using rule 242 (simple_stmt -> null_stmt .)
INFO:root:    WHILE           reduce using rule 242 (simple_stmt -> null_stmt .)
INFO:root:    DECLARE         reduce using rule 242 (simple_stmt -> null_stmt .)
INFO:root:    FOR             reduce using rule 242 (simple_stmt -> null_stmt .)
INFO:root:    LOOP            reduce using rule 242 (simple_stmt -> null_stmt .)
INFO:root:    BEGIN           reduce using rule 242 (simple_stmt -> null_stmt .)
INFO:root:    EXCEPTION       reduce using rule 242 (simple_stmt -> null_stmt .)
INFO:root:    OR              reduce using rule 242 (simple_stmt -> null_stmt .)
INFO:root:    ELSE            reduce using rule 242 (simple_stmt -> null_stmt .)
INFO:root:    THEN            reduce using rule 242 (simple_stmt -> null_stmt .)
INFO:root:    ELSIF           reduce using rule 242 (simple_stmt -> null_stmt .)
INFO:root:    WHEN            reduce using rule 242 (simple_stmt -> null_stmt .)
INFO:root:
INFO:root:
INFO:root:state 335
INFO:root:
INFO:root:    (239) statement -> label . statement
INFO:root:    (238) statement -> . unlabeled
INFO:root:    (239) statement -> . label statement
INFO:root:    (240) unlabeled -> . simple_stmt
INFO:root:    (241) unlabeled -> . compound_stmt
INFO:root:    (259) label -> . LL IDENTIFIER RR
INFO:root:    (242) simple_stmt -> . null_stmt
INFO:root:    (243) simple_stmt -> . assign_stmt
INFO:root:    (244) simple_stmt -> . exit_stmt
INFO:root:    (245) simple_stmt -> . return_stmt
INFO:root:    (246) simple_stmt -> . procedure_call
INFO:root:    (247) simple_stmt -> . delay_stmt
INFO:root:    (248) simple_stmt -> . abort_stmt
INFO:root:    (249) simple_stmt -> . raise_stmt
INFO:root:    (250) simple_stmt -> . code_stmt
INFO:root:    (251) simple_stmt -> . requeue_stmt
INFO:root:    (252) simple_stmt -> . error ;
INFO:root:    (253) compound_stmt -> . if_stmt
INFO:root:    (254) compound_stmt -> . case_stmt
INFO:root:    (255) compound_stmt -> . loop_stmt
INFO:root:    (256) compound_stmt -> . block
INFO:root:    (257) compound_stmt -> . accept_stmt
INFO:root:    (258) compound_stmt -> . select_stmt
INFO:root:    (260) null_stmt -> . NuLL ;
INFO:root:    (261) assign_stmt -> . name ASSIGN expression ;
INFO:root:    (294) exit_stmt -> . EXIT name_opt when_opt ;
INFO:root:    (299) return_stmt -> . RETURN ;
INFO:root:    (300) return_stmt -> . RETURN expression ;
INFO:root:    (323) procedure_call -> . name ;
INFO:root:    (395) delay_stmt -> . DELAY expression ;
INFO:root:    (396) delay_stmt -> . DELAY UNTIL expression ;
INFO:root:    (416) abort_stmt -> . ABORT name_s ;
INFO:root:    (455) raise_stmt -> . RAISE name_opt ;
INFO:root:    (501) code_stmt -> . qualified ;
INFO:root:    (456) requeue_stmt -> . REQUEUE name ;
INFO:root:    (457) requeue_stmt -> . REQUEUE name WITH ABORT ;
INFO:root:    (262) if_stmt -> . IF cond_clause_s else_opt END IF ;
INFO:root:    (270) case_stmt -> . case_hdr pragma_s alternative_s END CASE ;
INFO:root:    (275) loop_stmt -> . label_opt iteration basic_loop id_opt ;
INFO:root:    (287) block -> . label_opt block_decl block_body END id_opt ;
INFO:root:    (390) accept_stmt -> . accept_hdr ;
INFO:root:    (391) accept_stmt -> . accept_hdr DO handled_stmt_s END id_opt ;
INFO:root:    (397) select_stmt -> . select_wait
INFO:root:    (398) select_stmt -> . async_select
INFO:root:    (399) select_stmt -> . timed_entry_call
INFO:root:    (400) select_stmt -> . cond_entry_call
INFO:root:    (149) name -> . simple_name
INFO:root:    (150) name -> . indexed_comp
INFO:root:    (151) name -> . selected_comp
INFO:root:    (152) name -> . attribute
INFO:root:    (153) name -> . operator_symbol
INFO:root:    (233) qualified -> . name TICK parenthesized_primary
INFO:root:    (271) case_hdr -> . CASE expression IS
INFO:root:    (276) label_opt -> .
INFO:root:    (277) label_opt -> . IDENTIFIER :
INFO:root:    (392) accept_hdr -> . ACCEPT entry_name formal_part_opt
INFO:root:    (401) select_wait -> . SELECT guarded_select_alt or_select else_opt END SELECT ;
INFO:root:    (411) async_select -> . SELECT delay_or_entry_alt THEN ABORT statement_s END SELECT ;
INFO:root:    (412) timed_entry_call -> . SELECT entry_call stmts_opt OR delay_stmt stmts_opt END SELECT ;
INFO:root:    (413) cond_entry_call -> . SELECT entry_call stmts_opt ELSE statement_s END SELECT ;
INFO:root:    (157) simple_name -> . IDENTIFIER
INFO:root:    (164) indexed_comp -> . name ( value_s )
INFO:root:    (171) selected_comp -> . name . simple_name
INFO:root:    (172) selected_comp -> . name . used_char
INFO:root:    (173) selected_comp -> . name . operator_symbol
INFO:root:    (174) selected_comp -> . name . ALL
INFO:root:    (175) attribute -> . name TICK attribute_id
INFO:root:    (163) operator_symbol -> . STRING
INFO:root:
INFO:root:    LL              shift and go to state 344
INFO:root:    error           shift and go to state 341
INFO:root:    NuLL            shift and go to state 347
INFO:root:    EXIT            shift and go to state 340
INFO:root:    RETURN          shift and go to state 303
INFO:root:    DELAY           shift and go to state 332
INFO:root:    ABORT           shift and go to state 326
INFO:root:    RAISE           shift and go to state 314
INFO:root:    REQUEUE         shift and go to state 317
INFO:root:    IF              shift and go to state 327
INFO:root:    CASE            shift and go to state 312
INFO:root:    WHILE           reduce using rule 276 (label_opt -> .)
INFO:root:    DECLARE         reduce using rule 276 (label_opt -> .)
INFO:root:    FOR             reduce using rule 276 (label_opt -> .)
INFO:root:    LOOP            reduce using rule 276 (label_opt -> .)
INFO:root:    BEGIN           reduce using rule 276 (label_opt -> .)
INFO:root:    IDENTIFIER      shift and go to state 322
INFO:root:    ACCEPT          shift and go to state 310
INFO:root:    SELECT          shift and go to state 320
INFO:root:    STRING          shift and go to state 149
INFO:root:
INFO:root:    cond_entry_call                shift and go to state 345
INFO:root:    simple_stmt                    shift and go to state 302
INFO:root:    async_select                   shift and go to state 328
INFO:root:    simple_name                    shift and go to state 163
INFO:root:    requeue_stmt                   shift and go to state 329
INFO:root:    if_stmt                        shift and go to state 304
INFO:root:    procedure_call                 shift and go to state 305
INFO:root:    select_wait                    shift and go to state 330
INFO:root:    indexed_comp                   shift and go to state 140
INFO:root:    timed_entry_call               shift and go to state 307
INFO:root:    statement                      shift and go to state 496
INFO:root:    operator_symbol                shift and go to state 133
INFO:root:    exit_stmt                      shift and go to state 306
INFO:root:    code_stmt                      shift and go to state 331
INFO:root:    loop_stmt                      shift and go to state 333
INFO:root:    null_stmt                      shift and go to state 334
INFO:root:    label                          shift and go to state 335
INFO:root:    select_stmt                    shift and go to state 311
INFO:root:    label_opt                      shift and go to state 313
INFO:root:    assign_stmt                    shift and go to state 336
INFO:root:    selected_comp                  shift and go to state 139
INFO:root:    abort_stmt                     shift and go to state 315
INFO:root:    attribute                      shift and go to state 134
INFO:root:    name                           shift and go to state 316
INFO:root:    accept_hdr                     shift and go to state 318
INFO:root:    accept_stmt                    shift and go to state 337
INFO:root:    case_hdr                       shift and go to state 319
INFO:root:    delay_stmt                     shift and go to state 338
INFO:root:    compound_stmt                  shift and go to state 309
INFO:root:    raise_stmt                     shift and go to state 342
INFO:root:    qualified                      shift and go to state 321
INFO:root:    return_stmt                    shift and go to state 323
INFO:root:    case_stmt                      shift and go to state 324
INFO:root:    block                          shift and go to state 325
INFO:root:    unlabeled                      shift and go to state 346
INFO:root:
INFO:root:state 336
INFO:root:
INFO:root:    (243) simple_stmt -> assign_stmt .
INFO:root:
INFO:root:    END             reduce using rule 243 (simple_stmt -> assign_stmt .)
INFO:root:    LL              reduce using rule 243 (simple_stmt -> assign_stmt .)
INFO:root:    error           reduce using rule 243 (simple_stmt -> assign_stmt .)
INFO:root:    NuLL            reduce using rule 243 (simple_stmt -> assign_stmt .)
INFO:root:    EXIT            reduce using rule 243 (simple_stmt -> assign_stmt .)
INFO:root:    RETURN          reduce using rule 243 (simple_stmt -> assign_stmt .)
INFO:root:    DELAY           reduce using rule 243 (simple_stmt -> assign_stmt .)
INFO:root:    ABORT           reduce using rule 243 (simple_stmt -> assign_stmt .)
INFO:root:    RAISE           reduce using rule 243 (simple_stmt -> assign_stmt .)
INFO:root:    REQUEUE         reduce using rule 243 (simple_stmt -> assign_stmt .)
INFO:root:    IF              reduce using rule 243 (simple_stmt -> assign_stmt .)
INFO:root:    CASE            reduce using rule 243 (simple_stmt -> assign_stmt .)
INFO:root:    IDENTIFIER      reduce using rule 243 (simple_stmt -> assign_stmt .)
INFO:root:    ACCEPT          reduce using rule 243 (simple_stmt -> assign_stmt .)
INFO:root:    SELECT          reduce using rule 243 (simple_stmt -> assign_stmt .)
INFO:root:    STRING          reduce using rule 243 (simple_stmt -> assign_stmt .)
INFO:root:    WHILE           reduce using rule 243 (simple_stmt -> assign_stmt .)
INFO:root:    DECLARE         reduce using rule 243 (simple_stmt -> assign_stmt .)
INFO:root:    FOR             reduce using rule 243 (simple_stmt -> assign_stmt .)
INFO:root:    LOOP            reduce using rule 243 (simple_stmt -> assign_stmt .)
INFO:root:    BEGIN           reduce using rule 243 (simple_stmt -> assign_stmt .)
INFO:root:    EXCEPTION       reduce using rule 243 (simple_stmt -> assign_stmt .)
INFO:root:    OR              reduce using rule 243 (simple_stmt -> assign_stmt .)
INFO:root:    ELSE            reduce using rule 243 (simple_stmt -> assign_stmt .)
INFO:root:    THEN            reduce using rule 243 (simple_stmt -> assign_stmt .)
INFO:root:    ELSIF           reduce using rule 243 (simple_stmt -> assign_stmt .)
INFO:root:    WHEN            reduce using rule 243 (simple_stmt -> assign_stmt .)
INFO:root:
INFO:root:
INFO:root:state 337
INFO:root:
INFO:root:    (257) compound_stmt -> accept_stmt .
INFO:root:
INFO:root:    LL              reduce using rule 257 (compound_stmt -> accept_stmt .)
INFO:root:    error           reduce using rule 257 (compound_stmt -> accept_stmt .)
INFO:root:    NuLL            reduce using rule 257 (compound_stmt -> accept_stmt .)
INFO:root:    EXIT            reduce using rule 257 (compound_stmt -> accept_stmt .)
INFO:root:    RETURN          reduce using rule 257 (compound_stmt -> accept_stmt .)
INFO:root:    DELAY           reduce using rule 257 (compound_stmt -> accept_stmt .)
INFO:root:    ABORT           reduce using rule 257 (compound_stmt -> accept_stmt .)
INFO:root:    RAISE           reduce using rule 257 (compound_stmt -> accept_stmt .)
INFO:root:    REQUEUE         reduce using rule 257 (compound_stmt -> accept_stmt .)
INFO:root:    IF              reduce using rule 257 (compound_stmt -> accept_stmt .)
INFO:root:    CASE            reduce using rule 257 (compound_stmt -> accept_stmt .)
INFO:root:    IDENTIFIER      reduce using rule 257 (compound_stmt -> accept_stmt .)
INFO:root:    ACCEPT          reduce using rule 257 (compound_stmt -> accept_stmt .)
INFO:root:    SELECT          reduce using rule 257 (compound_stmt -> accept_stmt .)
INFO:root:    STRING          reduce using rule 257 (compound_stmt -> accept_stmt .)
INFO:root:    WHILE           reduce using rule 257 (compound_stmt -> accept_stmt .)
INFO:root:    DECLARE         reduce using rule 257 (compound_stmt -> accept_stmt .)
INFO:root:    FOR             reduce using rule 257 (compound_stmt -> accept_stmt .)
INFO:root:    LOOP            reduce using rule 257 (compound_stmt -> accept_stmt .)
INFO:root:    BEGIN           reduce using rule 257 (compound_stmt -> accept_stmt .)
INFO:root:    WHEN            reduce using rule 257 (compound_stmt -> accept_stmt .)
INFO:root:    END             reduce using rule 257 (compound_stmt -> accept_stmt .)
INFO:root:    OR              reduce using rule 257 (compound_stmt -> accept_stmt .)
INFO:root:    ELSE            reduce using rule 257 (compound_stmt -> accept_stmt .)
INFO:root:    ELSIF           reduce using rule 257 (compound_stmt -> accept_stmt .)
INFO:root:    EXCEPTION       reduce using rule 257 (compound_stmt -> accept_stmt .)
INFO:root:    THEN            reduce using rule 257 (compound_stmt -> accept_stmt .)
INFO:root:
INFO:root:
INFO:root:state 338
INFO:root:
INFO:root:    (247) simple_stmt -> delay_stmt .
INFO:root:
INFO:root:    END             reduce using rule 247 (simple_stmt -> delay_stmt .)
INFO:root:    LL              reduce using rule 247 (simple_stmt -> delay_stmt .)
INFO:root:    error           reduce using rule 247 (simple_stmt -> delay_stmt .)
INFO:root:    NuLL            reduce using rule 247 (simple_stmt -> delay_stmt .)
INFO:root:    EXIT            reduce using rule 247 (simple_stmt -> delay_stmt .)
INFO:root:    RETURN          reduce using rule 247 (simple_stmt -> delay_stmt .)
INFO:root:    DELAY           reduce using rule 247 (simple_stmt -> delay_stmt .)
INFO:root:    ABORT           reduce using rule 247 (simple_stmt -> delay_stmt .)
INFO:root:    RAISE           reduce using rule 247 (simple_stmt -> delay_stmt .)
INFO:root:    REQUEUE         reduce using rule 247 (simple_stmt -> delay_stmt .)
INFO:root:    IF              reduce using rule 247 (simple_stmt -> delay_stmt .)
INFO:root:    CASE            reduce using rule 247 (simple_stmt -> delay_stmt .)
INFO:root:    IDENTIFIER      reduce using rule 247 (simple_stmt -> delay_stmt .)
INFO:root:    ACCEPT          reduce using rule 247 (simple_stmt -> delay_stmt .)
INFO:root:    SELECT          reduce using rule 247 (simple_stmt -> delay_stmt .)
INFO:root:    STRING          reduce using rule 247 (simple_stmt -> delay_stmt .)
INFO:root:    WHILE           reduce using rule 247 (simple_stmt -> delay_stmt .)
INFO:root:    DECLARE         reduce using rule 247 (simple_stmt -> delay_stmt .)
INFO:root:    FOR             reduce using rule 247 (simple_stmt -> delay_stmt .)
INFO:root:    LOOP            reduce using rule 247 (simple_stmt -> delay_stmt .)
INFO:root:    BEGIN           reduce using rule 247 (simple_stmt -> delay_stmt .)
INFO:root:    EXCEPTION       reduce using rule 247 (simple_stmt -> delay_stmt .)
INFO:root:    OR              reduce using rule 247 (simple_stmt -> delay_stmt .)
INFO:root:    ELSE            reduce using rule 247 (simple_stmt -> delay_stmt .)
INFO:root:    THEN            reduce using rule 247 (simple_stmt -> delay_stmt .)
INFO:root:    ELSIF           reduce using rule 247 (simple_stmt -> delay_stmt .)
INFO:root:    WHEN            reduce using rule 247 (simple_stmt -> delay_stmt .)
INFO:root:
INFO:root:
INFO:root:state 339
INFO:root:
INFO:root:    (291) handled_stmt_s -> statement_s . except_handler_part_opt
INFO:root:    (237) statement_s -> statement_s . statement
INFO:root:    (292) except_handler_part_opt -> .
INFO:root:    (293) except_handler_part_opt -> . except_handler_part
INFO:root:    (238) statement -> . unlabeled
INFO:root:    (239) statement -> . label statement
INFO:root:    (447) except_handler_part -> . EXCEPTION exception_handler
INFO:root:    (448) except_handler_part -> . except_handler_part exception_handler
INFO:root:    (240) unlabeled -> . simple_stmt
INFO:root:    (241) unlabeled -> . compound_stmt
INFO:root:    (259) label -> . LL IDENTIFIER RR
INFO:root:    (242) simple_stmt -> . null_stmt
INFO:root:    (243) simple_stmt -> . assign_stmt
INFO:root:    (244) simple_stmt -> . exit_stmt
INFO:root:    (245) simple_stmt -> . return_stmt
INFO:root:    (246) simple_stmt -> . procedure_call
INFO:root:    (247) simple_stmt -> . delay_stmt
INFO:root:    (248) simple_stmt -> . abort_stmt
INFO:root:    (249) simple_stmt -> . raise_stmt
INFO:root:    (250) simple_stmt -> . code_stmt
INFO:root:    (251) simple_stmt -> . requeue_stmt
INFO:root:    (252) simple_stmt -> . error ;
INFO:root:    (253) compound_stmt -> . if_stmt
INFO:root:    (254) compound_stmt -> . case_stmt
INFO:root:    (255) compound_stmt -> . loop_stmt
INFO:root:    (256) compound_stmt -> . block
INFO:root:    (257) compound_stmt -> . accept_stmt
INFO:root:    (258) compound_stmt -> . select_stmt
INFO:root:    (260) null_stmt -> . NuLL ;
INFO:root:    (261) assign_stmt -> . name ASSIGN expression ;
INFO:root:    (294) exit_stmt -> . EXIT name_opt when_opt ;
INFO:root:    (299) return_stmt -> . RETURN ;
INFO:root:    (300) return_stmt -> . RETURN expression ;
INFO:root:    (323) procedure_call -> . name ;
INFO:root:    (395) delay_stmt -> . DELAY expression ;
INFO:root:    (396) delay_stmt -> . DELAY UNTIL expression ;
INFO:root:    (416) abort_stmt -> . ABORT name_s ;
INFO:root:    (455) raise_stmt -> . RAISE name_opt ;
INFO:root:    (501) code_stmt -> . qualified ;
INFO:root:    (456) requeue_stmt -> . REQUEUE name ;
INFO:root:    (457) requeue_stmt -> . REQUEUE name WITH ABORT ;
INFO:root:    (262) if_stmt -> . IF cond_clause_s else_opt END IF ;
INFO:root:    (270) case_stmt -> . case_hdr pragma_s alternative_s END CASE ;
INFO:root:    (275) loop_stmt -> . label_opt iteration basic_loop id_opt ;
INFO:root:    (287) block -> . label_opt block_decl block_body END id_opt ;
INFO:root:    (390) accept_stmt -> . accept_hdr ;
INFO:root:    (391) accept_stmt -> . accept_hdr DO handled_stmt_s END id_opt ;
INFO:root:    (397) select_stmt -> . select_wait
INFO:root:    (398) select_stmt -> . async_select
INFO:root:    (399) select_stmt -> . timed_entry_call
INFO:root:    (400) select_stmt -> . cond_entry_call
INFO:root:    (149) name -> . simple_name
INFO:root:    (150) name -> . indexed_comp
INFO:root:    (151) name -> . selected_comp
INFO:root:    (152) name -> . attribute
INFO:root:    (153) name -> . operator_symbol
INFO:root:    (233) qualified -> . name TICK parenthesized_primary
INFO:root:    (271) case_hdr -> . CASE expression IS
INFO:root:    (276) label_opt -> .
INFO:root:    (277) label_opt -> . IDENTIFIER :
INFO:root:    (392) accept_hdr -> . ACCEPT entry_name formal_part_opt
INFO:root:    (401) select_wait -> . SELECT guarded_select_alt or_select else_opt END SELECT ;
INFO:root:    (411) async_select -> . SELECT delay_or_entry_alt THEN ABORT statement_s END SELECT ;
INFO:root:    (412) timed_entry_call -> . SELECT entry_call stmts_opt OR delay_stmt stmts_opt END SELECT ;
INFO:root:    (413) cond_entry_call -> . SELECT entry_call stmts_opt ELSE statement_s END SELECT ;
INFO:root:    (157) simple_name -> . IDENTIFIER
INFO:root:    (164) indexed_comp -> . name ( value_s )
INFO:root:    (171) selected_comp -> . name . simple_name
INFO:root:    (172) selected_comp -> . name . used_char
INFO:root:    (173) selected_comp -> . name . operator_symbol
INFO:root:    (174) selected_comp -> . name . ALL
INFO:root:    (175) attribute -> . name TICK attribute_id
INFO:root:    (163) operator_symbol -> . STRING
INFO:root:
INFO:root:    END             reduce using rule 292 (except_handler_part_opt -> .)
INFO:root:    EXCEPTION       shift and go to state 498
INFO:root:    LL              shift and go to state 344
INFO:root:    error           shift and go to state 341
INFO:root:    NuLL            shift and go to state 347
INFO:root:    EXIT            shift and go to state 340
INFO:root:    RETURN          shift and go to state 303
INFO:root:    DELAY           shift and go to state 332
INFO:root:    ABORT           shift and go to state 326
INFO:root:    RAISE           shift and go to state 314
INFO:root:    REQUEUE         shift and go to state 317
INFO:root:    IF              shift and go to state 327
INFO:root:    CASE            shift and go to state 312
INFO:root:    WHILE           reduce using rule 276 (label_opt -> .)
INFO:root:    DECLARE         reduce using rule 276 (label_opt -> .)
INFO:root:    FOR             reduce using rule 276 (label_opt -> .)
INFO:root:    LOOP            reduce using rule 276 (label_opt -> .)
INFO:root:    BEGIN           reduce using rule 276 (label_opt -> .)
INFO:root:    IDENTIFIER      shift and go to state 322
INFO:root:    ACCEPT          shift and go to state 310
INFO:root:    SELECT          shift and go to state 320
INFO:root:    STRING          shift and go to state 149
INFO:root:
INFO:root:    cond_entry_call                shift and go to state 345
INFO:root:    simple_stmt                    shift and go to state 302
INFO:root:    async_select                   shift and go to state 328
INFO:root:    selected_comp                  shift and go to state 139
INFO:root:    simple_name                    shift and go to state 163
INFO:root:    requeue_stmt                   shift and go to state 329
INFO:root:    if_stmt                        shift and go to state 304
INFO:root:    procedure_call                 shift and go to state 305
INFO:root:    exit_stmt                      shift and go to state 306
INFO:root:    indexed_comp                   shift and go to state 140
INFO:root:    timed_entry_call               shift and go to state 307
INFO:root:    statement                      shift and go to state 497
INFO:root:    operator_symbol                shift and go to state 133
INFO:root:    code_stmt                      shift and go to state 331
INFO:root:    loop_stmt                      shift and go to state 333
INFO:root:    null_stmt                      shift and go to state 334
INFO:root:    label                          shift and go to state 335
INFO:root:    select_stmt                    shift and go to state 311
INFO:root:    label_opt                      shift and go to state 313
INFO:root:    assign_stmt                    shift and go to state 336
INFO:root:    except_handler_part            shift and go to state 499
INFO:root:    abort_stmt                     shift and go to state 315
INFO:root:    attribute                      shift and go to state 134
INFO:root:    name                           shift and go to state 316
INFO:root:    accept_hdr                     shift and go to state 318
INFO:root:    select_wait                    shift and go to state 330
INFO:root:    accept_stmt                    shift and go to state 337
INFO:root:    case_hdr                       shift and go to state 319
INFO:root:    delay_stmt                     shift and go to state 338
INFO:root:    compound_stmt                  shift and go to state 309
INFO:root:    raise_stmt                     shift and go to state 342
INFO:root:    qualified                      shift and go to state 321
INFO:root:    return_stmt                    shift and go to state 323
INFO:root:    except_handler_part_opt        shift and go to state 500
INFO:root:    case_stmt                      shift and go to state 324
INFO:root:    block                          shift and go to state 325
INFO:root:    unlabeled                      shift and go to state 346
INFO:root:
INFO:root:state 340
INFO:root:
INFO:root:    (294) exit_stmt -> EXIT . name_opt when_opt ;
INFO:root:    (295) name_opt -> .
INFO:root:    (296) name_opt -> . name
INFO:root:    (149) name -> . simple_name
INFO:root:    (150) name -> . indexed_comp
INFO:root:    (151) name -> . selected_comp
INFO:root:    (152) name -> . attribute
INFO:root:    (153) name -> . operator_symbol
INFO:root:    (157) simple_name -> . IDENTIFIER
INFO:root:    (164) indexed_comp -> . name ( value_s )
INFO:root:    (171) selected_comp -> . name . simple_name
INFO:root:    (172) selected_comp -> . name . used_char
INFO:root:    (173) selected_comp -> . name . operator_symbol
INFO:root:    (174) selected_comp -> . name . ALL
INFO:root:    (175) attribute -> . name TICK attribute_id
INFO:root:    (163) operator_symbol -> . STRING
INFO:root:
INFO:root:    WHEN            reduce using rule 295 (name_opt -> .)
INFO:root:    ;               reduce using rule 295 (name_opt -> .)
INFO:root:    IDENTIFIER      shift and go to state 33
INFO:root:    STRING          shift and go to state 149
INFO:root:
INFO:root:    attribute                      shift and go to state 134
INFO:root:    selected_comp                  shift and go to state 139
INFO:root:    simple_name                    shift and go to state 163
INFO:root:    indexed_comp                   shift and go to state 140
INFO:root:    name_opt                       shift and go to state 501
INFO:root:    name                           shift and go to state 468
INFO:root:    operator_symbol                shift and go to state 133
INFO:root:
INFO:root:state 341
INFO:root:
INFO:root:    (252) simple_stmt -> error . ;
INFO:root:
INFO:root:    ;               shift and go to state 502
INFO:root:
INFO:root:
INFO:root:state 342
INFO:root:
INFO:root:    (249) simple_stmt -> raise_stmt .
INFO:root:
INFO:root:    END             reduce using rule 249 (simple_stmt -> raise_stmt .)
INFO:root:    LL              reduce using rule 249 (simple_stmt -> raise_stmt .)
INFO:root:    error           reduce using rule 249 (simple_stmt -> raise_stmt .)
INFO:root:    NuLL            reduce using rule 249 (simple_stmt -> raise_stmt .)
INFO:root:    EXIT            reduce using rule 249 (simple_stmt -> raise_stmt .)
INFO:root:    RETURN          reduce using rule 249 (simple_stmt -> raise_stmt .)
INFO:root:    DELAY           reduce using rule 249 (simple_stmt -> raise_stmt .)
INFO:root:    ABORT           reduce using rule 249 (simple_stmt -> raise_stmt .)
INFO:root:    RAISE           reduce using rule 249 (simple_stmt -> raise_stmt .)
INFO:root:    REQUEUE         reduce using rule 249 (simple_stmt -> raise_stmt .)
INFO:root:    IF              reduce using rule 249 (simple_stmt -> raise_stmt .)
INFO:root:    CASE            reduce using rule 249 (simple_stmt -> raise_stmt .)
INFO:root:    IDENTIFIER      reduce using rule 249 (simple_stmt -> raise_stmt .)
INFO:root:    ACCEPT          reduce using rule 249 (simple_stmt -> raise_stmt .)
INFO:root:    SELECT          reduce using rule 249 (simple_stmt -> raise_stmt .)
INFO:root:    STRING          reduce using rule 249 (simple_stmt -> raise_stmt .)
INFO:root:    WHILE           reduce using rule 249 (simple_stmt -> raise_stmt .)
INFO:root:    DECLARE         reduce using rule 249 (simple_stmt -> raise_stmt .)
INFO:root:    FOR             reduce using rule 249 (simple_stmt -> raise_stmt .)
INFO:root:    LOOP            reduce using rule 249 (simple_stmt -> raise_stmt .)
INFO:root:    BEGIN           reduce using rule 249 (simple_stmt -> raise_stmt .)
INFO:root:    EXCEPTION       reduce using rule 249 (simple_stmt -> raise_stmt .)
INFO:root:    OR              reduce using rule 249 (simple_stmt -> raise_stmt .)
INFO:root:    ELSE            reduce using rule 249 (simple_stmt -> raise_stmt .)
INFO:root:    THEN            reduce using rule 249 (simple_stmt -> raise_stmt .)
INFO:root:    ELSIF           reduce using rule 249 (simple_stmt -> raise_stmt .)
INFO:root:    WHEN            reduce using rule 249 (simple_stmt -> raise_stmt .)
INFO:root:
INFO:root:
INFO:root:state 343
INFO:root:
INFO:root:    (290) block_body -> BEGIN handled_stmt_s .
INFO:root:
INFO:root:    END             reduce using rule 290 (block_body -> BEGIN handled_stmt_s .)
INFO:root:
INFO:root:
INFO:root:state 344
INFO:root:
INFO:root:    (259) label -> LL . IDENTIFIER RR
INFO:root:
INFO:root:    IDENTIFIER      shift and go to state 503
INFO:root:
INFO:root:
INFO:root:state 345
INFO:root:
INFO:root:    (400) select_stmt -> cond_entry_call .
INFO:root:
INFO:root:    LL              reduce using rule 400 (select_stmt -> cond_entry_call .)
INFO:root:    error           reduce using rule 400 (select_stmt -> cond_entry_call .)
INFO:root:    NuLL            reduce using rule 400 (select_stmt -> cond_entry_call .)
INFO:root:    EXIT            reduce using rule 400 (select_stmt -> cond_entry_call .)
INFO:root:    RETURN          reduce using rule 400 (select_stmt -> cond_entry_call .)
INFO:root:    DELAY           reduce using rule 400 (select_stmt -> cond_entry_call .)
INFO:root:    ABORT           reduce using rule 400 (select_stmt -> cond_entry_call .)
INFO:root:    RAISE           reduce using rule 400 (select_stmt -> cond_entry_call .)
INFO:root:    REQUEUE         reduce using rule 400 (select_stmt -> cond_entry_call .)
INFO:root:    IF              reduce using rule 400 (select_stmt -> cond_entry_call .)
INFO:root:    CASE            reduce using rule 400 (select_stmt -> cond_entry_call .)
INFO:root:    IDENTIFIER      reduce using rule 400 (select_stmt -> cond_entry_call .)
INFO:root:    ACCEPT          reduce using rule 400 (select_stmt -> cond_entry_call .)
INFO:root:    SELECT          reduce using rule 400 (select_stmt -> cond_entry_call .)
INFO:root:    STRING          reduce using rule 400 (select_stmt -> cond_entry_call .)
INFO:root:    WHILE           reduce using rule 400 (select_stmt -> cond_entry_call .)
INFO:root:    DECLARE         reduce using rule 400 (select_stmt -> cond_entry_call .)
INFO:root:    FOR             reduce using rule 400 (select_stmt -> cond_entry_call .)
INFO:root:    LOOP            reduce using rule 400 (select_stmt -> cond_entry_call .)
INFO:root:    BEGIN           reduce using rule 400 (select_stmt -> cond_entry_call .)
INFO:root:    END             reduce using rule 400 (select_stmt -> cond_entry_call .)
INFO:root:    WHEN            reduce using rule 400 (select_stmt -> cond_entry_call .)
INFO:root:    ELSIF           reduce using rule 400 (select_stmt -> cond_entry_call .)
INFO:root:    ELSE            reduce using rule 400 (select_stmt -> cond_entry_call .)
INFO:root:    EXCEPTION       reduce using rule 400 (select_stmt -> cond_entry_call .)
INFO:root:    OR              reduce using rule 400 (select_stmt -> cond_entry_call .)
INFO:root:    THEN            reduce using rule 400 (select_stmt -> cond_entry_call .)
INFO:root:
INFO:root:
INFO:root:state 346
INFO:root:
INFO:root:    (238) statement -> unlabeled .
INFO:root:
INFO:root:    LL              reduce using rule 238 (statement -> unlabeled .)
INFO:root:    error           reduce using rule 238 (statement -> unlabeled .)
INFO:root:    NuLL            reduce using rule 238 (statement -> unlabeled .)
INFO:root:    EXIT            reduce using rule 238 (statement -> unlabeled .)
INFO:root:    RETURN          reduce using rule 238 (statement -> unlabeled .)
INFO:root:    DELAY           reduce using rule 238 (statement -> unlabeled .)
INFO:root:    ABORT           reduce using rule 238 (statement -> unlabeled .)
INFO:root:    RAISE           reduce using rule 238 (statement -> unlabeled .)
INFO:root:    REQUEUE         reduce using rule 238 (statement -> unlabeled .)
INFO:root:    IF              reduce using rule 238 (statement -> unlabeled .)
INFO:root:    CASE            reduce using rule 238 (statement -> unlabeled .)
INFO:root:    IDENTIFIER      reduce using rule 238 (statement -> unlabeled .)
INFO:root:    ACCEPT          reduce using rule 238 (statement -> unlabeled .)
INFO:root:    SELECT          reduce using rule 238 (statement -> unlabeled .)
INFO:root:    STRING          reduce using rule 238 (statement -> unlabeled .)
INFO:root:    WHILE           reduce using rule 238 (statement -> unlabeled .)
INFO:root:    DECLARE         reduce using rule 238 (statement -> unlabeled .)
INFO:root:    FOR             reduce using rule 238 (statement -> unlabeled .)
INFO:root:    LOOP            reduce using rule 238 (statement -> unlabeled .)
INFO:root:    BEGIN           reduce using rule 238 (statement -> unlabeled .)
INFO:root:    WHEN            reduce using rule 238 (statement -> unlabeled .)
INFO:root:    END             reduce using rule 238 (statement -> unlabeled .)
INFO:root:    EXCEPTION       reduce using rule 238 (statement -> unlabeled .)
INFO:root:    OR              reduce using rule 238 (statement -> unlabeled .)
INFO:root:    ELSE            reduce using rule 238 (statement -> unlabeled .)
INFO:root:    THEN            reduce using rule 238 (statement -> unlabeled .)
INFO:root:    ELSIF           reduce using rule 238 (statement -> unlabeled .)
INFO:root:
INFO:root:
INFO:root:state 347
INFO:root:
INFO:root:    (260) null_stmt -> NuLL . ;
INFO:root:
INFO:root:    ;               shift and go to state 504
INFO:root:
INFO:root:
INFO:root:state 348
INFO:root:
INFO:root:    (50) subtype_decl -> SUBTYPE IDENTIFIER IS . subtype_ind ;
INFO:root:    (51) subtype_ind -> . name constraint
INFO:root:    (52) subtype_ind -> . name
INFO:root:    (149) name -> . simple_name
INFO:root:    (150) name -> . indexed_comp
INFO:root:    (151) name -> . selected_comp
INFO:root:    (152) name -> . attribute
INFO:root:    (153) name -> . operator_symbol
INFO:root:    (157) simple_name -> . IDENTIFIER
INFO:root:    (164) indexed_comp -> . name ( value_s )
INFO:root:    (171) selected_comp -> . name . simple_name
INFO:root:    (172) selected_comp -> . name . used_char
INFO:root:    (173) selected_comp -> . name . operator_symbol
INFO:root:    (174) selected_comp -> . name . ALL
INFO:root:    (175) attribute -> . name TICK attribute_id
INFO:root:    (163) operator_symbol -> . STRING
INFO:root:
INFO:root:    IDENTIFIER      shift and go to state 33
INFO:root:    STRING          shift and go to state 149
INFO:root:
INFO:root:    selected_comp                  shift and go to state 139
INFO:root:    simple_name                    shift and go to state 163
INFO:root:    indexed_comp                   shift and go to state 140
INFO:root:    attribute                      shift and go to state 134
INFO:root:    name                           shift and go to state 432
INFO:root:    operator_symbol                shift and go to state 133
INFO:root:    subtype_ind                    shift and go to state 505
INFO:root:
INFO:root:state 349
INFO:root:
INFO:root:    (7) pragma_arg -> simple_name ARROW expression .
INFO:root:    (189) expression -> expression . logical relation
INFO:root:    (190) expression -> expression . short_circuit relation
INFO:root:    (191) logical -> . AND
INFO:root:    (192) logical -> . OR
INFO:root:    (193) logical -> . XOR
INFO:root:    (194) short_circuit -> . AND THEN
INFO:root:    (195) short_circuit -> . OR ELSE
INFO:root:
INFO:root:    )               reduce using rule 7 (pragma_arg -> simple_name ARROW expression .)
INFO:root:    ,               reduce using rule 7 (pragma_arg -> simple_name ARROW expression .)
INFO:root:    AND             shift and go to state 215
INFO:root:    OR              shift and go to state 216
INFO:root:    XOR             shift and go to state 214
INFO:root:
INFO:root:    short_circuit                  shift and go to state 212
INFO:root:    logical                        shift and go to state 213
INFO:root:
INFO:root:state 350
INFO:root:
INFO:root:    (187) comp_assoc -> choice_s ARROW . expression
INFO:root:    (188) expression -> . relation
INFO:root:    (189) expression -> . expression logical relation
INFO:root:    (190) expression -> . expression short_circuit relation
INFO:root:    (196) relation -> . simple_expression
INFO:root:    (197) relation -> . simple_expression relational simple_expression
INFO:root:    (198) relation -> . simple_expression membership range
INFO:root:    (199) relation -> . simple_expression membership name
INFO:root:    (208) simple_expression -> . unary term
INFO:root:    (209) simple_expression -> . term
INFO:root:    (210) simple_expression -> . simple_expression adding term
INFO:root:    (211) unary -> . +
INFO:root:    (212) unary -> . -
INFO:root:    (216) term -> . factor
INFO:root:    (217) term -> . term multiplying factor
INFO:root:    (223) factor -> . primary
INFO:root:    (224) factor -> . NOT primary
INFO:root:    (225) factor -> . ABS primary
INFO:root:    (226) primary -> . literal
INFO:root:    (227) primary -> . name
INFO:root:    (228) primary -> . allocator
INFO:root:    (229) primary -> . qualified
INFO:root:    (230) primary -> . parenthesized_primary
INFO:root:    (180) literal -> . INT
INFO:root:    (181) literal -> . FLOAT
INFO:root:    (182) literal -> . NuLL
INFO:root:    (149) name -> . simple_name
INFO:root:    (150) name -> . indexed_comp
INFO:root:    (151) name -> . selected_comp
INFO:root:    (152) name -> . attribute
INFO:root:    (153) name -> . operator_symbol
INFO:root:    (234) allocator -> . NEW name
INFO:root:    (235) allocator -> . NEW qualified
INFO:root:    (233) qualified -> . name TICK parenthesized_primary
INFO:root:    (231) parenthesized_primary -> . aggregate
INFO:root:    (232) parenthesized_primary -> . ( expression )
INFO:root:    (157) simple_name -> . IDENTIFIER
INFO:root:    (164) indexed_comp -> . name ( value_s )
INFO:root:    (171) selected_comp -> . name . simple_name
INFO:root:    (172) selected_comp -> . name . used_char
INFO:root:    (173) selected_comp -> . name . operator_symbol
INFO:root:    (174) selected_comp -> . name . ALL
INFO:root:    (175) attribute -> . name TICK attribute_id
INFO:root:    (163) operator_symbol -> . STRING
INFO:root:    (183) aggregate -> . ( comp_assoc )
INFO:root:    (184) aggregate -> . ( expression WITH value_s )
INFO:root:    (185) aggregate -> . ( expression WITH NuLL RECORD )
INFO:root:    (186) aggregate -> . ( NuLL RECORD )
INFO:root:
INFO:root:    +               shift and go to state 148
INFO:root:    -               shift and go to state 136
INFO:root:    NOT             shift and go to state 131
INFO:root:    ABS             shift and go to state 132
INFO:root:    INT             shift and go to state 120
INFO:root:    FLOAT           shift and go to state 128
INFO:root:    NuLL            shift and go to state 130
INFO:root:    NEW             shift and go to state 137
INFO:root:    (               shift and go to state 125
INFO:root:    IDENTIFIER      shift and go to state 33
INFO:root:    STRING          shift and go to state 149
INFO:root:
INFO:root:    literal                        shift and go to state 121
INFO:root:    allocator                      shift and go to state 122
INFO:root:    simple_name                    shift and go to state 163
INFO:root:    indexed_comp                   shift and go to state 140
INFO:root:    name                           shift and go to state 142
INFO:root:    selected_comp                  shift and go to state 139
INFO:root:    factor                         shift and go to state 126
INFO:root:    expression                     shift and go to state 506
INFO:root:    unary                          shift and go to state 144
INFO:root:    qualified                      shift and go to state 145
INFO:root:    aggregate                      shift and go to state 143
INFO:root:    simple_expression              shift and go to state 129
INFO:root:    term                           shift and go to state 146
INFO:root:    operator_symbol                shift and go to state 133
INFO:root:    parenthesized_primary          shift and go to state 147
INFO:root:    primary                        shift and go to state 135
INFO:root:    attribute                      shift and go to state 134
INFO:root:    relation                       shift and go to state 138
INFO:root:
INFO:root:state 351
INFO:root:
INFO:root:    (122) choice_s -> choice_s | . choice
INFO:root:    (123) choice -> . expression
INFO:root:    (124) choice -> . discrete_with_range
INFO:root:    (125) choice -> . OTHERS
INFO:root:    (188) expression -> . relation
INFO:root:    (189) expression -> . expression logical relation
INFO:root:    (190) expression -> . expression short_circuit relation
INFO:root:    (126) discrete_with_range -> . name range_constraint
INFO:root:    (127) discrete_with_range -> . range
INFO:root:    (196) relation -> . simple_expression
INFO:root:    (197) relation -> . simple_expression relational simple_expression
INFO:root:    (198) relation -> . simple_expression membership range
INFO:root:    (199) relation -> . simple_expression membership name
INFO:root:    (149) name -> . simple_name
INFO:root:    (150) name -> . indexed_comp
INFO:root:    (151) name -> . selected_comp
INFO:root:    (152) name -> . attribute
INFO:root:    (153) name -> . operator_symbol
INFO:root:    (62) range -> . simple_expression DOTDOT simple_expression
INFO:root:    (208) simple_expression -> . unary term
INFO:root:    (209) simple_expression -> . term
INFO:root:    (210) simple_expression -> . simple_expression adding term
INFO:root:    (157) simple_name -> . IDENTIFIER
INFO:root:    (164) indexed_comp -> . name ( value_s )
INFO:root:    (171) selected_comp -> . name . simple_name
INFO:root:    (172) selected_comp -> . name . used_char
INFO:root:    (173) selected_comp -> . name . operator_symbol
INFO:root:    (174) selected_comp -> . name . ALL
INFO:root:    (175) attribute -> . name TICK attribute_id
INFO:root:    (163) operator_symbol -> . STRING
INFO:root:    (211) unary -> . +
INFO:root:    (212) unary -> . -
INFO:root:    (216) term -> . factor
INFO:root:    (217) term -> . term multiplying factor
INFO:root:    (223) factor -> . primary
INFO:root:    (224) factor -> . NOT primary
INFO:root:    (225) factor -> . ABS primary
INFO:root:    (226) primary -> . literal
INFO:root:    (227) primary -> . name
INFO:root:    (228) primary -> . allocator
INFO:root:    (229) primary -> . qualified
INFO:root:    (230) primary -> . parenthesized_primary
INFO:root:    (180) literal -> . INT
INFO:root:    (181) literal -> . FLOAT
INFO:root:    (182) literal -> . NuLL
INFO:root:    (234) allocator -> . NEW name
INFO:root:    (235) allocator -> . NEW qualified
INFO:root:    (233) qualified -> . name TICK parenthesized_primary
INFO:root:    (231) parenthesized_primary -> . aggregate
INFO:root:    (232) parenthesized_primary -> . ( expression )
INFO:root:    (183) aggregate -> . ( comp_assoc )
INFO:root:    (184) aggregate -> . ( expression WITH value_s )
INFO:root:    (185) aggregate -> . ( expression WITH NuLL RECORD )
INFO:root:    (186) aggregate -> . ( NuLL RECORD )
INFO:root:
INFO:root:    OTHERS          shift and go to state 204
INFO:root:    IDENTIFIER      shift and go to state 33
INFO:root:    STRING          shift and go to state 149
INFO:root:    +               shift and go to state 148
INFO:root:    -               shift and go to state 136
INFO:root:    NOT             shift and go to state 131
INFO:root:    ABS             shift and go to state 132
INFO:root:    INT             shift and go to state 120
INFO:root:    FLOAT           shift and go to state 128
INFO:root:    NuLL            shift and go to state 130
INFO:root:    NEW             shift and go to state 137
INFO:root:    (               shift and go to state 125
INFO:root:
INFO:root:    selected_comp                  shift and go to state 139
INFO:root:    attribute                      shift and go to state 134
INFO:root:    factor                         shift and go to state 126
INFO:root:    indexed_comp                   shift and go to state 140
INFO:root:    name                           shift and go to state 377
INFO:root:    literal                        shift and go to state 121
INFO:root:    simple_name                    shift and go to state 163
INFO:root:    expression                     shift and go to state 507
INFO:root:    simple_expression              shift and go to state 374
INFO:root:    parenthesized_primary          shift and go to state 147
INFO:root:    unary                          shift and go to state 144
INFO:root:    aggregate                      shift and go to state 143
INFO:root:    discrete_with_range            shift and go to state 210
INFO:root:    term                           shift and go to state 146
INFO:root:    operator_symbol                shift and go to state 133
INFO:root:    primary                        shift and go to state 135
INFO:root:    qualified                      shift and go to state 145
INFO:root:    relation                       shift and go to state 138
INFO:root:    range                          shift and go to state 211
INFO:root:    allocator                      shift and go to state 122
INFO:root:    choice                         shift and go to state 508
INFO:root:
INFO:root:state 352
INFO:root:
INFO:root:    (232) parenthesized_primary -> ( expression ) .
INFO:root:
INFO:root:    *               reduce using rule 232 (parenthesized_primary -> ( expression ) .)
INFO:root:    /               reduce using rule 232 (parenthesized_primary -> ( expression ) .)
INFO:root:    MOD             reduce using rule 232 (parenthesized_primary -> ( expression ) .)
INFO:root:    REM             reduce using rule 232 (parenthesized_primary -> ( expression ) .)
INFO:root:    STARSTAR        reduce using rule 232 (parenthesized_primary -> ( expression ) .)
INFO:root:    =               reduce using rule 232 (parenthesized_primary -> ( expression ) .)
INFO:root:    NEQ             reduce using rule 232 (parenthesized_primary -> ( expression ) .)
INFO:root:    <               reduce using rule 232 (parenthesized_primary -> ( expression ) .)
INFO:root:    LEQ             reduce using rule 232 (parenthesized_primary -> ( expression ) .)
INFO:root:    >               reduce using rule 232 (parenthesized_primary -> ( expression ) .)
INFO:root:    GEQ             reduce using rule 232 (parenthesized_primary -> ( expression ) .)
INFO:root:    IN              reduce using rule 232 (parenthesized_primary -> ( expression ) .)
INFO:root:    NOT             reduce using rule 232 (parenthesized_primary -> ( expression ) .)
INFO:root:    +               reduce using rule 232 (parenthesized_primary -> ( expression ) .)
INFO:root:    -               reduce using rule 232 (parenthesized_primary -> ( expression ) .)
INFO:root:    &               reduce using rule 232 (parenthesized_primary -> ( expression ) .)
INFO:root:    IS              reduce using rule 232 (parenthesized_primary -> ( expression ) .)
INFO:root:    AND             reduce using rule 232 (parenthesized_primary -> ( expression ) .)
INFO:root:    OR              reduce using rule 232 (parenthesized_primary -> ( expression ) .)
INFO:root:    XOR             reduce using rule 232 (parenthesized_primary -> ( expression ) .)
INFO:root:    THEN            reduce using rule 232 (parenthesized_primary -> ( expression ) .)
INFO:root:    )               reduce using rule 232 (parenthesized_primary -> ( expression ) .)
INFO:root:    ,               reduce using rule 232 (parenthesized_primary -> ( expression ) .)
INFO:root:    DOTDOT          reduce using rule 232 (parenthesized_primary -> ( expression ) .)
INFO:root:    WITH            reduce using rule 232 (parenthesized_primary -> ( expression ) .)
INFO:root:    ARROW           reduce using rule 232 (parenthesized_primary -> ( expression ) .)
INFO:root:    |               reduce using rule 232 (parenthesized_primary -> ( expression ) .)
INFO:root:    ;               reduce using rule 232 (parenthesized_primary -> ( expression ) .)
INFO:root:    LOOP            reduce using rule 232 (parenthesized_primary -> ( expression ) .)
INFO:root:    RANGE           reduce using rule 232 (parenthesized_primary -> ( expression ) .)
INFO:root:    DIGITS          reduce using rule 232 (parenthesized_primary -> ( expression ) .)
INFO:root:    RENAMES         reduce using rule 232 (parenthesized_primary -> ( expression ) .)
INFO:root:    ASSIGN          reduce using rule 232 (parenthesized_primary -> ( expression ) .)
INFO:root:
INFO:root:
INFO:root:state 353
INFO:root:
INFO:root:    (184) aggregate -> ( expression WITH . value_s )
INFO:root:    (185) aggregate -> ( expression WITH . NuLL RECORD )
INFO:root:    (165) value_s -> . value
INFO:root:    (166) value_s -> . value_s , value
INFO:root:    (167) value -> . expression
INFO:root:    (168) value -> . comp_assoc
INFO:root:    (169) value -> . discrete_with_range
INFO:root:    (170) value -> . error
INFO:root:    (188) expression -> . relation
INFO:root:    (189) expression -> . expression logical relation
INFO:root:    (190) expression -> . expression short_circuit relation
INFO:root:    (187) comp_assoc -> . choice_s ARROW expression
INFO:root:    (126) discrete_with_range -> . name range_constraint
INFO:root:    (127) discrete_with_range -> . range
INFO:root:    (196) relation -> . simple_expression
INFO:root:    (197) relation -> . simple_expression relational simple_expression
INFO:root:    (198) relation -> . simple_expression membership range
INFO:root:    (199) relation -> . simple_expression membership name
INFO:root:    (121) choice_s -> . choice
INFO:root:    (122) choice_s -> . choice_s | choice
INFO:root:    (149) name -> . simple_name
INFO:root:    (150) name -> . indexed_comp
INFO:root:    (151) name -> . selected_comp
INFO:root:    (152) name -> . attribute
INFO:root:    (153) name -> . operator_symbol
INFO:root:    (62) range -> . simple_expression DOTDOT simple_expression
INFO:root:    (208) simple_expression -> . unary term
INFO:root:    (209) simple_expression -> . term
INFO:root:    (210) simple_expression -> . simple_expression adding term
INFO:root:    (123) choice -> . expression
INFO:root:    (124) choice -> . discrete_with_range
INFO:root:    (125) choice -> . OTHERS
INFO:root:    (157) simple_name -> . IDENTIFIER
INFO:root:    (164) indexed_comp -> . name ( value_s )
INFO:root:    (171) selected_comp -> . name . simple_name
INFO:root:    (172) selected_comp -> . name . used_char
INFO:root:    (173) selected_comp -> . name . operator_symbol
INFO:root:    (174) selected_comp -> . name . ALL
INFO:root:    (175) attribute -> . name TICK attribute_id
INFO:root:    (163) operator_symbol -> . STRING
INFO:root:    (211) unary -> . +
INFO:root:    (212) unary -> . -
INFO:root:    (216) term -> . factor
INFO:root:    (217) term -> . term multiplying factor
INFO:root:    (223) factor -> . primary
INFO:root:    (224) factor -> . NOT primary
INFO:root:    (225) factor -> . ABS primary
INFO:root:    (226) primary -> . literal
INFO:root:    (227) primary -> . name
INFO:root:    (228) primary -> . allocator
INFO:root:    (229) primary -> . qualified
INFO:root:    (230) primary -> . parenthesized_primary
INFO:root:    (180) literal -> . INT
INFO:root:    (181) literal -> . FLOAT
INFO:root:    (182) literal -> . NuLL
INFO:root:    (234) allocator -> . NEW name
INFO:root:    (235) allocator -> . NEW qualified
INFO:root:    (233) qualified -> . name TICK parenthesized_primary
INFO:root:    (231) parenthesized_primary -> . aggregate
INFO:root:    (232) parenthesized_primary -> . ( expression )
INFO:root:    (183) aggregate -> . ( comp_assoc )
INFO:root:    (184) aggregate -> . ( expression WITH value_s )
INFO:root:    (185) aggregate -> . ( expression WITH NuLL RECORD )
INFO:root:    (186) aggregate -> . ( NuLL RECORD )
INFO:root:
INFO:root:    NuLL            shift and go to state 509
INFO:root:    error           shift and go to state 379
INFO:root:    OTHERS          shift and go to state 204
INFO:root:    IDENTIFIER      shift and go to state 33
INFO:root:    STRING          shift and go to state 149
INFO:root:    +               shift and go to state 148
INFO:root:    -               shift and go to state 136
INFO:root:    NOT             shift and go to state 131
INFO:root:    ABS             shift and go to state 132
INFO:root:    INT             shift and go to state 120
INFO:root:    FLOAT           shift and go to state 128
INFO:root:    NEW             shift and go to state 137
INFO:root:    (               shift and go to state 125
INFO:root:
INFO:root:    value                          shift and go to state 372
INFO:root:    comp_assoc                     shift and go to state 376
INFO:root:    factor                         shift and go to state 126
INFO:root:    indexed_comp                   shift and go to state 140
INFO:root:    name                           shift and go to state 377
INFO:root:    literal                        shift and go to state 121
INFO:root:    selected_comp                  shift and go to state 139
INFO:root:    simple_name                    shift and go to state 163
INFO:root:    expression                     shift and go to state 373
INFO:root:    simple_expression              shift and go to state 374
INFO:root:    parenthesized_primary          shift and go to state 147
INFO:root:    unary                          shift and go to state 144
INFO:root:    term                           shift and go to state 146
INFO:root:    aggregate                      shift and go to state 143
INFO:root:    discrete_with_range            shift and go to state 378
INFO:root:    value_s                        shift and go to state 510
INFO:root:    operator_symbol                shift and go to state 133
INFO:root:    qualified                      shift and go to state 145
INFO:root:    choice_s                       shift and go to state 202
INFO:root:    primary                        shift and go to state 135
INFO:root:    attribute                      shift and go to state 134
INFO:root:    relation                       shift and go to state 138
INFO:root:    range                          shift and go to state 211
INFO:root:    allocator                      shift and go to state 122
INFO:root:    choice                         shift and go to state 207
INFO:root:
INFO:root:state 354
INFO:root:
INFO:root:    (62) range -> simple_expression DOTDOT . simple_expression
INFO:root:    (208) simple_expression -> . unary term
INFO:root:    (209) simple_expression -> . term
INFO:root:    (210) simple_expression -> . simple_expression adding term
INFO:root:    (211) unary -> . +
INFO:root:    (212) unary -> . -
INFO:root:    (216) term -> . factor
INFO:root:    (217) term -> . term multiplying factor
INFO:root:    (223) factor -> . primary
INFO:root:    (224) factor -> . NOT primary
INFO:root:    (225) factor -> . ABS primary
INFO:root:    (226) primary -> . literal
INFO:root:    (227) primary -> . name
INFO:root:    (228) primary -> . allocator
INFO:root:    (229) primary -> . qualified
INFO:root:    (230) primary -> . parenthesized_primary
INFO:root:    (180) literal -> . INT
INFO:root:    (181) literal -> . FLOAT
INFO:root:    (182) literal -> . NuLL
INFO:root:    (149) name -> . simple_name
INFO:root:    (150) name -> . indexed_comp
INFO:root:    (151) name -> . selected_comp
INFO:root:    (152) name -> . attribute
INFO:root:    (153) name -> . operator_symbol
INFO:root:    (234) allocator -> . NEW name
INFO:root:    (235) allocator -> . NEW qualified
INFO:root:    (233) qualified -> . name TICK parenthesized_primary
INFO:root:    (231) parenthesized_primary -> . aggregate
INFO:root:    (232) parenthesized_primary -> . ( expression )
INFO:root:    (157) simple_name -> . IDENTIFIER
INFO:root:    (164) indexed_comp -> . name ( value_s )
INFO:root:    (171) selected_comp -> . name . simple_name
INFO:root:    (172) selected_comp -> . name . used_char
INFO:root:    (173) selected_comp -> . name . operator_symbol
INFO:root:    (174) selected_comp -> . name . ALL
INFO:root:    (175) attribute -> . name TICK attribute_id
INFO:root:    (163) operator_symbol -> . STRING
INFO:root:    (183) aggregate -> . ( comp_assoc )
INFO:root:    (184) aggregate -> . ( expression WITH value_s )
INFO:root:    (185) aggregate -> . ( expression WITH NuLL RECORD )
INFO:root:    (186) aggregate -> . ( NuLL RECORD )
INFO:root:
INFO:root:    +               shift and go to state 148
INFO:root:    -               shift and go to state 136
INFO:root:    NOT             shift and go to state 131
INFO:root:    ABS             shift and go to state 132
INFO:root:    INT             shift and go to state 120
INFO:root:    FLOAT           shift and go to state 128
INFO:root:    NuLL            shift and go to state 130
INFO:root:    NEW             shift and go to state 137
INFO:root:    (               shift and go to state 125
INFO:root:    IDENTIFIER      shift and go to state 33
INFO:root:    STRING          shift and go to state 149
INFO:root:
INFO:root:    literal                        shift and go to state 121
INFO:root:    allocator                      shift and go to state 122
INFO:root:    simple_name                    shift and go to state 163
INFO:root:    indexed_comp                   shift and go to state 140
INFO:root:    attribute                      shift and go to state 134
INFO:root:    name                           shift and go to state 142
INFO:root:    term                           shift and go to state 146
INFO:root:    selected_comp                  shift and go to state 139
INFO:root:    factor                         shift and go to state 126
INFO:root:    aggregate                      shift and go to state 143
INFO:root:    unary                          shift and go to state 144
INFO:root:    qualified                      shift and go to state 145
INFO:root:    simple_expression              shift and go to state 511
INFO:root:    operator_symbol                shift and go to state 133
INFO:root:    parenthesized_primary          shift and go to state 147
INFO:root:    primary                        shift and go to state 135
INFO:root:
INFO:root:state 355
INFO:root:
INFO:root:    (186) aggregate -> ( NuLL RECORD . )
INFO:root:
INFO:root:    )               shift and go to state 512
INFO:root:
INFO:root:
INFO:root:state 356
INFO:root:
INFO:root:    (183) aggregate -> ( comp_assoc ) .
INFO:root:
INFO:root:    *               reduce using rule 183 (aggregate -> ( comp_assoc ) .)
INFO:root:    /               reduce using rule 183 (aggregate -> ( comp_assoc ) .)
INFO:root:    MOD             reduce using rule 183 (aggregate -> ( comp_assoc ) .)
INFO:root:    REM             reduce using rule 183 (aggregate -> ( comp_assoc ) .)
INFO:root:    STARSTAR        reduce using rule 183 (aggregate -> ( comp_assoc ) .)
INFO:root:    =               reduce using rule 183 (aggregate -> ( comp_assoc ) .)
INFO:root:    NEQ             reduce using rule 183 (aggregate -> ( comp_assoc ) .)
INFO:root:    <               reduce using rule 183 (aggregate -> ( comp_assoc ) .)
INFO:root:    LEQ             reduce using rule 183 (aggregate -> ( comp_assoc ) .)
INFO:root:    >               reduce using rule 183 (aggregate -> ( comp_assoc ) .)
INFO:root:    GEQ             reduce using rule 183 (aggregate -> ( comp_assoc ) .)
INFO:root:    IN              reduce using rule 183 (aggregate -> ( comp_assoc ) .)
INFO:root:    NOT             reduce using rule 183 (aggregate -> ( comp_assoc ) .)
INFO:root:    +               reduce using rule 183 (aggregate -> ( comp_assoc ) .)
INFO:root:    -               reduce using rule 183 (aggregate -> ( comp_assoc ) .)
INFO:root:    &               reduce using rule 183 (aggregate -> ( comp_assoc ) .)
INFO:root:    AND             reduce using rule 183 (aggregate -> ( comp_assoc ) .)
INFO:root:    OR              reduce using rule 183 (aggregate -> ( comp_assoc ) .)
INFO:root:    XOR             reduce using rule 183 (aggregate -> ( comp_assoc ) .)
INFO:root:    RANGE           reduce using rule 183 (aggregate -> ( comp_assoc ) .)
INFO:root:    RENAMES         reduce using rule 183 (aggregate -> ( comp_assoc ) .)
INFO:root:    ASSIGN          reduce using rule 183 (aggregate -> ( comp_assoc ) .)
INFO:root:    ;               reduce using rule 183 (aggregate -> ( comp_assoc ) .)
INFO:root:    WITH            reduce using rule 183 (aggregate -> ( comp_assoc ) .)
INFO:root:    DOTDOT          reduce using rule 183 (aggregate -> ( comp_assoc ) .)
INFO:root:    IS              reduce using rule 183 (aggregate -> ( comp_assoc ) .)
INFO:root:    )               reduce using rule 183 (aggregate -> ( comp_assoc ) .)
INFO:root:    ,               reduce using rule 183 (aggregate -> ( comp_assoc ) .)
INFO:root:    ARROW           reduce using rule 183 (aggregate -> ( comp_assoc ) .)
INFO:root:    |               reduce using rule 183 (aggregate -> ( comp_assoc ) .)
INFO:root:    THEN            reduce using rule 183 (aggregate -> ( comp_assoc ) .)
INFO:root:    LOOP            reduce using rule 183 (aggregate -> ( comp_assoc ) .)
INFO:root:    DIGITS          reduce using rule 183 (aggregate -> ( comp_assoc ) .)
INFO:root:
INFO:root:
INFO:root:state 357
INFO:root:
INFO:root:    (126) discrete_with_range -> name range_constraint .
INFO:root:
INFO:root:    ARROW           reduce using rule 126 (discrete_with_range -> name range_constraint .)
INFO:root:    |               reduce using rule 126 (discrete_with_range -> name range_constraint .)
INFO:root:    )               reduce using rule 126 (discrete_with_range -> name range_constraint .)
INFO:root:    ,               reduce using rule 126 (discrete_with_range -> name range_constraint .)
INFO:root:
INFO:root:
INFO:root:state 358
INFO:root:
INFO:root:    (61) range_constraint -> RANGE . range
INFO:root:    (62) range -> . simple_expression DOTDOT simple_expression
INFO:root:    (208) simple_expression -> . unary term
INFO:root:    (209) simple_expression -> . term
INFO:root:    (210) simple_expression -> . simple_expression adding term
INFO:root:    (211) unary -> . +
INFO:root:    (212) unary -> . -
INFO:root:    (216) term -> . factor
INFO:root:    (217) term -> . term multiplying factor
INFO:root:    (223) factor -> . primary
INFO:root:    (224) factor -> . NOT primary
INFO:root:    (225) factor -> . ABS primary
INFO:root:    (226) primary -> . literal
INFO:root:    (227) primary -> . name
INFO:root:    (228) primary -> . allocator
INFO:root:    (229) primary -> . qualified
INFO:root:    (230) primary -> . parenthesized_primary
INFO:root:    (180) literal -> . INT
INFO:root:    (181) literal -> . FLOAT
INFO:root:    (182) literal -> . NuLL
INFO:root:    (149) name -> . simple_name
INFO:root:    (150) name -> . indexed_comp
INFO:root:    (151) name -> . selected_comp
INFO:root:    (152) name -> . attribute
INFO:root:    (153) name -> . operator_symbol
INFO:root:    (234) allocator -> . NEW name
INFO:root:    (235) allocator -> . NEW qualified
INFO:root:    (233) qualified -> . name TICK parenthesized_primary
INFO:root:    (231) parenthesized_primary -> . aggregate
INFO:root:    (232) parenthesized_primary -> . ( expression )
INFO:root:    (157) simple_name -> . IDENTIFIER
INFO:root:    (164) indexed_comp -> . name ( value_s )
INFO:root:    (171) selected_comp -> . name . simple_name
INFO:root:    (172) selected_comp -> . name . used_char
INFO:root:    (173) selected_comp -> . name . operator_symbol
INFO:root:    (174) selected_comp -> . name . ALL
INFO:root:    (175) attribute -> . name TICK attribute_id
INFO:root:    (163) operator_symbol -> . STRING
INFO:root:    (183) aggregate -> . ( comp_assoc )
INFO:root:    (184) aggregate -> . ( expression WITH value_s )
INFO:root:    (185) aggregate -> . ( expression WITH NuLL RECORD )
INFO:root:    (186) aggregate -> . ( NuLL RECORD )
INFO:root:
INFO:root:    +               shift and go to state 148
INFO:root:    -               shift and go to state 136
INFO:root:    NOT             shift and go to state 131
INFO:root:    ABS             shift and go to state 132
INFO:root:    INT             shift and go to state 120
INFO:root:    FLOAT           shift and go to state 128
INFO:root:    NuLL            shift and go to state 130
INFO:root:    NEW             shift and go to state 137
INFO:root:    (               shift and go to state 125
INFO:root:    IDENTIFIER      shift and go to state 33
INFO:root:    STRING          shift and go to state 149
INFO:root:
INFO:root:    literal                        shift and go to state 121
INFO:root:    allocator                      shift and go to state 122
INFO:root:    simple_name                    shift and go to state 163
INFO:root:    indexed_comp                   shift and go to state 140
INFO:root:    attribute                      shift and go to state 134
INFO:root:    name                           shift and go to state 142
INFO:root:    selected_comp                  shift and go to state 139
INFO:root:    factor                         shift and go to state 126
INFO:root:    aggregate                      shift and go to state 143
INFO:root:    unary                          shift and go to state 144
INFO:root:    term                           shift and go to state 146
INFO:root:    simple_expression              shift and go to state 366
INFO:root:    operator_symbol                shift and go to state 133
INFO:root:    parenthesized_primary          shift and go to state 147
INFO:root:    primary                        shift and go to state 135
INFO:root:    qualified                      shift and go to state 145
INFO:root:    range                          shift and go to state 513
INFO:root:
INFO:root:state 359
INFO:root:
INFO:root:    (175) attribute -> name TICK . attribute_id
INFO:root:    (233) qualified -> name TICK . parenthesized_primary
INFO:root:    (176) attribute_id -> . IDENTIFIER
INFO:root:    (177) attribute_id -> . DIGITS
INFO:root:    (178) attribute_id -> . DELTA
INFO:root:    (179) attribute_id -> . ACCESS
INFO:root:    (231) parenthesized_primary -> . aggregate
INFO:root:    (232) parenthesized_primary -> . ( expression )
INFO:root:    (183) aggregate -> . ( comp_assoc )
INFO:root:    (184) aggregate -> . ( expression WITH value_s )
INFO:root:    (185) aggregate -> . ( expression WITH NuLL RECORD )
INFO:root:    (186) aggregate -> . ( NuLL RECORD )
INFO:root:
INFO:root:    IDENTIFIER      shift and go to state 380
INFO:root:    DIGITS          shift and go to state 385
INFO:root:    DELTA           shift and go to state 382
INFO:root:    ACCESS          shift and go to state 381
INFO:root:    (               shift and go to state 125
INFO:root:
INFO:root:    aggregate                      shift and go to state 143
INFO:root:    attribute_id                   shift and go to state 383
INFO:root:    parenthesized_primary          shift and go to state 384
INFO:root:
INFO:root:state 360
INFO:root:
INFO:root:    (190) expression -> expression short_circuit relation .
INFO:root:
INFO:root:    )               reduce using rule 190 (expression -> expression short_circuit relation .)
INFO:root:    WITH            reduce using rule 190 (expression -> expression short_circuit relation .)
INFO:root:    AND             reduce using rule 190 (expression -> expression short_circuit relation .)
INFO:root:    OR              reduce using rule 190 (expression -> expression short_circuit relation .)
INFO:root:    XOR             reduce using rule 190 (expression -> expression short_circuit relation .)
INFO:root:    ARROW           reduce using rule 190 (expression -> expression short_circuit relation .)
INFO:root:    |               reduce using rule 190 (expression -> expression short_circuit relation .)
INFO:root:    RANGE           reduce using rule 190 (expression -> expression short_circuit relation .)
INFO:root:    ;               reduce using rule 190 (expression -> expression short_circuit relation .)
INFO:root:    THEN            reduce using rule 190 (expression -> expression short_circuit relation .)
INFO:root:    DIGITS          reduce using rule 190 (expression -> expression short_circuit relation .)
INFO:root:    ,               reduce using rule 190 (expression -> expression short_circuit relation .)
INFO:root:    RENAMES         reduce using rule 190 (expression -> expression short_circuit relation .)
INFO:root:    ASSIGN          reduce using rule 190 (expression -> expression short_circuit relation .)
INFO:root:    IS              reduce using rule 190 (expression -> expression short_circuit relation .)
INFO:root:    LOOP            reduce using rule 190 (expression -> expression short_circuit relation .)
INFO:root:
INFO:root:
INFO:root:state 361
INFO:root:
INFO:root:    (189) expression -> expression logical relation .
INFO:root:
INFO:root:    )               reduce using rule 189 (expression -> expression logical relation .)
INFO:root:    WITH            reduce using rule 189 (expression -> expression logical relation .)
INFO:root:    AND             reduce using rule 189 (expression -> expression logical relation .)
INFO:root:    OR              reduce using rule 189 (expression -> expression logical relation .)
INFO:root:    XOR             reduce using rule 189 (expression -> expression logical relation .)
INFO:root:    ARROW           reduce using rule 189 (expression -> expression logical relation .)
INFO:root:    |               reduce using rule 189 (expression -> expression logical relation .)
INFO:root:    RANGE           reduce using rule 189 (expression -> expression logical relation .)
INFO:root:    ;               reduce using rule 189 (expression -> expression logical relation .)
INFO:root:    THEN            reduce using rule 189 (expression -> expression logical relation .)
INFO:root:    DIGITS          reduce using rule 189 (expression -> expression logical relation .)
INFO:root:    ,               reduce using rule 189 (expression -> expression logical relation .)
INFO:root:    RENAMES         reduce using rule 189 (expression -> expression logical relation .)
INFO:root:    ASSIGN          reduce using rule 189 (expression -> expression logical relation .)
INFO:root:    IS              reduce using rule 189 (expression -> expression logical relation .)
INFO:root:    LOOP            reduce using rule 189 (expression -> expression logical relation .)
INFO:root:
INFO:root:
INFO:root:state 362
INFO:root:
INFO:root:    (194) short_circuit -> AND THEN .
INFO:root:
INFO:root:    +               reduce using rule 194 (short_circuit -> AND THEN .)
INFO:root:    -               reduce using rule 194 (short_circuit -> AND THEN .)
INFO:root:    NOT             reduce using rule 194 (short_circuit -> AND THEN .)
INFO:root:    ABS             reduce using rule 194 (short_circuit -> AND THEN .)
INFO:root:    INT             reduce using rule 194 (short_circuit -> AND THEN .)
INFO:root:    FLOAT           reduce using rule 194 (short_circuit -> AND THEN .)
INFO:root:    NuLL            reduce using rule 194 (short_circuit -> AND THEN .)
INFO:root:    NEW             reduce using rule 194 (short_circuit -> AND THEN .)
INFO:root:    (               reduce using rule 194 (short_circuit -> AND THEN .)
INFO:root:    IDENTIFIER      reduce using rule 194 (short_circuit -> AND THEN .)
INFO:root:    STRING          reduce using rule 194 (short_circuit -> AND THEN .)
INFO:root:
INFO:root:
INFO:root:state 363
INFO:root:
INFO:root:    (195) short_circuit -> OR ELSE .
INFO:root:
INFO:root:    +               reduce using rule 195 (short_circuit -> OR ELSE .)
INFO:root:    -               reduce using rule 195 (short_circuit -> OR ELSE .)
INFO:root:    NOT             reduce using rule 195 (short_circuit -> OR ELSE .)
INFO:root:    ABS             reduce using rule 195 (short_circuit -> OR ELSE .)
INFO:root:    INT             reduce using rule 195 (short_circuit -> OR ELSE .)
INFO:root:    FLOAT           reduce using rule 195 (short_circuit -> OR ELSE .)
INFO:root:    NuLL            reduce using rule 195 (short_circuit -> OR ELSE .)
INFO:root:    NEW             reduce using rule 195 (short_circuit -> OR ELSE .)
INFO:root:    (               reduce using rule 195 (short_circuit -> OR ELSE .)
INFO:root:    IDENTIFIER      reduce using rule 195 (short_circuit -> OR ELSE .)
INFO:root:    STRING          reduce using rule 195 (short_circuit -> OR ELSE .)
INFO:root:
INFO:root:
INFO:root:state 364
INFO:root:
INFO:root:    (207) membership -> NOT IN .
INFO:root:
INFO:root:    IDENTIFIER      reduce using rule 207 (membership -> NOT IN .)
INFO:root:    STRING          reduce using rule 207 (membership -> NOT IN .)
INFO:root:    +               reduce using rule 207 (membership -> NOT IN .)
INFO:root:    -               reduce using rule 207 (membership -> NOT IN .)
INFO:root:    NOT             reduce using rule 207 (membership -> NOT IN .)
INFO:root:    ABS             reduce using rule 207 (membership -> NOT IN .)
INFO:root:    INT             reduce using rule 207 (membership -> NOT IN .)
INFO:root:    FLOAT           reduce using rule 207 (membership -> NOT IN .)
INFO:root:    NuLL            reduce using rule 207 (membership -> NOT IN .)
INFO:root:    NEW             reduce using rule 207 (membership -> NOT IN .)
INFO:root:    (               reduce using rule 207 (membership -> NOT IN .)
INFO:root:
INFO:root:
INFO:root:state 365
INFO:root:
INFO:root:    (199) relation -> simple_expression membership name .
INFO:root:    (164) indexed_comp -> name . ( value_s )
INFO:root:    (171) selected_comp -> name . . simple_name
INFO:root:    (172) selected_comp -> name . . used_char
INFO:root:    (173) selected_comp -> name . . operator_symbol
INFO:root:    (174) selected_comp -> name . . ALL
INFO:root:    (175) attribute -> name . TICK attribute_id
INFO:root:    (227) primary -> name .
INFO:root:    (233) qualified -> name . TICK parenthesized_primary
INFO:root:
INFO:root:    AND             reduce using rule 199 (relation -> simple_expression membership name .)
INFO:root:    OR              reduce using rule 199 (relation -> simple_expression membership name .)
INFO:root:    XOR             reduce using rule 199 (relation -> simple_expression membership name .)
INFO:root:    RANGE           reduce using rule 199 (relation -> simple_expression membership name .)
INFO:root:    RENAMES         reduce using rule 199 (relation -> simple_expression membership name .)
INFO:root:    ASSIGN          reduce using rule 199 (relation -> simple_expression membership name .)
INFO:root:    ;               reduce using rule 199 (relation -> simple_expression membership name .)
INFO:root:    WITH            reduce using rule 199 (relation -> simple_expression membership name .)
INFO:root:    )               reduce using rule 199 (relation -> simple_expression membership name .)
INFO:root:    ,               reduce using rule 199 (relation -> simple_expression membership name .)
INFO:root:    ARROW           reduce using rule 199 (relation -> simple_expression membership name .)
INFO:root:    |               reduce using rule 199 (relation -> simple_expression membership name .)
INFO:root:    IS              reduce using rule 199 (relation -> simple_expression membership name .)
INFO:root:    THEN            reduce using rule 199 (relation -> simple_expression membership name .)
INFO:root:    LOOP            reduce using rule 199 (relation -> simple_expression membership name .)
INFO:root:    DIGITS          reduce using rule 199 (relation -> simple_expression membership name .)
INFO:root:    (               shift and go to state 237
INFO:root:    .               shift and go to state 239
INFO:root:    TICK            shift and go to state 359
INFO:root:    *               reduce using rule 227 (primary -> name .)
INFO:root:    /               reduce using rule 227 (primary -> name .)
INFO:root:    MOD             reduce using rule 227 (primary -> name .)
INFO:root:    REM             reduce using rule 227 (primary -> name .)
INFO:root:    STARSTAR        reduce using rule 227 (primary -> name .)
INFO:root:    DOTDOT          reduce using rule 227 (primary -> name .)
INFO:root:    +               reduce using rule 227 (primary -> name .)
INFO:root:    -               reduce using rule 227 (primary -> name .)
INFO:root:    &               reduce using rule 227 (primary -> name .)
INFO:root:
INFO:root:
INFO:root:state 366
INFO:root:
INFO:root:    (62) range -> simple_expression . DOTDOT simple_expression
INFO:root:    (210) simple_expression -> simple_expression . adding term
INFO:root:    (213) adding -> . +
INFO:root:    (214) adding -> . -
INFO:root:    (215) adding -> . &
INFO:root:
INFO:root:    DOTDOT          shift and go to state 354
INFO:root:    +               shift and go to state 226
INFO:root:    -               shift and go to state 217
INFO:root:    &               shift and go to state 229
INFO:root:
INFO:root:    adding                         shift and go to state 230
INFO:root:
INFO:root:state 367
INFO:root:
INFO:root:    (198) relation -> simple_expression membership range .
INFO:root:
INFO:root:    AND             reduce using rule 198 (relation -> simple_expression membership range .)
INFO:root:    OR              reduce using rule 198 (relation -> simple_expression membership range .)
INFO:root:    XOR             reduce using rule 198 (relation -> simple_expression membership range .)
INFO:root:    RANGE           reduce using rule 198 (relation -> simple_expression membership range .)
INFO:root:    RENAMES         reduce using rule 198 (relation -> simple_expression membership range .)
INFO:root:    ASSIGN          reduce using rule 198 (relation -> simple_expression membership range .)
INFO:root:    ;               reduce using rule 198 (relation -> simple_expression membership range .)
INFO:root:    WITH            reduce using rule 198 (relation -> simple_expression membership range .)
INFO:root:    )               reduce using rule 198 (relation -> simple_expression membership range .)
INFO:root:    ,               reduce using rule 198 (relation -> simple_expression membership range .)
INFO:root:    ARROW           reduce using rule 198 (relation -> simple_expression membership range .)
INFO:root:    |               reduce using rule 198 (relation -> simple_expression membership range .)
INFO:root:    IS              reduce using rule 198 (relation -> simple_expression membership range .)
INFO:root:    THEN            reduce using rule 198 (relation -> simple_expression membership range .)
INFO:root:    LOOP            reduce using rule 198 (relation -> simple_expression membership range .)
INFO:root:    DIGITS          reduce using rule 198 (relation -> simple_expression membership range .)
INFO:root:
INFO:root:
INFO:root:state 368
INFO:root:
INFO:root:    (197) relation -> simple_expression relational simple_expression .
INFO:root:    (210) simple_expression -> simple_expression . adding term
INFO:root:    (213) adding -> . +
INFO:root:    (214) adding -> . -
INFO:root:    (215) adding -> . &
INFO:root:
INFO:root:    AND             reduce using rule 197 (relation -> simple_expression relational simple_expression .)
INFO:root:    OR              reduce using rule 197 (relation -> simple_expression relational simple_expression .)
INFO:root:    XOR             reduce using rule 197 (relation -> simple_expression relational simple_expression .)
INFO:root:    RANGE           reduce using rule 197 (relation -> simple_expression relational simple_expression .)
INFO:root:    RENAMES         reduce using rule 197 (relation -> simple_expression relational simple_expression .)
INFO:root:    ASSIGN          reduce using rule 197 (relation -> simple_expression relational simple_expression .)
INFO:root:    ;               reduce using rule 197 (relation -> simple_expression relational simple_expression .)
INFO:root:    WITH            reduce using rule 197 (relation -> simple_expression relational simple_expression .)
INFO:root:    )               reduce using rule 197 (relation -> simple_expression relational simple_expression .)
INFO:root:    ,               reduce using rule 197 (relation -> simple_expression relational simple_expression .)
INFO:root:    ARROW           reduce using rule 197 (relation -> simple_expression relational simple_expression .)
INFO:root:    |               reduce using rule 197 (relation -> simple_expression relational simple_expression .)
INFO:root:    IS              reduce using rule 197 (relation -> simple_expression relational simple_expression .)
INFO:root:    THEN            reduce using rule 197 (relation -> simple_expression relational simple_expression .)
INFO:root:    LOOP            reduce using rule 197 (relation -> simple_expression relational simple_expression .)
INFO:root:    DIGITS          reduce using rule 197 (relation -> simple_expression relational simple_expression .)
INFO:root:    +               shift and go to state 226
INFO:root:    -               shift and go to state 217
INFO:root:    &               shift and go to state 229
INFO:root:
INFO:root:    adding                         shift and go to state 230
INFO:root:
INFO:root:state 369
INFO:root:
INFO:root:    (210) simple_expression -> simple_expression adding term .
INFO:root:    (217) term -> term . multiplying factor
INFO:root:    (218) multiplying -> . *
INFO:root:    (219) multiplying -> . /
INFO:root:    (220) multiplying -> . MOD
INFO:root:    (221) multiplying -> . REM
INFO:root:    (222) multiplying -> . STARSTAR
INFO:root:
INFO:root:    DOTDOT          reduce using rule 210 (simple_expression -> simple_expression adding term .)
INFO:root:    +               reduce using rule 210 (simple_expression -> simple_expression adding term .)
INFO:root:    -               reduce using rule 210 (simple_expression -> simple_expression adding term .)
INFO:root:    &               reduce using rule 210 (simple_expression -> simple_expression adding term .)
INFO:root:    =               reduce using rule 210 (simple_expression -> simple_expression adding term .)
INFO:root:    NEQ             reduce using rule 210 (simple_expression -> simple_expression adding term .)
INFO:root:    <               reduce using rule 210 (simple_expression -> simple_expression adding term .)
INFO:root:    LEQ             reduce using rule 210 (simple_expression -> simple_expression adding term .)
INFO:root:    >               reduce using rule 210 (simple_expression -> simple_expression adding term .)
INFO:root:    GEQ             reduce using rule 210 (simple_expression -> simple_expression adding term .)
INFO:root:    IN              reduce using rule 210 (simple_expression -> simple_expression adding term .)
INFO:root:    NOT             reduce using rule 210 (simple_expression -> simple_expression adding term .)
INFO:root:    DIGITS          reduce using rule 210 (simple_expression -> simple_expression adding term .)
INFO:root:    AND             reduce using rule 210 (simple_expression -> simple_expression adding term .)
INFO:root:    OR              reduce using rule 210 (simple_expression -> simple_expression adding term .)
INFO:root:    XOR             reduce using rule 210 (simple_expression -> simple_expression adding term .)
INFO:root:    RANGE           reduce using rule 210 (simple_expression -> simple_expression adding term .)
INFO:root:    ARROW           reduce using rule 210 (simple_expression -> simple_expression adding term .)
INFO:root:    |               reduce using rule 210 (simple_expression -> simple_expression adding term .)
INFO:root:    )               reduce using rule 210 (simple_expression -> simple_expression adding term .)
INFO:root:    ,               reduce using rule 210 (simple_expression -> simple_expression adding term .)
INFO:root:    WITH            reduce using rule 210 (simple_expression -> simple_expression adding term .)
INFO:root:    ;               reduce using rule 210 (simple_expression -> simple_expression adding term .)
INFO:root:    IS              reduce using rule 210 (simple_expression -> simple_expression adding term .)
INFO:root:    THEN            reduce using rule 210 (simple_expression -> simple_expression adding term .)
INFO:root:    LOOP            reduce using rule 210 (simple_expression -> simple_expression adding term .)
INFO:root:    RENAMES         reduce using rule 210 (simple_expression -> simple_expression adding term .)
INFO:root:    ASSIGN          reduce using rule 210 (simple_expression -> simple_expression adding term .)
INFO:root:    *               shift and go to state 243
INFO:root:    /               shift and go to state 246
INFO:root:    MOD             shift and go to state 241
INFO:root:    REM             shift and go to state 242
INFO:root:    STARSTAR        shift and go to state 245
INFO:root:
INFO:root:    multiplying                    shift and go to state 244
INFO:root:
INFO:root:state 370
INFO:root:
INFO:root:    (3) pragma -> PRAGMA simple_name ( pragma_arg_s ) ; .
INFO:root:
INFO:root:    PACKAGE         reduce using rule 3 (pragma -> PRAGMA simple_name ( pragma_arg_s ) ; .)
INFO:root:    TASK            reduce using rule 3 (pragma -> PRAGMA simple_name ( pragma_arg_s ) ; .)
INFO:root:    PROTECTED       reduce using rule 3 (pragma -> PRAGMA simple_name ( pragma_arg_s ) ; .)
INFO:root:    error           reduce using rule 3 (pragma -> PRAGMA simple_name ( pragma_arg_s ) ; .)
INFO:root:    USE             reduce using rule 3 (pragma -> PRAGMA simple_name ( pragma_arg_s ) ; .)
INFO:root:    PRAGMA          reduce using rule 3 (pragma -> PRAGMA simple_name ( pragma_arg_s ) ; .)
INFO:root:    TYPE            reduce using rule 3 (pragma -> PRAGMA simple_name ( pragma_arg_s ) ; .)
INFO:root:    SUBTYPE         reduce using rule 3 (pragma -> PRAGMA simple_name ( pragma_arg_s ) ; .)
INFO:root:    FOR             reduce using rule 3 (pragma -> PRAGMA simple_name ( pragma_arg_s ) ; .)
INFO:root:    PROCEDURE       reduce using rule 3 (pragma -> PRAGMA simple_name ( pragma_arg_s ) ; .)
INFO:root:    FUNCTION        reduce using rule 3 (pragma -> PRAGMA simple_name ( pragma_arg_s ) ; .)
INFO:root:    GENERIC         reduce using rule 3 (pragma -> PRAGMA simple_name ( pragma_arg_s ) ; .)
INFO:root:    IDENTIFIER      reduce using rule 3 (pragma -> PRAGMA simple_name ( pragma_arg_s ) ; .)
INFO:root:    BEGIN           reduce using rule 3 (pragma -> PRAGMA simple_name ( pragma_arg_s ) ; .)
INFO:root:    PRIVATE         reduce using rule 3 (pragma -> PRAGMA simple_name ( pragma_arg_s ) ; .)
INFO:root:    END             reduce using rule 3 (pragma -> PRAGMA simple_name ( pragma_arg_s ) ; .)
INFO:root:    WITH            reduce using rule 3 (pragma -> PRAGMA simple_name ( pragma_arg_s ) ; .)
INFO:root:    SEPARATE        reduce using rule 3 (pragma -> PRAGMA simple_name ( pragma_arg_s ) ; .)
INFO:root:    $end            reduce using rule 3 (pragma -> PRAGMA simple_name ( pragma_arg_s ) ; .)
INFO:root:    ENTRY           reduce using rule 3 (pragma -> PRAGMA simple_name ( pragma_arg_s ) ; .)
INFO:root:    WHEN            reduce using rule 3 (pragma -> PRAGMA simple_name ( pragma_arg_s ) ; .)
INFO:root:    CASE            reduce using rule 3 (pragma -> PRAGMA simple_name ( pragma_arg_s ) ; .)
INFO:root:    NuLL            reduce using rule 3 (pragma -> PRAGMA simple_name ( pragma_arg_s ) ; .)
INFO:root:
INFO:root:
INFO:root:state 371
INFO:root:
INFO:root:    (5) pragma_arg_s -> pragma_arg_s , pragma_arg .
INFO:root:
INFO:root:    )               reduce using rule 5 (pragma_arg_s -> pragma_arg_s , pragma_arg .)
INFO:root:    ,               reduce using rule 5 (pragma_arg_s -> pragma_arg_s , pragma_arg .)
INFO:root:
INFO:root:
INFO:root:state 372
INFO:root:
INFO:root:    (165) value_s -> value .
INFO:root:
INFO:root:    )               reduce using rule 165 (value_s -> value .)
INFO:root:    ,               reduce using rule 165 (value_s -> value .)
INFO:root:
INFO:root:
INFO:root:state 373
INFO:root:
INFO:root:    (167) value -> expression .
INFO:root:    (189) expression -> expression . logical relation
INFO:root:    (190) expression -> expression . short_circuit relation
INFO:root:    (123) choice -> expression .
INFO:root:    (191) logical -> . AND
INFO:root:    (192) logical -> . OR
INFO:root:    (193) logical -> . XOR
INFO:root:    (194) short_circuit -> . AND THEN
INFO:root:    (195) short_circuit -> . OR ELSE
INFO:root:
INFO:root:    )               reduce using rule 167 (value -> expression .)
INFO:root:    ,               reduce using rule 167 (value -> expression .)
INFO:root:    ARROW           reduce using rule 123 (choice -> expression .)
INFO:root:    |               reduce using rule 123 (choice -> expression .)
INFO:root:    AND             shift and go to state 215
INFO:root:    OR              shift and go to state 216
INFO:root:    XOR             shift and go to state 214
INFO:root:
INFO:root:    short_circuit                  shift and go to state 212
INFO:root:    logical                        shift and go to state 213
INFO:root:
INFO:root:state 374
INFO:root:
INFO:root:    (196) relation -> simple_expression .
INFO:root:    (197) relation -> simple_expression . relational simple_expression
INFO:root:    (198) relation -> simple_expression . membership range
INFO:root:    (199) relation -> simple_expression . membership name
INFO:root:    (62) range -> simple_expression . DOTDOT simple_expression
INFO:root:    (210) simple_expression -> simple_expression . adding term
INFO:root:    (200) relational -> . =
INFO:root:    (201) relational -> . NEQ
INFO:root:    (202) relational -> . <
INFO:root:    (203) relational -> . LEQ
INFO:root:    (204) relational -> . >
INFO:root:    (205) relational -> . GEQ
INFO:root:    (206) membership -> . IN
INFO:root:    (207) membership -> . NOT IN
INFO:root:    (213) adding -> . +
INFO:root:    (214) adding -> . -
INFO:root:    (215) adding -> . &
INFO:root:
INFO:root:    AND             reduce using rule 196 (relation -> simple_expression .)
INFO:root:    OR              reduce using rule 196 (relation -> simple_expression .)
INFO:root:    XOR             reduce using rule 196 (relation -> simple_expression .)
INFO:root:    ARROW           reduce using rule 196 (relation -> simple_expression .)
INFO:root:    |               reduce using rule 196 (relation -> simple_expression .)
INFO:root:    )               reduce using rule 196 (relation -> simple_expression .)
INFO:root:    ,               reduce using rule 196 (relation -> simple_expression .)
INFO:root:    DOTDOT          shift and go to state 354
INFO:root:    =               shift and go to state 219
INFO:root:    NEQ             shift and go to state 224
INFO:root:    <               shift and go to state 228
INFO:root:    LEQ             shift and go to state 218
INFO:root:    >               shift and go to state 222
INFO:root:    GEQ             shift and go to state 225
INFO:root:    IN              shift and go to state 223
INFO:root:    NOT             shift and go to state 220
INFO:root:    +               shift and go to state 226
INFO:root:    -               shift and go to state 217
INFO:root:    &               shift and go to state 229
INFO:root:
INFO:root:    membership                     shift and go to state 221
INFO:root:    relational                     shift and go to state 227
INFO:root:    adding                         shift and go to state 230
INFO:root:
INFO:root:state 375
INFO:root:
INFO:root:    (164) indexed_comp -> name ( value_s . )
INFO:root:    (166) value_s -> value_s . , value
INFO:root:
INFO:root:    )               shift and go to state 514
INFO:root:    ,               shift and go to state 515
INFO:root:
INFO:root:
INFO:root:state 376
INFO:root:
INFO:root:    (168) value -> comp_assoc .
INFO:root:
INFO:root:    )               reduce using rule 168 (value -> comp_assoc .)
INFO:root:    ,               reduce using rule 168 (value -> comp_assoc .)
INFO:root:
INFO:root:
INFO:root:state 377
INFO:root:
INFO:root:    (126) discrete_with_range -> name . range_constraint
INFO:root:    (164) indexed_comp -> name . ( value_s )
INFO:root:    (171) selected_comp -> name . . simple_name
INFO:root:    (172) selected_comp -> name . . used_char
INFO:root:    (173) selected_comp -> name . . operator_symbol
INFO:root:    (174) selected_comp -> name . . ALL
INFO:root:    (175) attribute -> name . TICK attribute_id
INFO:root:    (227) primary -> name .
INFO:root:    (233) qualified -> name . TICK parenthesized_primary
INFO:root:    (61) range_constraint -> . RANGE range
INFO:root:
INFO:root:    (               shift and go to state 237
INFO:root:    .               shift and go to state 239
INFO:root:    TICK            shift and go to state 359
INFO:root:    *               reduce using rule 227 (primary -> name .)
INFO:root:    /               reduce using rule 227 (primary -> name .)
INFO:root:    MOD             reduce using rule 227 (primary -> name .)
INFO:root:    REM             reduce using rule 227 (primary -> name .)
INFO:root:    STARSTAR        reduce using rule 227 (primary -> name .)
INFO:root:    DOTDOT          reduce using rule 227 (primary -> name .)
INFO:root:    =               reduce using rule 227 (primary -> name .)
INFO:root:    NEQ             reduce using rule 227 (primary -> name .)
INFO:root:    <               reduce using rule 227 (primary -> name .)
INFO:root:    LEQ             reduce using rule 227 (primary -> name .)
INFO:root:    >               reduce using rule 227 (primary -> name .)
INFO:root:    GEQ             reduce using rule 227 (primary -> name .)
INFO:root:    IN              reduce using rule 227 (primary -> name .)
INFO:root:    NOT             reduce using rule 227 (primary -> name .)
INFO:root:    +               reduce using rule 227 (primary -> name .)
INFO:root:    -               reduce using rule 227 (primary -> name .)
INFO:root:    &               reduce using rule 227 (primary -> name .)
INFO:root:    AND             reduce using rule 227 (primary -> name .)
INFO:root:    OR              reduce using rule 227 (primary -> name .)
INFO:root:    XOR             reduce using rule 227 (primary -> name .)
INFO:root:    )               reduce using rule 227 (primary -> name .)
INFO:root:    ,               reduce using rule 227 (primary -> name .)
INFO:root:    ARROW           reduce using rule 227 (primary -> name .)
INFO:root:    |               reduce using rule 227 (primary -> name .)
INFO:root:    RANGE           shift and go to state 358
INFO:root:
INFO:root:    range_constraint               shift and go to state 357
INFO:root:
INFO:root:state 378
INFO:root:
INFO:root:    (169) value -> discrete_with_range .
INFO:root:    (124) choice -> discrete_with_range .
INFO:root:
INFO:root:    )               reduce using rule 169 (value -> discrete_with_range .)
INFO:root:    ,               reduce using rule 169 (value -> discrete_with_range .)
INFO:root:    ARROW           reduce using rule 124 (choice -> discrete_with_range .)
INFO:root:    |               reduce using rule 124 (choice -> discrete_with_range .)
INFO:root:
INFO:root:
INFO:root:state 379
INFO:root:
INFO:root:    (170) value -> error .
INFO:root:
INFO:root:    )               reduce using rule 170 (value -> error .)
INFO:root:    ,               reduce using rule 170 (value -> error .)
INFO:root:
INFO:root:
INFO:root:state 380
INFO:root:
INFO:root:    (176) attribute_id -> IDENTIFIER .
INFO:root:
INFO:root:    TICK            reduce using rule 176 (attribute_id -> IDENTIFIER .)
INFO:root:    (               reduce using rule 176 (attribute_id -> IDENTIFIER .)
INFO:root:    .               reduce using rule 176 (attribute_id -> IDENTIFIER .)
INFO:root:    *               reduce using rule 176 (attribute_id -> IDENTIFIER .)
INFO:root:    /               reduce using rule 176 (attribute_id -> IDENTIFIER .)
INFO:root:    MOD             reduce using rule 176 (attribute_id -> IDENTIFIER .)
INFO:root:    REM             reduce using rule 176 (attribute_id -> IDENTIFIER .)
INFO:root:    STARSTAR        reduce using rule 176 (attribute_id -> IDENTIFIER .)
INFO:root:    =               reduce using rule 176 (attribute_id -> IDENTIFIER .)
INFO:root:    NEQ             reduce using rule 176 (attribute_id -> IDENTIFIER .)
INFO:root:    <               reduce using rule 176 (attribute_id -> IDENTIFIER .)
INFO:root:    LEQ             reduce using rule 176 (attribute_id -> IDENTIFIER .)
INFO:root:    >               reduce using rule 176 (attribute_id -> IDENTIFIER .)
INFO:root:    GEQ             reduce using rule 176 (attribute_id -> IDENTIFIER .)
INFO:root:    IN              reduce using rule 176 (attribute_id -> IDENTIFIER .)
INFO:root:    NOT             reduce using rule 176 (attribute_id -> IDENTIFIER .)
INFO:root:    +               reduce using rule 176 (attribute_id -> IDENTIFIER .)
INFO:root:    -               reduce using rule 176 (attribute_id -> IDENTIFIER .)
INFO:root:    &               reduce using rule 176 (attribute_id -> IDENTIFIER .)
INFO:root:    AND             reduce using rule 176 (attribute_id -> IDENTIFIER .)
INFO:root:    OR              reduce using rule 176 (attribute_id -> IDENTIFIER .)
INFO:root:    XOR             reduce using rule 176 (attribute_id -> IDENTIFIER .)
INFO:root:    )               reduce using rule 176 (attribute_id -> IDENTIFIER .)
INFO:root:    ,               reduce using rule 176 (attribute_id -> IDENTIFIER .)
INFO:root:    DOTDOT          reduce using rule 176 (attribute_id -> IDENTIFIER .)
INFO:root:    WITH            reduce using rule 176 (attribute_id -> IDENTIFIER .)
INFO:root:    ARROW           reduce using rule 176 (attribute_id -> IDENTIFIER .)
INFO:root:    |               reduce using rule 176 (attribute_id -> IDENTIFIER .)
INFO:root:    ;               reduce using rule 176 (attribute_id -> IDENTIFIER .)
INFO:root:    IS              reduce using rule 176 (attribute_id -> IDENTIFIER .)
INFO:root:    THEN            reduce using rule 176 (attribute_id -> IDENTIFIER .)
INFO:root:    LOOP            reduce using rule 176 (attribute_id -> IDENTIFIER .)
INFO:root:    RANGE           reduce using rule 176 (attribute_id -> IDENTIFIER .)
INFO:root:    DIGITS          reduce using rule 176 (attribute_id -> IDENTIFIER .)
INFO:root:    RENAMES         reduce using rule 176 (attribute_id -> IDENTIFIER .)
INFO:root:    ASSIGN          reduce using rule 176 (attribute_id -> IDENTIFIER .)
INFO:root:    USE             reduce using rule 176 (attribute_id -> IDENTIFIER .)
INFO:root:    AT              reduce using rule 176 (attribute_id -> IDENTIFIER .)
INFO:root:    WHEN            reduce using rule 176 (attribute_id -> IDENTIFIER .)
INFO:root:
INFO:root:
INFO:root:state 381
INFO:root:
INFO:root:    (179) attribute_id -> ACCESS .
INFO:root:
INFO:root:    TICK            reduce using rule 179 (attribute_id -> ACCESS .)
INFO:root:    (               reduce using rule 179 (attribute_id -> ACCESS .)
INFO:root:    .               reduce using rule 179 (attribute_id -> ACCESS .)
INFO:root:    *               reduce using rule 179 (attribute_id -> ACCESS .)
INFO:root:    /               reduce using rule 179 (attribute_id -> ACCESS .)
INFO:root:    MOD             reduce using rule 179 (attribute_id -> ACCESS .)
INFO:root:    REM             reduce using rule 179 (attribute_id -> ACCESS .)
INFO:root:    STARSTAR        reduce using rule 179 (attribute_id -> ACCESS .)
INFO:root:    =               reduce using rule 179 (attribute_id -> ACCESS .)
INFO:root:    NEQ             reduce using rule 179 (attribute_id -> ACCESS .)
INFO:root:    <               reduce using rule 179 (attribute_id -> ACCESS .)
INFO:root:    LEQ             reduce using rule 179 (attribute_id -> ACCESS .)
INFO:root:    >               reduce using rule 179 (attribute_id -> ACCESS .)
INFO:root:    GEQ             reduce using rule 179 (attribute_id -> ACCESS .)
INFO:root:    IN              reduce using rule 179 (attribute_id -> ACCESS .)
INFO:root:    NOT             reduce using rule 179 (attribute_id -> ACCESS .)
INFO:root:    +               reduce using rule 179 (attribute_id -> ACCESS .)
INFO:root:    -               reduce using rule 179 (attribute_id -> ACCESS .)
INFO:root:    &               reduce using rule 179 (attribute_id -> ACCESS .)
INFO:root:    AND             reduce using rule 179 (attribute_id -> ACCESS .)
INFO:root:    OR              reduce using rule 179 (attribute_id -> ACCESS .)
INFO:root:    XOR             reduce using rule 179 (attribute_id -> ACCESS .)
INFO:root:    )               reduce using rule 179 (attribute_id -> ACCESS .)
INFO:root:    ,               reduce using rule 179 (attribute_id -> ACCESS .)
INFO:root:    DOTDOT          reduce using rule 179 (attribute_id -> ACCESS .)
INFO:root:    WITH            reduce using rule 179 (attribute_id -> ACCESS .)
INFO:root:    ARROW           reduce using rule 179 (attribute_id -> ACCESS .)
INFO:root:    |               reduce using rule 179 (attribute_id -> ACCESS .)
INFO:root:    ;               reduce using rule 179 (attribute_id -> ACCESS .)
INFO:root:    IS              reduce using rule 179 (attribute_id -> ACCESS .)
INFO:root:    THEN            reduce using rule 179 (attribute_id -> ACCESS .)
INFO:root:    LOOP            reduce using rule 179 (attribute_id -> ACCESS .)
INFO:root:    RANGE           reduce using rule 179 (attribute_id -> ACCESS .)
INFO:root:    DIGITS          reduce using rule 179 (attribute_id -> ACCESS .)
INFO:root:    RENAMES         reduce using rule 179 (attribute_id -> ACCESS .)
INFO:root:    ASSIGN          reduce using rule 179 (attribute_id -> ACCESS .)
INFO:root:    USE             reduce using rule 179 (attribute_id -> ACCESS .)
INFO:root:    AT              reduce using rule 179 (attribute_id -> ACCESS .)
INFO:root:    WHEN            reduce using rule 179 (attribute_id -> ACCESS .)
INFO:root:
INFO:root:
INFO:root:state 382
INFO:root:
INFO:root:    (178) attribute_id -> DELTA .
INFO:root:
INFO:root:    TICK            reduce using rule 178 (attribute_id -> DELTA .)
INFO:root:    (               reduce using rule 178 (attribute_id -> DELTA .)
INFO:root:    .               reduce using rule 178 (attribute_id -> DELTA .)
INFO:root:    *               reduce using rule 178 (attribute_id -> DELTA .)
INFO:root:    /               reduce using rule 178 (attribute_id -> DELTA .)
INFO:root:    MOD             reduce using rule 178 (attribute_id -> DELTA .)
INFO:root:    REM             reduce using rule 178 (attribute_id -> DELTA .)
INFO:root:    STARSTAR        reduce using rule 178 (attribute_id -> DELTA .)
INFO:root:    =               reduce using rule 178 (attribute_id -> DELTA .)
INFO:root:    NEQ             reduce using rule 178 (attribute_id -> DELTA .)
INFO:root:    <               reduce using rule 178 (attribute_id -> DELTA .)
INFO:root:    LEQ             reduce using rule 178 (attribute_id -> DELTA .)
INFO:root:    >               reduce using rule 178 (attribute_id -> DELTA .)
INFO:root:    GEQ             reduce using rule 178 (attribute_id -> DELTA .)
INFO:root:    IN              reduce using rule 178 (attribute_id -> DELTA .)
INFO:root:    NOT             reduce using rule 178 (attribute_id -> DELTA .)
INFO:root:    +               reduce using rule 178 (attribute_id -> DELTA .)
INFO:root:    -               reduce using rule 178 (attribute_id -> DELTA .)
INFO:root:    &               reduce using rule 178 (attribute_id -> DELTA .)
INFO:root:    AND             reduce using rule 178 (attribute_id -> DELTA .)
INFO:root:    OR              reduce using rule 178 (attribute_id -> DELTA .)
INFO:root:    XOR             reduce using rule 178 (attribute_id -> DELTA .)
INFO:root:    )               reduce using rule 178 (attribute_id -> DELTA .)
INFO:root:    ,               reduce using rule 178 (attribute_id -> DELTA .)
INFO:root:    DOTDOT          reduce using rule 178 (attribute_id -> DELTA .)
INFO:root:    WITH            reduce using rule 178 (attribute_id -> DELTA .)
INFO:root:    ARROW           reduce using rule 178 (attribute_id -> DELTA .)
INFO:root:    |               reduce using rule 178 (attribute_id -> DELTA .)
INFO:root:    ;               reduce using rule 178 (attribute_id -> DELTA .)
INFO:root:    IS              reduce using rule 178 (attribute_id -> DELTA .)
INFO:root:    THEN            reduce using rule 178 (attribute_id -> DELTA .)
INFO:root:    LOOP            reduce using rule 178 (attribute_id -> DELTA .)
INFO:root:    RANGE           reduce using rule 178 (attribute_id -> DELTA .)
INFO:root:    DIGITS          reduce using rule 178 (attribute_id -> DELTA .)
INFO:root:    RENAMES         reduce using rule 178 (attribute_id -> DELTA .)
INFO:root:    ASSIGN          reduce using rule 178 (attribute_id -> DELTA .)
INFO:root:    USE             reduce using rule 178 (attribute_id -> DELTA .)
INFO:root:    AT              reduce using rule 178 (attribute_id -> DELTA .)
INFO:root:    WHEN            reduce using rule 178 (attribute_id -> DELTA .)
INFO:root:
INFO:root:
INFO:root:state 383
INFO:root:
INFO:root:    (175) attribute -> name TICK attribute_id .
INFO:root:
INFO:root:    TICK            reduce using rule 175 (attribute -> name TICK attribute_id .)
INFO:root:    (               reduce using rule 175 (attribute -> name TICK attribute_id .)
INFO:root:    .               reduce using rule 175 (attribute -> name TICK attribute_id .)
INFO:root:    *               reduce using rule 175 (attribute -> name TICK attribute_id .)
INFO:root:    /               reduce using rule 175 (attribute -> name TICK attribute_id .)
INFO:root:    MOD             reduce using rule 175 (attribute -> name TICK attribute_id .)
INFO:root:    REM             reduce using rule 175 (attribute -> name TICK attribute_id .)
INFO:root:    STARSTAR        reduce using rule 175 (attribute -> name TICK attribute_id .)
INFO:root:    =               reduce using rule 175 (attribute -> name TICK attribute_id .)
INFO:root:    NEQ             reduce using rule 175 (attribute -> name TICK attribute_id .)
INFO:root:    <               reduce using rule 175 (attribute -> name TICK attribute_id .)
INFO:root:    LEQ             reduce using rule 175 (attribute -> name TICK attribute_id .)
INFO:root:    >               reduce using rule 175 (attribute -> name TICK attribute_id .)
INFO:root:    GEQ             reduce using rule 175 (attribute -> name TICK attribute_id .)
INFO:root:    IN              reduce using rule 175 (attribute -> name TICK attribute_id .)
INFO:root:    NOT             reduce using rule 175 (attribute -> name TICK attribute_id .)
INFO:root:    +               reduce using rule 175 (attribute -> name TICK attribute_id .)
INFO:root:    -               reduce using rule 175 (attribute -> name TICK attribute_id .)
INFO:root:    &               reduce using rule 175 (attribute -> name TICK attribute_id .)
INFO:root:    AND             reduce using rule 175 (attribute -> name TICK attribute_id .)
INFO:root:    OR              reduce using rule 175 (attribute -> name TICK attribute_id .)
INFO:root:    XOR             reduce using rule 175 (attribute -> name TICK attribute_id .)
INFO:root:    LOOP            reduce using rule 175 (attribute -> name TICK attribute_id .)
INFO:root:    RANGE           reduce using rule 175 (attribute -> name TICK attribute_id .)
INFO:root:    DOTDOT          reduce using rule 175 (attribute -> name TICK attribute_id .)
INFO:root:    ARROW           reduce using rule 175 (attribute -> name TICK attribute_id .)
INFO:root:    |               reduce using rule 175 (attribute -> name TICK attribute_id .)
INFO:root:    )               reduce using rule 175 (attribute -> name TICK attribute_id .)
INFO:root:    ,               reduce using rule 175 (attribute -> name TICK attribute_id .)
INFO:root:    WITH            reduce using rule 175 (attribute -> name TICK attribute_id .)
INFO:root:    ;               reduce using rule 175 (attribute -> name TICK attribute_id .)
INFO:root:    IS              reduce using rule 175 (attribute -> name TICK attribute_id .)
INFO:root:    THEN            reduce using rule 175 (attribute -> name TICK attribute_id .)
INFO:root:    DIGITS          reduce using rule 175 (attribute -> name TICK attribute_id .)
INFO:root:    RENAMES         reduce using rule 175 (attribute -> name TICK attribute_id .)
INFO:root:    ASSIGN          reduce using rule 175 (attribute -> name TICK attribute_id .)
INFO:root:    WHEN            reduce using rule 175 (attribute -> name TICK attribute_id .)
INFO:root:
INFO:root:
INFO:root:state 384
INFO:root:
INFO:root:    (233) qualified -> name TICK parenthesized_primary .
INFO:root:
INFO:root:    *               reduce using rule 233 (qualified -> name TICK parenthesized_primary .)
INFO:root:    /               reduce using rule 233 (qualified -> name TICK parenthesized_primary .)
INFO:root:    MOD             reduce using rule 233 (qualified -> name TICK parenthesized_primary .)
INFO:root:    REM             reduce using rule 233 (qualified -> name TICK parenthesized_primary .)
INFO:root:    STARSTAR        reduce using rule 233 (qualified -> name TICK parenthesized_primary .)
INFO:root:    DOTDOT          reduce using rule 233 (qualified -> name TICK parenthesized_primary .)
INFO:root:    =               reduce using rule 233 (qualified -> name TICK parenthesized_primary .)
INFO:root:    NEQ             reduce using rule 233 (qualified -> name TICK parenthesized_primary .)
INFO:root:    <               reduce using rule 233 (qualified -> name TICK parenthesized_primary .)
INFO:root:    LEQ             reduce using rule 233 (qualified -> name TICK parenthesized_primary .)
INFO:root:    >               reduce using rule 233 (qualified -> name TICK parenthesized_primary .)
INFO:root:    GEQ             reduce using rule 233 (qualified -> name TICK parenthesized_primary .)
INFO:root:    IN              reduce using rule 233 (qualified -> name TICK parenthesized_primary .)
INFO:root:    NOT             reduce using rule 233 (qualified -> name TICK parenthesized_primary .)
INFO:root:    +               reduce using rule 233 (qualified -> name TICK parenthesized_primary .)
INFO:root:    -               reduce using rule 233 (qualified -> name TICK parenthesized_primary .)
INFO:root:    &               reduce using rule 233 (qualified -> name TICK parenthesized_primary .)
INFO:root:    )               reduce using rule 233 (qualified -> name TICK parenthesized_primary .)
INFO:root:    WITH            reduce using rule 233 (qualified -> name TICK parenthesized_primary .)
INFO:root:    AND             reduce using rule 233 (qualified -> name TICK parenthesized_primary .)
INFO:root:    OR              reduce using rule 233 (qualified -> name TICK parenthesized_primary .)
INFO:root:    XOR             reduce using rule 233 (qualified -> name TICK parenthesized_primary .)
INFO:root:    ARROW           reduce using rule 233 (qualified -> name TICK parenthesized_primary .)
INFO:root:    |               reduce using rule 233 (qualified -> name TICK parenthesized_primary .)
INFO:root:    ,               reduce using rule 233 (qualified -> name TICK parenthesized_primary .)
INFO:root:    ;               reduce using rule 233 (qualified -> name TICK parenthesized_primary .)
INFO:root:    IS              reduce using rule 233 (qualified -> name TICK parenthesized_primary .)
INFO:root:    THEN            reduce using rule 233 (qualified -> name TICK parenthesized_primary .)
INFO:root:    LOOP            reduce using rule 233 (qualified -> name TICK parenthesized_primary .)
INFO:root:    RANGE           reduce using rule 233 (qualified -> name TICK parenthesized_primary .)
INFO:root:    DIGITS          reduce using rule 233 (qualified -> name TICK parenthesized_primary .)
INFO:root:    RENAMES         reduce using rule 233 (qualified -> name TICK parenthesized_primary .)
INFO:root:    ASSIGN          reduce using rule 233 (qualified -> name TICK parenthesized_primary .)
INFO:root:
INFO:root:
INFO:root:state 385
INFO:root:
INFO:root:    (177) attribute_id -> DIGITS .
INFO:root:
INFO:root:    TICK            reduce using rule 177 (attribute_id -> DIGITS .)
INFO:root:    (               reduce using rule 177 (attribute_id -> DIGITS .)
INFO:root:    .               reduce using rule 177 (attribute_id -> DIGITS .)
INFO:root:    *               reduce using rule 177 (attribute_id -> DIGITS .)
INFO:root:    /               reduce using rule 177 (attribute_id -> DIGITS .)
INFO:root:    MOD             reduce using rule 177 (attribute_id -> DIGITS .)
INFO:root:    REM             reduce using rule 177 (attribute_id -> DIGITS .)
INFO:root:    STARSTAR        reduce using rule 177 (attribute_id -> DIGITS .)
INFO:root:    =               reduce using rule 177 (attribute_id -> DIGITS .)
INFO:root:    NEQ             reduce using rule 177 (attribute_id -> DIGITS .)
INFO:root:    <               reduce using rule 177 (attribute_id -> DIGITS .)
INFO:root:    LEQ             reduce using rule 177 (attribute_id -> DIGITS .)
INFO:root:    >               reduce using rule 177 (attribute_id -> DIGITS .)
INFO:root:    GEQ             reduce using rule 177 (attribute_id -> DIGITS .)
INFO:root:    IN              reduce using rule 177 (attribute_id -> DIGITS .)
INFO:root:    NOT             reduce using rule 177 (attribute_id -> DIGITS .)
INFO:root:    +               reduce using rule 177 (attribute_id -> DIGITS .)
INFO:root:    -               reduce using rule 177 (attribute_id -> DIGITS .)
INFO:root:    &               reduce using rule 177 (attribute_id -> DIGITS .)
INFO:root:    AND             reduce using rule 177 (attribute_id -> DIGITS .)
INFO:root:    OR              reduce using rule 177 (attribute_id -> DIGITS .)
INFO:root:    XOR             reduce using rule 177 (attribute_id -> DIGITS .)
INFO:root:    )               reduce using rule 177 (attribute_id -> DIGITS .)
INFO:root:    ,               reduce using rule 177 (attribute_id -> DIGITS .)
INFO:root:    DOTDOT          reduce using rule 177 (attribute_id -> DIGITS .)
INFO:root:    WITH            reduce using rule 177 (attribute_id -> DIGITS .)
INFO:root:    ARROW           reduce using rule 177 (attribute_id -> DIGITS .)
INFO:root:    |               reduce using rule 177 (attribute_id -> DIGITS .)
INFO:root:    ;               reduce using rule 177 (attribute_id -> DIGITS .)
INFO:root:    IS              reduce using rule 177 (attribute_id -> DIGITS .)
INFO:root:    THEN            reduce using rule 177 (attribute_id -> DIGITS .)
INFO:root:    LOOP            reduce using rule 177 (attribute_id -> DIGITS .)
INFO:root:    RANGE           reduce using rule 177 (attribute_id -> DIGITS .)
INFO:root:    DIGITS          reduce using rule 177 (attribute_id -> DIGITS .)
INFO:root:    RENAMES         reduce using rule 177 (attribute_id -> DIGITS .)
INFO:root:    ASSIGN          reduce using rule 177 (attribute_id -> DIGITS .)
INFO:root:    USE             reduce using rule 177 (attribute_id -> DIGITS .)
INFO:root:    AT              reduce using rule 177 (attribute_id -> DIGITS .)
INFO:root:    WHEN            reduce using rule 177 (attribute_id -> DIGITS .)
INFO:root:
INFO:root:
INFO:root:state 386
INFO:root:
INFO:root:    (174) selected_comp -> name . ALL .
INFO:root:
INFO:root:    TICK            reduce using rule 174 (selected_comp -> name . ALL .)
INFO:root:    (               reduce using rule 174 (selected_comp -> name . ALL .)
INFO:root:    .               reduce using rule 174 (selected_comp -> name . ALL .)
INFO:root:    *               reduce using rule 174 (selected_comp -> name . ALL .)
INFO:root:    /               reduce using rule 174 (selected_comp -> name . ALL .)
INFO:root:    MOD             reduce using rule 174 (selected_comp -> name . ALL .)
INFO:root:    REM             reduce using rule 174 (selected_comp -> name . ALL .)
INFO:root:    STARSTAR        reduce using rule 174 (selected_comp -> name . ALL .)
INFO:root:    =               reduce using rule 174 (selected_comp -> name . ALL .)
INFO:root:    NEQ             reduce using rule 174 (selected_comp -> name . ALL .)
INFO:root:    <               reduce using rule 174 (selected_comp -> name . ALL .)
INFO:root:    LEQ             reduce using rule 174 (selected_comp -> name . ALL .)
INFO:root:    >               reduce using rule 174 (selected_comp -> name . ALL .)
INFO:root:    GEQ             reduce using rule 174 (selected_comp -> name . ALL .)
INFO:root:    IN              reduce using rule 174 (selected_comp -> name . ALL .)
INFO:root:    NOT             reduce using rule 174 (selected_comp -> name . ALL .)
INFO:root:    +               reduce using rule 174 (selected_comp -> name . ALL .)
INFO:root:    -               reduce using rule 174 (selected_comp -> name . ALL .)
INFO:root:    &               reduce using rule 174 (selected_comp -> name . ALL .)
INFO:root:    ;               reduce using rule 174 (selected_comp -> name . ALL .)
INFO:root:    AND             reduce using rule 174 (selected_comp -> name . ALL .)
INFO:root:    OR              reduce using rule 174 (selected_comp -> name . ALL .)
INFO:root:    XOR             reduce using rule 174 (selected_comp -> name . ALL .)
INFO:root:    ASSIGN          reduce using rule 174 (selected_comp -> name . ALL .)
INFO:root:    THEN            reduce using rule 174 (selected_comp -> name . ALL .)
INFO:root:    DOTDOT          reduce using rule 174 (selected_comp -> name . ALL .)
INFO:root:    RANGE           reduce using rule 174 (selected_comp -> name . ALL .)
INFO:root:    ARROW           reduce using rule 174 (selected_comp -> name . ALL .)
INFO:root:    |               reduce using rule 174 (selected_comp -> name . ALL .)
INFO:root:    )               reduce using rule 174 (selected_comp -> name . ALL .)
INFO:root:    ,               reduce using rule 174 (selected_comp -> name . ALL .)
INFO:root:    WITH            reduce using rule 174 (selected_comp -> name . ALL .)
INFO:root:    IS              reduce using rule 174 (selected_comp -> name . ALL .)
INFO:root:    LOOP            reduce using rule 174 (selected_comp -> name . ALL .)
INFO:root:    DIGITS          reduce using rule 174 (selected_comp -> name . ALL .)
INFO:root:    RENAMES         reduce using rule 174 (selected_comp -> name . ALL .)
INFO:root:    WHEN            reduce using rule 174 (selected_comp -> name . ALL .)
INFO:root:
INFO:root:
INFO:root:state 387
INFO:root:
INFO:root:    (171) selected_comp -> name . simple_name .
INFO:root:
INFO:root:    TICK            reduce using rule 171 (selected_comp -> name . simple_name .)
INFO:root:    (               reduce using rule 171 (selected_comp -> name . simple_name .)
INFO:root:    .               reduce using rule 171 (selected_comp -> name . simple_name .)
INFO:root:    *               reduce using rule 171 (selected_comp -> name . simple_name .)
INFO:root:    /               reduce using rule 171 (selected_comp -> name . simple_name .)
INFO:root:    MOD             reduce using rule 171 (selected_comp -> name . simple_name .)
INFO:root:    REM             reduce using rule 171 (selected_comp -> name . simple_name .)
INFO:root:    STARSTAR        reduce using rule 171 (selected_comp -> name . simple_name .)
INFO:root:    =               reduce using rule 171 (selected_comp -> name . simple_name .)
INFO:root:    NEQ             reduce using rule 171 (selected_comp -> name . simple_name .)
INFO:root:    <               reduce using rule 171 (selected_comp -> name . simple_name .)
INFO:root:    LEQ             reduce using rule 171 (selected_comp -> name . simple_name .)
INFO:root:    >               reduce using rule 171 (selected_comp -> name . simple_name .)
INFO:root:    GEQ             reduce using rule 171 (selected_comp -> name . simple_name .)
INFO:root:    IN              reduce using rule 171 (selected_comp -> name . simple_name .)
INFO:root:    NOT             reduce using rule 171 (selected_comp -> name . simple_name .)
INFO:root:    +               reduce using rule 171 (selected_comp -> name . simple_name .)
INFO:root:    -               reduce using rule 171 (selected_comp -> name . simple_name .)
INFO:root:    &               reduce using rule 171 (selected_comp -> name . simple_name .)
INFO:root:    ;               reduce using rule 171 (selected_comp -> name . simple_name .)
INFO:root:    AND             reduce using rule 171 (selected_comp -> name . simple_name .)
INFO:root:    OR              reduce using rule 171 (selected_comp -> name . simple_name .)
INFO:root:    XOR             reduce using rule 171 (selected_comp -> name . simple_name .)
INFO:root:    ASSIGN          reduce using rule 171 (selected_comp -> name . simple_name .)
INFO:root:    THEN            reduce using rule 171 (selected_comp -> name . simple_name .)
INFO:root:    DOTDOT          reduce using rule 171 (selected_comp -> name . simple_name .)
INFO:root:    RANGE           reduce using rule 171 (selected_comp -> name . simple_name .)
INFO:root:    ARROW           reduce using rule 171 (selected_comp -> name . simple_name .)
INFO:root:    |               reduce using rule 171 (selected_comp -> name . simple_name .)
INFO:root:    )               reduce using rule 171 (selected_comp -> name . simple_name .)
INFO:root:    ,               reduce using rule 171 (selected_comp -> name . simple_name .)
INFO:root:    WITH            reduce using rule 171 (selected_comp -> name . simple_name .)
INFO:root:    IS              reduce using rule 171 (selected_comp -> name . simple_name .)
INFO:root:    LOOP            reduce using rule 171 (selected_comp -> name . simple_name .)
INFO:root:    DIGITS          reduce using rule 171 (selected_comp -> name . simple_name .)
INFO:root:    RENAMES         reduce using rule 171 (selected_comp -> name . simple_name .)
INFO:root:    WHEN            reduce using rule 171 (selected_comp -> name . simple_name .)
INFO:root:
INFO:root:
INFO:root:state 388
INFO:root:
INFO:root:    (162) used_char -> CHAR .
INFO:root:
INFO:root:    TICK            reduce using rule 162 (used_char -> CHAR .)
INFO:root:    (               reduce using rule 162 (used_char -> CHAR .)
INFO:root:    .               reduce using rule 162 (used_char -> CHAR .)
INFO:root:    *               reduce using rule 162 (used_char -> CHAR .)
INFO:root:    /               reduce using rule 162 (used_char -> CHAR .)
INFO:root:    MOD             reduce using rule 162 (used_char -> CHAR .)
INFO:root:    REM             reduce using rule 162 (used_char -> CHAR .)
INFO:root:    STARSTAR        reduce using rule 162 (used_char -> CHAR .)
INFO:root:    =               reduce using rule 162 (used_char -> CHAR .)
INFO:root:    NEQ             reduce using rule 162 (used_char -> CHAR .)
INFO:root:    <               reduce using rule 162 (used_char -> CHAR .)
INFO:root:    LEQ             reduce using rule 162 (used_char -> CHAR .)
INFO:root:    >               reduce using rule 162 (used_char -> CHAR .)
INFO:root:    GEQ             reduce using rule 162 (used_char -> CHAR .)
INFO:root:    IN              reduce using rule 162 (used_char -> CHAR .)
INFO:root:    NOT             reduce using rule 162 (used_char -> CHAR .)
INFO:root:    +               reduce using rule 162 (used_char -> CHAR .)
INFO:root:    -               reduce using rule 162 (used_char -> CHAR .)
INFO:root:    &               reduce using rule 162 (used_char -> CHAR .)
INFO:root:    AND             reduce using rule 162 (used_char -> CHAR .)
INFO:root:    OR              reduce using rule 162 (used_char -> CHAR .)
INFO:root:    XOR             reduce using rule 162 (used_char -> CHAR .)
INFO:root:    )               reduce using rule 162 (used_char -> CHAR .)
INFO:root:    ,               reduce using rule 162 (used_char -> CHAR .)
INFO:root:    ;               reduce using rule 162 (used_char -> CHAR .)
INFO:root:    RANGE           reduce using rule 162 (used_char -> CHAR .)
INFO:root:    DOTDOT          reduce using rule 162 (used_char -> CHAR .)
INFO:root:    WITH            reduce using rule 162 (used_char -> CHAR .)
INFO:root:    ARROW           reduce using rule 162 (used_char -> CHAR .)
INFO:root:    |               reduce using rule 162 (used_char -> CHAR .)
INFO:root:    IS              reduce using rule 162 (used_char -> CHAR .)
INFO:root:    THEN            reduce using rule 162 (used_char -> CHAR .)
INFO:root:    LOOP            reduce using rule 162 (used_char -> CHAR .)
INFO:root:    DIGITS          reduce using rule 162 (used_char -> CHAR .)
INFO:root:    RENAMES         reduce using rule 162 (used_char -> CHAR .)
INFO:root:    ASSIGN          reduce using rule 162 (used_char -> CHAR .)
INFO:root:    WHEN            reduce using rule 162 (used_char -> CHAR .)
INFO:root:
INFO:root:
INFO:root:state 389
INFO:root:
INFO:root:    (173) selected_comp -> name . operator_symbol .
INFO:root:
INFO:root:    TICK            reduce using rule 173 (selected_comp -> name . operator_symbol .)
INFO:root:    (               reduce using rule 173 (selected_comp -> name . operator_symbol .)
INFO:root:    .               reduce using rule 173 (selected_comp -> name . operator_symbol .)
INFO:root:    *               reduce using rule 173 (selected_comp -> name . operator_symbol .)
INFO:root:    /               reduce using rule 173 (selected_comp -> name . operator_symbol .)
INFO:root:    MOD             reduce using rule 173 (selected_comp -> name . operator_symbol .)
INFO:root:    REM             reduce using rule 173 (selected_comp -> name . operator_symbol .)
INFO:root:    STARSTAR        reduce using rule 173 (selected_comp -> name . operator_symbol .)
INFO:root:    =               reduce using rule 173 (selected_comp -> name . operator_symbol .)
INFO:root:    NEQ             reduce using rule 173 (selected_comp -> name . operator_symbol .)
INFO:root:    <               reduce using rule 173 (selected_comp -> name . operator_symbol .)
INFO:root:    LEQ             reduce using rule 173 (selected_comp -> name . operator_symbol .)
INFO:root:    >               reduce using rule 173 (selected_comp -> name . operator_symbol .)
INFO:root:    GEQ             reduce using rule 173 (selected_comp -> name . operator_symbol .)
INFO:root:    IN              reduce using rule 173 (selected_comp -> name . operator_symbol .)
INFO:root:    NOT             reduce using rule 173 (selected_comp -> name . operator_symbol .)
INFO:root:    +               reduce using rule 173 (selected_comp -> name . operator_symbol .)
INFO:root:    -               reduce using rule 173 (selected_comp -> name . operator_symbol .)
INFO:root:    &               reduce using rule 173 (selected_comp -> name . operator_symbol .)
INFO:root:    ;               reduce using rule 173 (selected_comp -> name . operator_symbol .)
INFO:root:    AND             reduce using rule 173 (selected_comp -> name . operator_symbol .)
INFO:root:    OR              reduce using rule 173 (selected_comp -> name . operator_symbol .)
INFO:root:    XOR             reduce using rule 173 (selected_comp -> name . operator_symbol .)
INFO:root:    ASSIGN          reduce using rule 173 (selected_comp -> name . operator_symbol .)
INFO:root:    THEN            reduce using rule 173 (selected_comp -> name . operator_symbol .)
INFO:root:    DOTDOT          reduce using rule 173 (selected_comp -> name . operator_symbol .)
INFO:root:    RANGE           reduce using rule 173 (selected_comp -> name . operator_symbol .)
INFO:root:    ARROW           reduce using rule 173 (selected_comp -> name . operator_symbol .)
INFO:root:    |               reduce using rule 173 (selected_comp -> name . operator_symbol .)
INFO:root:    )               reduce using rule 173 (selected_comp -> name . operator_symbol .)
INFO:root:    ,               reduce using rule 173 (selected_comp -> name . operator_symbol .)
INFO:root:    WITH            reduce using rule 173 (selected_comp -> name . operator_symbol .)
INFO:root:    IS              reduce using rule 173 (selected_comp -> name . operator_symbol .)
INFO:root:    LOOP            reduce using rule 173 (selected_comp -> name . operator_symbol .)
INFO:root:    DIGITS          reduce using rule 173 (selected_comp -> name . operator_symbol .)
INFO:root:    RENAMES         reduce using rule 173 (selected_comp -> name . operator_symbol .)
INFO:root:    WHEN            reduce using rule 173 (selected_comp -> name . operator_symbol .)
INFO:root:
INFO:root:
INFO:root:state 390
INFO:root:
INFO:root:    (172) selected_comp -> name . used_char .
INFO:root:
INFO:root:    TICK            reduce using rule 172 (selected_comp -> name . used_char .)
INFO:root:    (               reduce using rule 172 (selected_comp -> name . used_char .)
INFO:root:    .               reduce using rule 172 (selected_comp -> name . used_char .)
INFO:root:    *               reduce using rule 172 (selected_comp -> name . used_char .)
INFO:root:    /               reduce using rule 172 (selected_comp -> name . used_char .)
INFO:root:    MOD             reduce using rule 172 (selected_comp -> name . used_char .)
INFO:root:    REM             reduce using rule 172 (selected_comp -> name . used_char .)
INFO:root:    STARSTAR        reduce using rule 172 (selected_comp -> name . used_char .)
INFO:root:    =               reduce using rule 172 (selected_comp -> name . used_char .)
INFO:root:    NEQ             reduce using rule 172 (selected_comp -> name . used_char .)
INFO:root:    <               reduce using rule 172 (selected_comp -> name . used_char .)
INFO:root:    LEQ             reduce using rule 172 (selected_comp -> name . used_char .)
INFO:root:    >               reduce using rule 172 (selected_comp -> name . used_char .)
INFO:root:    GEQ             reduce using rule 172 (selected_comp -> name . used_char .)
INFO:root:    IN              reduce using rule 172 (selected_comp -> name . used_char .)
INFO:root:    NOT             reduce using rule 172 (selected_comp -> name . used_char .)
INFO:root:    +               reduce using rule 172 (selected_comp -> name . used_char .)
INFO:root:    -               reduce using rule 172 (selected_comp -> name . used_char .)
INFO:root:    &               reduce using rule 172 (selected_comp -> name . used_char .)
INFO:root:    ;               reduce using rule 172 (selected_comp -> name . used_char .)
INFO:root:    AND             reduce using rule 172 (selected_comp -> name . used_char .)
INFO:root:    OR              reduce using rule 172 (selected_comp -> name . used_char .)
INFO:root:    XOR             reduce using rule 172 (selected_comp -> name . used_char .)
INFO:root:    ASSIGN          reduce using rule 172 (selected_comp -> name . used_char .)
INFO:root:    THEN            reduce using rule 172 (selected_comp -> name . used_char .)
INFO:root:    DOTDOT          reduce using rule 172 (selected_comp -> name . used_char .)
INFO:root:    RANGE           reduce using rule 172 (selected_comp -> name . used_char .)
INFO:root:    ARROW           reduce using rule 172 (selected_comp -> name . used_char .)
INFO:root:    |               reduce using rule 172 (selected_comp -> name . used_char .)
INFO:root:    )               reduce using rule 172 (selected_comp -> name . used_char .)
INFO:root:    ,               reduce using rule 172 (selected_comp -> name . used_char .)
INFO:root:    WITH            reduce using rule 172 (selected_comp -> name . used_char .)
INFO:root:    IS              reduce using rule 172 (selected_comp -> name . used_char .)
INFO:root:    LOOP            reduce using rule 172 (selected_comp -> name . used_char .)
INFO:root:    DIGITS          reduce using rule 172 (selected_comp -> name . used_char .)
INFO:root:    RENAMES         reduce using rule 172 (selected_comp -> name . used_char .)
INFO:root:    WHEN            reduce using rule 172 (selected_comp -> name . used_char .)
INFO:root:
INFO:root:
INFO:root:state 391
INFO:root:
INFO:root:    (217) term -> term multiplying factor .
INFO:root:
INFO:root:    *               reduce using rule 217 (term -> term multiplying factor .)
INFO:root:    /               reduce using rule 217 (term -> term multiplying factor .)
INFO:root:    MOD             reduce using rule 217 (term -> term multiplying factor .)
INFO:root:    REM             reduce using rule 217 (term -> term multiplying factor .)
INFO:root:    STARSTAR        reduce using rule 217 (term -> term multiplying factor .)
INFO:root:    DOTDOT          reduce using rule 217 (term -> term multiplying factor .)
INFO:root:    +               reduce using rule 217 (term -> term multiplying factor .)
INFO:root:    -               reduce using rule 217 (term -> term multiplying factor .)
INFO:root:    &               reduce using rule 217 (term -> term multiplying factor .)
INFO:root:    =               reduce using rule 217 (term -> term multiplying factor .)
INFO:root:    NEQ             reduce using rule 217 (term -> term multiplying factor .)
INFO:root:    <               reduce using rule 217 (term -> term multiplying factor .)
INFO:root:    LEQ             reduce using rule 217 (term -> term multiplying factor .)
INFO:root:    >               reduce using rule 217 (term -> term multiplying factor .)
INFO:root:    GEQ             reduce using rule 217 (term -> term multiplying factor .)
INFO:root:    IN              reduce using rule 217 (term -> term multiplying factor .)
INFO:root:    NOT             reduce using rule 217 (term -> term multiplying factor .)
INFO:root:    AND             reduce using rule 217 (term -> term multiplying factor .)
INFO:root:    OR              reduce using rule 217 (term -> term multiplying factor .)
INFO:root:    XOR             reduce using rule 217 (term -> term multiplying factor .)
INFO:root:    )               reduce using rule 217 (term -> term multiplying factor .)
INFO:root:    ,               reduce using rule 217 (term -> term multiplying factor .)
INFO:root:    WITH            reduce using rule 217 (term -> term multiplying factor .)
INFO:root:    ARROW           reduce using rule 217 (term -> term multiplying factor .)
INFO:root:    |               reduce using rule 217 (term -> term multiplying factor .)
INFO:root:    ;               reduce using rule 217 (term -> term multiplying factor .)
INFO:root:    IS              reduce using rule 217 (term -> term multiplying factor .)
INFO:root:    THEN            reduce using rule 217 (term -> term multiplying factor .)
INFO:root:    LOOP            reduce using rule 217 (term -> term multiplying factor .)
INFO:root:    RANGE           reduce using rule 217 (term -> term multiplying factor .)
INFO:root:    DIGITS          reduce using rule 217 (term -> term multiplying factor .)
INFO:root:    RENAMES         reduce using rule 217 (term -> term multiplying factor .)
INFO:root:    ASSIGN          reduce using rule 217 (term -> term multiplying factor .)
INFO:root:
INFO:root:
INFO:root:state 392
INFO:root:
INFO:root:    (313) param_s -> param_s ; . param
INFO:root:    (314) param -> . def_id_s : mode mark init_opt
INFO:root:    (315) param -> . error
INFO:root:    (24) def_id_s -> . def_id
INFO:root:    (25) def_id_s -> . def_id_s , def_id
INFO:root:    (26) def_id -> . IDENTIFIER
INFO:root:
INFO:root:    error           shift and go to state 55
INFO:root:    IDENTIFIER      shift and go to state 52
INFO:root:
INFO:root:    def_id_s                       shift and go to state 56
INFO:root:    def_id                         shift and go to state 57
INFO:root:    param                          shift and go to state 516
INFO:root:
INFO:root:state 393
INFO:root:
INFO:root:    (311) formal_part -> ( param_s ) .
INFO:root:
INFO:root:    ;               reduce using rule 311 (formal_part -> ( param_s ) .)
INFO:root:    IS              reduce using rule 311 (formal_part -> ( param_s ) .)
INFO:root:    RENAMES         reduce using rule 311 (formal_part -> ( param_s ) .)
INFO:root:    WHEN            reduce using rule 311 (formal_part -> ( param_s ) .)
INFO:root:    RETURN          reduce using rule 311 (formal_part -> ( param_s ) .)
INFO:root:    DO              reduce using rule 311 (formal_part -> ( param_s ) .)
INFO:root:
INFO:root:
INFO:root:state 394
INFO:root:
INFO:root:    (465) generic_formal -> WITH FUNCTION designator formal_part_opt . RETURN name subp_default ;
INFO:root:
INFO:root:    RETURN          shift and go to state 517
INFO:root:
INFO:root:
INFO:root:state 395
INFO:root:
INFO:root:    (464) generic_formal -> WITH PROCEDURE simple_name formal_part_opt . subp_default ;
INFO:root:    (472) subp_default -> .
INFO:root:    (473) subp_default -> . IS name
INFO:root:    (474) subp_default -> . IS BOX
INFO:root:
INFO:root:    ;               reduce using rule 472 (subp_default -> .)
INFO:root:    IS              shift and go to state 519
INFO:root:
INFO:root:    subp_default                   shift and go to state 518
INFO:root:
INFO:root:state 396
INFO:root:
INFO:root:    (466) generic_formal -> WITH PACKAGE simple_name IS . NEW name ( BOX ) ;
INFO:root:    (467) generic_formal -> WITH PACKAGE simple_name IS . NEW name ;
INFO:root:
INFO:root:    NEW             shift and go to state 520
INFO:root:
INFO:root:
INFO:root:state 397
INFO:root:
INFO:root:    (346) rename_unit -> generic_formal_part PACKAGE compound_name renames ; .
INFO:root:
INFO:root:    error           reduce using rule 346 (rename_unit -> generic_formal_part PACKAGE compound_name renames ; .)
INFO:root:    USE             reduce using rule 346 (rename_unit -> generic_formal_part PACKAGE compound_name renames ; .)
INFO:root:    PRAGMA          reduce using rule 346 (rename_unit -> generic_formal_part PACKAGE compound_name renames ; .)
INFO:root:    TYPE            reduce using rule 346 (rename_unit -> generic_formal_part PACKAGE compound_name renames ; .)
INFO:root:    SUBTYPE         reduce using rule 346 (rename_unit -> generic_formal_part PACKAGE compound_name renames ; .)
INFO:root:    TASK            reduce using rule 346 (rename_unit -> generic_formal_part PACKAGE compound_name renames ; .)
INFO:root:    PACKAGE         reduce using rule 346 (rename_unit -> generic_formal_part PACKAGE compound_name renames ; .)
INFO:root:    PROTECTED       reduce using rule 346 (rename_unit -> generic_formal_part PACKAGE compound_name renames ; .)
INFO:root:    FOR             reduce using rule 346 (rename_unit -> generic_formal_part PACKAGE compound_name renames ; .)
INFO:root:    PROCEDURE       reduce using rule 346 (rename_unit -> generic_formal_part PACKAGE compound_name renames ; .)
INFO:root:    FUNCTION        reduce using rule 346 (rename_unit -> generic_formal_part PACKAGE compound_name renames ; .)
INFO:root:    GENERIC         reduce using rule 346 (rename_unit -> generic_formal_part PACKAGE compound_name renames ; .)
INFO:root:    IDENTIFIER      reduce using rule 346 (rename_unit -> generic_formal_part PACKAGE compound_name renames ; .)
INFO:root:    END             reduce using rule 346 (rename_unit -> generic_formal_part PACKAGE compound_name renames ; .)
INFO:root:    BEGIN           reduce using rule 346 (rename_unit -> generic_formal_part PACKAGE compound_name renames ; .)
INFO:root:    PRIVATE         reduce using rule 346 (rename_unit -> generic_formal_part PACKAGE compound_name renames ; .)
INFO:root:    WITH            reduce using rule 346 (rename_unit -> generic_formal_part PACKAGE compound_name renames ; .)
INFO:root:    SEPARATE        reduce using rule 346 (rename_unit -> generic_formal_part PACKAGE compound_name renames ; .)
INFO:root:    $end            reduce using rule 346 (rename_unit -> generic_formal_part PACKAGE compound_name renames ; .)
INFO:root:
INFO:root:
INFO:root:state 398
INFO:root:
INFO:root:    (471) generic_discrim_part_opt -> ( BOX . )
INFO:root:
INFO:root:    )               shift and go to state 521
INFO:root:
INFO:root:
INFO:root:state 399
INFO:root:
INFO:root:    (114) discrim_spec -> error .
INFO:root:
INFO:root:    )               reduce using rule 114 (discrim_spec -> error .)
INFO:root:    ;               reduce using rule 114 (discrim_spec -> error .)
INFO:root:
INFO:root:
INFO:root:state 400
INFO:root:
INFO:root:    (113) discrim_spec -> def_id_s . : access_opt mark init_opt
INFO:root:    (25) def_id_s -> def_id_s . , def_id
INFO:root:
INFO:root:    :               shift and go to state 522
INFO:root:    ,               shift and go to state 165
INFO:root:
INFO:root:
INFO:root:state 401
INFO:root:
INFO:root:    (111) discrim_spec_s -> discrim_spec .
INFO:root:
INFO:root:    )               reduce using rule 111 (discrim_spec_s -> discrim_spec .)
INFO:root:    ;               reduce using rule 111 (discrim_spec_s -> discrim_spec .)
INFO:root:
INFO:root:
INFO:root:state 402
INFO:root:
INFO:root:    (110) discrim_part -> ( discrim_spec_s . )
INFO:root:    (112) discrim_spec_s -> discrim_spec_s . ; discrim_spec
INFO:root:
INFO:root:    )               shift and go to state 523
INFO:root:    ;               shift and go to state 524
INFO:root:
INFO:root:
INFO:root:state 403
INFO:root:
INFO:root:    (463) generic_formal -> TYPE simple_name generic_discrim_part_opt IS . generic_type_def ;
INFO:root:    (475) generic_type_def -> . ( BOX )
INFO:root:    (476) generic_type_def -> . RANGE BOX
INFO:root:    (477) generic_type_def -> . MOD BOX
INFO:root:    (478) generic_type_def -> . DELTA BOX
INFO:root:    (479) generic_type_def -> . DELTA BOX DIGITS BOX
INFO:root:    (480) generic_type_def -> . DIGITS BOX
INFO:root:    (481) generic_type_def -> . array_type
INFO:root:    (482) generic_type_def -> . access_type
INFO:root:    (483) generic_type_def -> . private_type
INFO:root:    (484) generic_type_def -> . generic_derived_type
INFO:root:    (78) array_type -> . unconstr_array_type
INFO:root:    (79) array_type -> . constr_array_type
INFO:root:    (128) access_type -> . ACCESS subtype_ind
INFO:root:    (129) access_type -> . ACCESS CONSTANT subtype_ind
INFO:root:    (130) access_type -> . ACCESS ALL subtype_ind
INFO:root:    (334) private_type -> . tagged_opt limited_opt PRIVATE
INFO:root:    (485) generic_derived_type -> . NEW subtype_ind
INFO:root:    (486) generic_derived_type -> . NEW subtype_ind WITH PRIVATE
INFO:root:    (487) generic_derived_type -> . ABSTRACT NEW subtype_ind WITH PRIVATE
INFO:root:    (80) unconstr_array_type -> . ARRAY ( index_s ) OF component_subtype_def
INFO:root:    (81) constr_array_type -> . ARRAY iter_index_constraint OF component_subtype_def
INFO:root:    (98) tagged_opt -> .
INFO:root:    (99) tagged_opt -> . TAGGED
INFO:root:    (100) tagged_opt -> . ABSTRACT TAGGED
INFO:root:
INFO:root:    (               shift and go to state 528
INFO:root:    RANGE           shift and go to state 535
INFO:root:    MOD             shift and go to state 532
INFO:root:    DELTA           shift and go to state 537
INFO:root:    DIGITS          shift and go to state 533
INFO:root:    ACCESS          shift and go to state 534
INFO:root:    NEW             shift and go to state 539
INFO:root:    ABSTRACT        shift and go to state 530
INFO:root:    ARRAY           shift and go to state 431
INFO:root:    LIMITED         reduce using rule 98 (tagged_opt -> .)
INFO:root:    PRIVATE         reduce using rule 98 (tagged_opt -> .)
INFO:root:    TAGGED          shift and go to state 529
INFO:root:
INFO:root:    array_type                     shift and go to state 526
INFO:root:    generic_derived_type           shift and go to state 536
INFO:root:    private_type                   shift and go to state 525
INFO:root:    tagged_opt                     shift and go to state 538
INFO:root:    unconstr_array_type            shift and go to state 434
INFO:root:    generic_type_def               shift and go to state 527
INFO:root:    constr_array_type              shift and go to state 436
INFO:root:    access_type                    shift and go to state 531
INFO:root:
INFO:root:state 404
INFO:root:
INFO:root:    (340) name_s -> name_s , name .
INFO:root:    (164) indexed_comp -> name . ( value_s )
INFO:root:    (171) selected_comp -> name . . simple_name
INFO:root:    (172) selected_comp -> name . . used_char
INFO:root:    (173) selected_comp -> name . . operator_symbol
INFO:root:    (174) selected_comp -> name . . ALL
INFO:root:    (175) attribute -> name . TICK attribute_id
INFO:root:
INFO:root:    ;               reduce using rule 340 (name_s -> name_s , name .)
INFO:root:    ,               reduce using rule 340 (name_s -> name_s , name .)
INFO:root:    (               shift and go to state 237
INFO:root:    .               shift and go to state 239
INFO:root:    TICK            shift and go to state 260
INFO:root:
INFO:root:
INFO:root:state 405
INFO:root:
INFO:root:    (338) use_clause -> USE TYPE name_s ; .
INFO:root:
INFO:root:    PACKAGE         reduce using rule 338 (use_clause -> USE TYPE name_s ; .)
INFO:root:    TASK            reduce using rule 338 (use_clause -> USE TYPE name_s ; .)
INFO:root:    PROTECTED       reduce using rule 338 (use_clause -> USE TYPE name_s ; .)
INFO:root:    error           reduce using rule 338 (use_clause -> USE TYPE name_s ; .)
INFO:root:    USE             reduce using rule 338 (use_clause -> USE TYPE name_s ; .)
INFO:root:    PRAGMA          reduce using rule 338 (use_clause -> USE TYPE name_s ; .)
INFO:root:    TYPE            reduce using rule 338 (use_clause -> USE TYPE name_s ; .)
INFO:root:    SUBTYPE         reduce using rule 338 (use_clause -> USE TYPE name_s ; .)
INFO:root:    FOR             reduce using rule 338 (use_clause -> USE TYPE name_s ; .)
INFO:root:    PROCEDURE       reduce using rule 338 (use_clause -> USE TYPE name_s ; .)
INFO:root:    FUNCTION        reduce using rule 338 (use_clause -> USE TYPE name_s ; .)
INFO:root:    GENERIC         reduce using rule 338 (use_clause -> USE TYPE name_s ; .)
INFO:root:    IDENTIFIER      reduce using rule 338 (use_clause -> USE TYPE name_s ; .)
INFO:root:    BEGIN           reduce using rule 338 (use_clause -> USE TYPE name_s ; .)
INFO:root:    END             reduce using rule 338 (use_clause -> USE TYPE name_s ; .)
INFO:root:    PRIVATE         reduce using rule 338 (use_clause -> USE TYPE name_s ; .)
INFO:root:    WITH            reduce using rule 338 (use_clause -> USE TYPE name_s ; .)
INFO:root:    SEPARATE        reduce using rule 338 (use_clause -> USE TYPE name_s ; .)
INFO:root:
INFO:root:
INFO:root:state 406
INFO:root:
INFO:root:    (314) param -> def_id_s : mode mark . init_opt
INFO:root:    (155) mark -> mark . TICK attribute_id
INFO:root:    (156) mark -> mark . . simple_name
INFO:root:    (33) init_opt -> .
INFO:root:    (34) init_opt -> . ASSIGN expression
INFO:root:
INFO:root:    TICK            shift and go to state 300
INFO:root:    .               shift and go to state 298
INFO:root:    ;               reduce using rule 33 (init_opt -> .)
INFO:root:    )               reduce using rule 33 (init_opt -> .)
INFO:root:    ASSIGN          shift and go to state 540
INFO:root:
INFO:root:    init_opt                       shift and go to state 541
INFO:root:
INFO:root:state 407
INFO:root:
INFO:root:    (319) mode -> IN OUT .
INFO:root:
INFO:root:    IDENTIFIER      reduce using rule 319 (mode -> IN OUT .)
INFO:root:
INFO:root:
INFO:root:state 408
INFO:root:
INFO:root:    (331) pkg_body -> PACKAGE . BODY compound_name IS decl_part body_opt END c_id_opt ;
INFO:root:
INFO:root:    BODY            shift and go to state 71
INFO:root:
INFO:root:
INFO:root:state 409
INFO:root:
INFO:root:    (321) subprog_spec_is_push -> subprog_spec . IS
INFO:root:
INFO:root:    IS              shift and go to state 542
INFO:root:
INFO:root:
INFO:root:state 410
INFO:root:
INFO:root:    (440) subunit_body -> task_body .
INFO:root:
INFO:root:    PRAGMA          reduce using rule 440 (subunit_body -> task_body .)
INFO:root:    PRIVATE         reduce using rule 440 (subunit_body -> task_body .)
INFO:root:    WITH            reduce using rule 440 (subunit_body -> task_body .)
INFO:root:    PACKAGE         reduce using rule 440 (subunit_body -> task_body .)
INFO:root:    SEPARATE        reduce using rule 440 (subunit_body -> task_body .)
INFO:root:    PROCEDURE       reduce using rule 440 (subunit_body -> task_body .)
INFO:root:    FUNCTION        reduce using rule 440 (subunit_body -> task_body .)
INFO:root:    GENERIC         reduce using rule 440 (subunit_body -> task_body .)
INFO:root:    $end            reduce using rule 440 (subunit_body -> task_body .)
INFO:root:
INFO:root:
INFO:root:state 411
INFO:root:
INFO:root:    (356) task_body -> TASK . BODY simple_name IS decl_part block_body END id_opt ;
INFO:root:
INFO:root:    BODY            shift and go to state 543
INFO:root:
INFO:root:
INFO:root:state 412
INFO:root:
INFO:root:    (439) subunit_body -> pkg_body .
INFO:root:
INFO:root:    PRAGMA          reduce using rule 439 (subunit_body -> pkg_body .)
INFO:root:    PRIVATE         reduce using rule 439 (subunit_body -> pkg_body .)
INFO:root:    WITH            reduce using rule 439 (subunit_body -> pkg_body .)
INFO:root:    PACKAGE         reduce using rule 439 (subunit_body -> pkg_body .)
INFO:root:    SEPARATE        reduce using rule 439 (subunit_body -> pkg_body .)
INFO:root:    PROCEDURE       reduce using rule 439 (subunit_body -> pkg_body .)
INFO:root:    FUNCTION        reduce using rule 439 (subunit_body -> pkg_body .)
INFO:root:    GENERIC         reduce using rule 439 (subunit_body -> pkg_body .)
INFO:root:    $end            reduce using rule 439 (subunit_body -> pkg_body .)
INFO:root:
INFO:root:
INFO:root:state 413
INFO:root:
INFO:root:    (437) subunit -> SEPARATE ( compound_name ) subunit_body .
INFO:root:
INFO:root:    PRAGMA          reduce using rule 437 (subunit -> SEPARATE ( compound_name ) subunit_body .)
INFO:root:    PRIVATE         reduce using rule 437 (subunit -> SEPARATE ( compound_name ) subunit_body .)
INFO:root:    WITH            reduce using rule 437 (subunit -> SEPARATE ( compound_name ) subunit_body .)
INFO:root:    PACKAGE         reduce using rule 437 (subunit -> SEPARATE ( compound_name ) subunit_body .)
INFO:root:    SEPARATE        reduce using rule 437 (subunit -> SEPARATE ( compound_name ) subunit_body .)
INFO:root:    PROCEDURE       reduce using rule 437 (subunit -> SEPARATE ( compound_name ) subunit_body .)
INFO:root:    FUNCTION        reduce using rule 437 (subunit -> SEPARATE ( compound_name ) subunit_body .)
INFO:root:    GENERIC         reduce using rule 437 (subunit -> SEPARATE ( compound_name ) subunit_body .)
INFO:root:    $end            reduce using rule 437 (subunit -> SEPARATE ( compound_name ) subunit_body .)
INFO:root:
INFO:root:
INFO:root:state 414
INFO:root:
INFO:root:    (438) subunit_body -> subprog_body .
INFO:root:
INFO:root:    PRAGMA          reduce using rule 438 (subunit_body -> subprog_body .)
INFO:root:    PRIVATE         reduce using rule 438 (subunit_body -> subprog_body .)
INFO:root:    WITH            reduce using rule 438 (subunit_body -> subprog_body .)
INFO:root:    PACKAGE         reduce using rule 438 (subunit_body -> subprog_body .)
INFO:root:    SEPARATE        reduce using rule 438 (subunit_body -> subprog_body .)
INFO:root:    PROCEDURE       reduce using rule 438 (subunit_body -> subprog_body .)
INFO:root:    FUNCTION        reduce using rule 438 (subunit_body -> subprog_body .)
INFO:root:    GENERIC         reduce using rule 438 (subunit_body -> subprog_body .)
INFO:root:    $end            reduce using rule 438 (subunit_body -> subprog_body .)
INFO:root:
INFO:root:
INFO:root:state 415
INFO:root:
INFO:root:    (322) subprog_body -> subprog_spec_is_push . decl_part block_body END id_opt ;
INFO:root:    (131) decl_part -> .
INFO:root:    (132) decl_part -> . decl_item_or_body_s1
INFO:root:    (141) decl_item_or_body_s1 -> . decl_item_or_body
INFO:root:    (142) decl_item_or_body_s1 -> . decl_item_or_body_s1 decl_item_or_body
INFO:root:    (143) decl_item_or_body -> . body
INFO:root:    (144) decl_item_or_body -> . decl_item
INFO:root:    (145) body -> . subprog_body
INFO:root:    (146) body -> . pkg_body
INFO:root:    (147) body -> . task_body
INFO:root:    (148) body -> . prot_body
INFO:root:    (137) decl_item -> . decl
INFO:root:    (138) decl_item -> . use_clause
INFO:root:    (139) decl_item -> . rep_spec
INFO:root:    (140) decl_item -> . pragma
INFO:root:    (322) subprog_body -> . subprog_spec_is_push decl_part block_body END id_opt ;
INFO:root:    (331) pkg_body -> . PACKAGE BODY compound_name IS decl_part body_opt END c_id_opt ;
INFO:root:    (356) task_body -> . TASK BODY simple_name IS decl_part block_body END id_opt ;
INFO:root:    (373) prot_body -> . PROTECTED BODY simple_name IS prot_op_body_s END id_opt ;
INFO:root:    (10) decl -> . object_decl
INFO:root:    (11) decl -> . number_decl
INFO:root:    (12) decl -> . type_decl
INFO:root:    (13) decl -> . subtype_decl
INFO:root:    (14) decl -> . subprog_decl
INFO:root:    (15) decl -> . pkg_decl
INFO:root:    (16) decl -> . task_decl
INFO:root:    (17) decl -> . prot_decl
INFO:root:    (18) decl -> . exception_decl
INFO:root:    (19) decl -> . rename_decl
INFO:root:    (20) decl -> . generic_decl
INFO:root:    (21) decl -> . body_stub
INFO:root:    (22) decl -> . error ;
INFO:root:    (337) use_clause -> . USE name_s ;
INFO:root:    (338) use_clause -> . USE TYPE name_s ;
INFO:root:    (491) rep_spec -> . attrib_def
INFO:root:    (492) rep_spec -> . record_type_spec
INFO:root:    (493) rep_spec -> . address_spec
INFO:root:    (2) pragma -> . PRAGMA IDENTIFIER ;
INFO:root:    (3) pragma -> . PRAGMA simple_name ( pragma_arg_s ) ;
INFO:root:    (321) subprog_spec_is_push -> . subprog_spec IS
INFO:root:    (23) object_decl -> . def_id_s : object_qualifier_opt object_subtype_def init_opt ;
INFO:root:    (35) number_decl -> . def_id_s : CONSTANT ASSIGN expression ;
INFO:root:    (36) type_decl -> . TYPE IDENTIFIER discrim_part_opt type_completion ;
INFO:root:    (50) subtype_decl -> . SUBTYPE IDENTIFIER IS subtype_ind ;
INFO:root:    (301) subprog_decl -> . subprog_spec ;
INFO:root:    (302) subprog_decl -> . generic_subp_inst ;
INFO:root:    (303) subprog_decl -> . subprog_spec_is_push ABSTRACT ;
INFO:root:    (324) pkg_decl -> . pkg_spec ;
INFO:root:    (325) pkg_decl -> . generic_pkg_inst ;
INFO:root:    (349) task_decl -> . task_spec ;
INFO:root:    (357) prot_decl -> . prot_spec ;
INFO:root:    (446) exception_decl -> . def_id_s : EXCEPTION ;
INFO:root:    (341) rename_decl -> . def_id_s : object_qualifier_opt subtype_ind renames ;
INFO:root:    (342) rename_decl -> . def_id_s : EXCEPTION renames ;
INFO:root:    (343) rename_decl -> . rename_unit
INFO:root:    (458) generic_decl -> . generic_formal_part subprog_spec ;
INFO:root:    (459) generic_decl -> . generic_formal_part pkg_spec ;
INFO:root:    (442) body_stub -> . TASK BODY simple_name IS SEPARATE ;
INFO:root:    (443) body_stub -> . PACKAGE BODY compound_name IS SEPARATE ;
INFO:root:    (444) body_stub -> . subprog_spec IS SEPARATE ;
INFO:root:    (445) body_stub -> . PROTECTED BODY simple_name IS SEPARATE ;
INFO:root:    (494) attrib_def -> . FOR mark USE expression ;
INFO:root:    (495) record_type_spec -> . FOR mark USE RECORD align_opt comp_loc_s END RECORD ;
INFO:root:    (500) address_spec -> . FOR mark USE AT expression ;
INFO:root:    (304) subprog_spec -> . PROCEDURE compound_name formal_part_opt
INFO:root:    (305) subprog_spec -> . FUNCTION designator formal_part_opt RETURN name
INFO:root:    (306) subprog_spec -> . FUNCTION designator
INFO:root:    (24) def_id_s -> . def_id
INFO:root:    (25) def_id_s -> . def_id_s , def_id
INFO:root:    (488) generic_subp_inst -> . subprog_spec IS generic_inst
INFO:root:    (326) pkg_spec -> . PACKAGE compound_name IS decl_item_s private_part END c_id_opt
INFO:root:    (489) generic_pkg_inst -> . PACKAGE compound_name IS generic_inst
INFO:root:    (350) task_spec -> . TASK simple_name task_def
INFO:root:    (351) task_spec -> . TASK TYPE simple_name discrim_part_opt task_def
INFO:root:    (358) prot_spec -> . PROTECTED IDENTIFIER prot_def
INFO:root:    (359) prot_spec -> . PROTECTED TYPE simple_name discrim_part_opt prot_def
INFO:root:    (344) rename_unit -> . PACKAGE compound_name renames ;
INFO:root:    (345) rename_unit -> . subprog_spec renames ;
INFO:root:    (346) rename_unit -> . generic_formal_part PACKAGE compound_name renames ;
INFO:root:    (347) rename_unit -> . generic_formal_part subprog_spec renames ;
INFO:root:    (460) generic_formal_part -> . GENERIC
INFO:root:    (461) generic_formal_part -> . generic_formal_part generic_formal
INFO:root:    (26) def_id -> . IDENTIFIER
INFO:root:
INFO:root:    BEGIN           reduce using rule 131 (decl_part -> .)
INFO:root:    PACKAGE         shift and go to state 73
INFO:root:    TASK            shift and go to state 84
INFO:root:    PROTECTED       shift and go to state 99
INFO:root:    error           shift and go to state 107
INFO:root:    USE             shift and go to state 53
INFO:root:    PRAGMA          shift and go to state 2
INFO:root:    TYPE            shift and go to state 74
INFO:root:    SUBTYPE         shift and go to state 110
INFO:root:    FOR             shift and go to state 102
INFO:root:    PROCEDURE       shift and go to state 17
INFO:root:    FUNCTION        shift and go to state 23
INFO:root:    GENERIC         shift and go to state 26
INFO:root:    IDENTIFIER      shift and go to state 52
INFO:root:
INFO:root:    generic_formal_part            shift and go to state 20
INFO:root:    pkg_decl                       shift and go to state 93
INFO:root:    pragma                         shift and go to state 94
INFO:root:    generic_pkg_inst               shift and go to state 19
INFO:root:    prot_decl                      shift and go to state 95
INFO:root:    body                           shift and go to state 75
INFO:root:    task_decl                      shift and go to state 76
INFO:root:    generic_decl                   shift and go to state 88
INFO:root:    subprog_decl                   shift and go to state 77
INFO:root:    type_decl                      shift and go to state 81
INFO:root:    def_id_s                       shift and go to state 79
INFO:root:    def_id                         shift and go to state 57
INFO:root:    rep_spec                       shift and go to state 72
INFO:root:    use_clause                     shift and go to state 97
INFO:root:    rename_decl                    shift and go to state 98
INFO:root:    body_stub                      shift and go to state 80
INFO:root:    address_spec                   shift and go to state 83
INFO:root:    task_spec                      shift and go to state 82
INFO:root:    number_decl                    shift and go to state 101
INFO:root:    generic_subp_inst              shift and go to state 24
INFO:root:    decl_item_or_body_s1           shift and go to state 103
INFO:root:    prot_spec                      shift and go to state 85
INFO:root:    rename_unit                    shift and go to state 104
INFO:root:    subprog_spec                   shift and go to state 86
INFO:root:    object_decl                    shift and go to state 87
INFO:root:    subtype_decl                   shift and go to state 105
INFO:root:    task_body                      shift and go to state 96
INFO:root:    prot_body                      shift and go to state 100
INFO:root:    pkg_body                       shift and go to state 90
INFO:root:    decl_part                      shift and go to state 106
INFO:root:    pkg_spec                       shift and go to state 16
INFO:root:    record_type_spec               shift and go to state 108
INFO:root:    decl                           shift and go to state 109
INFO:root:    decl_item                      shift and go to state 78
INFO:root:    exception_decl                 shift and go to state 91
INFO:root:    subprog_body                   shift and go to state 113
INFO:root:    attrib_def                     shift and go to state 92
INFO:root:    subprog_spec_is_push           shift and go to state 111
INFO:root:    decl_item_or_body              shift and go to state 112
INFO:root:
INFO:root:state 416
INFO:root:
INFO:root:    (441) subunit_body -> prot_body .
INFO:root:
INFO:root:    PRAGMA          reduce using rule 441 (subunit_body -> prot_body .)
INFO:root:    PRIVATE         reduce using rule 441 (subunit_body -> prot_body .)
INFO:root:    WITH            reduce using rule 441 (subunit_body -> prot_body .)
INFO:root:    PACKAGE         reduce using rule 441 (subunit_body -> prot_body .)
INFO:root:    SEPARATE        reduce using rule 441 (subunit_body -> prot_body .)
INFO:root:    PROCEDURE       reduce using rule 441 (subunit_body -> prot_body .)
INFO:root:    FUNCTION        reduce using rule 441 (subunit_body -> prot_body .)
INFO:root:    GENERIC         reduce using rule 441 (subunit_body -> prot_body .)
INFO:root:    $end            reduce using rule 441 (subunit_body -> prot_body .)
INFO:root:
INFO:root:
INFO:root:state 417
INFO:root:
INFO:root:    (373) prot_body -> PROTECTED . BODY simple_name IS prot_op_body_s END id_opt ;
INFO:root:
INFO:root:    BODY            shift and go to state 544
INFO:root:
INFO:root:
INFO:root:state 418
INFO:root:
INFO:root:    (305) subprog_spec -> FUNCTION designator formal_part_opt RETURN name .
INFO:root:    (164) indexed_comp -> name . ( value_s )
INFO:root:    (171) selected_comp -> name . . simple_name
INFO:root:    (172) selected_comp -> name . . used_char
INFO:root:    (173) selected_comp -> name . . operator_symbol
INFO:root:    (174) selected_comp -> name . . ALL
INFO:root:    (175) attribute -> name . TICK attribute_id
INFO:root:
INFO:root:    ;               reduce using rule 305 (subprog_spec -> FUNCTION designator formal_part_opt RETURN name .)
INFO:root:    IS              reduce using rule 305 (subprog_spec -> FUNCTION designator formal_part_opt RETURN name .)
INFO:root:    RENAMES         reduce using rule 305 (subprog_spec -> FUNCTION designator formal_part_opt RETURN name .)
INFO:root:    (               shift and go to state 237
INFO:root:    .               shift and go to state 239
INFO:root:    TICK            shift and go to state 260
INFO:root:
INFO:root:
INFO:root:state 419
INFO:root:
INFO:root:    (443) body_stub -> PACKAGE BODY . compound_name IS SEPARATE ;
INFO:root:    (158) compound_name -> . simple_name
INFO:root:    (159) compound_name -> . compound_name . simple_name
INFO:root:    (157) simple_name -> . IDENTIFIER
INFO:root:
INFO:root:    IDENTIFIER      shift and go to state 33
INFO:root:
INFO:root:    simple_name                    shift and go to state 34
INFO:root:    compound_name                  shift and go to state 545
INFO:root:
INFO:root:state 420
INFO:root:
INFO:root:    (444) body_stub -> subprog_spec IS . SEPARATE ;
INFO:root:    (488) generic_subp_inst -> subprog_spec IS . generic_inst
INFO:root:    (321) subprog_spec_is_push -> subprog_spec IS .
INFO:root:    (490) generic_inst -> . NEW name
INFO:root:
INFO:root:    SEPARATE        shift and go to state 293
INFO:root:    ABSTRACT        reduce using rule 321 (subprog_spec_is_push -> subprog_spec IS .)
INFO:root:    NEW             shift and go to state 173
INFO:root:
INFO:root:    generic_inst                   shift and go to state 172
INFO:root:
INFO:root:state 421
INFO:root:
INFO:root:    (442) body_stub -> TASK BODY . simple_name IS SEPARATE ;
INFO:root:    (157) simple_name -> . IDENTIFIER
INFO:root:
INFO:root:    IDENTIFIER      shift and go to state 33
INFO:root:
INFO:root:    simple_name                    shift and go to state 546
INFO:root:
INFO:root:state 422
INFO:root:
INFO:root:    (136) decl_item_s1 -> decl_item_s1 decl_item .
INFO:root:
INFO:root:    error           reduce using rule 136 (decl_item_s1 -> decl_item_s1 decl_item .)
INFO:root:    USE             reduce using rule 136 (decl_item_s1 -> decl_item_s1 decl_item .)
INFO:root:    PRAGMA          reduce using rule 136 (decl_item_s1 -> decl_item_s1 decl_item .)
INFO:root:    TYPE            reduce using rule 136 (decl_item_s1 -> decl_item_s1 decl_item .)
INFO:root:    SUBTYPE         reduce using rule 136 (decl_item_s1 -> decl_item_s1 decl_item .)
INFO:root:    TASK            reduce using rule 136 (decl_item_s1 -> decl_item_s1 decl_item .)
INFO:root:    PACKAGE         reduce using rule 136 (decl_item_s1 -> decl_item_s1 decl_item .)
INFO:root:    PROTECTED       reduce using rule 136 (decl_item_s1 -> decl_item_s1 decl_item .)
INFO:root:    FOR             reduce using rule 136 (decl_item_s1 -> decl_item_s1 decl_item .)
INFO:root:    PROCEDURE       reduce using rule 136 (decl_item_s1 -> decl_item_s1 decl_item .)
INFO:root:    FUNCTION        reduce using rule 136 (decl_item_s1 -> decl_item_s1 decl_item .)
INFO:root:    GENERIC         reduce using rule 136 (decl_item_s1 -> decl_item_s1 decl_item .)
INFO:root:    IDENTIFIER      reduce using rule 136 (decl_item_s1 -> decl_item_s1 decl_item .)
INFO:root:    PRIVATE         reduce using rule 136 (decl_item_s1 -> decl_item_s1 decl_item .)
INFO:root:    END             reduce using rule 136 (decl_item_s1 -> decl_item_s1 decl_item .)
INFO:root:
INFO:root:
INFO:root:state 423
INFO:root:
INFO:root:    (445) body_stub -> PROTECTED BODY . simple_name IS SEPARATE ;
INFO:root:    (157) simple_name -> . IDENTIFIER
INFO:root:
INFO:root:    IDENTIFIER      shift and go to state 33
INFO:root:
INFO:root:    simple_name                    shift and go to state 547
INFO:root:
INFO:root:state 424
INFO:root:
INFO:root:    (326) pkg_spec -> PACKAGE compound_name IS decl_item_s private_part . END c_id_opt
INFO:root:
INFO:root:    END             shift and go to state 548
INFO:root:
INFO:root:
INFO:root:state 425
INFO:root:
INFO:root:    (328) private_part -> PRIVATE . decl_item_s
INFO:root:    (133) decl_item_s -> .
INFO:root:    (134) decl_item_s -> . decl_item_s1
INFO:root:    (135) decl_item_s1 -> . decl_item
INFO:root:    (136) decl_item_s1 -> . decl_item_s1 decl_item
INFO:root:    (137) decl_item -> . decl
INFO:root:    (138) decl_item -> . use_clause
INFO:root:    (139) decl_item -> . rep_spec
INFO:root:    (140) decl_item -> . pragma
INFO:root:    (10) decl -> . object_decl
INFO:root:    (11) decl -> . number_decl
INFO:root:    (12) decl -> . type_decl
INFO:root:    (13) decl -> . subtype_decl
INFO:root:    (14) decl -> . subprog_decl
INFO:root:    (15) decl -> . pkg_decl
INFO:root:    (16) decl -> . task_decl
INFO:root:    (17) decl -> . prot_decl
INFO:root:    (18) decl -> . exception_decl
INFO:root:    (19) decl -> . rename_decl
INFO:root:    (20) decl -> . generic_decl
INFO:root:    (21) decl -> . body_stub
INFO:root:    (22) decl -> . error ;
INFO:root:    (337) use_clause -> . USE name_s ;
INFO:root:    (338) use_clause -> . USE TYPE name_s ;
INFO:root:    (491) rep_spec -> . attrib_def
INFO:root:    (492) rep_spec -> . record_type_spec
INFO:root:    (493) rep_spec -> . address_spec
INFO:root:    (2) pragma -> . PRAGMA IDENTIFIER ;
INFO:root:    (3) pragma -> . PRAGMA simple_name ( pragma_arg_s ) ;
INFO:root:    (23) object_decl -> . def_id_s : object_qualifier_opt object_subtype_def init_opt ;
INFO:root:    (35) number_decl -> . def_id_s : CONSTANT ASSIGN expression ;
INFO:root:    (36) type_decl -> . TYPE IDENTIFIER discrim_part_opt type_completion ;
INFO:root:    (50) subtype_decl -> . SUBTYPE IDENTIFIER IS subtype_ind ;
INFO:root:    (301) subprog_decl -> . subprog_spec ;
INFO:root:    (302) subprog_decl -> . generic_subp_inst ;
INFO:root:    (303) subprog_decl -> . subprog_spec_is_push ABSTRACT ;
INFO:root:    (324) pkg_decl -> . pkg_spec ;
INFO:root:    (325) pkg_decl -> . generic_pkg_inst ;
INFO:root:    (349) task_decl -> . task_spec ;
INFO:root:    (357) prot_decl -> . prot_spec ;
INFO:root:    (446) exception_decl -> . def_id_s : EXCEPTION ;
INFO:root:    (341) rename_decl -> . def_id_s : object_qualifier_opt subtype_ind renames ;
INFO:root:    (342) rename_decl -> . def_id_s : EXCEPTION renames ;
INFO:root:    (343) rename_decl -> . rename_unit
INFO:root:    (458) generic_decl -> . generic_formal_part subprog_spec ;
INFO:root:    (459) generic_decl -> . generic_formal_part pkg_spec ;
INFO:root:    (442) body_stub -> . TASK BODY simple_name IS SEPARATE ;
INFO:root:    (443) body_stub -> . PACKAGE BODY compound_name IS SEPARATE ;
INFO:root:    (444) body_stub -> . subprog_spec IS SEPARATE ;
INFO:root:    (445) body_stub -> . PROTECTED BODY simple_name IS SEPARATE ;
INFO:root:    (494) attrib_def -> . FOR mark USE expression ;
INFO:root:    (495) record_type_spec -> . FOR mark USE RECORD align_opt comp_loc_s END RECORD ;
INFO:root:    (500) address_spec -> . FOR mark USE AT expression ;
INFO:root:    (24) def_id_s -> . def_id
INFO:root:    (25) def_id_s -> . def_id_s , def_id
INFO:root:    (304) subprog_spec -> . PROCEDURE compound_name formal_part_opt
INFO:root:    (305) subprog_spec -> . FUNCTION designator formal_part_opt RETURN name
INFO:root:    (306) subprog_spec -> . FUNCTION designator
INFO:root:    (488) generic_subp_inst -> . subprog_spec IS generic_inst
INFO:root:    (321) subprog_spec_is_push -> . subprog_spec IS
INFO:root:    (326) pkg_spec -> . PACKAGE compound_name IS decl_item_s private_part END c_id_opt
INFO:root:    (489) generic_pkg_inst -> . PACKAGE compound_name IS generic_inst
INFO:root:    (350) task_spec -> . TASK simple_name task_def
INFO:root:    (351) task_spec -> . TASK TYPE simple_name discrim_part_opt task_def
INFO:root:    (358) prot_spec -> . PROTECTED IDENTIFIER prot_def
INFO:root:    (359) prot_spec -> . PROTECTED TYPE simple_name discrim_part_opt prot_def
INFO:root:    (344) rename_unit -> . PACKAGE compound_name renames ;
INFO:root:    (345) rename_unit -> . subprog_spec renames ;
INFO:root:    (346) rename_unit -> . generic_formal_part PACKAGE compound_name renames ;
INFO:root:    (347) rename_unit -> . generic_formal_part subprog_spec renames ;
INFO:root:    (460) generic_formal_part -> . GENERIC
INFO:root:    (461) generic_formal_part -> . generic_formal_part generic_formal
INFO:root:    (26) def_id -> . IDENTIFIER
INFO:root:
INFO:root:    END             reduce using rule 133 (decl_item_s -> .)
INFO:root:    error           shift and go to state 107
INFO:root:    USE             shift and go to state 53
INFO:root:    PRAGMA          shift and go to state 2
INFO:root:    TYPE            shift and go to state 74
INFO:root:    SUBTYPE         shift and go to state 110
INFO:root:    TASK            shift and go to state 275
INFO:root:    PACKAGE         shift and go to state 271
INFO:root:    PROTECTED       shift and go to state 277
INFO:root:    FOR             shift and go to state 102
INFO:root:    PROCEDURE       shift and go to state 17
INFO:root:    FUNCTION        shift and go to state 23
INFO:root:    GENERIC         shift and go to state 26
INFO:root:    IDENTIFIER      shift and go to state 52
INFO:root:
INFO:root:    rep_spec                       shift and go to state 72
INFO:root:    pkg_decl                       shift and go to state 93
INFO:root:    pragma                         shift and go to state 94
INFO:root:    prot_decl                      shift and go to state 95
INFO:root:    task_decl                      shift and go to state 76
INFO:root:    subprog_decl                   shift and go to state 77
INFO:root:    type_decl                      shift and go to state 81
INFO:root:    def_id_s                       shift and go to state 79
INFO:root:    generic_pkg_inst               shift and go to state 19
INFO:root:    def_id                         shift and go to state 57
INFO:root:    generic_formal_part            shift and go to state 20
INFO:root:    use_clause                     shift and go to state 97
INFO:root:    decl_item_s1                   shift and go to state 276
INFO:root:    rename_decl                    shift and go to state 98
INFO:root:    body_stub                      shift and go to state 80
INFO:root:    address_spec                   shift and go to state 83
INFO:root:    task_spec                      shift and go to state 82
INFO:root:    exception_decl                 shift and go to state 91
INFO:root:    number_decl                    shift and go to state 101
INFO:root:    generic_subp_inst              shift and go to state 24
INFO:root:    decl_item_s                    shift and go to state 549
INFO:root:    prot_spec                      shift and go to state 85
INFO:root:    rename_unit                    shift and go to state 104
INFO:root:    subprog_spec                   shift and go to state 273
INFO:root:    object_decl                    shift and go to state 87
INFO:root:    generic_decl                   shift and go to state 88
INFO:root:    pkg_spec                       shift and go to state 16
INFO:root:    record_type_spec               shift and go to state 108
INFO:root:    decl                           shift and go to state 109
INFO:root:    decl_item                      shift and go to state 272
INFO:root:    attrib_def                     shift and go to state 92
INFO:root:    subprog_spec_is_push           shift and go to state 279
INFO:root:    subtype_decl                   shift and go to state 105
INFO:root:
INFO:root:state 426
INFO:root:
INFO:root:    (331) pkg_body -> PACKAGE BODY compound_name IS decl_part . body_opt END c_id_opt ;
INFO:root:    (332) body_opt -> .
INFO:root:    (333) body_opt -> . block_body
INFO:root:    (290) block_body -> . BEGIN handled_stmt_s
INFO:root:
INFO:root:    END             reduce using rule 332 (body_opt -> .)
INFO:root:    BEGIN           shift and go to state 195
INFO:root:
INFO:root:    block_body                     shift and go to state 551
INFO:root:    body_opt                       shift and go to state 550
INFO:root:
INFO:root:state 427
INFO:root:
INFO:root:    (331) pkg_body -> PACKAGE BODY compound_name IS . decl_part body_opt END c_id_opt ;
INFO:root:    (443) body_stub -> PACKAGE BODY compound_name IS . SEPARATE ;
INFO:root:    (131) decl_part -> .
INFO:root:    (132) decl_part -> . decl_item_or_body_s1
INFO:root:    (141) decl_item_or_body_s1 -> . decl_item_or_body
INFO:root:    (142) decl_item_or_body_s1 -> . decl_item_or_body_s1 decl_item_or_body
INFO:root:    (143) decl_item_or_body -> . body
INFO:root:    (144) decl_item_or_body -> . decl_item
INFO:root:    (145) body -> . subprog_body
INFO:root:    (146) body -> . pkg_body
INFO:root:    (147) body -> . task_body
INFO:root:    (148) body -> . prot_body
INFO:root:    (137) decl_item -> . decl
INFO:root:    (138) decl_item -> . use_clause
INFO:root:    (139) decl_item -> . rep_spec
INFO:root:    (140) decl_item -> . pragma
INFO:root:    (322) subprog_body -> . subprog_spec_is_push decl_part block_body END id_opt ;
INFO:root:    (331) pkg_body -> . PACKAGE BODY compound_name IS decl_part body_opt END c_id_opt ;
INFO:root:    (356) task_body -> . TASK BODY simple_name IS decl_part block_body END id_opt ;
INFO:root:    (373) prot_body -> . PROTECTED BODY simple_name IS prot_op_body_s END id_opt ;
INFO:root:    (10) decl -> . object_decl
INFO:root:    (11) decl -> . number_decl
INFO:root:    (12) decl -> . type_decl
INFO:root:    (13) decl -> . subtype_decl
INFO:root:    (14) decl -> . subprog_decl
INFO:root:    (15) decl -> . pkg_decl
INFO:root:    (16) decl -> . task_decl
INFO:root:    (17) decl -> . prot_decl
INFO:root:    (18) decl -> . exception_decl
INFO:root:    (19) decl -> . rename_decl
INFO:root:    (20) decl -> . generic_decl
INFO:root:    (21) decl -> . body_stub
INFO:root:    (22) decl -> . error ;
INFO:root:    (337) use_clause -> . USE name_s ;
INFO:root:    (338) use_clause -> . USE TYPE name_s ;
INFO:root:    (491) rep_spec -> . attrib_def
INFO:root:    (492) rep_spec -> . record_type_spec
INFO:root:    (493) rep_spec -> . address_spec
INFO:root:    (2) pragma -> . PRAGMA IDENTIFIER ;
INFO:root:    (3) pragma -> . PRAGMA simple_name ( pragma_arg_s ) ;
INFO:root:    (321) subprog_spec_is_push -> . subprog_spec IS
INFO:root:    (23) object_decl -> . def_id_s : object_qualifier_opt object_subtype_def init_opt ;
INFO:root:    (35) number_decl -> . def_id_s : CONSTANT ASSIGN expression ;
INFO:root:    (36) type_decl -> . TYPE IDENTIFIER discrim_part_opt type_completion ;
INFO:root:    (50) subtype_decl -> . SUBTYPE IDENTIFIER IS subtype_ind ;
INFO:root:    (301) subprog_decl -> . subprog_spec ;
INFO:root:    (302) subprog_decl -> . generic_subp_inst ;
INFO:root:    (303) subprog_decl -> . subprog_spec_is_push ABSTRACT ;
INFO:root:    (324) pkg_decl -> . pkg_spec ;
INFO:root:    (325) pkg_decl -> . generic_pkg_inst ;
INFO:root:    (349) task_decl -> . task_spec ;
INFO:root:    (357) prot_decl -> . prot_spec ;
INFO:root:    (446) exception_decl -> . def_id_s : EXCEPTION ;
INFO:root:    (341) rename_decl -> . def_id_s : object_qualifier_opt subtype_ind renames ;
INFO:root:    (342) rename_decl -> . def_id_s : EXCEPTION renames ;
INFO:root:    (343) rename_decl -> . rename_unit
INFO:root:    (458) generic_decl -> . generic_formal_part subprog_spec ;
INFO:root:    (459) generic_decl -> . generic_formal_part pkg_spec ;
INFO:root:    (442) body_stub -> . TASK BODY simple_name IS SEPARATE ;
INFO:root:    (443) body_stub -> . PACKAGE BODY compound_name IS SEPARATE ;
INFO:root:    (444) body_stub -> . subprog_spec IS SEPARATE ;
INFO:root:    (445) body_stub -> . PROTECTED BODY simple_name IS SEPARATE ;
INFO:root:    (494) attrib_def -> . FOR mark USE expression ;
INFO:root:    (495) record_type_spec -> . FOR mark USE RECORD align_opt comp_loc_s END RECORD ;
INFO:root:    (500) address_spec -> . FOR mark USE AT expression ;
INFO:root:    (304) subprog_spec -> . PROCEDURE compound_name formal_part_opt
INFO:root:    (305) subprog_spec -> . FUNCTION designator formal_part_opt RETURN name
INFO:root:    (306) subprog_spec -> . FUNCTION designator
INFO:root:    (24) def_id_s -> . def_id
INFO:root:    (25) def_id_s -> . def_id_s , def_id
INFO:root:    (488) generic_subp_inst -> . subprog_spec IS generic_inst
INFO:root:    (326) pkg_spec -> . PACKAGE compound_name IS decl_item_s private_part END c_id_opt
INFO:root:    (489) generic_pkg_inst -> . PACKAGE compound_name IS generic_inst
INFO:root:    (350) task_spec -> . TASK simple_name task_def
INFO:root:    (351) task_spec -> . TASK TYPE simple_name discrim_part_opt task_def
INFO:root:    (358) prot_spec -> . PROTECTED IDENTIFIER prot_def
INFO:root:    (359) prot_spec -> . PROTECTED TYPE simple_name discrim_part_opt prot_def
INFO:root:    (344) rename_unit -> . PACKAGE compound_name renames ;
INFO:root:    (345) rename_unit -> . subprog_spec renames ;
INFO:root:    (346) rename_unit -> . generic_formal_part PACKAGE compound_name renames ;
INFO:root:    (347) rename_unit -> . generic_formal_part subprog_spec renames ;
INFO:root:    (460) generic_formal_part -> . GENERIC
INFO:root:    (461) generic_formal_part -> . generic_formal_part generic_formal
INFO:root:    (26) def_id -> . IDENTIFIER
INFO:root:
INFO:root:    SEPARATE        shift and go to state 552
INFO:root:    BEGIN           reduce using rule 131 (decl_part -> .)
INFO:root:    END             reduce using rule 131 (decl_part -> .)
INFO:root:    PACKAGE         shift and go to state 73
INFO:root:    TASK            shift and go to state 84
INFO:root:    PROTECTED       shift and go to state 99
INFO:root:    error           shift and go to state 107
INFO:root:    USE             shift and go to state 53
INFO:root:    PRAGMA          shift and go to state 2
INFO:root:    TYPE            shift and go to state 74
INFO:root:    SUBTYPE         shift and go to state 110
INFO:root:    FOR             shift and go to state 102
INFO:root:    PROCEDURE       shift and go to state 17
INFO:root:    FUNCTION        shift and go to state 23
INFO:root:    GENERIC         shift and go to state 26
INFO:root:    IDENTIFIER      shift and go to state 52
INFO:root:
INFO:root:    generic_formal_part            shift and go to state 20
INFO:root:    pkg_decl                       shift and go to state 93
INFO:root:    pragma                         shift and go to state 94
INFO:root:    generic_pkg_inst               shift and go to state 19
INFO:root:    prot_decl                      shift and go to state 95
INFO:root:    body                           shift and go to state 75
INFO:root:    task_decl                      shift and go to state 76
INFO:root:    generic_decl                   shift and go to state 88
INFO:root:    subprog_decl                   shift and go to state 77
INFO:root:    type_decl                      shift and go to state 81
INFO:root:    def_id_s                       shift and go to state 79
INFO:root:    def_id                         shift and go to state 57
INFO:root:    rep_spec                       shift and go to state 72
INFO:root:    use_clause                     shift and go to state 97
INFO:root:    rename_decl                    shift and go to state 98
INFO:root:    body_stub                      shift and go to state 80
INFO:root:    address_spec                   shift and go to state 83
INFO:root:    task_spec                      shift and go to state 82
INFO:root:    number_decl                    shift and go to state 101
INFO:root:    generic_subp_inst              shift and go to state 24
INFO:root:    decl_item_or_body_s1           shift and go to state 103
INFO:root:    prot_spec                      shift and go to state 85
INFO:root:    rename_unit                    shift and go to state 104
INFO:root:    subprog_spec                   shift and go to state 86
INFO:root:    object_decl                    shift and go to state 87
INFO:root:    subtype_decl                   shift and go to state 105
INFO:root:    task_body                      shift and go to state 96
INFO:root:    prot_body                      shift and go to state 100
INFO:root:    pkg_body                       shift and go to state 90
INFO:root:    decl_part                      shift and go to state 426
INFO:root:    pkg_spec                       shift and go to state 16
INFO:root:    record_type_spec               shift and go to state 108
INFO:root:    decl                           shift and go to state 109
INFO:root:    decl_item                      shift and go to state 78
INFO:root:    exception_decl                 shift and go to state 91
INFO:root:    subprog_body                   shift and go to state 113
INFO:root:    attrib_def                     shift and go to state 92
INFO:root:    subprog_spec_is_push           shift and go to state 111
INFO:root:    decl_item_or_body              shift and go to state 112
INFO:root:
INFO:root:state 428
INFO:root:
INFO:root:    (36) type_decl -> TYPE IDENTIFIER discrim_part_opt type_completion . ;
INFO:root:
INFO:root:    ;               shift and go to state 553
INFO:root:
INFO:root:
INFO:root:state 429
INFO:root:
INFO:root:    (41) type_completion -> IS . type_def
INFO:root:    (42) type_def -> . enumeration_type
INFO:root:    (43) type_def -> . integer_type
INFO:root:    (44) type_def -> . real_type
INFO:root:    (45) type_def -> . array_type
INFO:root:    (46) type_def -> . record_type
INFO:root:    (47) type_def -> . access_type
INFO:root:    (48) type_def -> . derived_type
INFO:root:    (49) type_def -> . private_type
INFO:root:    (63) enumeration_type -> . ( enum_id_s )
INFO:root:    (68) integer_type -> . range_spec
INFO:root:    (69) integer_type -> . MOD expression
INFO:root:    (73) real_type -> . float_type
INFO:root:    (74) real_type -> . fixed_type
INFO:root:    (78) array_type -> . unconstr_array_type
INFO:root:    (79) array_type -> . constr_array_type
INFO:root:    (95) record_type -> . tagged_opt limited_opt record_def
INFO:root:    (128) access_type -> . ACCESS subtype_ind
INFO:root:    (129) access_type -> . ACCESS CONSTANT subtype_ind
INFO:root:    (130) access_type -> . ACCESS ALL subtype_ind
INFO:root:    (56) derived_type -> . NEW subtype_ind
INFO:root:    (57) derived_type -> . NEW subtype_ind WITH PRIVATE
INFO:root:    (58) derived_type -> . NEW subtype_ind WITH record_def
INFO:root:    (59) derived_type -> . ABSTRACT NEW subtype_ind WITH PRIVATE
INFO:root:    (60) derived_type -> . ABSTRACT NEW subtype_ind WITH record_def
INFO:root:    (334) private_type -> . tagged_opt limited_opt PRIVATE
INFO:root:    (70) range_spec -> . range_constraint
INFO:root:    (75) float_type -> . DIGITS expression range_spec_opt
INFO:root:    (76) fixed_type -> . DELTA expression range_spec
INFO:root:    (77) fixed_type -> . DELTA expression DIGITS expression range_spec_opt
INFO:root:    (80) unconstr_array_type -> . ARRAY ( index_s ) OF component_subtype_def
INFO:root:    (81) constr_array_type -> . ARRAY iter_index_constraint OF component_subtype_def
INFO:root:    (98) tagged_opt -> .
INFO:root:    (99) tagged_opt -> . TAGGED
INFO:root:    (100) tagged_opt -> . ABSTRACT TAGGED
INFO:root:    (61) range_constraint -> . RANGE range
INFO:root:
INFO:root:    (               shift and go to state 564
INFO:root:    MOD             shift and go to state 560
INFO:root:    ACCESS          shift and go to state 534
INFO:root:    NEW             shift and go to state 559
INFO:root:    ABSTRACT        shift and go to state 566
INFO:root:    DIGITS          shift and go to state 567
INFO:root:    DELTA           shift and go to state 571
INFO:root:    ARRAY           shift and go to state 431
INFO:root:    LIMITED         reduce using rule 98 (tagged_opt -> .)
INFO:root:    PRIVATE         reduce using rule 98 (tagged_opt -> .)
INFO:root:    RECORD          reduce using rule 98 (tagged_opt -> .)
INFO:root:    NuLL            reduce using rule 98 (tagged_opt -> .)
INFO:root:    TAGGED          shift and go to state 529
INFO:root:    RANGE           shift and go to state 358
INFO:root:
INFO:root:    fixed_type                     shift and go to state 554
INFO:root:    real_type                      shift and go to state 555
INFO:root:    integer_type                   shift and go to state 556
INFO:root:    derived_type                   shift and go to state 557
INFO:root:    private_type                   shift and go to state 558
INFO:root:    unconstr_array_type            shift and go to state 434
INFO:root:    range_spec                     shift and go to state 561
INFO:root:    enumeration_type               shift and go to state 562
INFO:root:    tagged_opt                     shift and go to state 565
INFO:root:    access_type                    shift and go to state 568
INFO:root:    record_type                    shift and go to state 563
INFO:root:    array_type                     shift and go to state 569
INFO:root:    range_constraint               shift and go to state 570
INFO:root:    constr_array_type              shift and go to state 436
INFO:root:    type_def                       shift and go to state 572
INFO:root:    float_type                     shift and go to state 573
INFO:root:
INFO:root:state 430
INFO:root:
INFO:root:    (39) discrim_part_opt -> ( BOX . )
INFO:root:
INFO:root:    )               shift and go to state 574
INFO:root:
INFO:root:
INFO:root:state 431
INFO:root:
INFO:root:    (80) unconstr_array_type -> ARRAY . ( index_s ) OF component_subtype_def
INFO:root:    (81) constr_array_type -> ARRAY . iter_index_constraint OF component_subtype_def
INFO:root:    (88) iter_index_constraint -> . ( iter_discrete_range_s )
INFO:root:
INFO:root:    (               shift and go to state 575
INFO:root:
INFO:root:    iter_index_constraint          shift and go to state 576
INFO:root:
INFO:root:state 432
INFO:root:
INFO:root:    (51) subtype_ind -> name . constraint
INFO:root:    (52) subtype_ind -> name .
INFO:root:    (164) indexed_comp -> name . ( value_s )
INFO:root:    (171) selected_comp -> name . . simple_name
INFO:root:    (172) selected_comp -> name . . used_char
INFO:root:    (173) selected_comp -> name . . operator_symbol
INFO:root:    (174) selected_comp -> name . . ALL
INFO:root:    (175) attribute -> name . TICK attribute_id
INFO:root:    (53) constraint -> . range_constraint
INFO:root:    (54) constraint -> . decimal_digits_constraint
INFO:root:    (61) range_constraint -> . RANGE range
INFO:root:    (55) decimal_digits_constraint -> . DIGITS expression range_constr_opt
INFO:root:
INFO:root:    RENAMES         reduce using rule 52 (subtype_ind -> name .)
INFO:root:    ASSIGN          reduce using rule 52 (subtype_ind -> name .)
INFO:root:    ;               reduce using rule 52 (subtype_ind -> name .)
INFO:root:    WITH            reduce using rule 52 (subtype_ind -> name .)
INFO:root:    (               shift and go to state 237
INFO:root:    .               shift and go to state 239
INFO:root:    TICK            shift and go to state 260
INFO:root:    RANGE           shift and go to state 358
INFO:root:    DIGITS          shift and go to state 577
INFO:root:
INFO:root:    range_constraint               shift and go to state 578
INFO:root:    decimal_digits_constraint      shift and go to state 580
INFO:root:    constraint                     shift and go to state 579
INFO:root:
INFO:root:state 433
INFO:root:
INFO:root:    (341) rename_decl -> def_id_s : object_qualifier_opt subtype_ind . renames ;
INFO:root:    (31) object_subtype_def -> subtype_ind .
INFO:root:    (348) renames -> . RENAMES name
INFO:root:
INFO:root:    ASSIGN          reduce using rule 31 (object_subtype_def -> subtype_ind .)
INFO:root:    ;               reduce using rule 31 (object_subtype_def -> subtype_ind .)
INFO:root:    RENAMES         shift and go to state 66
INFO:root:
INFO:root:    renames                        shift and go to state 581
INFO:root:
INFO:root:state 434
INFO:root:
INFO:root:    (78) array_type -> unconstr_array_type .
INFO:root:
INFO:root:    ASSIGN          reduce using rule 78 (array_type -> unconstr_array_type .)
INFO:root:    ;               reduce using rule 78 (array_type -> unconstr_array_type .)
INFO:root:
INFO:root:
INFO:root:state 435
INFO:root:
INFO:root:    (32) object_subtype_def -> array_type .
INFO:root:
INFO:root:    ASSIGN          reduce using rule 32 (object_subtype_def -> array_type .)
INFO:root:    ;               reduce using rule 32 (object_subtype_def -> array_type .)
INFO:root:
INFO:root:
INFO:root:state 436
INFO:root:
INFO:root:    (79) array_type -> constr_array_type .
INFO:root:
INFO:root:    ASSIGN          reduce using rule 79 (array_type -> constr_array_type .)
INFO:root:    ;               reduce using rule 79 (array_type -> constr_array_type .)
INFO:root:
INFO:root:
INFO:root:state 437
INFO:root:
INFO:root:    (23) object_decl -> def_id_s : object_qualifier_opt object_subtype_def . init_opt ;
INFO:root:    (33) init_opt -> .
INFO:root:    (34) init_opt -> . ASSIGN expression
INFO:root:
INFO:root:    ;               reduce using rule 33 (init_opt -> .)
INFO:root:    ASSIGN          shift and go to state 540
INFO:root:
INFO:root:    init_opt                       shift and go to state 582
INFO:root:
INFO:root:state 438
INFO:root:
INFO:root:    (35) number_decl -> def_id_s : CONSTANT ASSIGN . expression ;
INFO:root:    (188) expression -> . relation
INFO:root:    (189) expression -> . expression logical relation
INFO:root:    (190) expression -> . expression short_circuit relation
INFO:root:    (196) relation -> . simple_expression
INFO:root:    (197) relation -> . simple_expression relational simple_expression
INFO:root:    (198) relation -> . simple_expression membership range
INFO:root:    (199) relation -> . simple_expression membership name
INFO:root:    (208) simple_expression -> . unary term
INFO:root:    (209) simple_expression -> . term
INFO:root:    (210) simple_expression -> . simple_expression adding term
INFO:root:    (211) unary -> . +
INFO:root:    (212) unary -> . -
INFO:root:    (216) term -> . factor
INFO:root:    (217) term -> . term multiplying factor
INFO:root:    (223) factor -> . primary
INFO:root:    (224) factor -> . NOT primary
INFO:root:    (225) factor -> . ABS primary
INFO:root:    (226) primary -> . literal
INFO:root:    (227) primary -> . name
INFO:root:    (228) primary -> . allocator
INFO:root:    (229) primary -> . qualified
INFO:root:    (230) primary -> . parenthesized_primary
INFO:root:    (180) literal -> . INT
INFO:root:    (181) literal -> . FLOAT
INFO:root:    (182) literal -> . NuLL
INFO:root:    (149) name -> . simple_name
INFO:root:    (150) name -> . indexed_comp
INFO:root:    (151) name -> . selected_comp
INFO:root:    (152) name -> . attribute
INFO:root:    (153) name -> . operator_symbol
INFO:root:    (234) allocator -> . NEW name
INFO:root:    (235) allocator -> . NEW qualified
INFO:root:    (233) qualified -> . name TICK parenthesized_primary
INFO:root:    (231) parenthesized_primary -> . aggregate
INFO:root:    (232) parenthesized_primary -> . ( expression )
INFO:root:    (157) simple_name -> . IDENTIFIER
INFO:root:    (164) indexed_comp -> . name ( value_s )
INFO:root:    (171) selected_comp -> . name . simple_name
INFO:root:    (172) selected_comp -> . name . used_char
INFO:root:    (173) selected_comp -> . name . operator_symbol
INFO:root:    (174) selected_comp -> . name . ALL
INFO:root:    (175) attribute -> . name TICK attribute_id
INFO:root:    (163) operator_symbol -> . STRING
INFO:root:    (183) aggregate -> . ( comp_assoc )
INFO:root:    (184) aggregate -> . ( expression WITH value_s )
INFO:root:    (185) aggregate -> . ( expression WITH NuLL RECORD )
INFO:root:    (186) aggregate -> . ( NuLL RECORD )
INFO:root:
INFO:root:    +               shift and go to state 148
INFO:root:    -               shift and go to state 136
INFO:root:    NOT             shift and go to state 131
INFO:root:    ABS             shift and go to state 132
INFO:root:    INT             shift and go to state 120
INFO:root:    FLOAT           shift and go to state 128
INFO:root:    NuLL            shift and go to state 130
INFO:root:    NEW             shift and go to state 137
INFO:root:    (               shift and go to state 125
INFO:root:    IDENTIFIER      shift and go to state 33
INFO:root:    STRING          shift and go to state 149
INFO:root:
INFO:root:    literal                        shift and go to state 121
INFO:root:    allocator                      shift and go to state 122
INFO:root:    simple_name                    shift and go to state 163
INFO:root:    indexed_comp                   shift and go to state 140
INFO:root:    name                           shift and go to state 142
INFO:root:    term                           shift and go to state 146
INFO:root:    selected_comp                  shift and go to state 139
INFO:root:    factor                         shift and go to state 126
INFO:root:    expression                     shift and go to state 583
INFO:root:    unary                          shift and go to state 144
INFO:root:    qualified                      shift and go to state 145
INFO:root:    aggregate                      shift and go to state 143
INFO:root:    simple_expression              shift and go to state 129
INFO:root:    operator_symbol                shift and go to state 133
INFO:root:    parenthesized_primary          shift and go to state 147
INFO:root:    attribute                      shift and go to state 134
INFO:root:    primary                        shift and go to state 135
INFO:root:    relation                       shift and go to state 138
INFO:root:
INFO:root:state 439
INFO:root:
INFO:root:    (342) rename_decl -> def_id_s : EXCEPTION renames . ;
INFO:root:
INFO:root:    ;               shift and go to state 584
INFO:root:
INFO:root:
INFO:root:state 440
INFO:root:
INFO:root:    (446) exception_decl -> def_id_s : EXCEPTION ; .
INFO:root:
INFO:root:    PACKAGE         reduce using rule 446 (exception_decl -> def_id_s : EXCEPTION ; .)
INFO:root:    TASK            reduce using rule 446 (exception_decl -> def_id_s : EXCEPTION ; .)
INFO:root:    PROTECTED       reduce using rule 446 (exception_decl -> def_id_s : EXCEPTION ; .)
INFO:root:    error           reduce using rule 446 (exception_decl -> def_id_s : EXCEPTION ; .)
INFO:root:    USE             reduce using rule 446 (exception_decl -> def_id_s : EXCEPTION ; .)
INFO:root:    PRAGMA          reduce using rule 446 (exception_decl -> def_id_s : EXCEPTION ; .)
INFO:root:    TYPE            reduce using rule 446 (exception_decl -> def_id_s : EXCEPTION ; .)
INFO:root:    SUBTYPE         reduce using rule 446 (exception_decl -> def_id_s : EXCEPTION ; .)
INFO:root:    FOR             reduce using rule 446 (exception_decl -> def_id_s : EXCEPTION ; .)
INFO:root:    PROCEDURE       reduce using rule 446 (exception_decl -> def_id_s : EXCEPTION ; .)
INFO:root:    FUNCTION        reduce using rule 446 (exception_decl -> def_id_s : EXCEPTION ; .)
INFO:root:    GENERIC         reduce using rule 446 (exception_decl -> def_id_s : EXCEPTION ; .)
INFO:root:    IDENTIFIER      reduce using rule 446 (exception_decl -> def_id_s : EXCEPTION ; .)
INFO:root:    BEGIN           reduce using rule 446 (exception_decl -> def_id_s : EXCEPTION ; .)
INFO:root:    PRIVATE         reduce using rule 446 (exception_decl -> def_id_s : EXCEPTION ; .)
INFO:root:    END             reduce using rule 446 (exception_decl -> def_id_s : EXCEPTION ; .)
INFO:root:
INFO:root:
INFO:root:state 441
INFO:root:
INFO:root:    (30) object_qualifier_opt -> ALIASED CONSTANT .
INFO:root:
INFO:root:    ARRAY           reduce using rule 30 (object_qualifier_opt -> ALIASED CONSTANT .)
INFO:root:    IDENTIFIER      reduce using rule 30 (object_qualifier_opt -> ALIASED CONSTANT .)
INFO:root:    STRING          reduce using rule 30 (object_qualifier_opt -> ALIASED CONSTANT .)
INFO:root:
INFO:root:
INFO:root:state 442
INFO:root:
INFO:root:    (351) task_spec -> TASK TYPE simple_name discrim_part_opt . task_def
INFO:root:    (352) task_def -> .
INFO:root:    (353) task_def -> . IS entry_decl_s rep_spec_s task_private_opt END id_opt
INFO:root:
INFO:root:    ;               reduce using rule 352 (task_def -> .)
INFO:root:    IS              shift and go to state 292
INFO:root:
INFO:root:    task_def                       shift and go to state 585
INFO:root:
INFO:root:state 443
INFO:root:
INFO:root:    (356) task_body -> TASK BODY simple_name IS . decl_part block_body END id_opt ;
INFO:root:    (442) body_stub -> TASK BODY simple_name IS . SEPARATE ;
INFO:root:    (131) decl_part -> .
INFO:root:    (132) decl_part -> . decl_item_or_body_s1
INFO:root:    (141) decl_item_or_body_s1 -> . decl_item_or_body
INFO:root:    (142) decl_item_or_body_s1 -> . decl_item_or_body_s1 decl_item_or_body
INFO:root:    (143) decl_item_or_body -> . body
INFO:root:    (144) decl_item_or_body -> . decl_item
INFO:root:    (145) body -> . subprog_body
INFO:root:    (146) body -> . pkg_body
INFO:root:    (147) body -> . task_body
INFO:root:    (148) body -> . prot_body
INFO:root:    (137) decl_item -> . decl
INFO:root:    (138) decl_item -> . use_clause
INFO:root:    (139) decl_item -> . rep_spec
INFO:root:    (140) decl_item -> . pragma
INFO:root:    (322) subprog_body -> . subprog_spec_is_push decl_part block_body END id_opt ;
INFO:root:    (331) pkg_body -> . PACKAGE BODY compound_name IS decl_part body_opt END c_id_opt ;
INFO:root:    (356) task_body -> . TASK BODY simple_name IS decl_part block_body END id_opt ;
INFO:root:    (373) prot_body -> . PROTECTED BODY simple_name IS prot_op_body_s END id_opt ;
INFO:root:    (10) decl -> . object_decl
INFO:root:    (11) decl -> . number_decl
INFO:root:    (12) decl -> . type_decl
INFO:root:    (13) decl -> . subtype_decl
INFO:root:    (14) decl -> . subprog_decl
INFO:root:    (15) decl -> . pkg_decl
INFO:root:    (16) decl -> . task_decl
INFO:root:    (17) decl -> . prot_decl
INFO:root:    (18) decl -> . exception_decl
INFO:root:    (19) decl -> . rename_decl
INFO:root:    (20) decl -> . generic_decl
INFO:root:    (21) decl -> . body_stub
INFO:root:    (22) decl -> . error ;
INFO:root:    (337) use_clause -> . USE name_s ;
INFO:root:    (338) use_clause -> . USE TYPE name_s ;
INFO:root:    (491) rep_spec -> . attrib_def
INFO:root:    (492) rep_spec -> . record_type_spec
INFO:root:    (493) rep_spec -> . address_spec
INFO:root:    (2) pragma -> . PRAGMA IDENTIFIER ;
INFO:root:    (3) pragma -> . PRAGMA simple_name ( pragma_arg_s ) ;
INFO:root:    (321) subprog_spec_is_push -> . subprog_spec IS
INFO:root:    (23) object_decl -> . def_id_s : object_qualifier_opt object_subtype_def init_opt ;
INFO:root:    (35) number_decl -> . def_id_s : CONSTANT ASSIGN expression ;
INFO:root:    (36) type_decl -> . TYPE IDENTIFIER discrim_part_opt type_completion ;
INFO:root:    (50) subtype_decl -> . SUBTYPE IDENTIFIER IS subtype_ind ;
INFO:root:    (301) subprog_decl -> . subprog_spec ;
INFO:root:    (302) subprog_decl -> . generic_subp_inst ;
INFO:root:    (303) subprog_decl -> . subprog_spec_is_push ABSTRACT ;
INFO:root:    (324) pkg_decl -> . pkg_spec ;
INFO:root:    (325) pkg_decl -> . generic_pkg_inst ;
INFO:root:    (349) task_decl -> . task_spec ;
INFO:root:    (357) prot_decl -> . prot_spec ;
INFO:root:    (446) exception_decl -> . def_id_s : EXCEPTION ;
INFO:root:    (341) rename_decl -> . def_id_s : object_qualifier_opt subtype_ind renames ;
INFO:root:    (342) rename_decl -> . def_id_s : EXCEPTION renames ;
INFO:root:    (343) rename_decl -> . rename_unit
INFO:root:    (458) generic_decl -> . generic_formal_part subprog_spec ;
INFO:root:    (459) generic_decl -> . generic_formal_part pkg_spec ;
INFO:root:    (442) body_stub -> . TASK BODY simple_name IS SEPARATE ;
INFO:root:    (443) body_stub -> . PACKAGE BODY compound_name IS SEPARATE ;
INFO:root:    (444) body_stub -> . subprog_spec IS SEPARATE ;
INFO:root:    (445) body_stub -> . PROTECTED BODY simple_name IS SEPARATE ;
INFO:root:    (494) attrib_def -> . FOR mark USE expression ;
INFO:root:    (495) record_type_spec -> . FOR mark USE RECORD align_opt comp_loc_s END RECORD ;
INFO:root:    (500) address_spec -> . FOR mark USE AT expression ;
INFO:root:    (304) subprog_spec -> . PROCEDURE compound_name formal_part_opt
INFO:root:    (305) subprog_spec -> . FUNCTION designator formal_part_opt RETURN name
INFO:root:    (306) subprog_spec -> . FUNCTION designator
INFO:root:    (24) def_id_s -> . def_id
INFO:root:    (25) def_id_s -> . def_id_s , def_id
INFO:root:    (488) generic_subp_inst -> . subprog_spec IS generic_inst
INFO:root:    (326) pkg_spec -> . PACKAGE compound_name IS decl_item_s private_part END c_id_opt
INFO:root:    (489) generic_pkg_inst -> . PACKAGE compound_name IS generic_inst
INFO:root:    (350) task_spec -> . TASK simple_name task_def
INFO:root:    (351) task_spec -> . TASK TYPE simple_name discrim_part_opt task_def
INFO:root:    (358) prot_spec -> . PROTECTED IDENTIFIER prot_def
INFO:root:    (359) prot_spec -> . PROTECTED TYPE simple_name discrim_part_opt prot_def
INFO:root:    (344) rename_unit -> . PACKAGE compound_name renames ;
INFO:root:    (345) rename_unit -> . subprog_spec renames ;
INFO:root:    (346) rename_unit -> . generic_formal_part PACKAGE compound_name renames ;
INFO:root:    (347) rename_unit -> . generic_formal_part subprog_spec renames ;
INFO:root:    (460) generic_formal_part -> . GENERIC
INFO:root:    (461) generic_formal_part -> . generic_formal_part generic_formal
INFO:root:    (26) def_id -> . IDENTIFIER
INFO:root:
INFO:root:    SEPARATE        shift and go to state 586
INFO:root:    BEGIN           reduce using rule 131 (decl_part -> .)
INFO:root:    PACKAGE         shift and go to state 73
INFO:root:    TASK            shift and go to state 84
INFO:root:    PROTECTED       shift and go to state 99
INFO:root:    error           shift and go to state 107
INFO:root:    USE             shift and go to state 53
INFO:root:    PRAGMA          shift and go to state 2
INFO:root:    TYPE            shift and go to state 74
INFO:root:    SUBTYPE         shift and go to state 110
INFO:root:    FOR             shift and go to state 102
INFO:root:    PROCEDURE       shift and go to state 17
INFO:root:    FUNCTION        shift and go to state 23
INFO:root:    GENERIC         shift and go to state 26
INFO:root:    IDENTIFIER      shift and go to state 52
INFO:root:
INFO:root:    generic_formal_part            shift and go to state 20
INFO:root:    pkg_decl                       shift and go to state 93
INFO:root:    pragma                         shift and go to state 94
INFO:root:    generic_pkg_inst               shift and go to state 19
INFO:root:    prot_decl                      shift and go to state 95
INFO:root:    body                           shift and go to state 75
INFO:root:    task_decl                      shift and go to state 76
INFO:root:    generic_decl                   shift and go to state 88
INFO:root:    subprog_decl                   shift and go to state 77
INFO:root:    type_decl                      shift and go to state 81
INFO:root:    def_id_s                       shift and go to state 79
INFO:root:    def_id                         shift and go to state 57
INFO:root:    rep_spec                       shift and go to state 72
INFO:root:    use_clause                     shift and go to state 97
INFO:root:    rename_decl                    shift and go to state 98
INFO:root:    body_stub                      shift and go to state 80
INFO:root:    address_spec                   shift and go to state 83
INFO:root:    task_spec                      shift and go to state 82
INFO:root:    number_decl                    shift and go to state 101
INFO:root:    generic_subp_inst              shift and go to state 24
INFO:root:    decl_item_or_body_s1           shift and go to state 103
INFO:root:    prot_spec                      shift and go to state 85
INFO:root:    rename_unit                    shift and go to state 104
INFO:root:    subprog_spec                   shift and go to state 86
INFO:root:    object_decl                    shift and go to state 87
INFO:root:    subtype_decl                   shift and go to state 105
INFO:root:    task_body                      shift and go to state 96
INFO:root:    prot_body                      shift and go to state 100
INFO:root:    pkg_body                       shift and go to state 90
INFO:root:    decl_part                      shift and go to state 587
INFO:root:    pkg_spec                       shift and go to state 16
INFO:root:    record_type_spec               shift and go to state 108
INFO:root:    decl                           shift and go to state 109
INFO:root:    decl_item                      shift and go to state 78
INFO:root:    exception_decl                 shift and go to state 91
INFO:root:    subprog_body                   shift and go to state 113
INFO:root:    attrib_def                     shift and go to state 92
INFO:root:    subprog_spec_is_push           shift and go to state 111
INFO:root:    decl_item_or_body              shift and go to state 112
INFO:root:
INFO:root:state 444
INFO:root:
INFO:root:    (353) task_def -> IS entry_decl_s . rep_spec_s task_private_opt END id_opt
INFO:root:    (380) entry_decl_s -> entry_decl_s . entry_decl pragma_s
INFO:root:    (387) rep_spec_s -> .
INFO:root:    (388) rep_spec_s -> . rep_spec_s rep_spec pragma_s
INFO:root:    (381) entry_decl -> . ENTRY IDENTIFIER formal_part_opt ;
INFO:root:    (382) entry_decl -> . ENTRY IDENTIFIER ( discrete_range ) formal_part_opt ;
INFO:root:
INFO:root:    PRIVATE         reduce using rule 387 (rep_spec_s -> .)
INFO:root:    FOR             reduce using rule 387 (rep_spec_s -> .)
INFO:root:    END             reduce using rule 387 (rep_spec_s -> .)
INFO:root:    ENTRY           shift and go to state 590
INFO:root:
INFO:root:    entry_decl                     shift and go to state 588
INFO:root:    rep_spec_s                     shift and go to state 589
INFO:root:
INFO:root:state 445
INFO:root:
INFO:root:    (379) entry_decl_s -> pragma_s .
INFO:root:    (9) pragma_s -> pragma_s . pragma
INFO:root:    (2) pragma -> . PRAGMA IDENTIFIER ;
INFO:root:    (3) pragma -> . PRAGMA simple_name ( pragma_arg_s ) ;
INFO:root:
INFO:root:    ENTRY           reduce using rule 379 (entry_decl_s -> pragma_s .)
INFO:root:    FOR             reduce using rule 379 (entry_decl_s -> pragma_s .)
INFO:root:    END             reduce using rule 379 (entry_decl_s -> pragma_s .)
INFO:root:    PRIVATE         reduce using rule 379 (entry_decl_s -> pragma_s .)
INFO:root:    PRAGMA          shift and go to state 2
INFO:root:
INFO:root:    pragma                         shift and go to state 43
INFO:root:
INFO:root:state 446
INFO:root:
INFO:root:    (444) body_stub -> subprog_spec IS SEPARATE ; .
INFO:root:
INFO:root:    error           reduce using rule 444 (body_stub -> subprog_spec IS SEPARATE ; .)
INFO:root:    USE             reduce using rule 444 (body_stub -> subprog_spec IS SEPARATE ; .)
INFO:root:    PRAGMA          reduce using rule 444 (body_stub -> subprog_spec IS SEPARATE ; .)
INFO:root:    TYPE            reduce using rule 444 (body_stub -> subprog_spec IS SEPARATE ; .)
INFO:root:    SUBTYPE         reduce using rule 444 (body_stub -> subprog_spec IS SEPARATE ; .)
INFO:root:    TASK            reduce using rule 444 (body_stub -> subprog_spec IS SEPARATE ; .)
INFO:root:    PACKAGE         reduce using rule 444 (body_stub -> subprog_spec IS SEPARATE ; .)
INFO:root:    PROTECTED       reduce using rule 444 (body_stub -> subprog_spec IS SEPARATE ; .)
INFO:root:    FOR             reduce using rule 444 (body_stub -> subprog_spec IS SEPARATE ; .)
INFO:root:    PROCEDURE       reduce using rule 444 (body_stub -> subprog_spec IS SEPARATE ; .)
INFO:root:    FUNCTION        reduce using rule 444 (body_stub -> subprog_spec IS SEPARATE ; .)
INFO:root:    GENERIC         reduce using rule 444 (body_stub -> subprog_spec IS SEPARATE ; .)
INFO:root:    IDENTIFIER      reduce using rule 444 (body_stub -> subprog_spec IS SEPARATE ; .)
INFO:root:    PRIVATE         reduce using rule 444 (body_stub -> subprog_spec IS SEPARATE ; .)
INFO:root:    END             reduce using rule 444 (body_stub -> subprog_spec IS SEPARATE ; .)
INFO:root:    BEGIN           reduce using rule 444 (body_stub -> subprog_spec IS SEPARATE ; .)
INFO:root:
INFO:root:
INFO:root:state 447
INFO:root:
INFO:root:    (373) prot_body -> PROTECTED BODY simple_name IS . prot_op_body_s END id_opt ;
INFO:root:    (445) body_stub -> PROTECTED BODY simple_name IS . SEPARATE ;
INFO:root:    (374) prot_op_body_s -> . pragma_s
INFO:root:    (375) prot_op_body_s -> . prot_op_body_s prot_op_body pragma_s
INFO:root:    (8) pragma_s -> .
INFO:root:    (9) pragma_s -> . pragma_s pragma
INFO:root:
INFO:root:    SEPARATE        shift and go to state 591
INFO:root:    PRAGMA          reduce using rule 8 (pragma_s -> .)
INFO:root:    END             reduce using rule 8 (pragma_s -> .)
INFO:root:    ENTRY           reduce using rule 8 (pragma_s -> .)
INFO:root:    PROCEDURE       reduce using rule 8 (pragma_s -> .)
INFO:root:    FUNCTION        reduce using rule 8 (pragma_s -> .)
INFO:root:
INFO:root:    pragma_s                       shift and go to state 592
INFO:root:    prot_op_body_s                 shift and go to state 593
INFO:root:
INFO:root:state 448
INFO:root:
INFO:root:    (359) prot_spec -> PROTECTED TYPE simple_name discrim_part_opt . prot_def
INFO:root:    (360) prot_def -> . IS prot_op_decl_s prot_private_opt END id_opt
INFO:root:
INFO:root:    IS              shift and go to state 297
INFO:root:
INFO:root:    prot_def                       shift and go to state 594
INFO:root:
INFO:root:state 449
INFO:root:
INFO:root:    (360) prot_def -> IS prot_op_decl_s . prot_private_opt END id_opt
INFO:root:    (364) prot_op_decl_s -> prot_op_decl_s . prot_op_decl
INFO:root:    (361) prot_private_opt -> .
INFO:root:    (362) prot_private_opt -> . PRIVATE prot_elem_decl_s
INFO:root:    (365) prot_op_decl -> . entry_decl
INFO:root:    (366) prot_op_decl -> . subprog_spec ;
INFO:root:    (367) prot_op_decl -> . rep_spec
INFO:root:    (368) prot_op_decl -> . pragma
INFO:root:    (381) entry_decl -> . ENTRY IDENTIFIER formal_part_opt ;
INFO:root:    (382) entry_decl -> . ENTRY IDENTIFIER ( discrete_range ) formal_part_opt ;
INFO:root:    (304) subprog_spec -> . PROCEDURE compound_name formal_part_opt
INFO:root:    (305) subprog_spec -> . FUNCTION designator formal_part_opt RETURN name
INFO:root:    (306) subprog_spec -> . FUNCTION designator
INFO:root:    (491) rep_spec -> . attrib_def
INFO:root:    (492) rep_spec -> . record_type_spec
INFO:root:    (493) rep_spec -> . address_spec
INFO:root:    (2) pragma -> . PRAGMA IDENTIFIER ;
INFO:root:    (3) pragma -> . PRAGMA simple_name ( pragma_arg_s ) ;
INFO:root:    (494) attrib_def -> . FOR mark USE expression ;
INFO:root:    (495) record_type_spec -> . FOR mark USE RECORD align_opt comp_loc_s END RECORD ;
INFO:root:    (500) address_spec -> . FOR mark USE AT expression ;
INFO:root:
INFO:root:    END             reduce using rule 361 (prot_private_opt -> .)
INFO:root:    PRIVATE         shift and go to state 599
INFO:root:    ENTRY           shift and go to state 590
INFO:root:    PROCEDURE       shift and go to state 17
INFO:root:    FUNCTION        shift and go to state 23
INFO:root:    PRAGMA          shift and go to state 2
INFO:root:    FOR             shift and go to state 102
INFO:root:
INFO:root:    prot_op_decl                   shift and go to state 595
INFO:root:    pragma                         shift and go to state 596
INFO:root:    subprog_spec                   shift and go to state 597
INFO:root:    prot_private_opt               shift and go to state 598
INFO:root:    entry_decl                     shift and go to state 600
INFO:root:    record_type_spec               shift and go to state 108
INFO:root:    rep_spec                       shift and go to state 601
INFO:root:    address_spec                   shift and go to state 83
INFO:root:    attrib_def                     shift and go to state 92
INFO:root:
INFO:root:state 450
INFO:root:
INFO:root:    (156) mark -> mark . simple_name .
INFO:root:
INFO:root:    USE             reduce using rule 156 (mark -> mark . simple_name .)
INFO:root:    TICK            reduce using rule 156 (mark -> mark . simple_name .)
INFO:root:    .               reduce using rule 156 (mark -> mark . simple_name .)
INFO:root:    ASSIGN          reduce using rule 156 (mark -> mark . simple_name .)
INFO:root:    )               reduce using rule 156 (mark -> mark . simple_name .)
INFO:root:    ;               reduce using rule 156 (mark -> mark . simple_name .)
INFO:root:    AT              reduce using rule 156 (mark -> mark . simple_name .)
INFO:root:
INFO:root:
INFO:root:state 451
INFO:root:
INFO:root:    (494) attrib_def -> FOR mark USE expression . ;
INFO:root:    (189) expression -> expression . logical relation
INFO:root:    (190) expression -> expression . short_circuit relation
INFO:root:    (191) logical -> . AND
INFO:root:    (192) logical -> . OR
INFO:root:    (193) logical -> . XOR
INFO:root:    (194) short_circuit -> . AND THEN
INFO:root:    (195) short_circuit -> . OR ELSE
INFO:root:
INFO:root:    ;               shift and go to state 602
INFO:root:    AND             shift and go to state 215
INFO:root:    OR              shift and go to state 216
INFO:root:    XOR             shift and go to state 214
INFO:root:
INFO:root:    short_circuit                  shift and go to state 212
INFO:root:    logical                        shift and go to state 213
INFO:root:
INFO:root:state 452
INFO:root:
INFO:root:    (500) address_spec -> FOR mark USE AT . expression ;
INFO:root:    (188) expression -> . relation
INFO:root:    (189) expression -> . expression logical relation
INFO:root:    (190) expression -> . expression short_circuit relation
INFO:root:    (196) relation -> . simple_expression
INFO:root:    (197) relation -> . simple_expression relational simple_expression
INFO:root:    (198) relation -> . simple_expression membership range
INFO:root:    (199) relation -> . simple_expression membership name
INFO:root:    (208) simple_expression -> . unary term
INFO:root:    (209) simple_expression -> . term
INFO:root:    (210) simple_expression -> . simple_expression adding term
INFO:root:    (211) unary -> . +
INFO:root:    (212) unary -> . -
INFO:root:    (216) term -> . factor
INFO:root:    (217) term -> . term multiplying factor
INFO:root:    (223) factor -> . primary
INFO:root:    (224) factor -> . NOT primary
INFO:root:    (225) factor -> . ABS primary
INFO:root:    (226) primary -> . literal
INFO:root:    (227) primary -> . name
INFO:root:    (228) primary -> . allocator
INFO:root:    (229) primary -> . qualified
INFO:root:    (230) primary -> . parenthesized_primary
INFO:root:    (180) literal -> . INT
INFO:root:    (181) literal -> . FLOAT
INFO:root:    (182) literal -> . NuLL
INFO:root:    (149) name -> . simple_name
INFO:root:    (150) name -> . indexed_comp
INFO:root:    (151) name -> . selected_comp
INFO:root:    (152) name -> . attribute
INFO:root:    (153) name -> . operator_symbol
INFO:root:    (234) allocator -> . NEW name
INFO:root:    (235) allocator -> . NEW qualified
INFO:root:    (233) qualified -> . name TICK parenthesized_primary
INFO:root:    (231) parenthesized_primary -> . aggregate
INFO:root:    (232) parenthesized_primary -> . ( expression )
INFO:root:    (157) simple_name -> . IDENTIFIER
INFO:root:    (164) indexed_comp -> . name ( value_s )
INFO:root:    (171) selected_comp -> . name . simple_name
INFO:root:    (172) selected_comp -> . name . used_char
INFO:root:    (173) selected_comp -> . name . operator_symbol
INFO:root:    (174) selected_comp -> . name . ALL
INFO:root:    (175) attribute -> . name TICK attribute_id
INFO:root:    (163) operator_symbol -> . STRING
INFO:root:    (183) aggregate -> . ( comp_assoc )
INFO:root:    (184) aggregate -> . ( expression WITH value_s )
INFO:root:    (185) aggregate -> . ( expression WITH NuLL RECORD )
INFO:root:    (186) aggregate -> . ( NuLL RECORD )
INFO:root:
INFO:root:    +               shift and go to state 148
INFO:root:    -               shift and go to state 136
INFO:root:    NOT             shift and go to state 131
INFO:root:    ABS             shift and go to state 132
INFO:root:    INT             shift and go to state 120
INFO:root:    FLOAT           shift and go to state 128
INFO:root:    NuLL            shift and go to state 130
INFO:root:    NEW             shift and go to state 137
INFO:root:    (               shift and go to state 125
INFO:root:    IDENTIFIER      shift and go to state 33
INFO:root:    STRING          shift and go to state 149
INFO:root:
INFO:root:    literal                        shift and go to state 121
INFO:root:    allocator                      shift and go to state 122
INFO:root:    simple_name                    shift and go to state 163
INFO:root:    indexed_comp                   shift and go to state 140
INFO:root:    name                           shift and go to state 142
INFO:root:    selected_comp                  shift and go to state 139
INFO:root:    factor                         shift and go to state 126
INFO:root:    expression                     shift and go to state 603
INFO:root:    unary                          shift and go to state 144
INFO:root:    qualified                      shift and go to state 145
INFO:root:    aggregate                      shift and go to state 143
INFO:root:    simple_expression              shift and go to state 129
INFO:root:    term                           shift and go to state 146
INFO:root:    operator_symbol                shift and go to state 133
INFO:root:    parenthesized_primary          shift and go to state 147
INFO:root:    attribute                      shift and go to state 134
INFO:root:    primary                        shift and go to state 135
INFO:root:    relation                       shift and go to state 138
INFO:root:
INFO:root:state 453
INFO:root:
INFO:root:    (495) record_type_spec -> FOR mark USE RECORD . align_opt comp_loc_s END RECORD ;
INFO:root:    (496) align_opt -> .
INFO:root:    (497) align_opt -> . AT MOD expression ;
INFO:root:
INFO:root:    END             reduce using rule 496 (align_opt -> .)
INFO:root:    IDENTIFIER      reduce using rule 496 (align_opt -> .)
INFO:root:    AT              shift and go to state 604
INFO:root:
INFO:root:    align_opt                      shift and go to state 605
INFO:root:
INFO:root:state 454
INFO:root:
INFO:root:    (155) mark -> mark TICK attribute_id .
INFO:root:
INFO:root:    USE             reduce using rule 155 (mark -> mark TICK attribute_id .)
INFO:root:    TICK            reduce using rule 155 (mark -> mark TICK attribute_id .)
INFO:root:    .               reduce using rule 155 (mark -> mark TICK attribute_id .)
INFO:root:    ASSIGN          reduce using rule 155 (mark -> mark TICK attribute_id .)
INFO:root:    )               reduce using rule 155 (mark -> mark TICK attribute_id .)
INFO:root:    ;               reduce using rule 155 (mark -> mark TICK attribute_id .)
INFO:root:    AT              reduce using rule 155 (mark -> mark TICK attribute_id .)
INFO:root:
INFO:root:
INFO:root:state 455
INFO:root:
INFO:root:    (286) id_opt -> designator .
INFO:root:
INFO:root:    ;               reduce using rule 286 (id_opt -> designator .)
INFO:root:
INFO:root:
INFO:root:state 456
INFO:root:
INFO:root:    (322) subprog_body -> subprog_spec_is_push decl_part block_body END id_opt . ;
INFO:root:
INFO:root:    ;               shift and go to state 606
INFO:root:
INFO:root:
INFO:root:state 457
INFO:root:
INFO:root:    (300) return_stmt -> RETURN expression . ;
INFO:root:    (189) expression -> expression . logical relation
INFO:root:    (190) expression -> expression . short_circuit relation
INFO:root:    (191) logical -> . AND
INFO:root:    (192) logical -> . OR
INFO:root:    (193) logical -> . XOR
INFO:root:    (194) short_circuit -> . AND THEN
INFO:root:    (195) short_circuit -> . OR ELSE
INFO:root:
INFO:root:    ;               shift and go to state 607
INFO:root:    AND             shift and go to state 215
INFO:root:    OR              shift and go to state 216
INFO:root:    XOR             shift and go to state 214
INFO:root:
INFO:root:    short_circuit                  shift and go to state 212
INFO:root:    logical                        shift and go to state 213
INFO:root:
INFO:root:state 458
INFO:root:
INFO:root:    (299) return_stmt -> RETURN ; .
INFO:root:
INFO:root:    LL              reduce using rule 299 (return_stmt -> RETURN ; .)
INFO:root:    error           reduce using rule 299 (return_stmt -> RETURN ; .)
INFO:root:    NuLL            reduce using rule 299 (return_stmt -> RETURN ; .)
INFO:root:    EXIT            reduce using rule 299 (return_stmt -> RETURN ; .)
INFO:root:    RETURN          reduce using rule 299 (return_stmt -> RETURN ; .)
INFO:root:    DELAY           reduce using rule 299 (return_stmt -> RETURN ; .)
INFO:root:    ABORT           reduce using rule 299 (return_stmt -> RETURN ; .)
INFO:root:    RAISE           reduce using rule 299 (return_stmt -> RETURN ; .)
INFO:root:    REQUEUE         reduce using rule 299 (return_stmt -> RETURN ; .)
INFO:root:    IF              reduce using rule 299 (return_stmt -> RETURN ; .)
INFO:root:    CASE            reduce using rule 299 (return_stmt -> RETURN ; .)
INFO:root:    IDENTIFIER      reduce using rule 299 (return_stmt -> RETURN ; .)
INFO:root:    ACCEPT          reduce using rule 299 (return_stmt -> RETURN ; .)
INFO:root:    SELECT          reduce using rule 299 (return_stmt -> RETURN ; .)
INFO:root:    STRING          reduce using rule 299 (return_stmt -> RETURN ; .)
INFO:root:    WHILE           reduce using rule 299 (return_stmt -> RETURN ; .)
INFO:root:    DECLARE         reduce using rule 299 (return_stmt -> RETURN ; .)
INFO:root:    FOR             reduce using rule 299 (return_stmt -> RETURN ; .)
INFO:root:    LOOP            reduce using rule 299 (return_stmt -> RETURN ; .)
INFO:root:    BEGIN           reduce using rule 299 (return_stmt -> RETURN ; .)
INFO:root:    ELSIF           reduce using rule 299 (return_stmt -> RETURN ; .)
INFO:root:    ELSE            reduce using rule 299 (return_stmt -> RETURN ; .)
INFO:root:    END             reduce using rule 299 (return_stmt -> RETURN ; .)
INFO:root:    OR              reduce using rule 299 (return_stmt -> RETURN ; .)
INFO:root:    WHEN            reduce using rule 299 (return_stmt -> RETURN ; .)
INFO:root:    THEN            reduce using rule 299 (return_stmt -> RETURN ; .)
INFO:root:    EXCEPTION       reduce using rule 299 (return_stmt -> RETURN ; .)
INFO:root:
INFO:root:
INFO:root:state 459
INFO:root:
INFO:root:    (393) entry_name -> simple_name .
INFO:root:
INFO:root:    (               reduce using rule 393 (entry_name -> simple_name .)
INFO:root:    ;               reduce using rule 393 (entry_name -> simple_name .)
INFO:root:    DO              reduce using rule 393 (entry_name -> simple_name .)
INFO:root:
INFO:root:
INFO:root:state 460
INFO:root:
INFO:root:    (392) accept_hdr -> ACCEPT entry_name . formal_part_opt
INFO:root:    (394) entry_name -> entry_name . ( expression )
INFO:root:    (309) formal_part_opt -> .
INFO:root:    (310) formal_part_opt -> . formal_part
INFO:root:    (311) formal_part -> . ( param_s )
INFO:root:
INFO:root:    (               shift and go to state 609
INFO:root:    ;               reduce using rule 309 (formal_part_opt -> .)
INFO:root:    DO              reduce using rule 309 (formal_part_opt -> .)
INFO:root:
INFO:root:    formal_part                    shift and go to state 152
INFO:root:    formal_part_opt                shift and go to state 608
INFO:root:
INFO:root:state 461
INFO:root:
INFO:root:    (271) case_hdr -> CASE expression . IS
INFO:root:    (189) expression -> expression . logical relation
INFO:root:    (190) expression -> expression . short_circuit relation
INFO:root:    (191) logical -> . AND
INFO:root:    (192) logical -> . OR
INFO:root:    (193) logical -> . XOR
INFO:root:    (194) short_circuit -> . AND THEN
INFO:root:    (195) short_circuit -> . OR ELSE
INFO:root:
INFO:root:    IS              shift and go to state 610
INFO:root:    AND             shift and go to state 215
INFO:root:    OR              shift and go to state 216
INFO:root:    XOR             shift and go to state 214
INFO:root:
INFO:root:    short_circuit                  shift and go to state 212
INFO:root:    logical                        shift and go to state 213
INFO:root:
INFO:root:state 462
INFO:root:
INFO:root:    (275) loop_stmt -> label_opt iteration . basic_loop id_opt ;
INFO:root:    (284) basic_loop -> . LOOP statement_s END LOOP
INFO:root:
INFO:root:    LOOP            shift and go to state 612
INFO:root:
INFO:root:    basic_loop                     shift and go to state 611
INFO:root:
INFO:root:state 463
INFO:root:
INFO:root:    (287) block -> label_opt block_decl . block_body END id_opt ;
INFO:root:    (290) block_body -> . BEGIN handled_stmt_s
INFO:root:
INFO:root:    BEGIN           shift and go to state 195
INFO:root:
INFO:root:    block_body                     shift and go to state 613
INFO:root:
INFO:root:state 464
INFO:root:
INFO:root:    (281) iter_part -> FOR . IDENTIFIER IN
INFO:root:
INFO:root:    IDENTIFIER      shift and go to state 614
INFO:root:
INFO:root:
INFO:root:state 465
INFO:root:
INFO:root:    (279) iteration -> WHILE . condition
INFO:root:    (267) condition -> . expression
INFO:root:    (188) expression -> . relation
INFO:root:    (189) expression -> . expression logical relation
INFO:root:    (190) expression -> . expression short_circuit relation
INFO:root:    (196) relation -> . simple_expression
INFO:root:    (197) relation -> . simple_expression relational simple_expression
INFO:root:    (198) relation -> . simple_expression membership range
INFO:root:    (199) relation -> . simple_expression membership name
INFO:root:    (208) simple_expression -> . unary term
INFO:root:    (209) simple_expression -> . term
INFO:root:    (210) simple_expression -> . simple_expression adding term
INFO:root:    (211) unary -> . +
INFO:root:    (212) unary -> . -
INFO:root:    (216) term -> . factor
INFO:root:    (217) term -> . term multiplying factor
INFO:root:    (223) factor -> . primary
INFO:root:    (224) factor -> . NOT primary
INFO:root:    (225) factor -> . ABS primary
INFO:root:    (226) primary -> . literal
INFO:root:    (227) primary -> . name
INFO:root:    (228) primary -> . allocator
INFO:root:    (229) primary -> . qualified
INFO:root:    (230) primary -> . parenthesized_primary
INFO:root:    (180) literal -> . INT
INFO:root:    (181) literal -> . FLOAT
INFO:root:    (182) literal -> . NuLL
INFO:root:    (149) name -> . simple_name
INFO:root:    (150) name -> . indexed_comp
INFO:root:    (151) name -> . selected_comp
INFO:root:    (152) name -> . attribute
INFO:root:    (153) name -> . operator_symbol
INFO:root:    (234) allocator -> . NEW name
INFO:root:    (235) allocator -> . NEW qualified
INFO:root:    (233) qualified -> . name TICK parenthesized_primary
INFO:root:    (231) parenthesized_primary -> . aggregate
INFO:root:    (232) parenthesized_primary -> . ( expression )
INFO:root:    (157) simple_name -> . IDENTIFIER
INFO:root:    (164) indexed_comp -> . name ( value_s )
INFO:root:    (171) selected_comp -> . name . simple_name
INFO:root:    (172) selected_comp -> . name . used_char
INFO:root:    (173) selected_comp -> . name . operator_symbol
INFO:root:    (174) selected_comp -> . name . ALL
INFO:root:    (175) attribute -> . name TICK attribute_id
INFO:root:    (163) operator_symbol -> . STRING
INFO:root:    (183) aggregate -> . ( comp_assoc )
INFO:root:    (184) aggregate -> . ( expression WITH value_s )
INFO:root:    (185) aggregate -> . ( expression WITH NuLL RECORD )
INFO:root:    (186) aggregate -> . ( NuLL RECORD )
INFO:root:
INFO:root:    +               shift and go to state 148
INFO:root:    -               shift and go to state 136
INFO:root:    NOT             shift and go to state 131
INFO:root:    ABS             shift and go to state 132
INFO:root:    INT             shift and go to state 120
INFO:root:    FLOAT           shift and go to state 128
INFO:root:    NuLL            shift and go to state 130
INFO:root:    NEW             shift and go to state 137
INFO:root:    (               shift and go to state 125
INFO:root:    IDENTIFIER      shift and go to state 33
INFO:root:    STRING          shift and go to state 149
INFO:root:
INFO:root:    literal                        shift and go to state 121
INFO:root:    allocator                      shift and go to state 122
INFO:root:    simple_name                    shift and go to state 163
INFO:root:    indexed_comp                   shift and go to state 140
INFO:root:    name                           shift and go to state 142
INFO:root:    condition                      shift and go to state 615
INFO:root:    selected_comp                  shift and go to state 139
INFO:root:    factor                         shift and go to state 126
INFO:root:    expression                     shift and go to state 489
INFO:root:    unary                          shift and go to state 144
INFO:root:    qualified                      shift and go to state 145
INFO:root:    aggregate                      shift and go to state 143
INFO:root:    simple_expression              shift and go to state 129
INFO:root:    term                           shift and go to state 146
INFO:root:    operator_symbol                shift and go to state 133
INFO:root:    parenthesized_primary          shift and go to state 147
INFO:root:    attribute                      shift and go to state 134
INFO:root:    primary                        shift and go to state 135
INFO:root:    relation                       shift and go to state 138
INFO:root:
INFO:root:state 466
INFO:root:
INFO:root:    (289) block_decl -> DECLARE . decl_part
INFO:root:    (131) decl_part -> .
INFO:root:    (132) decl_part -> . decl_item_or_body_s1
INFO:root:    (141) decl_item_or_body_s1 -> . decl_item_or_body
INFO:root:    (142) decl_item_or_body_s1 -> . decl_item_or_body_s1 decl_item_or_body
INFO:root:    (143) decl_item_or_body -> . body
INFO:root:    (144) decl_item_or_body -> . decl_item
INFO:root:    (145) body -> . subprog_body
INFO:root:    (146) body -> . pkg_body
INFO:root:    (147) body -> . task_body
INFO:root:    (148) body -> . prot_body
INFO:root:    (137) decl_item -> . decl
INFO:root:    (138) decl_item -> . use_clause
INFO:root:    (139) decl_item -> . rep_spec
INFO:root:    (140) decl_item -> . pragma
INFO:root:    (322) subprog_body -> . subprog_spec_is_push decl_part block_body END id_opt ;
INFO:root:    (331) pkg_body -> . PACKAGE BODY compound_name IS decl_part body_opt END c_id_opt ;
INFO:root:    (356) task_body -> . TASK BODY simple_name IS decl_part block_body END id_opt ;
INFO:root:    (373) prot_body -> . PROTECTED BODY simple_name IS prot_op_body_s END id_opt ;
INFO:root:    (10) decl -> . object_decl
INFO:root:    (11) decl -> . number_decl
INFO:root:    (12) decl -> . type_decl
INFO:root:    (13) decl -> . subtype_decl
INFO:root:    (14) decl -> . subprog_decl
INFO:root:    (15) decl -> . pkg_decl
INFO:root:    (16) decl -> . task_decl
INFO:root:    (17) decl -> . prot_decl
INFO:root:    (18) decl -> . exception_decl
INFO:root:    (19) decl -> . rename_decl
INFO:root:    (20) decl -> . generic_decl
INFO:root:    (21) decl -> . body_stub
INFO:root:    (22) decl -> . error ;
INFO:root:    (337) use_clause -> . USE name_s ;
INFO:root:    (338) use_clause -> . USE TYPE name_s ;
INFO:root:    (491) rep_spec -> . attrib_def
INFO:root:    (492) rep_spec -> . record_type_spec
INFO:root:    (493) rep_spec -> . address_spec
INFO:root:    (2) pragma -> . PRAGMA IDENTIFIER ;
INFO:root:    (3) pragma -> . PRAGMA simple_name ( pragma_arg_s ) ;
INFO:root:    (321) subprog_spec_is_push -> . subprog_spec IS
INFO:root:    (23) object_decl -> . def_id_s : object_qualifier_opt object_subtype_def init_opt ;
INFO:root:    (35) number_decl -> . def_id_s : CONSTANT ASSIGN expression ;
INFO:root:    (36) type_decl -> . TYPE IDENTIFIER discrim_part_opt type_completion ;
INFO:root:    (50) subtype_decl -> . SUBTYPE IDENTIFIER IS subtype_ind ;
INFO:root:    (301) subprog_decl -> . subprog_spec ;
INFO:root:    (302) subprog_decl -> . generic_subp_inst ;
INFO:root:    (303) subprog_decl -> . subprog_spec_is_push ABSTRACT ;
INFO:root:    (324) pkg_decl -> . pkg_spec ;
INFO:root:    (325) pkg_decl -> . generic_pkg_inst ;
INFO:root:    (349) task_decl -> . task_spec ;
INFO:root:    (357) prot_decl -> . prot_spec ;
INFO:root:    (446) exception_decl -> . def_id_s : EXCEPTION ;
INFO:root:    (341) rename_decl -> . def_id_s : object_qualifier_opt subtype_ind renames ;
INFO:root:    (342) rename_decl -> . def_id_s : EXCEPTION renames ;
INFO:root:    (343) rename_decl -> . rename_unit
INFO:root:    (458) generic_decl -> . generic_formal_part subprog_spec ;
INFO:root:    (459) generic_decl -> . generic_formal_part pkg_spec ;
INFO:root:    (442) body_stub -> . TASK BODY simple_name IS SEPARATE ;
INFO:root:    (443) body_stub -> . PACKAGE BODY compound_name IS SEPARATE ;
INFO:root:    (444) body_stub -> . subprog_spec IS SEPARATE ;
INFO:root:    (445) body_stub -> . PROTECTED BODY simple_name IS SEPARATE ;
INFO:root:    (494) attrib_def -> . FOR mark USE expression ;
INFO:root:    (495) record_type_spec -> . FOR mark USE RECORD align_opt comp_loc_s END RECORD ;
INFO:root:    (500) address_spec -> . FOR mark USE AT expression ;
INFO:root:    (304) subprog_spec -> . PROCEDURE compound_name formal_part_opt
INFO:root:    (305) subprog_spec -> . FUNCTION designator formal_part_opt RETURN name
INFO:root:    (306) subprog_spec -> . FUNCTION designator
INFO:root:    (24) def_id_s -> . def_id
INFO:root:    (25) def_id_s -> . def_id_s , def_id
INFO:root:    (488) generic_subp_inst -> . subprog_spec IS generic_inst
INFO:root:    (326) pkg_spec -> . PACKAGE compound_name IS decl_item_s private_part END c_id_opt
INFO:root:    (489) generic_pkg_inst -> . PACKAGE compound_name IS generic_inst
INFO:root:    (350) task_spec -> . TASK simple_name task_def
INFO:root:    (351) task_spec -> . TASK TYPE simple_name discrim_part_opt task_def
INFO:root:    (358) prot_spec -> . PROTECTED IDENTIFIER prot_def
INFO:root:    (359) prot_spec -> . PROTECTED TYPE simple_name discrim_part_opt prot_def
INFO:root:    (344) rename_unit -> . PACKAGE compound_name renames ;
INFO:root:    (345) rename_unit -> . subprog_spec renames ;
INFO:root:    (346) rename_unit -> . generic_formal_part PACKAGE compound_name renames ;
INFO:root:    (347) rename_unit -> . generic_formal_part subprog_spec renames ;
INFO:root:    (460) generic_formal_part -> . GENERIC
INFO:root:    (461) generic_formal_part -> . generic_formal_part generic_formal
INFO:root:    (26) def_id -> . IDENTIFIER
INFO:root:
INFO:root:    BEGIN           reduce using rule 131 (decl_part -> .)
INFO:root:    PACKAGE         shift and go to state 73
INFO:root:    TASK            shift and go to state 84
INFO:root:    PROTECTED       shift and go to state 99
INFO:root:    error           shift and go to state 107
INFO:root:    USE             shift and go to state 53
INFO:root:    PRAGMA          shift and go to state 2
INFO:root:    TYPE            shift and go to state 74
INFO:root:    SUBTYPE         shift and go to state 110
INFO:root:    FOR             shift and go to state 102
INFO:root:    PROCEDURE       shift and go to state 17
INFO:root:    FUNCTION        shift and go to state 23
INFO:root:    GENERIC         shift and go to state 26
INFO:root:    IDENTIFIER      shift and go to state 52
INFO:root:
INFO:root:    generic_formal_part            shift and go to state 20
INFO:root:    pkg_decl                       shift and go to state 93
INFO:root:    pragma                         shift and go to state 94
INFO:root:    generic_pkg_inst               shift and go to state 19
INFO:root:    prot_decl                      shift and go to state 95
INFO:root:    body                           shift and go to state 75
INFO:root:    task_decl                      shift and go to state 76
INFO:root:    generic_decl                   shift and go to state 88
INFO:root:    subprog_decl                   shift and go to state 77
INFO:root:    type_decl                      shift and go to state 81
INFO:root:    def_id_s                       shift and go to state 79
INFO:root:    def_id                         shift and go to state 57
INFO:root:    rep_spec                       shift and go to state 72
INFO:root:    use_clause                     shift and go to state 97
INFO:root:    rename_decl                    shift and go to state 98
INFO:root:    body_stub                      shift and go to state 80
INFO:root:    address_spec                   shift and go to state 83
INFO:root:    task_spec                      shift and go to state 82
INFO:root:    number_decl                    shift and go to state 101
INFO:root:    generic_subp_inst              shift and go to state 24
INFO:root:    decl_item_or_body_s1           shift and go to state 103
INFO:root:    prot_spec                      shift and go to state 85
INFO:root:    rename_unit                    shift and go to state 104
INFO:root:    subprog_spec                   shift and go to state 86
INFO:root:    object_decl                    shift and go to state 87
INFO:root:    subtype_decl                   shift and go to state 105
INFO:root:    task_body                      shift and go to state 96
INFO:root:    prot_body                      shift and go to state 100
INFO:root:    pkg_body                       shift and go to state 90
INFO:root:    decl_part                      shift and go to state 616
INFO:root:    pkg_spec                       shift and go to state 16
INFO:root:    record_type_spec               shift and go to state 108
INFO:root:    decl                           shift and go to state 109
INFO:root:    decl_item                      shift and go to state 78
INFO:root:    exception_decl                 shift and go to state 91
INFO:root:    subprog_body                   shift and go to state 113
INFO:root:    attrib_def                     shift and go to state 92
INFO:root:    subprog_spec_is_push           shift and go to state 111
INFO:root:    decl_item_or_body              shift and go to state 112
INFO:root:
INFO:root:state 467
INFO:root:
INFO:root:    (280) iteration -> iter_part . reverse_opt discrete_range
INFO:root:    (282) reverse_opt -> .
INFO:root:    (283) reverse_opt -> . REVERSE
INFO:root:
INFO:root:    IDENTIFIER      reduce using rule 282 (reverse_opt -> .)
INFO:root:    STRING          reduce using rule 282 (reverse_opt -> .)
INFO:root:    +               reduce using rule 282 (reverse_opt -> .)
INFO:root:    -               reduce using rule 282 (reverse_opt -> .)
INFO:root:    NOT             reduce using rule 282 (reverse_opt -> .)
INFO:root:    ABS             reduce using rule 282 (reverse_opt -> .)
INFO:root:    INT             reduce using rule 282 (reverse_opt -> .)
INFO:root:    FLOAT           reduce using rule 282 (reverse_opt -> .)
INFO:root:    NuLL            reduce using rule 282 (reverse_opt -> .)
INFO:root:    NEW             reduce using rule 282 (reverse_opt -> .)
INFO:root:    (               reduce using rule 282 (reverse_opt -> .)
INFO:root:    REVERSE         shift and go to state 617
INFO:root:
INFO:root:    reverse_opt                    shift and go to state 618
INFO:root:
INFO:root:state 468
INFO:root:
INFO:root:    (296) name_opt -> name .
INFO:root:    (164) indexed_comp -> name . ( value_s )
INFO:root:    (171) selected_comp -> name . . simple_name
INFO:root:    (172) selected_comp -> name . . used_char
INFO:root:    (173) selected_comp -> name . . operator_symbol
INFO:root:    (174) selected_comp -> name . . ALL
INFO:root:    (175) attribute -> name . TICK attribute_id
INFO:root:
INFO:root:    ;               reduce using rule 296 (name_opt -> name .)
INFO:root:    WHEN            reduce using rule 296 (name_opt -> name .)
INFO:root:    (               shift and go to state 237
INFO:root:    .               shift and go to state 239
INFO:root:    TICK            shift and go to state 260
INFO:root:
INFO:root:
INFO:root:state 469
INFO:root:
INFO:root:    (455) raise_stmt -> RAISE name_opt . ;
INFO:root:
INFO:root:    ;               shift and go to state 619
INFO:root:
INFO:root:
INFO:root:state 470
INFO:root:
INFO:root:    (323) procedure_call -> name ; .
INFO:root:
INFO:root:    LL              reduce using rule 323 (procedure_call -> name ; .)
INFO:root:    error           reduce using rule 323 (procedure_call -> name ; .)
INFO:root:    NuLL            reduce using rule 323 (procedure_call -> name ; .)
INFO:root:    EXIT            reduce using rule 323 (procedure_call -> name ; .)
INFO:root:    RETURN          reduce using rule 323 (procedure_call -> name ; .)
INFO:root:    DELAY           reduce using rule 323 (procedure_call -> name ; .)
INFO:root:    ABORT           reduce using rule 323 (procedure_call -> name ; .)
INFO:root:    RAISE           reduce using rule 323 (procedure_call -> name ; .)
INFO:root:    REQUEUE         reduce using rule 323 (procedure_call -> name ; .)
INFO:root:    IF              reduce using rule 323 (procedure_call -> name ; .)
INFO:root:    CASE            reduce using rule 323 (procedure_call -> name ; .)
INFO:root:    IDENTIFIER      reduce using rule 323 (procedure_call -> name ; .)
INFO:root:    ACCEPT          reduce using rule 323 (procedure_call -> name ; .)
INFO:root:    SELECT          reduce using rule 323 (procedure_call -> name ; .)
INFO:root:    STRING          reduce using rule 323 (procedure_call -> name ; .)
INFO:root:    WHILE           reduce using rule 323 (procedure_call -> name ; .)
INFO:root:    DECLARE         reduce using rule 323 (procedure_call -> name ; .)
INFO:root:    FOR             reduce using rule 323 (procedure_call -> name ; .)
INFO:root:    LOOP            reduce using rule 323 (procedure_call -> name ; .)
INFO:root:    BEGIN           reduce using rule 323 (procedure_call -> name ; .)
INFO:root:    OR              reduce using rule 323 (procedure_call -> name ; .)
INFO:root:    ELSE            reduce using rule 323 (procedure_call -> name ; .)
INFO:root:    THEN            reduce using rule 323 (procedure_call -> name ; .)
INFO:root:    END             reduce using rule 323 (procedure_call -> name ; .)
INFO:root:    ELSIF           reduce using rule 323 (procedure_call -> name ; .)
INFO:root:    WHEN            reduce using rule 323 (procedure_call -> name ; .)
INFO:root:    EXCEPTION       reduce using rule 323 (procedure_call -> name ; .)
INFO:root:
INFO:root:
INFO:root:state 471
INFO:root:
INFO:root:    (261) assign_stmt -> name ASSIGN . expression ;
INFO:root:    (188) expression -> . relation
INFO:root:    (189) expression -> . expression logical relation
INFO:root:    (190) expression -> . expression short_circuit relation
INFO:root:    (196) relation -> . simple_expression
INFO:root:    (197) relation -> . simple_expression relational simple_expression
INFO:root:    (198) relation -> . simple_expression membership range
INFO:root:    (199) relation -> . simple_expression membership name
INFO:root:    (208) simple_expression -> . unary term
INFO:root:    (209) simple_expression -> . term
INFO:root:    (210) simple_expression -> . simple_expression adding term
INFO:root:    (211) unary -> . +
INFO:root:    (212) unary -> . -
INFO:root:    (216) term -> . factor
INFO:root:    (217) term -> . term multiplying factor
INFO:root:    (223) factor -> . primary
INFO:root:    (224) factor -> . NOT primary
INFO:root:    (225) factor -> . ABS primary
INFO:root:    (226) primary -> . literal
INFO:root:    (227) primary -> . name
INFO:root:    (228) primary -> . allocator
INFO:root:    (229) primary -> . qualified
INFO:root:    (230) primary -> . parenthesized_primary
INFO:root:    (180) literal -> . INT
INFO:root:    (181) literal -> . FLOAT
INFO:root:    (182) literal -> . NuLL
INFO:root:    (149) name -> . simple_name
INFO:root:    (150) name -> . indexed_comp
INFO:root:    (151) name -> . selected_comp
INFO:root:    (152) name -> . attribute
INFO:root:    (153) name -> . operator_symbol
INFO:root:    (234) allocator -> . NEW name
INFO:root:    (235) allocator -> . NEW qualified
INFO:root:    (233) qualified -> . name TICK parenthesized_primary
INFO:root:    (231) parenthesized_primary -> . aggregate
INFO:root:    (232) parenthesized_primary -> . ( expression )
INFO:root:    (157) simple_name -> . IDENTIFIER
INFO:root:    (164) indexed_comp -> . name ( value_s )
INFO:root:    (171) selected_comp -> . name . simple_name
INFO:root:    (172) selected_comp -> . name . used_char
INFO:root:    (173) selected_comp -> . name . operator_symbol
INFO:root:    (174) selected_comp -> . name . ALL
INFO:root:    (175) attribute -> . name TICK attribute_id
INFO:root:    (163) operator_symbol -> . STRING
INFO:root:    (183) aggregate -> . ( comp_assoc )
INFO:root:    (184) aggregate -> . ( expression WITH value_s )
INFO:root:    (185) aggregate -> . ( expression WITH NuLL RECORD )
INFO:root:    (186) aggregate -> . ( NuLL RECORD )
INFO:root:
INFO:root:    +               shift and go to state 148
INFO:root:    -               shift and go to state 136
INFO:root:    NOT             shift and go to state 131
INFO:root:    ABS             shift and go to state 132
INFO:root:    INT             shift and go to state 120
INFO:root:    FLOAT           shift and go to state 128
INFO:root:    NuLL            shift and go to state 130
INFO:root:    NEW             shift and go to state 137
INFO:root:    (               shift and go to state 125
INFO:root:    IDENTIFIER      shift and go to state 33
INFO:root:    STRING          shift and go to state 149
INFO:root:
INFO:root:    literal                        shift and go to state 121
INFO:root:    allocator                      shift and go to state 122
INFO:root:    simple_name                    shift and go to state 163
INFO:root:    indexed_comp                   shift and go to state 140
INFO:root:    name                           shift and go to state 142
INFO:root:    selected_comp                  shift and go to state 139
INFO:root:    factor                         shift and go to state 126
INFO:root:    expression                     shift and go to state 620
INFO:root:    unary                          shift and go to state 144
INFO:root:    qualified                      shift and go to state 145
INFO:root:    aggregate                      shift and go to state 143
INFO:root:    simple_expression              shift and go to state 129
INFO:root:    term                           shift and go to state 146
INFO:root:    operator_symbol                shift and go to state 133
INFO:root:    parenthesized_primary          shift and go to state 147
INFO:root:    attribute                      shift and go to state 134
INFO:root:    primary                        shift and go to state 135
INFO:root:    relation                       shift and go to state 138
INFO:root:
INFO:root:state 472
INFO:root:
INFO:root:    (456) requeue_stmt -> REQUEUE name . ;
INFO:root:    (457) requeue_stmt -> REQUEUE name . WITH ABORT ;
INFO:root:    (164) indexed_comp -> name . ( value_s )
INFO:root:    (171) selected_comp -> name . . simple_name
INFO:root:    (172) selected_comp -> name . . used_char
INFO:root:    (173) selected_comp -> name . . operator_symbol
INFO:root:    (174) selected_comp -> name . . ALL
INFO:root:    (175) attribute -> name . TICK attribute_id
INFO:root:
INFO:root:    ;               shift and go to state 622
INFO:root:    WITH            shift and go to state 621
INFO:root:    (               shift and go to state 237
INFO:root:    .               shift and go to state 239
INFO:root:    TICK            shift and go to state 260
INFO:root:
INFO:root:
INFO:root:state 473
INFO:root:
INFO:root:    (391) accept_stmt -> accept_hdr DO . handled_stmt_s END id_opt ;
INFO:root:    (291) handled_stmt_s -> . statement_s except_handler_part_opt
INFO:root:    (236) statement_s -> . statement
INFO:root:    (237) statement_s -> . statement_s statement
INFO:root:    (238) statement -> . unlabeled
INFO:root:    (239) statement -> . label statement
INFO:root:    (240) unlabeled -> . simple_stmt
INFO:root:    (241) unlabeled -> . compound_stmt
INFO:root:    (259) label -> . LL IDENTIFIER RR
INFO:root:    (242) simple_stmt -> . null_stmt
INFO:root:    (243) simple_stmt -> . assign_stmt
INFO:root:    (244) simple_stmt -> . exit_stmt
INFO:root:    (245) simple_stmt -> . return_stmt
INFO:root:    (246) simple_stmt -> . procedure_call
INFO:root:    (247) simple_stmt -> . delay_stmt
INFO:root:    (248) simple_stmt -> . abort_stmt
INFO:root:    (249) simple_stmt -> . raise_stmt
INFO:root:    (250) simple_stmt -> . code_stmt
INFO:root:    (251) simple_stmt -> . requeue_stmt
INFO:root:    (252) simple_stmt -> . error ;
INFO:root:    (253) compound_stmt -> . if_stmt
INFO:root:    (254) compound_stmt -> . case_stmt
INFO:root:    (255) compound_stmt -> . loop_stmt
INFO:root:    (256) compound_stmt -> . block
INFO:root:    (257) compound_stmt -> . accept_stmt
INFO:root:    (258) compound_stmt -> . select_stmt
INFO:root:    (260) null_stmt -> . NuLL ;
INFO:root:    (261) assign_stmt -> . name ASSIGN expression ;
INFO:root:    (294) exit_stmt -> . EXIT name_opt when_opt ;
INFO:root:    (299) return_stmt -> . RETURN ;
INFO:root:    (300) return_stmt -> . RETURN expression ;
INFO:root:    (323) procedure_call -> . name ;
INFO:root:    (395) delay_stmt -> . DELAY expression ;
INFO:root:    (396) delay_stmt -> . DELAY UNTIL expression ;
INFO:root:    (416) abort_stmt -> . ABORT name_s ;
INFO:root:    (455) raise_stmt -> . RAISE name_opt ;
INFO:root:    (501) code_stmt -> . qualified ;
INFO:root:    (456) requeue_stmt -> . REQUEUE name ;
INFO:root:    (457) requeue_stmt -> . REQUEUE name WITH ABORT ;
INFO:root:    (262) if_stmt -> . IF cond_clause_s else_opt END IF ;
INFO:root:    (270) case_stmt -> . case_hdr pragma_s alternative_s END CASE ;
INFO:root:    (275) loop_stmt -> . label_opt iteration basic_loop id_opt ;
INFO:root:    (287) block -> . label_opt block_decl block_body END id_opt ;
INFO:root:    (390) accept_stmt -> . accept_hdr ;
INFO:root:    (391) accept_stmt -> . accept_hdr DO handled_stmt_s END id_opt ;
INFO:root:    (397) select_stmt -> . select_wait
INFO:root:    (398) select_stmt -> . async_select
INFO:root:    (399) select_stmt -> . timed_entry_call
INFO:root:    (400) select_stmt -> . cond_entry_call
INFO:root:    (149) name -> . simple_name
INFO:root:    (150) name -> . indexed_comp
INFO:root:    (151) name -> . selected_comp
INFO:root:    (152) name -> . attribute
INFO:root:    (153) name -> . operator_symbol
INFO:root:    (233) qualified -> . name TICK parenthesized_primary
INFO:root:    (271) case_hdr -> . CASE expression IS
INFO:root:    (276) label_opt -> .
INFO:root:    (277) label_opt -> . IDENTIFIER :
INFO:root:    (392) accept_hdr -> . ACCEPT entry_name formal_part_opt
INFO:root:    (401) select_wait -> . SELECT guarded_select_alt or_select else_opt END SELECT ;
INFO:root:    (411) async_select -> . SELECT delay_or_entry_alt THEN ABORT statement_s END SELECT ;
INFO:root:    (412) timed_entry_call -> . SELECT entry_call stmts_opt OR delay_stmt stmts_opt END SELECT ;
INFO:root:    (413) cond_entry_call -> . SELECT entry_call stmts_opt ELSE statement_s END SELECT ;
INFO:root:    (157) simple_name -> . IDENTIFIER
INFO:root:    (164) indexed_comp -> . name ( value_s )
INFO:root:    (171) selected_comp -> . name . simple_name
INFO:root:    (172) selected_comp -> . name . used_char
INFO:root:    (173) selected_comp -> . name . operator_symbol
INFO:root:    (174) selected_comp -> . name . ALL
INFO:root:    (175) attribute -> . name TICK attribute_id
INFO:root:    (163) operator_symbol -> . STRING
INFO:root:
INFO:root:    LL              shift and go to state 344
INFO:root:    error           shift and go to state 341
INFO:root:    NuLL            shift and go to state 347
INFO:root:    EXIT            shift and go to state 340
INFO:root:    RETURN          shift and go to state 303
INFO:root:    DELAY           shift and go to state 332
INFO:root:    ABORT           shift and go to state 326
INFO:root:    RAISE           shift and go to state 314
INFO:root:    REQUEUE         shift and go to state 317
INFO:root:    IF              shift and go to state 327
INFO:root:    CASE            shift and go to state 312
INFO:root:    WHILE           reduce using rule 276 (label_opt -> .)
INFO:root:    DECLARE         reduce using rule 276 (label_opt -> .)
INFO:root:    FOR             reduce using rule 276 (label_opt -> .)
INFO:root:    LOOP            reduce using rule 276 (label_opt -> .)
INFO:root:    BEGIN           reduce using rule 276 (label_opt -> .)
INFO:root:    IDENTIFIER      shift and go to state 322
INFO:root:    ACCEPT          shift and go to state 310
INFO:root:    SELECT          shift and go to state 320
INFO:root:    STRING          shift and go to state 149
INFO:root:
INFO:root:    cond_entry_call                shift and go to state 345
INFO:root:    simple_stmt                    shift and go to state 302
INFO:root:    async_select                   shift and go to state 328
INFO:root:    simple_name                    shift and go to state 163
INFO:root:    requeue_stmt                   shift and go to state 329
INFO:root:    abort_stmt                     shift and go to state 315
INFO:root:    if_stmt                        shift and go to state 304
INFO:root:    procedure_call                 shift and go to state 305
INFO:root:    select_wait                    shift and go to state 330
INFO:root:    indexed_comp                   shift and go to state 140
INFO:root:    timed_entry_call               shift and go to state 307
INFO:root:    statement                      shift and go to state 308
INFO:root:    operator_symbol                shift and go to state 133
INFO:root:    exit_stmt                      shift and go to state 306
INFO:root:    code_stmt                      shift and go to state 331
INFO:root:    loop_stmt                      shift and go to state 333
INFO:root:    null_stmt                      shift and go to state 334
INFO:root:    label                          shift and go to state 335
INFO:root:    select_stmt                    shift and go to state 311
INFO:root:    label_opt                      shift and go to state 313
INFO:root:    assign_stmt                    shift and go to state 336
INFO:root:    selected_comp                  shift and go to state 139
INFO:root:    attribute                      shift and go to state 134
INFO:root:    name                           shift and go to state 316
INFO:root:    accept_hdr                     shift and go to state 318
INFO:root:    accept_stmt                    shift and go to state 337
INFO:root:    case_hdr                       shift and go to state 319
INFO:root:    delay_stmt                     shift and go to state 338
INFO:root:    statement_s                    shift and go to state 339
INFO:root:    compound_stmt                  shift and go to state 309
INFO:root:    raise_stmt                     shift and go to state 342
INFO:root:    qualified                      shift and go to state 321
INFO:root:    return_stmt                    shift and go to state 323
INFO:root:    case_stmt                      shift and go to state 324
INFO:root:    block                          shift and go to state 325
INFO:root:    handled_stmt_s                 shift and go to state 623
INFO:root:    unlabeled                      shift and go to state 346
INFO:root:
INFO:root:state 474
INFO:root:
INFO:root:    (390) accept_stmt -> accept_hdr ; .
INFO:root:
INFO:root:    END             reduce using rule 390 (accept_stmt -> accept_hdr ; .)
INFO:root:    LL              reduce using rule 390 (accept_stmt -> accept_hdr ; .)
INFO:root:    error           reduce using rule 390 (accept_stmt -> accept_hdr ; .)
INFO:root:    NuLL            reduce using rule 390 (accept_stmt -> accept_hdr ; .)
INFO:root:    EXIT            reduce using rule 390 (accept_stmt -> accept_hdr ; .)
INFO:root:    RETURN          reduce using rule 390 (accept_stmt -> accept_hdr ; .)
INFO:root:    DELAY           reduce using rule 390 (accept_stmt -> accept_hdr ; .)
INFO:root:    ABORT           reduce using rule 390 (accept_stmt -> accept_hdr ; .)
INFO:root:    RAISE           reduce using rule 390 (accept_stmt -> accept_hdr ; .)
INFO:root:    REQUEUE         reduce using rule 390 (accept_stmt -> accept_hdr ; .)
INFO:root:    IF              reduce using rule 390 (accept_stmt -> accept_hdr ; .)
INFO:root:    CASE            reduce using rule 390 (accept_stmt -> accept_hdr ; .)
INFO:root:    IDENTIFIER      reduce using rule 390 (accept_stmt -> accept_hdr ; .)
INFO:root:    ACCEPT          reduce using rule 390 (accept_stmt -> accept_hdr ; .)
INFO:root:    SELECT          reduce using rule 390 (accept_stmt -> accept_hdr ; .)
INFO:root:    STRING          reduce using rule 390 (accept_stmt -> accept_hdr ; .)
INFO:root:    WHILE           reduce using rule 390 (accept_stmt -> accept_hdr ; .)
INFO:root:    DECLARE         reduce using rule 390 (accept_stmt -> accept_hdr ; .)
INFO:root:    FOR             reduce using rule 390 (accept_stmt -> accept_hdr ; .)
INFO:root:    LOOP            reduce using rule 390 (accept_stmt -> accept_hdr ; .)
INFO:root:    BEGIN           reduce using rule 390 (accept_stmt -> accept_hdr ; .)
INFO:root:    OR              reduce using rule 390 (accept_stmt -> accept_hdr ; .)
INFO:root:    ELSE            reduce using rule 390 (accept_stmt -> accept_hdr ; .)
INFO:root:    EXCEPTION       reduce using rule 390 (accept_stmt -> accept_hdr ; .)
INFO:root:    WHEN            reduce using rule 390 (accept_stmt -> accept_hdr ; .)
INFO:root:    THEN            reduce using rule 390 (accept_stmt -> accept_hdr ; .)
INFO:root:    ELSIF           reduce using rule 390 (accept_stmt -> accept_hdr ; .)
INFO:root:
INFO:root:
INFO:root:state 475
INFO:root:
INFO:root:    (270) case_stmt -> case_hdr pragma_s . alternative_s END CASE ;
INFO:root:    (9) pragma_s -> pragma_s . pragma
INFO:root:    (272) alternative_s -> .
INFO:root:    (273) alternative_s -> . alternative_s alternative
INFO:root:    (2) pragma -> . PRAGMA IDENTIFIER ;
INFO:root:    (3) pragma -> . PRAGMA simple_name ( pragma_arg_s ) ;
INFO:root:
INFO:root:    END             reduce using rule 272 (alternative_s -> .)
INFO:root:    WHEN            reduce using rule 272 (alternative_s -> .)
INFO:root:    PRAGMA          shift and go to state 2
INFO:root:
INFO:root:    alternative_s                  shift and go to state 624
INFO:root:    pragma                         shift and go to state 43
INFO:root:
INFO:root:state 476
INFO:root:
INFO:root:    (412) timed_entry_call -> SELECT entry_call . stmts_opt OR delay_stmt stmts_opt END SELECT ;
INFO:root:    (413) cond_entry_call -> SELECT entry_call . stmts_opt ELSE statement_s END SELECT ;
INFO:root:    (410) delay_or_entry_alt -> entry_call . stmts_opt
INFO:root:    (414) stmts_opt -> .
INFO:root:    (415) stmts_opt -> . statement_s
INFO:root:    (236) statement_s -> . statement
INFO:root:    (237) statement_s -> . statement_s statement
INFO:root:    (238) statement -> . unlabeled
INFO:root:    (239) statement -> . label statement
INFO:root:    (240) unlabeled -> . simple_stmt
INFO:root:    (241) unlabeled -> . compound_stmt
INFO:root:    (259) label -> . LL IDENTIFIER RR
INFO:root:    (242) simple_stmt -> . null_stmt
INFO:root:    (243) simple_stmt -> . assign_stmt
INFO:root:    (244) simple_stmt -> . exit_stmt
INFO:root:    (245) simple_stmt -> . return_stmt
INFO:root:    (246) simple_stmt -> . procedure_call
INFO:root:    (247) simple_stmt -> . delay_stmt
INFO:root:    (248) simple_stmt -> . abort_stmt
INFO:root:    (249) simple_stmt -> . raise_stmt
INFO:root:    (250) simple_stmt -> . code_stmt
INFO:root:    (251) simple_stmt -> . requeue_stmt
INFO:root:    (252) simple_stmt -> . error ;
INFO:root:    (253) compound_stmt -> . if_stmt
INFO:root:    (254) compound_stmt -> . case_stmt
INFO:root:    (255) compound_stmt -> . loop_stmt
INFO:root:    (256) compound_stmt -> . block
INFO:root:    (257) compound_stmt -> . accept_stmt
INFO:root:    (258) compound_stmt -> . select_stmt
INFO:root:    (260) null_stmt -> . NuLL ;
INFO:root:    (261) assign_stmt -> . name ASSIGN expression ;
INFO:root:    (294) exit_stmt -> . EXIT name_opt when_opt ;
INFO:root:    (299) return_stmt -> . RETURN ;
INFO:root:    (300) return_stmt -> . RETURN expression ;
INFO:root:    (323) procedure_call -> . name ;
INFO:root:    (395) delay_stmt -> . DELAY expression ;
INFO:root:    (396) delay_stmt -> . DELAY UNTIL expression ;
INFO:root:    (416) abort_stmt -> . ABORT name_s ;
INFO:root:    (455) raise_stmt -> . RAISE name_opt ;
INFO:root:    (501) code_stmt -> . qualified ;
INFO:root:    (456) requeue_stmt -> . REQUEUE name ;
INFO:root:    (457) requeue_stmt -> . REQUEUE name WITH ABORT ;
INFO:root:    (262) if_stmt -> . IF cond_clause_s else_opt END IF ;
INFO:root:    (270) case_stmt -> . case_hdr pragma_s alternative_s END CASE ;
INFO:root:    (275) loop_stmt -> . label_opt iteration basic_loop id_opt ;
INFO:root:    (287) block -> . label_opt block_decl block_body END id_opt ;
INFO:root:    (390) accept_stmt -> . accept_hdr ;
INFO:root:    (391) accept_stmt -> . accept_hdr DO handled_stmt_s END id_opt ;
INFO:root:    (397) select_stmt -> . select_wait
INFO:root:    (398) select_stmt -> . async_select
INFO:root:    (399) select_stmt -> . timed_entry_call
INFO:root:    (400) select_stmt -> . cond_entry_call
INFO:root:    (149) name -> . simple_name
INFO:root:    (150) name -> . indexed_comp
INFO:root:    (151) name -> . selected_comp
INFO:root:    (152) name -> . attribute
INFO:root:    (153) name -> . operator_symbol
INFO:root:    (233) qualified -> . name TICK parenthesized_primary
INFO:root:    (271) case_hdr -> . CASE expression IS
INFO:root:    (276) label_opt -> .
INFO:root:    (277) label_opt -> . IDENTIFIER :
INFO:root:    (392) accept_hdr -> . ACCEPT entry_name formal_part_opt
INFO:root:    (401) select_wait -> . SELECT guarded_select_alt or_select else_opt END SELECT ;
INFO:root:    (411) async_select -> . SELECT delay_or_entry_alt THEN ABORT statement_s END SELECT ;
INFO:root:    (412) timed_entry_call -> . SELECT entry_call stmts_opt OR delay_stmt stmts_opt END SELECT ;
INFO:root:    (413) cond_entry_call -> . SELECT entry_call stmts_opt ELSE statement_s END SELECT ;
INFO:root:    (157) simple_name -> . IDENTIFIER
INFO:root:    (164) indexed_comp -> . name ( value_s )
INFO:root:    (171) selected_comp -> . name . simple_name
INFO:root:    (172) selected_comp -> . name . used_char
INFO:root:    (173) selected_comp -> . name . operator_symbol
INFO:root:    (174) selected_comp -> . name . ALL
INFO:root:    (175) attribute -> . name TICK attribute_id
INFO:root:    (163) operator_symbol -> . STRING
INFO:root:
INFO:root:    OR              reduce using rule 414 (stmts_opt -> .)
INFO:root:    ELSE            reduce using rule 414 (stmts_opt -> .)
INFO:root:    THEN            reduce using rule 414 (stmts_opt -> .)
INFO:root:    LL              shift and go to state 344
INFO:root:    error           shift and go to state 341
INFO:root:    NuLL            shift and go to state 347
INFO:root:    EXIT            shift and go to state 340
INFO:root:    RETURN          shift and go to state 303
INFO:root:    DELAY           shift and go to state 332
INFO:root:    ABORT           shift and go to state 326
INFO:root:    RAISE           shift and go to state 314
INFO:root:    REQUEUE         shift and go to state 317
INFO:root:    IF              shift and go to state 327
INFO:root:    CASE            shift and go to state 312
INFO:root:    WHILE           reduce using rule 276 (label_opt -> .)
INFO:root:    DECLARE         reduce using rule 276 (label_opt -> .)
INFO:root:    FOR             reduce using rule 276 (label_opt -> .)
INFO:root:    LOOP            reduce using rule 276 (label_opt -> .)
INFO:root:    BEGIN           reduce using rule 276 (label_opt -> .)
INFO:root:    IDENTIFIER      shift and go to state 322
INFO:root:    ACCEPT          shift and go to state 310
INFO:root:    SELECT          shift and go to state 320
INFO:root:    STRING          shift and go to state 149
INFO:root:
INFO:root:    cond_entry_call                shift and go to state 345
INFO:root:    simple_stmt                    shift and go to state 302
INFO:root:    async_select                   shift and go to state 328
INFO:root:    selected_comp                  shift and go to state 139
INFO:root:    simple_name                    shift and go to state 163
INFO:root:    requeue_stmt                   shift and go to state 329
INFO:root:    if_stmt                        shift and go to state 304
INFO:root:    procedure_call                 shift and go to state 305
INFO:root:    exit_stmt                      shift and go to state 306
INFO:root:    timed_entry_call               shift and go to state 307
INFO:root:    statement                      shift and go to state 308
INFO:root:    operator_symbol                shift and go to state 133
INFO:root:    code_stmt                      shift and go to state 331
INFO:root:    loop_stmt                      shift and go to state 333
INFO:root:    null_stmt                      shift and go to state 334
INFO:root:    label                          shift and go to state 335
INFO:root:    select_stmt                    shift and go to state 311
INFO:root:    label_opt                      shift and go to state 313
INFO:root:    assign_stmt                    shift and go to state 336
INFO:root:    select_wait                    shift and go to state 330
INFO:root:    abort_stmt                     shift and go to state 315
INFO:root:    attribute                      shift and go to state 134
INFO:root:    name                           shift and go to state 316
INFO:root:    accept_hdr                     shift and go to state 318
INFO:root:    accept_stmt                    shift and go to state 337
INFO:root:    case_hdr                       shift and go to state 319
INFO:root:    delay_stmt                     shift and go to state 338
INFO:root:    statement_s                    shift and go to state 626
INFO:root:    compound_stmt                  shift and go to state 309
INFO:root:    raise_stmt                     shift and go to state 342
INFO:root:    qualified                      shift and go to state 321
INFO:root:    return_stmt                    shift and go to state 323
INFO:root:    stmts_opt                      shift and go to state 625
INFO:root:    case_stmt                      shift and go to state 324
INFO:root:    block                          shift and go to state 325
INFO:root:    indexed_comp                   shift and go to state 140
INFO:root:    unlabeled                      shift and go to state 346
INFO:root:
INFO:root:state 477
INFO:root:
INFO:root:    (389) entry_call -> procedure_call .
INFO:root:
INFO:root:    LL              reduce using rule 389 (entry_call -> procedure_call .)
INFO:root:    error           reduce using rule 389 (entry_call -> procedure_call .)
INFO:root:    NuLL            reduce using rule 389 (entry_call -> procedure_call .)
INFO:root:    EXIT            reduce using rule 389 (entry_call -> procedure_call .)
INFO:root:    RETURN          reduce using rule 389 (entry_call -> procedure_call .)
INFO:root:    DELAY           reduce using rule 389 (entry_call -> procedure_call .)
INFO:root:    ABORT           reduce using rule 389 (entry_call -> procedure_call .)
INFO:root:    RAISE           reduce using rule 389 (entry_call -> procedure_call .)
INFO:root:    REQUEUE         reduce using rule 389 (entry_call -> procedure_call .)
INFO:root:    IF              reduce using rule 389 (entry_call -> procedure_call .)
INFO:root:    CASE            reduce using rule 389 (entry_call -> procedure_call .)
INFO:root:    IDENTIFIER      reduce using rule 389 (entry_call -> procedure_call .)
INFO:root:    ACCEPT          reduce using rule 389 (entry_call -> procedure_call .)
INFO:root:    SELECT          reduce using rule 389 (entry_call -> procedure_call .)
INFO:root:    STRING          reduce using rule 389 (entry_call -> procedure_call .)
INFO:root:    OR              reduce using rule 389 (entry_call -> procedure_call .)
INFO:root:    ELSE            reduce using rule 389 (entry_call -> procedure_call .)
INFO:root:    WHILE           reduce using rule 389 (entry_call -> procedure_call .)
INFO:root:    DECLARE         reduce using rule 389 (entry_call -> procedure_call .)
INFO:root:    FOR             reduce using rule 389 (entry_call -> procedure_call .)
INFO:root:    LOOP            reduce using rule 389 (entry_call -> procedure_call .)
INFO:root:    BEGIN           reduce using rule 389 (entry_call -> procedure_call .)
INFO:root:    THEN            reduce using rule 389 (entry_call -> procedure_call .)
INFO:root:
INFO:root:
INFO:root:state 478
INFO:root:
INFO:root:    (401) select_wait -> SELECT guarded_select_alt . or_select else_opt END SELECT ;
INFO:root:    (404) or_select -> .
INFO:root:    (405) or_select -> . or_select OR guarded_select_alt
INFO:root:
INFO:root:    OR              reduce using rule 404 (or_select -> .)
INFO:root:    ELSE            reduce using rule 404 (or_select -> .)
INFO:root:    END             reduce using rule 404 (or_select -> .)
INFO:root:
INFO:root:    or_select                      shift and go to state 627
INFO:root:
INFO:root:state 479
INFO:root:
INFO:root:    (408) select_alt -> TERMINATE . ;
INFO:root:
INFO:root:    ;               shift and go to state 628
INFO:root:
INFO:root:
INFO:root:state 480
INFO:root:
INFO:root:    (411) async_select -> SELECT delay_or_entry_alt . THEN ABORT statement_s END SELECT ;
INFO:root:
INFO:root:    THEN            shift and go to state 629
INFO:root:
INFO:root:
INFO:root:state 481
INFO:root:
INFO:root:    (323) procedure_call -> name . ;
INFO:root:    (164) indexed_comp -> name . ( value_s )
INFO:root:    (171) selected_comp -> name . . simple_name
INFO:root:    (172) selected_comp -> name . . used_char
INFO:root:    (173) selected_comp -> name . . operator_symbol
INFO:root:    (174) selected_comp -> name . . ALL
INFO:root:    (175) attribute -> name . TICK attribute_id
INFO:root:
INFO:root:    ;               shift and go to state 470
INFO:root:    (               shift and go to state 237
INFO:root:    .               shift and go to state 239
INFO:root:    TICK            shift and go to state 260
INFO:root:
INFO:root:
INFO:root:state 482
INFO:root:
INFO:root:    (406) select_alt -> accept_stmt . stmts_opt
INFO:root:    (414) stmts_opt -> .
INFO:root:    (415) stmts_opt -> . statement_s
INFO:root:    (236) statement_s -> . statement
INFO:root:    (237) statement_s -> . statement_s statement
INFO:root:    (238) statement -> . unlabeled
INFO:root:    (239) statement -> . label statement
INFO:root:    (240) unlabeled -> . simple_stmt
INFO:root:    (241) unlabeled -> . compound_stmt
INFO:root:    (259) label -> . LL IDENTIFIER RR
INFO:root:    (242) simple_stmt -> . null_stmt
INFO:root:    (243) simple_stmt -> . assign_stmt
INFO:root:    (244) simple_stmt -> . exit_stmt
INFO:root:    (245) simple_stmt -> . return_stmt
INFO:root:    (246) simple_stmt -> . procedure_call
INFO:root:    (247) simple_stmt -> . delay_stmt
INFO:root:    (248) simple_stmt -> . abort_stmt
INFO:root:    (249) simple_stmt -> . raise_stmt
INFO:root:    (250) simple_stmt -> . code_stmt
INFO:root:    (251) simple_stmt -> . requeue_stmt
INFO:root:    (252) simple_stmt -> . error ;
INFO:root:    (253) compound_stmt -> . if_stmt
INFO:root:    (254) compound_stmt -> . case_stmt
INFO:root:    (255) compound_stmt -> . loop_stmt
INFO:root:    (256) compound_stmt -> . block
INFO:root:    (257) compound_stmt -> . accept_stmt
INFO:root:    (258) compound_stmt -> . select_stmt
INFO:root:    (260) null_stmt -> . NuLL ;
INFO:root:    (261) assign_stmt -> . name ASSIGN expression ;
INFO:root:    (294) exit_stmt -> . EXIT name_opt when_opt ;
INFO:root:    (299) return_stmt -> . RETURN ;
INFO:root:    (300) return_stmt -> . RETURN expression ;
INFO:root:    (323) procedure_call -> . name ;
INFO:root:    (395) delay_stmt -> . DELAY expression ;
INFO:root:    (396) delay_stmt -> . DELAY UNTIL expression ;
INFO:root:    (416) abort_stmt -> . ABORT name_s ;
INFO:root:    (455) raise_stmt -> . RAISE name_opt ;
INFO:root:    (501) code_stmt -> . qualified ;
INFO:root:    (456) requeue_stmt -> . REQUEUE name ;
INFO:root:    (457) requeue_stmt -> . REQUEUE name WITH ABORT ;
INFO:root:    (262) if_stmt -> . IF cond_clause_s else_opt END IF ;
INFO:root:    (270) case_stmt -> . case_hdr pragma_s alternative_s END CASE ;
INFO:root:    (275) loop_stmt -> . label_opt iteration basic_loop id_opt ;
INFO:root:    (287) block -> . label_opt block_decl block_body END id_opt ;
INFO:root:    (390) accept_stmt -> . accept_hdr ;
INFO:root:    (391) accept_stmt -> . accept_hdr DO handled_stmt_s END id_opt ;
INFO:root:    (397) select_stmt -> . select_wait
INFO:root:    (398) select_stmt -> . async_select
INFO:root:    (399) select_stmt -> . timed_entry_call
INFO:root:    (400) select_stmt -> . cond_entry_call
INFO:root:    (149) name -> . simple_name
INFO:root:    (150) name -> . indexed_comp
INFO:root:    (151) name -> . selected_comp
INFO:root:    (152) name -> . attribute
INFO:root:    (153) name -> . operator_symbol
INFO:root:    (233) qualified -> . name TICK parenthesized_primary
INFO:root:    (271) case_hdr -> . CASE expression IS
INFO:root:    (276) label_opt -> .
INFO:root:    (277) label_opt -> . IDENTIFIER :
INFO:root:    (392) accept_hdr -> . ACCEPT entry_name formal_part_opt
INFO:root:    (401) select_wait -> . SELECT guarded_select_alt or_select else_opt END SELECT ;
INFO:root:    (411) async_select -> . SELECT delay_or_entry_alt THEN ABORT statement_s END SELECT ;
INFO:root:    (412) timed_entry_call -> . SELECT entry_call stmts_opt OR delay_stmt stmts_opt END SELECT ;
INFO:root:    (413) cond_entry_call -> . SELECT entry_call stmts_opt ELSE statement_s END SELECT ;
INFO:root:    (157) simple_name -> . IDENTIFIER
INFO:root:    (164) indexed_comp -> . name ( value_s )
INFO:root:    (171) selected_comp -> . name . simple_name
INFO:root:    (172) selected_comp -> . name . used_char
INFO:root:    (173) selected_comp -> . name . operator_symbol
INFO:root:    (174) selected_comp -> . name . ALL
INFO:root:    (175) attribute -> . name TICK attribute_id
INFO:root:    (163) operator_symbol -> . STRING
INFO:root:
INFO:root:    OR              reduce using rule 414 (stmts_opt -> .)
INFO:root:    ELSE            reduce using rule 414 (stmts_opt -> .)
INFO:root:    END             reduce using rule 414 (stmts_opt -> .)
INFO:root:    LL              shift and go to state 344
INFO:root:    error           shift and go to state 341
INFO:root:    NuLL            shift and go to state 347
INFO:root:    EXIT            shift and go to state 340
INFO:root:    RETURN          shift and go to state 303
INFO:root:    DELAY           shift and go to state 332
INFO:root:    ABORT           shift and go to state 326
INFO:root:    RAISE           shift and go to state 314
INFO:root:    REQUEUE         shift and go to state 317
INFO:root:    IF              shift and go to state 327
INFO:root:    CASE            shift and go to state 312
INFO:root:    WHILE           reduce using rule 276 (label_opt -> .)
INFO:root:    DECLARE         reduce using rule 276 (label_opt -> .)
INFO:root:    FOR             reduce using rule 276 (label_opt -> .)
INFO:root:    LOOP            reduce using rule 276 (label_opt -> .)
INFO:root:    BEGIN           reduce using rule 276 (label_opt -> .)
INFO:root:    IDENTIFIER      shift and go to state 322
INFO:root:    ACCEPT          shift and go to state 310
INFO:root:    SELECT          shift and go to state 320
INFO:root:    STRING          shift and go to state 149
INFO:root:
INFO:root:    cond_entry_call                shift and go to state 345
INFO:root:    simple_stmt                    shift and go to state 302
INFO:root:    async_select                   shift and go to state 328
INFO:root:    simple_name                    shift and go to state 163
INFO:root:    requeue_stmt                   shift and go to state 329
INFO:root:    if_stmt                        shift and go to state 304
INFO:root:    procedure_call                 shift and go to state 305
INFO:root:    select_wait                    shift and go to state 330
INFO:root:    indexed_comp                   shift and go to state 140
INFO:root:    timed_entry_call               shift and go to state 307
INFO:root:    statement                      shift and go to state 308
INFO:root:    operator_symbol                shift and go to state 133
INFO:root:    exit_stmt                      shift and go to state 306
INFO:root:    code_stmt                      shift and go to state 331
INFO:root:    loop_stmt                      shift and go to state 333
INFO:root:    null_stmt                      shift and go to state 334
INFO:root:    label                          shift and go to state 335
INFO:root:    select_stmt                    shift and go to state 311
INFO:root:    label_opt                      shift and go to state 313
INFO:root:    assign_stmt                    shift and go to state 336
INFO:root:    selected_comp                  shift and go to state 139
INFO:root:    abort_stmt                     shift and go to state 315
INFO:root:    attribute                      shift and go to state 134
INFO:root:    name                           shift and go to state 316
INFO:root:    accept_hdr                     shift and go to state 318
INFO:root:    accept_stmt                    shift and go to state 337
INFO:root:    case_hdr                       shift and go to state 319
INFO:root:    delay_stmt                     shift and go to state 338
INFO:root:    statement_s                    shift and go to state 626
INFO:root:    compound_stmt                  shift and go to state 309
INFO:root:    raise_stmt                     shift and go to state 342
INFO:root:    qualified                      shift and go to state 321
INFO:root:    return_stmt                    shift and go to state 323
INFO:root:    stmts_opt                      shift and go to state 630
INFO:root:    case_stmt                      shift and go to state 324
INFO:root:    block                          shift and go to state 325
INFO:root:    unlabeled                      shift and go to state 346
INFO:root:
INFO:root:state 483
INFO:root:
INFO:root:    (409) delay_or_entry_alt -> delay_stmt . stmts_opt
INFO:root:    (407) select_alt -> delay_stmt . stmts_opt
INFO:root:    (414) stmts_opt -> .
INFO:root:    (415) stmts_opt -> . statement_s
INFO:root:    (236) statement_s -> . statement
INFO:root:    (237) statement_s -> . statement_s statement
INFO:root:    (238) statement -> . unlabeled
INFO:root:    (239) statement -> . label statement
INFO:root:    (240) unlabeled -> . simple_stmt
INFO:root:    (241) unlabeled -> . compound_stmt
INFO:root:    (259) label -> . LL IDENTIFIER RR
INFO:root:    (242) simple_stmt -> . null_stmt
INFO:root:    (243) simple_stmt -> . assign_stmt
INFO:root:    (244) simple_stmt -> . exit_stmt
INFO:root:    (245) simple_stmt -> . return_stmt
INFO:root:    (246) simple_stmt -> . procedure_call
INFO:root:    (247) simple_stmt -> . delay_stmt
INFO:root:    (248) simple_stmt -> . abort_stmt
INFO:root:    (249) simple_stmt -> . raise_stmt
INFO:root:    (250) simple_stmt -> . code_stmt
INFO:root:    (251) simple_stmt -> . requeue_stmt
INFO:root:    (252) simple_stmt -> . error ;
INFO:root:    (253) compound_stmt -> . if_stmt
INFO:root:    (254) compound_stmt -> . case_stmt
INFO:root:    (255) compound_stmt -> . loop_stmt
INFO:root:    (256) compound_stmt -> . block
INFO:root:    (257) compound_stmt -> . accept_stmt
INFO:root:    (258) compound_stmt -> . select_stmt
INFO:root:    (260) null_stmt -> . NuLL ;
INFO:root:    (261) assign_stmt -> . name ASSIGN expression ;
INFO:root:    (294) exit_stmt -> . EXIT name_opt when_opt ;
INFO:root:    (299) return_stmt -> . RETURN ;
INFO:root:    (300) return_stmt -> . RETURN expression ;
INFO:root:    (323) procedure_call -> . name ;
INFO:root:    (395) delay_stmt -> . DELAY expression ;
INFO:root:    (396) delay_stmt -> . DELAY UNTIL expression ;
INFO:root:    (416) abort_stmt -> . ABORT name_s ;
INFO:root:    (455) raise_stmt -> . RAISE name_opt ;
INFO:root:    (501) code_stmt -> . qualified ;
INFO:root:    (456) requeue_stmt -> . REQUEUE name ;
INFO:root:    (457) requeue_stmt -> . REQUEUE name WITH ABORT ;
INFO:root:    (262) if_stmt -> . IF cond_clause_s else_opt END IF ;
INFO:root:    (270) case_stmt -> . case_hdr pragma_s alternative_s END CASE ;
INFO:root:    (275) loop_stmt -> . label_opt iteration basic_loop id_opt ;
INFO:root:    (287) block -> . label_opt block_decl block_body END id_opt ;
INFO:root:    (390) accept_stmt -> . accept_hdr ;
INFO:root:    (391) accept_stmt -> . accept_hdr DO handled_stmt_s END id_opt ;
INFO:root:    (397) select_stmt -> . select_wait
INFO:root:    (398) select_stmt -> . async_select
INFO:root:    (399) select_stmt -> . timed_entry_call
INFO:root:    (400) select_stmt -> . cond_entry_call
INFO:root:    (149) name -> . simple_name
INFO:root:    (150) name -> . indexed_comp
INFO:root:    (151) name -> . selected_comp
INFO:root:    (152) name -> . attribute
INFO:root:    (153) name -> . operator_symbol
INFO:root:    (233) qualified -> . name TICK parenthesized_primary
INFO:root:    (271) case_hdr -> . CASE expression IS
INFO:root:    (276) label_opt -> .
INFO:root:    (277) label_opt -> . IDENTIFIER :
INFO:root:    (392) accept_hdr -> . ACCEPT entry_name formal_part_opt
INFO:root:    (401) select_wait -> . SELECT guarded_select_alt or_select else_opt END SELECT ;
INFO:root:    (411) async_select -> . SELECT delay_or_entry_alt THEN ABORT statement_s END SELECT ;
INFO:root:    (412) timed_entry_call -> . SELECT entry_call stmts_opt OR delay_stmt stmts_opt END SELECT ;
INFO:root:    (413) cond_entry_call -> . SELECT entry_call stmts_opt ELSE statement_s END SELECT ;
INFO:root:    (157) simple_name -> . IDENTIFIER
INFO:root:    (164) indexed_comp -> . name ( value_s )
INFO:root:    (171) selected_comp -> . name . simple_name
INFO:root:    (172) selected_comp -> . name . used_char
INFO:root:    (173) selected_comp -> . name . operator_symbol
INFO:root:    (174) selected_comp -> . name . ALL
INFO:root:    (175) attribute -> . name TICK attribute_id
INFO:root:    (163) operator_symbol -> . STRING
INFO:root:
INFO:root:    THEN            reduce using rule 414 (stmts_opt -> .)
INFO:root:    OR              reduce using rule 414 (stmts_opt -> .)
INFO:root:    ELSE            reduce using rule 414 (stmts_opt -> .)
INFO:root:    END             reduce using rule 414 (stmts_opt -> .)
INFO:root:    LL              shift and go to state 344
INFO:root:    error           shift and go to state 341
INFO:root:    NuLL            shift and go to state 347
INFO:root:    EXIT            shift and go to state 340
INFO:root:    RETURN          shift and go to state 303
INFO:root:    DELAY           shift and go to state 332
INFO:root:    ABORT           shift and go to state 326
INFO:root:    RAISE           shift and go to state 314
INFO:root:    REQUEUE         shift and go to state 317
INFO:root:    IF              shift and go to state 327
INFO:root:    CASE            shift and go to state 312
INFO:root:    WHILE           reduce using rule 276 (label_opt -> .)
INFO:root:    DECLARE         reduce using rule 276 (label_opt -> .)
INFO:root:    FOR             reduce using rule 276 (label_opt -> .)
INFO:root:    LOOP            reduce using rule 276 (label_opt -> .)
INFO:root:    BEGIN           reduce using rule 276 (label_opt -> .)
INFO:root:    IDENTIFIER      shift and go to state 322
INFO:root:    ACCEPT          shift and go to state 310
INFO:root:    SELECT          shift and go to state 320
INFO:root:    STRING          shift and go to state 149
INFO:root:
INFO:root:    cond_entry_call                shift and go to state 345
INFO:root:    simple_stmt                    shift and go to state 302
INFO:root:    async_select                   shift and go to state 328
INFO:root:    simple_name                    shift and go to state 163
INFO:root:    requeue_stmt                   shift and go to state 329
INFO:root:    if_stmt                        shift and go to state 304
INFO:root:    procedure_call                 shift and go to state 305
INFO:root:    select_wait                    shift and go to state 330
INFO:root:    indexed_comp                   shift and go to state 140
INFO:root:    timed_entry_call               shift and go to state 307
INFO:root:    statement                      shift and go to state 308
INFO:root:    operator_symbol                shift and go to state 133
INFO:root:    exit_stmt                      shift and go to state 306
INFO:root:    code_stmt                      shift and go to state 331
INFO:root:    loop_stmt                      shift and go to state 333
INFO:root:    null_stmt                      shift and go to state 334
INFO:root:    label                          shift and go to state 335
INFO:root:    select_stmt                    shift and go to state 311
INFO:root:    label_opt                      shift and go to state 313
INFO:root:    assign_stmt                    shift and go to state 336
INFO:root:    selected_comp                  shift and go to state 139
INFO:root:    abort_stmt                     shift and go to state 315
INFO:root:    attribute                      shift and go to state 134
INFO:root:    name                           shift and go to state 316
INFO:root:    accept_hdr                     shift and go to state 318
INFO:root:    accept_stmt                    shift and go to state 337
INFO:root:    case_hdr                       shift and go to state 319
INFO:root:    delay_stmt                     shift and go to state 338
INFO:root:    statement_s                    shift and go to state 626
INFO:root:    compound_stmt                  shift and go to state 309
INFO:root:    raise_stmt                     shift and go to state 342
INFO:root:    qualified                      shift and go to state 321
INFO:root:    return_stmt                    shift and go to state 323
INFO:root:    stmts_opt                      shift and go to state 631
INFO:root:    case_stmt                      shift and go to state 324
INFO:root:    block                          shift and go to state 325
INFO:root:    unlabeled                      shift and go to state 346
INFO:root:
INFO:root:state 484
INFO:root:
INFO:root:    (403) guarded_select_alt -> WHEN . condition ARROW select_alt
INFO:root:    (267) condition -> . expression
INFO:root:    (188) expression -> . relation
INFO:root:    (189) expression -> . expression logical relation
INFO:root:    (190) expression -> . expression short_circuit relation
INFO:root:    (196) relation -> . simple_expression
INFO:root:    (197) relation -> . simple_expression relational simple_expression
INFO:root:    (198) relation -> . simple_expression membership range
INFO:root:    (199) relation -> . simple_expression membership name
INFO:root:    (208) simple_expression -> . unary term
INFO:root:    (209) simple_expression -> . term
INFO:root:    (210) simple_expression -> . simple_expression adding term
INFO:root:    (211) unary -> . +
INFO:root:    (212) unary -> . -
INFO:root:    (216) term -> . factor
INFO:root:    (217) term -> . term multiplying factor
INFO:root:    (223) factor -> . primary
INFO:root:    (224) factor -> . NOT primary
INFO:root:    (225) factor -> . ABS primary
INFO:root:    (226) primary -> . literal
INFO:root:    (227) primary -> . name
INFO:root:    (228) primary -> . allocator
INFO:root:    (229) primary -> . qualified
INFO:root:    (230) primary -> . parenthesized_primary
INFO:root:    (180) literal -> . INT
INFO:root:    (181) literal -> . FLOAT
INFO:root:    (182) literal -> . NuLL
INFO:root:    (149) name -> . simple_name
INFO:root:    (150) name -> . indexed_comp
INFO:root:    (151) name -> . selected_comp
INFO:root:    (152) name -> . attribute
INFO:root:    (153) name -> . operator_symbol
INFO:root:    (234) allocator -> . NEW name
INFO:root:    (235) allocator -> . NEW qualified
INFO:root:    (233) qualified -> . name TICK parenthesized_primary
INFO:root:    (231) parenthesized_primary -> . aggregate
INFO:root:    (232) parenthesized_primary -> . ( expression )
INFO:root:    (157) simple_name -> . IDENTIFIER
INFO:root:    (164) indexed_comp -> . name ( value_s )
INFO:root:    (171) selected_comp -> . name . simple_name
INFO:root:    (172) selected_comp -> . name . used_char
INFO:root:    (173) selected_comp -> . name . operator_symbol
INFO:root:    (174) selected_comp -> . name . ALL
INFO:root:    (175) attribute -> . name TICK attribute_id
INFO:root:    (163) operator_symbol -> . STRING
INFO:root:    (183) aggregate -> . ( comp_assoc )
INFO:root:    (184) aggregate -> . ( expression WITH value_s )
INFO:root:    (185) aggregate -> . ( expression WITH NuLL RECORD )
INFO:root:    (186) aggregate -> . ( NuLL RECORD )
INFO:root:
INFO:root:    +               shift and go to state 148
INFO:root:    -               shift and go to state 136
INFO:root:    NOT             shift and go to state 131
INFO:root:    ABS             shift and go to state 132
INFO:root:    INT             shift and go to state 120
INFO:root:    FLOAT           shift and go to state 128
INFO:root:    NuLL            shift and go to state 130
INFO:root:    NEW             shift and go to state 137
INFO:root:    (               shift and go to state 125
INFO:root:    IDENTIFIER      shift and go to state 33
INFO:root:    STRING          shift and go to state 149
INFO:root:
INFO:root:    literal                        shift and go to state 121
INFO:root:    allocator                      shift and go to state 122
INFO:root:    simple_name                    shift and go to state 163
INFO:root:    indexed_comp                   shift and go to state 140
INFO:root:    name                           shift and go to state 142
INFO:root:    condition                      shift and go to state 632
INFO:root:    selected_comp                  shift and go to state 139
INFO:root:    factor                         shift and go to state 126
INFO:root:    expression                     shift and go to state 489
INFO:root:    unary                          shift and go to state 144
INFO:root:    qualified                      shift and go to state 145
INFO:root:    aggregate                      shift and go to state 143
INFO:root:    simple_expression              shift and go to state 129
INFO:root:    term                           shift and go to state 146
INFO:root:    operator_symbol                shift and go to state 133
INFO:root:    parenthesized_primary          shift and go to state 147
INFO:root:    attribute                      shift and go to state 134
INFO:root:    primary                        shift and go to state 135
INFO:root:    relation                       shift and go to state 138
INFO:root:
INFO:root:state 485
INFO:root:
INFO:root:    (402) guarded_select_alt -> select_alt .
INFO:root:
INFO:root:    OR              reduce using rule 402 (guarded_select_alt -> select_alt .)
INFO:root:    ELSE            reduce using rule 402 (guarded_select_alt -> select_alt .)
INFO:root:    END             reduce using rule 402 (guarded_select_alt -> select_alt .)
INFO:root:
INFO:root:
INFO:root:state 486
INFO:root:
INFO:root:    (501) code_stmt -> qualified ; .
INFO:root:
INFO:root:    END             reduce using rule 501 (code_stmt -> qualified ; .)
INFO:root:    LL              reduce using rule 501 (code_stmt -> qualified ; .)
INFO:root:    error           reduce using rule 501 (code_stmt -> qualified ; .)
INFO:root:    NuLL            reduce using rule 501 (code_stmt -> qualified ; .)
INFO:root:    EXIT            reduce using rule 501 (code_stmt -> qualified ; .)
INFO:root:    RETURN          reduce using rule 501 (code_stmt -> qualified ; .)
INFO:root:    DELAY           reduce using rule 501 (code_stmt -> qualified ; .)
INFO:root:    ABORT           reduce using rule 501 (code_stmt -> qualified ; .)
INFO:root:    RAISE           reduce using rule 501 (code_stmt -> qualified ; .)
INFO:root:    REQUEUE         reduce using rule 501 (code_stmt -> qualified ; .)
INFO:root:    IF              reduce using rule 501 (code_stmt -> qualified ; .)
INFO:root:    CASE            reduce using rule 501 (code_stmt -> qualified ; .)
INFO:root:    IDENTIFIER      reduce using rule 501 (code_stmt -> qualified ; .)
INFO:root:    ACCEPT          reduce using rule 501 (code_stmt -> qualified ; .)
INFO:root:    SELECT          reduce using rule 501 (code_stmt -> qualified ; .)
INFO:root:    STRING          reduce using rule 501 (code_stmt -> qualified ; .)
INFO:root:    WHILE           reduce using rule 501 (code_stmt -> qualified ; .)
INFO:root:    DECLARE         reduce using rule 501 (code_stmt -> qualified ; .)
INFO:root:    FOR             reduce using rule 501 (code_stmt -> qualified ; .)
INFO:root:    LOOP            reduce using rule 501 (code_stmt -> qualified ; .)
INFO:root:    BEGIN           reduce using rule 501 (code_stmt -> qualified ; .)
INFO:root:    WHEN            reduce using rule 501 (code_stmt -> qualified ; .)
INFO:root:    OR              reduce using rule 501 (code_stmt -> qualified ; .)
INFO:root:    ELSE            reduce using rule 501 (code_stmt -> qualified ; .)
INFO:root:    THEN            reduce using rule 501 (code_stmt -> qualified ; .)
INFO:root:    ELSIF           reduce using rule 501 (code_stmt -> qualified ; .)
INFO:root:    EXCEPTION       reduce using rule 501 (code_stmt -> qualified ; .)
INFO:root:
INFO:root:
INFO:root:state 487
INFO:root:
INFO:root:    (277) label_opt -> IDENTIFIER : .
INFO:root:
INFO:root:    WHILE           reduce using rule 277 (label_opt -> IDENTIFIER : .)
INFO:root:    DECLARE         reduce using rule 277 (label_opt -> IDENTIFIER : .)
INFO:root:    FOR             reduce using rule 277 (label_opt -> IDENTIFIER : .)
INFO:root:    LOOP            reduce using rule 277 (label_opt -> IDENTIFIER : .)
INFO:root:    BEGIN           reduce using rule 277 (label_opt -> IDENTIFIER : .)
INFO:root:
INFO:root:
INFO:root:state 488
INFO:root:
INFO:root:    (416) abort_stmt -> ABORT name_s . ;
INFO:root:    (340) name_s -> name_s . , name
INFO:root:
INFO:root:    ;               shift and go to state 633
INFO:root:    ,               shift and go to state 258
INFO:root:
INFO:root:
INFO:root:state 489
INFO:root:
INFO:root:    (267) condition -> expression .
INFO:root:    (189) expression -> expression . logical relation
INFO:root:    (190) expression -> expression . short_circuit relation
INFO:root:    (191) logical -> . AND
INFO:root:    (192) logical -> . OR
INFO:root:    (193) logical -> . XOR
INFO:root:    (194) short_circuit -> . AND THEN
INFO:root:    (195) short_circuit -> . OR ELSE
INFO:root:
INFO:root:    ;               reduce using rule 267 (condition -> expression .)
INFO:root:    LOOP            reduce using rule 267 (condition -> expression .)
INFO:root:    ARROW           reduce using rule 267 (condition -> expression .)
INFO:root:    THEN            reduce using rule 267 (condition -> expression .)
INFO:root:    IS              reduce using rule 267 (condition -> expression .)
INFO:root:    AND             shift and go to state 215
INFO:root:    OR              shift and go to state 216
INFO:root:    XOR             shift and go to state 214
INFO:root:
INFO:root:    short_circuit                  shift and go to state 212
INFO:root:    logical                        shift and go to state 213
INFO:root:
INFO:root:state 490
INFO:root:
INFO:root:    (262) if_stmt -> IF cond_clause_s . else_opt END IF ;
INFO:root:    (264) cond_clause_s -> cond_clause_s . ELSIF cond_clause
INFO:root:    (268) else_opt -> .
INFO:root:    (269) else_opt -> . ELSE statement_s
INFO:root:
INFO:root:    ELSIF           shift and go to state 636
INFO:root:    END             reduce using rule 268 (else_opt -> .)
INFO:root:    ELSE            shift and go to state 634
INFO:root:
INFO:root:    else_opt                       shift and go to state 635
INFO:root:
INFO:root:state 491
INFO:root:
INFO:root:    (263) cond_clause_s -> cond_clause .
INFO:root:
INFO:root:    ELSIF           reduce using rule 263 (cond_clause_s -> cond_clause .)
INFO:root:    ELSE            reduce using rule 263 (cond_clause_s -> cond_clause .)
INFO:root:    END             reduce using rule 263 (cond_clause_s -> cond_clause .)
INFO:root:
INFO:root:
INFO:root:state 492
INFO:root:
INFO:root:    (266) cond_part -> condition . THEN
INFO:root:
INFO:root:    THEN            shift and go to state 637
INFO:root:
INFO:root:
INFO:root:state 493
INFO:root:
INFO:root:    (265) cond_clause -> cond_part . statement_s
INFO:root:    (236) statement_s -> . statement
INFO:root:    (237) statement_s -> . statement_s statement
INFO:root:    (238) statement -> . unlabeled
INFO:root:    (239) statement -> . label statement
INFO:root:    (240) unlabeled -> . simple_stmt
INFO:root:    (241) unlabeled -> . compound_stmt
INFO:root:    (259) label -> . LL IDENTIFIER RR
INFO:root:    (242) simple_stmt -> . null_stmt
INFO:root:    (243) simple_stmt -> . assign_stmt
INFO:root:    (244) simple_stmt -> . exit_stmt
INFO:root:    (245) simple_stmt -> . return_stmt
INFO:root:    (246) simple_stmt -> . procedure_call
INFO:root:    (247) simple_stmt -> . delay_stmt
INFO:root:    (248) simple_stmt -> . abort_stmt
INFO:root:    (249) simple_stmt -> . raise_stmt
INFO:root:    (250) simple_stmt -> . code_stmt
INFO:root:    (251) simple_stmt -> . requeue_stmt
INFO:root:    (252) simple_stmt -> . error ;
INFO:root:    (253) compound_stmt -> . if_stmt
INFO:root:    (254) compound_stmt -> . case_stmt
INFO:root:    (255) compound_stmt -> . loop_stmt
INFO:root:    (256) compound_stmt -> . block
INFO:root:    (257) compound_stmt -> . accept_stmt
INFO:root:    (258) compound_stmt -> . select_stmt
INFO:root:    (260) null_stmt -> . NuLL ;
INFO:root:    (261) assign_stmt -> . name ASSIGN expression ;
INFO:root:    (294) exit_stmt -> . EXIT name_opt when_opt ;
INFO:root:    (299) return_stmt -> . RETURN ;
INFO:root:    (300) return_stmt -> . RETURN expression ;
INFO:root:    (323) procedure_call -> . name ;
INFO:root:    (395) delay_stmt -> . DELAY expression ;
INFO:root:    (396) delay_stmt -> . DELAY UNTIL expression ;
INFO:root:    (416) abort_stmt -> . ABORT name_s ;
INFO:root:    (455) raise_stmt -> . RAISE name_opt ;
INFO:root:    (501) code_stmt -> . qualified ;
INFO:root:    (456) requeue_stmt -> . REQUEUE name ;
INFO:root:    (457) requeue_stmt -> . REQUEUE name WITH ABORT ;
INFO:root:    (262) if_stmt -> . IF cond_clause_s else_opt END IF ;
INFO:root:    (270) case_stmt -> . case_hdr pragma_s alternative_s END CASE ;
INFO:root:    (275) loop_stmt -> . label_opt iteration basic_loop id_opt ;
INFO:root:    (287) block -> . label_opt block_decl block_body END id_opt ;
INFO:root:    (390) accept_stmt -> . accept_hdr ;
INFO:root:    (391) accept_stmt -> . accept_hdr DO handled_stmt_s END id_opt ;
INFO:root:    (397) select_stmt -> . select_wait
INFO:root:    (398) select_stmt -> . async_select
INFO:root:    (399) select_stmt -> . timed_entry_call
INFO:root:    (400) select_stmt -> . cond_entry_call
INFO:root:    (149) name -> . simple_name
INFO:root:    (150) name -> . indexed_comp
INFO:root:    (151) name -> . selected_comp
INFO:root:    (152) name -> . attribute
INFO:root:    (153) name -> . operator_symbol
INFO:root:    (233) qualified -> . name TICK parenthesized_primary
INFO:root:    (271) case_hdr -> . CASE expression IS
INFO:root:    (276) label_opt -> .
INFO:root:    (277) label_opt -> . IDENTIFIER :
INFO:root:    (392) accept_hdr -> . ACCEPT entry_name formal_part_opt
INFO:root:    (401) select_wait -> . SELECT guarded_select_alt or_select else_opt END SELECT ;
INFO:root:    (411) async_select -> . SELECT delay_or_entry_alt THEN ABORT statement_s END SELECT ;
INFO:root:    (412) timed_entry_call -> . SELECT entry_call stmts_opt OR delay_stmt stmts_opt END SELECT ;
INFO:root:    (413) cond_entry_call -> . SELECT entry_call stmts_opt ELSE statement_s END SELECT ;
INFO:root:    (157) simple_name -> . IDENTIFIER
INFO:root:    (164) indexed_comp -> . name ( value_s )
INFO:root:    (171) selected_comp -> . name . simple_name
INFO:root:    (172) selected_comp -> . name . used_char
INFO:root:    (173) selected_comp -> . name . operator_symbol
INFO:root:    (174) selected_comp -> . name . ALL
INFO:root:    (175) attribute -> . name TICK attribute_id
INFO:root:    (163) operator_symbol -> . STRING
INFO:root:
INFO:root:    LL              shift and go to state 344
INFO:root:    error           shift and go to state 341
INFO:root:    NuLL            shift and go to state 347
INFO:root:    EXIT            shift and go to state 340
INFO:root:    RETURN          shift and go to state 303
INFO:root:    DELAY           shift and go to state 332
INFO:root:    ABORT           shift and go to state 326
INFO:root:    RAISE           shift and go to state 314
INFO:root:    REQUEUE         shift and go to state 317
INFO:root:    IF              shift and go to state 327
INFO:root:    CASE            shift and go to state 312
INFO:root:    WHILE           reduce using rule 276 (label_opt -> .)
INFO:root:    DECLARE         reduce using rule 276 (label_opt -> .)
INFO:root:    FOR             reduce using rule 276 (label_opt -> .)
INFO:root:    LOOP            reduce using rule 276 (label_opt -> .)
INFO:root:    BEGIN           reduce using rule 276 (label_opt -> .)
INFO:root:    IDENTIFIER      shift and go to state 322
INFO:root:    ACCEPT          shift and go to state 310
INFO:root:    SELECT          shift and go to state 320
INFO:root:    STRING          shift and go to state 149
INFO:root:
INFO:root:    cond_entry_call                shift and go to state 345
INFO:root:    simple_stmt                    shift and go to state 302
INFO:root:    async_select                   shift and go to state 328
INFO:root:    simple_name                    shift and go to state 163
INFO:root:    requeue_stmt                   shift and go to state 329
INFO:root:    if_stmt                        shift and go to state 304
INFO:root:    procedure_call                 shift and go to state 305
INFO:root:    select_wait                    shift and go to state 330
INFO:root:    indexed_comp                   shift and go to state 140
INFO:root:    timed_entry_call               shift and go to state 307
INFO:root:    statement                      shift and go to state 308
INFO:root:    operator_symbol                shift and go to state 133
INFO:root:    exit_stmt                      shift and go to state 306
INFO:root:    code_stmt                      shift and go to state 331
INFO:root:    loop_stmt                      shift and go to state 333
INFO:root:    null_stmt                      shift and go to state 334
INFO:root:    label                          shift and go to state 335
INFO:root:    select_stmt                    shift and go to state 311
INFO:root:    label_opt                      shift and go to state 313
INFO:root:    assign_stmt                    shift and go to state 336
INFO:root:    selected_comp                  shift and go to state 139
INFO:root:    abort_stmt                     shift and go to state 315
INFO:root:    attribute                      shift and go to state 134
INFO:root:    name                           shift and go to state 316
INFO:root:    accept_hdr                     shift and go to state 318
INFO:root:    accept_stmt                    shift and go to state 337
INFO:root:    case_hdr                       shift and go to state 319
INFO:root:    delay_stmt                     shift and go to state 338
INFO:root:    statement_s                    shift and go to state 638
INFO:root:    compound_stmt                  shift and go to state 309
INFO:root:    raise_stmt                     shift and go to state 342
INFO:root:    qualified                      shift and go to state 321
INFO:root:    return_stmt                    shift and go to state 323
INFO:root:    case_stmt                      shift and go to state 324
INFO:root:    block                          shift and go to state 325
INFO:root:    unlabeled                      shift and go to state 346
INFO:root:
INFO:root:state 494
INFO:root:
INFO:root:    (395) delay_stmt -> DELAY expression . ;
INFO:root:    (189) expression -> expression . logical relation
INFO:root:    (190) expression -> expression . short_circuit relation
INFO:root:    (191) logical -> . AND
INFO:root:    (192) logical -> . OR
INFO:root:    (193) logical -> . XOR
INFO:root:    (194) short_circuit -> . AND THEN
INFO:root:    (195) short_circuit -> . OR ELSE
INFO:root:
INFO:root:    ;               shift and go to state 639
INFO:root:    AND             shift and go to state 215
INFO:root:    OR              shift and go to state 216
INFO:root:    XOR             shift and go to state 214
INFO:root:
INFO:root:    short_circuit                  shift and go to state 212
INFO:root:    logical                        shift and go to state 213
INFO:root:
INFO:root:state 495
INFO:root:
INFO:root:    (396) delay_stmt -> DELAY UNTIL . expression ;
INFO:root:    (188) expression -> . relation
INFO:root:    (189) expression -> . expression logical relation
INFO:root:    (190) expression -> . expression short_circuit relation
INFO:root:    (196) relation -> . simple_expression
INFO:root:    (197) relation -> . simple_expression relational simple_expression
INFO:root:    (198) relation -> . simple_expression membership range
INFO:root:    (199) relation -> . simple_expression membership name
INFO:root:    (208) simple_expression -> . unary term
INFO:root:    (209) simple_expression -> . term
INFO:root:    (210) simple_expression -> . simple_expression adding term
INFO:root:    (211) unary -> . +
INFO:root:    (212) unary -> . -
INFO:root:    (216) term -> . factor
INFO:root:    (217) term -> . term multiplying factor
INFO:root:    (223) factor -> . primary
INFO:root:    (224) factor -> . NOT primary
INFO:root:    (225) factor -> . ABS primary
INFO:root:    (226) primary -> . literal
INFO:root:    (227) primary -> . name
INFO:root:    (228) primary -> . allocator
INFO:root:    (229) primary -> . qualified
INFO:root:    (230) primary -> . parenthesized_primary
INFO:root:    (180) literal -> . INT
INFO:root:    (181) literal -> . FLOAT
INFO:root:    (182) literal -> . NuLL
INFO:root:    (149) name -> . simple_name
INFO:root:    (150) name -> . indexed_comp
INFO:root:    (151) name -> . selected_comp
INFO:root:    (152) name -> . attribute
INFO:root:    (153) name -> . operator_symbol
INFO:root:    (234) allocator -> . NEW name
INFO:root:    (235) allocator -> . NEW qualified
INFO:root:    (233) qualified -> . name TICK parenthesized_primary
INFO:root:    (231) parenthesized_primary -> . aggregate
INFO:root:    (232) parenthesized_primary -> . ( expression )
INFO:root:    (157) simple_name -> . IDENTIFIER
INFO:root:    (164) indexed_comp -> . name ( value_s )
INFO:root:    (171) selected_comp -> . name . simple_name
INFO:root:    (172) selected_comp -> . name . used_char
INFO:root:    (173) selected_comp -> . name . operator_symbol
INFO:root:    (174) selected_comp -> . name . ALL
INFO:root:    (175) attribute -> . name TICK attribute_id
INFO:root:    (163) operator_symbol -> . STRING
INFO:root:    (183) aggregate -> . ( comp_assoc )
INFO:root:    (184) aggregate -> . ( expression WITH value_s )
INFO:root:    (185) aggregate -> . ( expression WITH NuLL RECORD )
INFO:root:    (186) aggregate -> . ( NuLL RECORD )
INFO:root:
INFO:root:    +               shift and go to state 148
INFO:root:    -               shift and go to state 136
INFO:root:    NOT             shift and go to state 131
INFO:root:    ABS             shift and go to state 132
INFO:root:    INT             shift and go to state 120
INFO:root:    FLOAT           shift and go to state 128
INFO:root:    NuLL            shift and go to state 130
INFO:root:    NEW             shift and go to state 137
INFO:root:    (               shift and go to state 125
INFO:root:    IDENTIFIER      shift and go to state 33
INFO:root:    STRING          shift and go to state 149
INFO:root:
INFO:root:    literal                        shift and go to state 121
INFO:root:    allocator                      shift and go to state 122
INFO:root:    simple_name                    shift and go to state 163
INFO:root:    indexed_comp                   shift and go to state 140
INFO:root:    name                           shift and go to state 142
INFO:root:    selected_comp                  shift and go to state 139
INFO:root:    factor                         shift and go to state 126
INFO:root:    expression                     shift and go to state 640
INFO:root:    unary                          shift and go to state 144
INFO:root:    qualified                      shift and go to state 145
INFO:root:    aggregate                      shift and go to state 143
INFO:root:    simple_expression              shift and go to state 129
INFO:root:    term                           shift and go to state 146
INFO:root:    operator_symbol                shift and go to state 133
INFO:root:    parenthesized_primary          shift and go to state 147
INFO:root:    attribute                      shift and go to state 134
INFO:root:    primary                        shift and go to state 135
INFO:root:    relation                       shift and go to state 138
INFO:root:
INFO:root:state 496
INFO:root:
INFO:root:    (239) statement -> label statement .
INFO:root:
INFO:root:    LL              reduce using rule 239 (statement -> label statement .)
INFO:root:    error           reduce using rule 239 (statement -> label statement .)
INFO:root:    NuLL            reduce using rule 239 (statement -> label statement .)
INFO:root:    EXIT            reduce using rule 239 (statement -> label statement .)
INFO:root:    RETURN          reduce using rule 239 (statement -> label statement .)
INFO:root:    DELAY           reduce using rule 239 (statement -> label statement .)
INFO:root:    ABORT           reduce using rule 239 (statement -> label statement .)
INFO:root:    RAISE           reduce using rule 239 (statement -> label statement .)
INFO:root:    REQUEUE         reduce using rule 239 (statement -> label statement .)
INFO:root:    IF              reduce using rule 239 (statement -> label statement .)
INFO:root:    CASE            reduce using rule 239 (statement -> label statement .)
INFO:root:    IDENTIFIER      reduce using rule 239 (statement -> label statement .)
INFO:root:    ACCEPT          reduce using rule 239 (statement -> label statement .)
INFO:root:    SELECT          reduce using rule 239 (statement -> label statement .)
INFO:root:    STRING          reduce using rule 239 (statement -> label statement .)
INFO:root:    WHILE           reduce using rule 239 (statement -> label statement .)
INFO:root:    DECLARE         reduce using rule 239 (statement -> label statement .)
INFO:root:    FOR             reduce using rule 239 (statement -> label statement .)
INFO:root:    LOOP            reduce using rule 239 (statement -> label statement .)
INFO:root:    BEGIN           reduce using rule 239 (statement -> label statement .)
INFO:root:    WHEN            reduce using rule 239 (statement -> label statement .)
INFO:root:    END             reduce using rule 239 (statement -> label statement .)
INFO:root:    EXCEPTION       reduce using rule 239 (statement -> label statement .)
INFO:root:    OR              reduce using rule 239 (statement -> label statement .)
INFO:root:    ELSE            reduce using rule 239 (statement -> label statement .)
INFO:root:    THEN            reduce using rule 239 (statement -> label statement .)
INFO:root:    ELSIF           reduce using rule 239 (statement -> label statement .)
INFO:root:
INFO:root:
INFO:root:state 497
INFO:root:
INFO:root:    (237) statement_s -> statement_s statement .
INFO:root:
INFO:root:    LL              reduce using rule 237 (statement_s -> statement_s statement .)
INFO:root:    error           reduce using rule 237 (statement_s -> statement_s statement .)
INFO:root:    NuLL            reduce using rule 237 (statement_s -> statement_s statement .)
INFO:root:    EXIT            reduce using rule 237 (statement_s -> statement_s statement .)
INFO:root:    RETURN          reduce using rule 237 (statement_s -> statement_s statement .)
INFO:root:    DELAY           reduce using rule 237 (statement_s -> statement_s statement .)
INFO:root:    ABORT           reduce using rule 237 (statement_s -> statement_s statement .)
INFO:root:    RAISE           reduce using rule 237 (statement_s -> statement_s statement .)
INFO:root:    REQUEUE         reduce using rule 237 (statement_s -> statement_s statement .)
INFO:root:    IF              reduce using rule 237 (statement_s -> statement_s statement .)
INFO:root:    CASE            reduce using rule 237 (statement_s -> statement_s statement .)
INFO:root:    IDENTIFIER      reduce using rule 237 (statement_s -> statement_s statement .)
INFO:root:    ACCEPT          reduce using rule 237 (statement_s -> statement_s statement .)
INFO:root:    SELECT          reduce using rule 237 (statement_s -> statement_s statement .)
INFO:root:    STRING          reduce using rule 237 (statement_s -> statement_s statement .)
INFO:root:    WHILE           reduce using rule 237 (statement_s -> statement_s statement .)
INFO:root:    DECLARE         reduce using rule 237 (statement_s -> statement_s statement .)
INFO:root:    FOR             reduce using rule 237 (statement_s -> statement_s statement .)
INFO:root:    LOOP            reduce using rule 237 (statement_s -> statement_s statement .)
INFO:root:    BEGIN           reduce using rule 237 (statement_s -> statement_s statement .)
INFO:root:    END             reduce using rule 237 (statement_s -> statement_s statement .)
INFO:root:    WHEN            reduce using rule 237 (statement_s -> statement_s statement .)
INFO:root:    THEN            reduce using rule 237 (statement_s -> statement_s statement .)
INFO:root:    OR              reduce using rule 237 (statement_s -> statement_s statement .)
INFO:root:    ELSE            reduce using rule 237 (statement_s -> statement_s statement .)
INFO:root:    EXCEPTION       reduce using rule 237 (statement_s -> statement_s statement .)
INFO:root:    ELSIF           reduce using rule 237 (statement_s -> statement_s statement .)
INFO:root:
INFO:root:
INFO:root:state 498
INFO:root:
INFO:root:    (447) except_handler_part -> EXCEPTION . exception_handler
INFO:root:    (449) exception_handler -> . WHEN except_choice_s ARROW statement_s
INFO:root:    (450) exception_handler -> . WHEN IDENTIFIER : except_choice_s ARROW statement_s
INFO:root:
INFO:root:    WHEN            shift and go to state 642
INFO:root:
INFO:root:    exception_handler              shift and go to state 641
INFO:root:
INFO:root:state 499
INFO:root:
INFO:root:    (293) except_handler_part_opt -> except_handler_part .
INFO:root:    (448) except_handler_part -> except_handler_part . exception_handler
INFO:root:    (449) exception_handler -> . WHEN except_choice_s ARROW statement_s
INFO:root:    (450) exception_handler -> . WHEN IDENTIFIER : except_choice_s ARROW statement_s
INFO:root:
INFO:root:    END             reduce using rule 293 (except_handler_part_opt -> except_handler_part .)
INFO:root:    WHEN            shift and go to state 642
INFO:root:
INFO:root:    exception_handler              shift and go to state 643
INFO:root:
INFO:root:state 500
INFO:root:
INFO:root:    (291) handled_stmt_s -> statement_s except_handler_part_opt .
INFO:root:
INFO:root:    END             reduce using rule 291 (handled_stmt_s -> statement_s except_handler_part_opt .)
INFO:root:
INFO:root:
INFO:root:state 501
INFO:root:
INFO:root:    (294) exit_stmt -> EXIT name_opt . when_opt ;
INFO:root:    (297) when_opt -> .
INFO:root:    (298) when_opt -> . WHEN condition
INFO:root:
INFO:root:    ;               reduce using rule 297 (when_opt -> .)
INFO:root:    WHEN            shift and go to state 645
INFO:root:
INFO:root:    when_opt                       shift and go to state 644
INFO:root:
INFO:root:state 502
INFO:root:
INFO:root:    (252) simple_stmt -> error ; .
INFO:root:
INFO:root:    END             reduce using rule 252 (simple_stmt -> error ; .)
INFO:root:    LL              reduce using rule 252 (simple_stmt -> error ; .)
INFO:root:    error           reduce using rule 252 (simple_stmt -> error ; .)
INFO:root:    NuLL            reduce using rule 252 (simple_stmt -> error ; .)
INFO:root:    EXIT            reduce using rule 252 (simple_stmt -> error ; .)
INFO:root:    RETURN          reduce using rule 252 (simple_stmt -> error ; .)
INFO:root:    DELAY           reduce using rule 252 (simple_stmt -> error ; .)
INFO:root:    ABORT           reduce using rule 252 (simple_stmt -> error ; .)
INFO:root:    RAISE           reduce using rule 252 (simple_stmt -> error ; .)
INFO:root:    REQUEUE         reduce using rule 252 (simple_stmt -> error ; .)
INFO:root:    IF              reduce using rule 252 (simple_stmt -> error ; .)
INFO:root:    CASE            reduce using rule 252 (simple_stmt -> error ; .)
INFO:root:    IDENTIFIER      reduce using rule 252 (simple_stmt -> error ; .)
INFO:root:    ACCEPT          reduce using rule 252 (simple_stmt -> error ; .)
INFO:root:    SELECT          reduce using rule 252 (simple_stmt -> error ; .)
INFO:root:    STRING          reduce using rule 252 (simple_stmt -> error ; .)
INFO:root:    WHILE           reduce using rule 252 (simple_stmt -> error ; .)
INFO:root:    DECLARE         reduce using rule 252 (simple_stmt -> error ; .)
INFO:root:    FOR             reduce using rule 252 (simple_stmt -> error ; .)
INFO:root:    LOOP            reduce using rule 252 (simple_stmt -> error ; .)
INFO:root:    BEGIN           reduce using rule 252 (simple_stmt -> error ; .)
INFO:root:    EXCEPTION       reduce using rule 252 (simple_stmt -> error ; .)
INFO:root:    OR              reduce using rule 252 (simple_stmt -> error ; .)
INFO:root:    ELSE            reduce using rule 252 (simple_stmt -> error ; .)
INFO:root:    THEN            reduce using rule 252 (simple_stmt -> error ; .)
INFO:root:    ELSIF           reduce using rule 252 (simple_stmt -> error ; .)
INFO:root:    WHEN            reduce using rule 252 (simple_stmt -> error ; .)
INFO:root:
INFO:root:
INFO:root:state 503
INFO:root:
INFO:root:    (259) label -> LL IDENTIFIER . RR
INFO:root:
INFO:root:    RR              shift and go to state 646
INFO:root:
INFO:root:
INFO:root:state 504
INFO:root:
INFO:root:    (260) null_stmt -> NuLL ; .
INFO:root:
INFO:root:    END             reduce using rule 260 (null_stmt -> NuLL ; .)
INFO:root:    LL              reduce using rule 260 (null_stmt -> NuLL ; .)
INFO:root:    error           reduce using rule 260 (null_stmt -> NuLL ; .)
INFO:root:    NuLL            reduce using rule 260 (null_stmt -> NuLL ; .)
INFO:root:    EXIT            reduce using rule 260 (null_stmt -> NuLL ; .)
INFO:root:    RETURN          reduce using rule 260 (null_stmt -> NuLL ; .)
INFO:root:    DELAY           reduce using rule 260 (null_stmt -> NuLL ; .)
INFO:root:    ABORT           reduce using rule 260 (null_stmt -> NuLL ; .)
INFO:root:    RAISE           reduce using rule 260 (null_stmt -> NuLL ; .)
INFO:root:    REQUEUE         reduce using rule 260 (null_stmt -> NuLL ; .)
INFO:root:    IF              reduce using rule 260 (null_stmt -> NuLL ; .)
INFO:root:    CASE            reduce using rule 260 (null_stmt -> NuLL ; .)
INFO:root:    IDENTIFIER      reduce using rule 260 (null_stmt -> NuLL ; .)
INFO:root:    ACCEPT          reduce using rule 260 (null_stmt -> NuLL ; .)
INFO:root:    SELECT          reduce using rule 260 (null_stmt -> NuLL ; .)
INFO:root:    STRING          reduce using rule 260 (null_stmt -> NuLL ; .)
INFO:root:    WHILE           reduce using rule 260 (null_stmt -> NuLL ; .)
INFO:root:    DECLARE         reduce using rule 260 (null_stmt -> NuLL ; .)
INFO:root:    FOR             reduce using rule 260 (null_stmt -> NuLL ; .)
INFO:root:    LOOP            reduce using rule 260 (null_stmt -> NuLL ; .)
INFO:root:    BEGIN           reduce using rule 260 (null_stmt -> NuLL ; .)
INFO:root:    OR              reduce using rule 260 (null_stmt -> NuLL ; .)
INFO:root:    ELSE            reduce using rule 260 (null_stmt -> NuLL ; .)
INFO:root:    ELSIF           reduce using rule 260 (null_stmt -> NuLL ; .)
INFO:root:    WHEN            reduce using rule 260 (null_stmt -> NuLL ; .)
INFO:root:    THEN            reduce using rule 260 (null_stmt -> NuLL ; .)
INFO:root:    EXCEPTION       reduce using rule 260 (null_stmt -> NuLL ; .)
INFO:root:
INFO:root:
INFO:root:state 505
INFO:root:
INFO:root:    (50) subtype_decl -> SUBTYPE IDENTIFIER IS subtype_ind . ;
INFO:root:
INFO:root:    ;               shift and go to state 647
INFO:root:
INFO:root:
INFO:root:state 506
INFO:root:
INFO:root:    (187) comp_assoc -> choice_s ARROW expression .
INFO:root:    (189) expression -> expression . logical relation
INFO:root:    (190) expression -> expression . short_circuit relation
INFO:root:    (191) logical -> . AND
INFO:root:    (192) logical -> . OR
INFO:root:    (193) logical -> . XOR
INFO:root:    (194) short_circuit -> . AND THEN
INFO:root:    (195) short_circuit -> . OR ELSE
INFO:root:
INFO:root:    )               reduce using rule 187 (comp_assoc -> choice_s ARROW expression .)
INFO:root:    ,               reduce using rule 187 (comp_assoc -> choice_s ARROW expression .)
INFO:root:    AND             shift and go to state 215
INFO:root:    OR              shift and go to state 216
INFO:root:    XOR             shift and go to state 214
INFO:root:
INFO:root:    logical                        shift and go to state 213
INFO:root:    short_circuit                  shift and go to state 212
INFO:root:
INFO:root:state 507
INFO:root:
INFO:root:    (123) choice -> expression .
INFO:root:    (189) expression -> expression . logical relation
INFO:root:    (190) expression -> expression . short_circuit relation
INFO:root:    (191) logical -> . AND
INFO:root:    (192) logical -> . OR
INFO:root:    (193) logical -> . XOR
INFO:root:    (194) short_circuit -> . AND THEN
INFO:root:    (195) short_circuit -> . OR ELSE
INFO:root:
INFO:root:    ARROW           reduce using rule 123 (choice -> expression .)
INFO:root:    |               reduce using rule 123 (choice -> expression .)
INFO:root:    AND             shift and go to state 215
INFO:root:    OR              shift and go to state 216
INFO:root:    XOR             shift and go to state 214
INFO:root:
INFO:root:    short_circuit                  shift and go to state 212
INFO:root:    logical                        shift and go to state 213
INFO:root:
INFO:root:state 508
INFO:root:
INFO:root:    (122) choice_s -> choice_s | choice .
INFO:root:
INFO:root:    ARROW           reduce using rule 122 (choice_s -> choice_s | choice .)
INFO:root:    |               reduce using rule 122 (choice_s -> choice_s | choice .)
INFO:root:
INFO:root:
INFO:root:state 509
INFO:root:
INFO:root:    (185) aggregate -> ( expression WITH NuLL . RECORD )
INFO:root:    (182) literal -> NuLL .
INFO:root:
INFO:root:    RECORD          shift and go to state 648
INFO:root:    *               reduce using rule 182 (literal -> NuLL .)
INFO:root:    /               reduce using rule 182 (literal -> NuLL .)
INFO:root:    MOD             reduce using rule 182 (literal -> NuLL .)
INFO:root:    REM             reduce using rule 182 (literal -> NuLL .)
INFO:root:    STARSTAR        reduce using rule 182 (literal -> NuLL .)
INFO:root:    DOTDOT          reduce using rule 182 (literal -> NuLL .)
INFO:root:    =               reduce using rule 182 (literal -> NuLL .)
INFO:root:    NEQ             reduce using rule 182 (literal -> NuLL .)
INFO:root:    <               reduce using rule 182 (literal -> NuLL .)
INFO:root:    LEQ             reduce using rule 182 (literal -> NuLL .)
INFO:root:    >               reduce using rule 182 (literal -> NuLL .)
INFO:root:    GEQ             reduce using rule 182 (literal -> NuLL .)
INFO:root:    IN              reduce using rule 182 (literal -> NuLL .)
INFO:root:    NOT             reduce using rule 182 (literal -> NuLL .)
INFO:root:    +               reduce using rule 182 (literal -> NuLL .)
INFO:root:    -               reduce using rule 182 (literal -> NuLL .)
INFO:root:    &               reduce using rule 182 (literal -> NuLL .)
INFO:root:    AND             reduce using rule 182 (literal -> NuLL .)
INFO:root:    OR              reduce using rule 182 (literal -> NuLL .)
INFO:root:    XOR             reduce using rule 182 (literal -> NuLL .)
INFO:root:    )               reduce using rule 182 (literal -> NuLL .)
INFO:root:    ,               reduce using rule 182 (literal -> NuLL .)
INFO:root:    ARROW           reduce using rule 182 (literal -> NuLL .)
INFO:root:    |               reduce using rule 182 (literal -> NuLL .)
INFO:root:
INFO:root:
INFO:root:state 510
INFO:root:
INFO:root:    (184) aggregate -> ( expression WITH value_s . )
INFO:root:    (166) value_s -> value_s . , value
INFO:root:
INFO:root:    )               shift and go to state 649
INFO:root:    ,               shift and go to state 515
INFO:root:
INFO:root:
INFO:root:state 511
INFO:root:
INFO:root:    (62) range -> simple_expression DOTDOT simple_expression .
INFO:root:    (210) simple_expression -> simple_expression . adding term
INFO:root:    (213) adding -> . +
INFO:root:    (214) adding -> . -
INFO:root:    (215) adding -> . &
INFO:root:
INFO:root:    )               reduce using rule 62 (range -> simple_expression DOTDOT simple_expression .)
INFO:root:    ,               reduce using rule 62 (range -> simple_expression DOTDOT simple_expression .)
INFO:root:    ARROW           reduce using rule 62 (range -> simple_expression DOTDOT simple_expression .)
INFO:root:    |               reduce using rule 62 (range -> simple_expression DOTDOT simple_expression .)
INFO:root:    LOOP            reduce using rule 62 (range -> simple_expression DOTDOT simple_expression .)
INFO:root:    ;               reduce using rule 62 (range -> simple_expression DOTDOT simple_expression .)
INFO:root:    RENAMES         reduce using rule 62 (range -> simple_expression DOTDOT simple_expression .)
INFO:root:    ASSIGN          reduce using rule 62 (range -> simple_expression DOTDOT simple_expression .)
INFO:root:    WITH            reduce using rule 62 (range -> simple_expression DOTDOT simple_expression .)
INFO:root:    AND             reduce using rule 62 (range -> simple_expression DOTDOT simple_expression .)
INFO:root:    OR              reduce using rule 62 (range -> simple_expression DOTDOT simple_expression .)
INFO:root:    XOR             reduce using rule 62 (range -> simple_expression DOTDOT simple_expression .)
INFO:root:    IS              reduce using rule 62 (range -> simple_expression DOTDOT simple_expression .)
INFO:root:    THEN            reduce using rule 62 (range -> simple_expression DOTDOT simple_expression .)
INFO:root:    RANGE           reduce using rule 62 (range -> simple_expression DOTDOT simple_expression .)
INFO:root:    DIGITS          reduce using rule 62 (range -> simple_expression DOTDOT simple_expression .)
INFO:root:    +               shift and go to state 226
INFO:root:    -               shift and go to state 217
INFO:root:    &               shift and go to state 229
INFO:root:
INFO:root:    adding                         shift and go to state 230
INFO:root:
INFO:root:state 512
INFO:root:
INFO:root:    (186) aggregate -> ( NuLL RECORD ) .
INFO:root:
INFO:root:    *               reduce using rule 186 (aggregate -> ( NuLL RECORD ) .)
INFO:root:    /               reduce using rule 186 (aggregate -> ( NuLL RECORD ) .)
INFO:root:    MOD             reduce using rule 186 (aggregate -> ( NuLL RECORD ) .)
INFO:root:    REM             reduce using rule 186 (aggregate -> ( NuLL RECORD ) .)
INFO:root:    STARSTAR        reduce using rule 186 (aggregate -> ( NuLL RECORD ) .)
INFO:root:    =               reduce using rule 186 (aggregate -> ( NuLL RECORD ) .)
INFO:root:    NEQ             reduce using rule 186 (aggregate -> ( NuLL RECORD ) .)
INFO:root:    <               reduce using rule 186 (aggregate -> ( NuLL RECORD ) .)
INFO:root:    LEQ             reduce using rule 186 (aggregate -> ( NuLL RECORD ) .)
INFO:root:    >               reduce using rule 186 (aggregate -> ( NuLL RECORD ) .)
INFO:root:    GEQ             reduce using rule 186 (aggregate -> ( NuLL RECORD ) .)
INFO:root:    IN              reduce using rule 186 (aggregate -> ( NuLL RECORD ) .)
INFO:root:    NOT             reduce using rule 186 (aggregate -> ( NuLL RECORD ) .)
INFO:root:    +               reduce using rule 186 (aggregate -> ( NuLL RECORD ) .)
INFO:root:    -               reduce using rule 186 (aggregate -> ( NuLL RECORD ) .)
INFO:root:    &               reduce using rule 186 (aggregate -> ( NuLL RECORD ) .)
INFO:root:    AND             reduce using rule 186 (aggregate -> ( NuLL RECORD ) .)
INFO:root:    OR              reduce using rule 186 (aggregate -> ( NuLL RECORD ) .)
INFO:root:    XOR             reduce using rule 186 (aggregate -> ( NuLL RECORD ) .)
INFO:root:    RANGE           reduce using rule 186 (aggregate -> ( NuLL RECORD ) .)
INFO:root:    RENAMES         reduce using rule 186 (aggregate -> ( NuLL RECORD ) .)
INFO:root:    ASSIGN          reduce using rule 186 (aggregate -> ( NuLL RECORD ) .)
INFO:root:    ;               reduce using rule 186 (aggregate -> ( NuLL RECORD ) .)
INFO:root:    WITH            reduce using rule 186 (aggregate -> ( NuLL RECORD ) .)
INFO:root:    DOTDOT          reduce using rule 186 (aggregate -> ( NuLL RECORD ) .)
INFO:root:    IS              reduce using rule 186 (aggregate -> ( NuLL RECORD ) .)
INFO:root:    )               reduce using rule 186 (aggregate -> ( NuLL RECORD ) .)
INFO:root:    ,               reduce using rule 186 (aggregate -> ( NuLL RECORD ) .)
INFO:root:    ARROW           reduce using rule 186 (aggregate -> ( NuLL RECORD ) .)
INFO:root:    |               reduce using rule 186 (aggregate -> ( NuLL RECORD ) .)
INFO:root:    THEN            reduce using rule 186 (aggregate -> ( NuLL RECORD ) .)
INFO:root:    LOOP            reduce using rule 186 (aggregate -> ( NuLL RECORD ) .)
INFO:root:    DIGITS          reduce using rule 186 (aggregate -> ( NuLL RECORD ) .)
INFO:root:
INFO:root:
INFO:root:state 513
INFO:root:
INFO:root:    (61) range_constraint -> RANGE range .
INFO:root:
INFO:root:    RENAMES         reduce using rule 61 (range_constraint -> RANGE range .)
INFO:root:    ASSIGN          reduce using rule 61 (range_constraint -> RANGE range .)
INFO:root:    ;               reduce using rule 61 (range_constraint -> RANGE range .)
INFO:root:    WITH            reduce using rule 61 (range_constraint -> RANGE range .)
INFO:root:    )               reduce using rule 61 (range_constraint -> RANGE range .)
INFO:root:    ,               reduce using rule 61 (range_constraint -> RANGE range .)
INFO:root:    ARROW           reduce using rule 61 (range_constraint -> RANGE range .)
INFO:root:    |               reduce using rule 61 (range_constraint -> RANGE range .)
INFO:root:    LOOP            reduce using rule 61 (range_constraint -> RANGE range .)
INFO:root:
INFO:root:
INFO:root:state 514
INFO:root:
INFO:root:    (164) indexed_comp -> name ( value_s ) .
INFO:root:
INFO:root:    TICK            reduce using rule 164 (indexed_comp -> name ( value_s ) .)
INFO:root:    (               reduce using rule 164 (indexed_comp -> name ( value_s ) .)
INFO:root:    .               reduce using rule 164 (indexed_comp -> name ( value_s ) .)
INFO:root:    *               reduce using rule 164 (indexed_comp -> name ( value_s ) .)
INFO:root:    /               reduce using rule 164 (indexed_comp -> name ( value_s ) .)
INFO:root:    MOD             reduce using rule 164 (indexed_comp -> name ( value_s ) .)
INFO:root:    REM             reduce using rule 164 (indexed_comp -> name ( value_s ) .)
INFO:root:    STARSTAR        reduce using rule 164 (indexed_comp -> name ( value_s ) .)
INFO:root:    =               reduce using rule 164 (indexed_comp -> name ( value_s ) .)
INFO:root:    NEQ             reduce using rule 164 (indexed_comp -> name ( value_s ) .)
INFO:root:    <               reduce using rule 164 (indexed_comp -> name ( value_s ) .)
INFO:root:    LEQ             reduce using rule 164 (indexed_comp -> name ( value_s ) .)
INFO:root:    >               reduce using rule 164 (indexed_comp -> name ( value_s ) .)
INFO:root:    GEQ             reduce using rule 164 (indexed_comp -> name ( value_s ) .)
INFO:root:    IN              reduce using rule 164 (indexed_comp -> name ( value_s ) .)
INFO:root:    NOT             reduce using rule 164 (indexed_comp -> name ( value_s ) .)
INFO:root:    +               reduce using rule 164 (indexed_comp -> name ( value_s ) .)
INFO:root:    -               reduce using rule 164 (indexed_comp -> name ( value_s ) .)
INFO:root:    &               reduce using rule 164 (indexed_comp -> name ( value_s ) .)
INFO:root:    AND             reduce using rule 164 (indexed_comp -> name ( value_s ) .)
INFO:root:    OR              reduce using rule 164 (indexed_comp -> name ( value_s ) .)
INFO:root:    XOR             reduce using rule 164 (indexed_comp -> name ( value_s ) .)
INFO:root:    )               reduce using rule 164 (indexed_comp -> name ( value_s ) .)
INFO:root:    ,               reduce using rule 164 (indexed_comp -> name ( value_s ) .)
INFO:root:    WITH            reduce using rule 164 (indexed_comp -> name ( value_s ) .)
INFO:root:    ARROW           reduce using rule 164 (indexed_comp -> name ( value_s ) .)
INFO:root:    |               reduce using rule 164 (indexed_comp -> name ( value_s ) .)
INFO:root:    ;               reduce using rule 164 (indexed_comp -> name ( value_s ) .)
INFO:root:    IS              reduce using rule 164 (indexed_comp -> name ( value_s ) .)
INFO:root:    THEN            reduce using rule 164 (indexed_comp -> name ( value_s ) .)
INFO:root:    LOOP            reduce using rule 164 (indexed_comp -> name ( value_s ) .)
INFO:root:    RANGE           reduce using rule 164 (indexed_comp -> name ( value_s ) .)
INFO:root:    DIGITS          reduce using rule 164 (indexed_comp -> name ( value_s ) .)
INFO:root:    RENAMES         reduce using rule 164 (indexed_comp -> name ( value_s ) .)
INFO:root:    ASSIGN          reduce using rule 164 (indexed_comp -> name ( value_s ) .)
INFO:root:    DOTDOT          reduce using rule 164 (indexed_comp -> name ( value_s ) .)
INFO:root:    WHEN            reduce using rule 164 (indexed_comp -> name ( value_s ) .)
INFO:root:
INFO:root:
INFO:root:state 515
INFO:root:
INFO:root:    (166) value_s -> value_s , . value
INFO:root:    (167) value -> . expression
INFO:root:    (168) value -> . comp_assoc
INFO:root:    (169) value -> . discrete_with_range
INFO:root:    (170) value -> . error
INFO:root:    (188) expression -> . relation
INFO:root:    (189) expression -> . expression logical relation
INFO:root:    (190) expression -> . expression short_circuit relation
INFO:root:    (187) comp_assoc -> . choice_s ARROW expression
INFO:root:    (126) discrete_with_range -> . name range_constraint
INFO:root:    (127) discrete_with_range -> . range
INFO:root:    (196) relation -> . simple_expression
INFO:root:    (197) relation -> . simple_expression relational simple_expression
INFO:root:    (198) relation -> . simple_expression membership range
INFO:root:    (199) relation -> . simple_expression membership name
INFO:root:    (121) choice_s -> . choice
INFO:root:    (122) choice_s -> . choice_s | choice
INFO:root:    (149) name -> . simple_name
INFO:root:    (150) name -> . indexed_comp
INFO:root:    (151) name -> . selected_comp
INFO:root:    (152) name -> . attribute
INFO:root:    (153) name -> . operator_symbol
INFO:root:    (62) range -> . simple_expression DOTDOT simple_expression
INFO:root:    (208) simple_expression -> . unary term
INFO:root:    (209) simple_expression -> . term
INFO:root:    (210) simple_expression -> . simple_expression adding term
INFO:root:    (123) choice -> . expression
INFO:root:    (124) choice -> . discrete_with_range
INFO:root:    (125) choice -> . OTHERS
INFO:root:    (157) simple_name -> . IDENTIFIER
INFO:root:    (164) indexed_comp -> . name ( value_s )
INFO:root:    (171) selected_comp -> . name . simple_name
INFO:root:    (172) selected_comp -> . name . used_char
INFO:root:    (173) selected_comp -> . name . operator_symbol
INFO:root:    (174) selected_comp -> . name . ALL
INFO:root:    (175) attribute -> . name TICK attribute_id
INFO:root:    (163) operator_symbol -> . STRING
INFO:root:    (211) unary -> . +
INFO:root:    (212) unary -> . -
INFO:root:    (216) term -> . factor
INFO:root:    (217) term -> . term multiplying factor
INFO:root:    (223) factor -> . primary
INFO:root:    (224) factor -> . NOT primary
INFO:root:    (225) factor -> . ABS primary
INFO:root:    (226) primary -> . literal
INFO:root:    (227) primary -> . name
INFO:root:    (228) primary -> . allocator
INFO:root:    (229) primary -> . qualified
INFO:root:    (230) primary -> . parenthesized_primary
INFO:root:    (180) literal -> . INT
INFO:root:    (181) literal -> . FLOAT
INFO:root:    (182) literal -> . NuLL
INFO:root:    (234) allocator -> . NEW name
INFO:root:    (235) allocator -> . NEW qualified
INFO:root:    (233) qualified -> . name TICK parenthesized_primary
INFO:root:    (231) parenthesized_primary -> . aggregate
INFO:root:    (232) parenthesized_primary -> . ( expression )
INFO:root:    (183) aggregate -> . ( comp_assoc )
INFO:root:    (184) aggregate -> . ( expression WITH value_s )
INFO:root:    (185) aggregate -> . ( expression WITH NuLL RECORD )
INFO:root:    (186) aggregate -> . ( NuLL RECORD )
INFO:root:
INFO:root:    error           shift and go to state 379
INFO:root:    OTHERS          shift and go to state 204
INFO:root:    IDENTIFIER      shift and go to state 33
INFO:root:    STRING          shift and go to state 149
INFO:root:    +               shift and go to state 148
INFO:root:    -               shift and go to state 136
INFO:root:    NOT             shift and go to state 131
INFO:root:    ABS             shift and go to state 132
INFO:root:    INT             shift and go to state 120
INFO:root:    FLOAT           shift and go to state 128
INFO:root:    NuLL            shift and go to state 130
INFO:root:    NEW             shift and go to state 137
INFO:root:    (               shift and go to state 125
INFO:root:
INFO:root:    value                          shift and go to state 650
INFO:root:    comp_assoc                     shift and go to state 376
INFO:root:    factor                         shift and go to state 126
INFO:root:    indexed_comp                   shift and go to state 140
INFO:root:    name                           shift and go to state 377
INFO:root:    literal                        shift and go to state 121
INFO:root:    selected_comp                  shift and go to state 139
INFO:root:    simple_name                    shift and go to state 163
INFO:root:    expression                     shift and go to state 373
INFO:root:    simple_expression              shift and go to state 374
INFO:root:    parenthesized_primary          shift and go to state 147
INFO:root:    unary                          shift and go to state 144
INFO:root:    term                           shift and go to state 146
INFO:root:    aggregate                      shift and go to state 143
INFO:root:    discrete_with_range            shift and go to state 378
INFO:root:    operator_symbol                shift and go to state 133
INFO:root:    qualified                      shift and go to state 145
INFO:root:    choice_s                       shift and go to state 202
INFO:root:    primary                        shift and go to state 135
INFO:root:    attribute                      shift and go to state 134
INFO:root:    relation                       shift and go to state 138
INFO:root:    range                          shift and go to state 211
INFO:root:    allocator                      shift and go to state 122
INFO:root:    choice                         shift and go to state 207
INFO:root:
INFO:root:state 516
INFO:root:
INFO:root:    (313) param_s -> param_s ; param .
INFO:root:
INFO:root:    )               reduce using rule 313 (param_s -> param_s ; param .)
INFO:root:    ;               reduce using rule 313 (param_s -> param_s ; param .)
INFO:root:
INFO:root:
INFO:root:state 517
INFO:root:
INFO:root:    (465) generic_formal -> WITH FUNCTION designator formal_part_opt RETURN . name subp_default ;
INFO:root:    (149) name -> . simple_name
INFO:root:    (150) name -> . indexed_comp
INFO:root:    (151) name -> . selected_comp
INFO:root:    (152) name -> . attribute
INFO:root:    (153) name -> . operator_symbol
INFO:root:    (157) simple_name -> . IDENTIFIER
INFO:root:    (164) indexed_comp -> . name ( value_s )
INFO:root:    (171) selected_comp -> . name . simple_name
INFO:root:    (172) selected_comp -> . name . used_char
INFO:root:    (173) selected_comp -> . name . operator_symbol
INFO:root:    (174) selected_comp -> . name . ALL
INFO:root:    (175) attribute -> . name TICK attribute_id
INFO:root:    (163) operator_symbol -> . STRING
INFO:root:
INFO:root:    IDENTIFIER      shift and go to state 33
INFO:root:    STRING          shift and go to state 149
INFO:root:
INFO:root:    selected_comp                  shift and go to state 139
INFO:root:    simple_name                    shift and go to state 163
INFO:root:    indexed_comp                   shift and go to state 140
INFO:root:    attribute                      shift and go to state 134
INFO:root:    name                           shift and go to state 651
INFO:root:    operator_symbol                shift and go to state 133
INFO:root:
INFO:root:state 518
INFO:root:
INFO:root:    (464) generic_formal -> WITH PROCEDURE simple_name formal_part_opt subp_default . ;
INFO:root:
INFO:root:    ;               shift and go to state 652
INFO:root:
INFO:root:
INFO:root:state 519
INFO:root:
INFO:root:    (473) subp_default -> IS . name
INFO:root:    (474) subp_default -> IS . BOX
INFO:root:    (149) name -> . simple_name
INFO:root:    (150) name -> . indexed_comp
INFO:root:    (151) name -> . selected_comp
INFO:root:    (152) name -> . attribute
INFO:root:    (153) name -> . operator_symbol
INFO:root:    (157) simple_name -> . IDENTIFIER
INFO:root:    (164) indexed_comp -> . name ( value_s )
INFO:root:    (171) selected_comp -> . name . simple_name
INFO:root:    (172) selected_comp -> . name . used_char
INFO:root:    (173) selected_comp -> . name . operator_symbol
INFO:root:    (174) selected_comp -> . name . ALL
INFO:root:    (175) attribute -> . name TICK attribute_id
INFO:root:    (163) operator_symbol -> . STRING
INFO:root:
INFO:root:    BOX             shift and go to state 653
INFO:root:    IDENTIFIER      shift and go to state 33
INFO:root:    STRING          shift and go to state 149
INFO:root:
INFO:root:    selected_comp                  shift and go to state 139
INFO:root:    simple_name                    shift and go to state 163
INFO:root:    indexed_comp                   shift and go to state 140
INFO:root:    attribute                      shift and go to state 134
INFO:root:    name                           shift and go to state 654
INFO:root:    operator_symbol                shift and go to state 133
INFO:root:
INFO:root:state 520
INFO:root:
INFO:root:    (466) generic_formal -> WITH PACKAGE simple_name IS NEW . name ( BOX ) ;
INFO:root:    (467) generic_formal -> WITH PACKAGE simple_name IS NEW . name ;
INFO:root:    (149) name -> . simple_name
INFO:root:    (150) name -> . indexed_comp
INFO:root:    (151) name -> . selected_comp
INFO:root:    (152) name -> . attribute
INFO:root:    (153) name -> . operator_symbol
INFO:root:    (157) simple_name -> . IDENTIFIER
INFO:root:    (164) indexed_comp -> . name ( value_s )
INFO:root:    (171) selected_comp -> . name . simple_name
INFO:root:    (172) selected_comp -> . name . used_char
INFO:root:    (173) selected_comp -> . name . operator_symbol
INFO:root:    (174) selected_comp -> . name . ALL
INFO:root:    (175) attribute -> . name TICK attribute_id
INFO:root:    (163) operator_symbol -> . STRING
INFO:root:
INFO:root:    IDENTIFIER      shift and go to state 33
INFO:root:    STRING          shift and go to state 149
INFO:root:
INFO:root:    selected_comp                  shift and go to state 139
INFO:root:    simple_name                    shift and go to state 163
INFO:root:    indexed_comp                   shift and go to state 140
INFO:root:    attribute                      shift and go to state 134
INFO:root:    name                           shift and go to state 655
INFO:root:    operator_symbol                shift and go to state 133
INFO:root:
INFO:root:state 521
INFO:root:
INFO:root:    (471) generic_discrim_part_opt -> ( BOX ) .
INFO:root:
INFO:root:    IS              reduce using rule 471 (generic_discrim_part_opt -> ( BOX ) .)
INFO:root:
INFO:root:
INFO:root:state 522
INFO:root:
INFO:root:    (113) discrim_spec -> def_id_s : . access_opt mark init_opt
INFO:root:    (115) access_opt -> .
INFO:root:    (116) access_opt -> . ACCESS
INFO:root:
INFO:root:    IDENTIFIER      reduce using rule 115 (access_opt -> .)
INFO:root:    ACCESS          shift and go to state 657
INFO:root:
INFO:root:    access_opt                     shift and go to state 656
INFO:root:
INFO:root:state 523
INFO:root:
INFO:root:    (110) discrim_part -> ( discrim_spec_s ) .
INFO:root:
INFO:root:    IS              reduce using rule 110 (discrim_part -> ( discrim_spec_s ) .)
INFO:root:    ;               reduce using rule 110 (discrim_part -> ( discrim_spec_s ) .)
INFO:root:
INFO:root:
INFO:root:state 524
INFO:root:
INFO:root:    (112) discrim_spec_s -> discrim_spec_s ; . discrim_spec
INFO:root:    (113) discrim_spec -> . def_id_s : access_opt mark init_opt
INFO:root:    (114) discrim_spec -> . error
INFO:root:    (24) def_id_s -> . def_id
INFO:root:    (25) def_id_s -> . def_id_s , def_id
INFO:root:    (26) def_id -> . IDENTIFIER
INFO:root:
INFO:root:    error           shift and go to state 399
INFO:root:    IDENTIFIER      shift and go to state 52
INFO:root:
INFO:root:    def_id                         shift and go to state 57
INFO:root:    def_id_s                       shift and go to state 400
INFO:root:    discrim_spec                   shift and go to state 658
INFO:root:
INFO:root:state 525
INFO:root:
INFO:root:    (483) generic_type_def -> private_type .
INFO:root:
INFO:root:    ;               reduce using rule 483 (generic_type_def -> private_type .)
INFO:root:
INFO:root:
INFO:root:state 526
INFO:root:
INFO:root:    (481) generic_type_def -> array_type .
INFO:root:
INFO:root:    ;               reduce using rule 481 (generic_type_def -> array_type .)
INFO:root:
INFO:root:
INFO:root:state 527
INFO:root:
INFO:root:    (463) generic_formal -> TYPE simple_name generic_discrim_part_opt IS generic_type_def . ;
INFO:root:
INFO:root:    ;               shift and go to state 659
INFO:root:
INFO:root:
INFO:root:state 528
INFO:root:
INFO:root:    (475) generic_type_def -> ( . BOX )
INFO:root:
INFO:root:    BOX             shift and go to state 660
INFO:root:
INFO:root:
INFO:root:state 529
INFO:root:
INFO:root:    (99) tagged_opt -> TAGGED .
INFO:root:
INFO:root:    LIMITED         reduce using rule 99 (tagged_opt -> TAGGED .)
INFO:root:    PRIVATE         reduce using rule 99 (tagged_opt -> TAGGED .)
INFO:root:    RECORD          reduce using rule 99 (tagged_opt -> TAGGED .)
INFO:root:    NuLL            reduce using rule 99 (tagged_opt -> TAGGED .)
INFO:root:
INFO:root:
INFO:root:state 530
INFO:root:
INFO:root:    (487) generic_derived_type -> ABSTRACT . NEW subtype_ind WITH PRIVATE
INFO:root:    (100) tagged_opt -> ABSTRACT . TAGGED
INFO:root:
INFO:root:    NEW             shift and go to state 662
INFO:root:    TAGGED          shift and go to state 661
INFO:root:
INFO:root:
INFO:root:state 531
INFO:root:
INFO:root:    (482) generic_type_def -> access_type .
INFO:root:
INFO:root:    ;               reduce using rule 482 (generic_type_def -> access_type .)
INFO:root:
INFO:root:
INFO:root:state 532
INFO:root:
INFO:root:    (477) generic_type_def -> MOD . BOX
INFO:root:
INFO:root:    BOX             shift and go to state 663
INFO:root:
INFO:root:
INFO:root:state 533
INFO:root:
INFO:root:    (480) generic_type_def -> DIGITS . BOX
INFO:root:
INFO:root:    BOX             shift and go to state 664
INFO:root:
INFO:root:
INFO:root:state 534
INFO:root:
INFO:root:    (128) access_type -> ACCESS . subtype_ind
INFO:root:    (129) access_type -> ACCESS . CONSTANT subtype_ind
INFO:root:    (130) access_type -> ACCESS . ALL subtype_ind
INFO:root:    (51) subtype_ind -> . name constraint
INFO:root:    (52) subtype_ind -> . name
INFO:root:    (149) name -> . simple_name
INFO:root:    (150) name -> . indexed_comp
INFO:root:    (151) name -> . selected_comp
INFO:root:    (152) name -> . attribute
INFO:root:    (153) name -> . operator_symbol
INFO:root:    (157) simple_name -> . IDENTIFIER
INFO:root:    (164) indexed_comp -> . name ( value_s )
INFO:root:    (171) selected_comp -> . name . simple_name
INFO:root:    (172) selected_comp -> . name . used_char
INFO:root:    (173) selected_comp -> . name . operator_symbol
INFO:root:    (174) selected_comp -> . name . ALL
INFO:root:    (175) attribute -> . name TICK attribute_id
INFO:root:    (163) operator_symbol -> . STRING
INFO:root:
INFO:root:    CONSTANT        shift and go to state 666
INFO:root:    ALL             shift and go to state 667
INFO:root:    IDENTIFIER      shift and go to state 33
INFO:root:    STRING          shift and go to state 149
INFO:root:
INFO:root:    selected_comp                  shift and go to state 139
INFO:root:    simple_name                    shift and go to state 163
INFO:root:    indexed_comp                   shift and go to state 140
INFO:root:    attribute                      shift and go to state 134
INFO:root:    name                           shift and go to state 432
INFO:root:    operator_symbol                shift and go to state 133
INFO:root:    subtype_ind                    shift and go to state 665
INFO:root:
INFO:root:state 535
INFO:root:
INFO:root:    (476) generic_type_def -> RANGE . BOX
INFO:root:
INFO:root:    BOX             shift and go to state 668
INFO:root:
INFO:root:
INFO:root:state 536
INFO:root:
INFO:root:    (484) generic_type_def -> generic_derived_type .
INFO:root:
INFO:root:    ;               reduce using rule 484 (generic_type_def -> generic_derived_type .)
INFO:root:
INFO:root:
INFO:root:state 537
INFO:root:
INFO:root:    (478) generic_type_def -> DELTA . BOX
INFO:root:    (479) generic_type_def -> DELTA . BOX DIGITS BOX
INFO:root:
INFO:root:    BOX             shift and go to state 669
INFO:root:
INFO:root:
INFO:root:state 538
INFO:root:
INFO:root:    (334) private_type -> tagged_opt . limited_opt PRIVATE
INFO:root:    (335) limited_opt -> .
INFO:root:    (336) limited_opt -> . LIMITED
INFO:root:
INFO:root:    PRIVATE         reduce using rule 335 (limited_opt -> .)
INFO:root:    LIMITED         shift and go to state 670
INFO:root:
INFO:root:    limited_opt                    shift and go to state 671
INFO:root:
INFO:root:state 539
INFO:root:
INFO:root:    (485) generic_derived_type -> NEW . subtype_ind
INFO:root:    (486) generic_derived_type -> NEW . subtype_ind WITH PRIVATE
INFO:root:    (51) subtype_ind -> . name constraint
INFO:root:    (52) subtype_ind -> . name
INFO:root:    (149) name -> . simple_name
INFO:root:    (150) name -> . indexed_comp
INFO:root:    (151) name -> . selected_comp
INFO:root:    (152) name -> . attribute
INFO:root:    (153) name -> . operator_symbol
INFO:root:    (157) simple_name -> . IDENTIFIER
INFO:root:    (164) indexed_comp -> . name ( value_s )
INFO:root:    (171) selected_comp -> . name . simple_name
INFO:root:    (172) selected_comp -> . name . used_char
INFO:root:    (173) selected_comp -> . name . operator_symbol
INFO:root:    (174) selected_comp -> . name . ALL
INFO:root:    (175) attribute -> . name TICK attribute_id
INFO:root:    (163) operator_symbol -> . STRING
INFO:root:
INFO:root:    IDENTIFIER      shift and go to state 33
INFO:root:    STRING          shift and go to state 149
INFO:root:
INFO:root:    selected_comp                  shift and go to state 139
INFO:root:    simple_name                    shift and go to state 163
INFO:root:    indexed_comp                   shift and go to state 140
INFO:root:    attribute                      shift and go to state 134
INFO:root:    name                           shift and go to state 432
INFO:root:    operator_symbol                shift and go to state 133
INFO:root:    subtype_ind                    shift and go to state 672
INFO:root:
INFO:root:state 540
INFO:root:
INFO:root:    (34) init_opt -> ASSIGN . expression
INFO:root:    (188) expression -> . relation
INFO:root:    (189) expression -> . expression logical relation
INFO:root:    (190) expression -> . expression short_circuit relation
INFO:root:    (196) relation -> . simple_expression
INFO:root:    (197) relation -> . simple_expression relational simple_expression
INFO:root:    (198) relation -> . simple_expression membership range
INFO:root:    (199) relation -> . simple_expression membership name
INFO:root:    (208) simple_expression -> . unary term
INFO:root:    (209) simple_expression -> . term
INFO:root:    (210) simple_expression -> . simple_expression adding term
INFO:root:    (211) unary -> . +
INFO:root:    (212) unary -> . -
INFO:root:    (216) term -> . factor
INFO:root:    (217) term -> . term multiplying factor
INFO:root:    (223) factor -> . primary
INFO:root:    (224) factor -> . NOT primary
INFO:root:    (225) factor -> . ABS primary
INFO:root:    (226) primary -> . literal
INFO:root:    (227) primary -> . name
INFO:root:    (228) primary -> . allocator
INFO:root:    (229) primary -> . qualified
INFO:root:    (230) primary -> . parenthesized_primary
INFO:root:    (180) literal -> . INT
INFO:root:    (181) literal -> . FLOAT
INFO:root:    (182) literal -> . NuLL
INFO:root:    (149) name -> . simple_name
INFO:root:    (150) name -> . indexed_comp
INFO:root:    (151) name -> . selected_comp
INFO:root:    (152) name -> . attribute
INFO:root:    (153) name -> . operator_symbol
INFO:root:    (234) allocator -> . NEW name
INFO:root:    (235) allocator -> . NEW qualified
INFO:root:    (233) qualified -> . name TICK parenthesized_primary
INFO:root:    (231) parenthesized_primary -> . aggregate
INFO:root:    (232) parenthesized_primary -> . ( expression )
INFO:root:    (157) simple_name -> . IDENTIFIER
INFO:root:    (164) indexed_comp -> . name ( value_s )
INFO:root:    (171) selected_comp -> . name . simple_name
INFO:root:    (172) selected_comp -> . name . used_char
INFO:root:    (173) selected_comp -> . name . operator_symbol
INFO:root:    (174) selected_comp -> . name . ALL
INFO:root:    (175) attribute -> . name TICK attribute_id
INFO:root:    (163) operator_symbol -> . STRING
INFO:root:    (183) aggregate -> . ( comp_assoc )
INFO:root:    (184) aggregate -> . ( expression WITH value_s )
INFO:root:    (185) aggregate -> . ( expression WITH NuLL RECORD )
INFO:root:    (186) aggregate -> . ( NuLL RECORD )
INFO:root:
INFO:root:    +               shift and go to state 148
INFO:root:    -               shift and go to state 136
INFO:root:    NOT             shift and go to state 131
INFO:root:    ABS             shift and go to state 132
INFO:root:    INT             shift and go to state 120
INFO:root:    FLOAT           shift and go to state 128
INFO:root:    NuLL            shift and go to state 130
INFO:root:    NEW             shift and go to state 137
INFO:root:    (               shift and go to state 125
INFO:root:    IDENTIFIER      shift and go to state 33
INFO:root:    STRING          shift and go to state 149
INFO:root:
INFO:root:    literal                        shift and go to state 121
INFO:root:    allocator                      shift and go to state 122
INFO:root:    simple_name                    shift and go to state 163
INFO:root:    indexed_comp                   shift and go to state 140
INFO:root:    name                           shift and go to state 142
INFO:root:    selected_comp                  shift and go to state 139
INFO:root:    factor                         shift and go to state 126
INFO:root:    expression                     shift and go to state 673
INFO:root:    unary                          shift and go to state 144
INFO:root:    qualified                      shift and go to state 145
INFO:root:    aggregate                      shift and go to state 143
INFO:root:    simple_expression              shift and go to state 129
INFO:root:    term                           shift and go to state 146
INFO:root:    operator_symbol                shift and go to state 133
INFO:root:    parenthesized_primary          shift and go to state 147
INFO:root:    attribute                      shift and go to state 134
INFO:root:    primary                        shift and go to state 135
INFO:root:    relation                       shift and go to state 138
INFO:root:
INFO:root:state 541
INFO:root:
INFO:root:    (314) param -> def_id_s : mode mark init_opt .
INFO:root:
INFO:root:    )               reduce using rule 314 (param -> def_id_s : mode mark init_opt .)
INFO:root:    ;               reduce using rule 314 (param -> def_id_s : mode mark init_opt .)
INFO:root:
INFO:root:
INFO:root:state 542
INFO:root:
INFO:root:    (321) subprog_spec_is_push -> subprog_spec IS .
INFO:root:
INFO:root:    PACKAGE         reduce using rule 321 (subprog_spec_is_push -> subprog_spec IS .)
INFO:root:    TASK            reduce using rule 321 (subprog_spec_is_push -> subprog_spec IS .)
INFO:root:    PROTECTED       reduce using rule 321 (subprog_spec_is_push -> subprog_spec IS .)
INFO:root:    error           reduce using rule 321 (subprog_spec_is_push -> subprog_spec IS .)
INFO:root:    USE             reduce using rule 321 (subprog_spec_is_push -> subprog_spec IS .)
INFO:root:    PRAGMA          reduce using rule 321 (subprog_spec_is_push -> subprog_spec IS .)
INFO:root:    TYPE            reduce using rule 321 (subprog_spec_is_push -> subprog_spec IS .)
INFO:root:    SUBTYPE         reduce using rule 321 (subprog_spec_is_push -> subprog_spec IS .)
INFO:root:    FOR             reduce using rule 321 (subprog_spec_is_push -> subprog_spec IS .)
INFO:root:    PROCEDURE       reduce using rule 321 (subprog_spec_is_push -> subprog_spec IS .)
INFO:root:    FUNCTION        reduce using rule 321 (subprog_spec_is_push -> subprog_spec IS .)
INFO:root:    GENERIC         reduce using rule 321 (subprog_spec_is_push -> subprog_spec IS .)
INFO:root:    IDENTIFIER      reduce using rule 321 (subprog_spec_is_push -> subprog_spec IS .)
INFO:root:    BEGIN           reduce using rule 321 (subprog_spec_is_push -> subprog_spec IS .)
INFO:root:
INFO:root:
INFO:root:state 543
INFO:root:
INFO:root:    (356) task_body -> TASK BODY . simple_name IS decl_part block_body END id_opt ;
INFO:root:    (157) simple_name -> . IDENTIFIER
INFO:root:
INFO:root:    IDENTIFIER      shift and go to state 33
INFO:root:
INFO:root:    simple_name                    shift and go to state 674
INFO:root:
INFO:root:state 544
INFO:root:
INFO:root:    (373) prot_body -> PROTECTED BODY . simple_name IS prot_op_body_s END id_opt ;
INFO:root:    (157) simple_name -> . IDENTIFIER
INFO:root:
INFO:root:    IDENTIFIER      shift and go to state 33
INFO:root:
INFO:root:    simple_name                    shift and go to state 675
INFO:root:
INFO:root:state 545
INFO:root:
INFO:root:    (443) body_stub -> PACKAGE BODY compound_name . IS SEPARATE ;
INFO:root:    (159) compound_name -> compound_name . . simple_name
INFO:root:
INFO:root:    IS              shift and go to state 676
INFO:root:    .               shift and go to state 116
INFO:root:
INFO:root:
INFO:root:state 546
INFO:root:
INFO:root:    (442) body_stub -> TASK BODY simple_name . IS SEPARATE ;
INFO:root:
INFO:root:    IS              shift and go to state 677
INFO:root:
INFO:root:
INFO:root:state 547
INFO:root:
INFO:root:    (445) body_stub -> PROTECTED BODY simple_name . IS SEPARATE ;
INFO:root:
INFO:root:    IS              shift and go to state 678
INFO:root:
INFO:root:
INFO:root:state 548
INFO:root:
INFO:root:    (326) pkg_spec -> PACKAGE compound_name IS decl_item_s private_part END . c_id_opt
INFO:root:    (329) c_id_opt -> .
INFO:root:    (330) c_id_opt -> . compound_name
INFO:root:    (158) compound_name -> . simple_name
INFO:root:    (159) compound_name -> . compound_name . simple_name
INFO:root:    (157) simple_name -> . IDENTIFIER
INFO:root:
INFO:root:    ;               reduce using rule 329 (c_id_opt -> .)
INFO:root:    IDENTIFIER      shift and go to state 33
INFO:root:
INFO:root:    simple_name                    shift and go to state 34
INFO:root:    c_id_opt                       shift and go to state 680
INFO:root:    compound_name                  shift and go to state 679
INFO:root:
INFO:root:state 549
INFO:root:
INFO:root:    (328) private_part -> PRIVATE decl_item_s .
INFO:root:
INFO:root:    END             reduce using rule 328 (private_part -> PRIVATE decl_item_s .)
INFO:root:
INFO:root:
INFO:root:state 550
INFO:root:
INFO:root:    (331) pkg_body -> PACKAGE BODY compound_name IS decl_part body_opt . END c_id_opt ;
INFO:root:
INFO:root:    END             shift and go to state 681
INFO:root:
INFO:root:
INFO:root:state 551
INFO:root:
INFO:root:    (333) body_opt -> block_body .
INFO:root:
INFO:root:    END             reduce using rule 333 (body_opt -> block_body .)
INFO:root:
INFO:root:
INFO:root:state 552
INFO:root:
INFO:root:    (443) body_stub -> PACKAGE BODY compound_name IS SEPARATE . ;
INFO:root:
INFO:root:    ;               shift and go to state 682
INFO:root:
INFO:root:
INFO:root:state 553
INFO:root:
INFO:root:    (36) type_decl -> TYPE IDENTIFIER discrim_part_opt type_completion ; .
INFO:root:
INFO:root:    PACKAGE         reduce using rule 36 (type_decl -> TYPE IDENTIFIER discrim_part_opt type_completion ; .)
INFO:root:    TASK            reduce using rule 36 (type_decl -> TYPE IDENTIFIER discrim_part_opt type_completion ; .)
INFO:root:    PROTECTED       reduce using rule 36 (type_decl -> TYPE IDENTIFIER discrim_part_opt type_completion ; .)
INFO:root:    error           reduce using rule 36 (type_decl -> TYPE IDENTIFIER discrim_part_opt type_completion ; .)
INFO:root:    USE             reduce using rule 36 (type_decl -> TYPE IDENTIFIER discrim_part_opt type_completion ; .)
INFO:root:    PRAGMA          reduce using rule 36 (type_decl -> TYPE IDENTIFIER discrim_part_opt type_completion ; .)
INFO:root:    TYPE            reduce using rule 36 (type_decl -> TYPE IDENTIFIER discrim_part_opt type_completion ; .)
INFO:root:    SUBTYPE         reduce using rule 36 (type_decl -> TYPE IDENTIFIER discrim_part_opt type_completion ; .)
INFO:root:    FOR             reduce using rule 36 (type_decl -> TYPE IDENTIFIER discrim_part_opt type_completion ; .)
INFO:root:    PROCEDURE       reduce using rule 36 (type_decl -> TYPE IDENTIFIER discrim_part_opt type_completion ; .)
INFO:root:    FUNCTION        reduce using rule 36 (type_decl -> TYPE IDENTIFIER discrim_part_opt type_completion ; .)
INFO:root:    GENERIC         reduce using rule 36 (type_decl -> TYPE IDENTIFIER discrim_part_opt type_completion ; .)
INFO:root:    IDENTIFIER      reduce using rule 36 (type_decl -> TYPE IDENTIFIER discrim_part_opt type_completion ; .)
INFO:root:    BEGIN           reduce using rule 36 (type_decl -> TYPE IDENTIFIER discrim_part_opt type_completion ; .)
INFO:root:    PRIVATE         reduce using rule 36 (type_decl -> TYPE IDENTIFIER discrim_part_opt type_completion ; .)
INFO:root:    END             reduce using rule 36 (type_decl -> TYPE IDENTIFIER discrim_part_opt type_completion ; .)
INFO:root:
INFO:root:
INFO:root:state 554
INFO:root:
INFO:root:    (74) real_type -> fixed_type .
INFO:root:
INFO:root:    ;               reduce using rule 74 (real_type -> fixed_type .)
INFO:root:
INFO:root:
INFO:root:state 555
INFO:root:
INFO:root:    (44) type_def -> real_type .
INFO:root:
INFO:root:    ;               reduce using rule 44 (type_def -> real_type .)
INFO:root:
INFO:root:
INFO:root:state 556
INFO:root:
INFO:root:    (43) type_def -> integer_type .
INFO:root:
INFO:root:    ;               reduce using rule 43 (type_def -> integer_type .)
INFO:root:
INFO:root:
INFO:root:state 557
INFO:root:
INFO:root:    (48) type_def -> derived_type .
INFO:root:
INFO:root:    ;               reduce using rule 48 (type_def -> derived_type .)
INFO:root:
INFO:root:
INFO:root:state 558
INFO:root:
INFO:root:    (49) type_def -> private_type .
INFO:root:
INFO:root:    ;               reduce using rule 49 (type_def -> private_type .)
INFO:root:
INFO:root:
INFO:root:state 559
INFO:root:
INFO:root:    (56) derived_type -> NEW . subtype_ind
INFO:root:    (57) derived_type -> NEW . subtype_ind WITH PRIVATE
INFO:root:    (58) derived_type -> NEW . subtype_ind WITH record_def
INFO:root:    (51) subtype_ind -> . name constraint
INFO:root:    (52) subtype_ind -> . name
INFO:root:    (149) name -> . simple_name
INFO:root:    (150) name -> . indexed_comp
INFO:root:    (151) name -> . selected_comp
INFO:root:    (152) name -> . attribute
INFO:root:    (153) name -> . operator_symbol
INFO:root:    (157) simple_name -> . IDENTIFIER
INFO:root:    (164) indexed_comp -> . name ( value_s )
INFO:root:    (171) selected_comp -> . name . simple_name
INFO:root:    (172) selected_comp -> . name . used_char
INFO:root:    (173) selected_comp -> . name . operator_symbol
INFO:root:    (174) selected_comp -> . name . ALL
INFO:root:    (175) attribute -> . name TICK attribute_id
INFO:root:    (163) operator_symbol -> . STRING
INFO:root:
INFO:root:    IDENTIFIER      shift and go to state 33
INFO:root:    STRING          shift and go to state 149
INFO:root:
INFO:root:    selected_comp                  shift and go to state 139
INFO:root:    indexed_comp                   shift and go to state 140
INFO:root:    attribute                      shift and go to state 134
INFO:root:    name                           shift and go to state 432
INFO:root:    operator_symbol                shift and go to state 133
INFO:root:    subtype_ind                    shift and go to state 683
INFO:root:    simple_name                    shift and go to state 163
INFO:root:
INFO:root:state 560
INFO:root:
INFO:root:    (69) integer_type -> MOD . expression
INFO:root:    (188) expression -> . relation
INFO:root:    (189) expression -> . expression logical relation
INFO:root:    (190) expression -> . expression short_circuit relation
INFO:root:    (196) relation -> . simple_expression
INFO:root:    (197) relation -> . simple_expression relational simple_expression
INFO:root:    (198) relation -> . simple_expression membership range
INFO:root:    (199) relation -> . simple_expression membership name
INFO:root:    (208) simple_expression -> . unary term
INFO:root:    (209) simple_expression -> . term
INFO:root:    (210) simple_expression -> . simple_expression adding term
INFO:root:    (211) unary -> . +
INFO:root:    (212) unary -> . -
INFO:root:    (216) term -> . factor
INFO:root:    (217) term -> . term multiplying factor
INFO:root:    (223) factor -> . primary
INFO:root:    (224) factor -> . NOT primary
INFO:root:    (225) factor -> . ABS primary
INFO:root:    (226) primary -> . literal
INFO:root:    (227) primary -> . name
INFO:root:    (228) primary -> . allocator
INFO:root:    (229) primary -> . qualified
INFO:root:    (230) primary -> . parenthesized_primary
INFO:root:    (180) literal -> . INT
INFO:root:    (181) literal -> . FLOAT
INFO:root:    (182) literal -> . NuLL
INFO:root:    (149) name -> . simple_name
INFO:root:    (150) name -> . indexed_comp
INFO:root:    (151) name -> . selected_comp
INFO:root:    (152) name -> . attribute
INFO:root:    (153) name -> . operator_symbol
INFO:root:    (234) allocator -> . NEW name
INFO:root:    (235) allocator -> . NEW qualified
INFO:root:    (233) qualified -> . name TICK parenthesized_primary
INFO:root:    (231) parenthesized_primary -> . aggregate
INFO:root:    (232) parenthesized_primary -> . ( expression )
INFO:root:    (157) simple_name -> . IDENTIFIER
INFO:root:    (164) indexed_comp -> . name ( value_s )
INFO:root:    (171) selected_comp -> . name . simple_name
INFO:root:    (172) selected_comp -> . name . used_char
INFO:root:    (173) selected_comp -> . name . operator_symbol
INFO:root:    (174) selected_comp -> . name . ALL
INFO:root:    (175) attribute -> . name TICK attribute_id
INFO:root:    (163) operator_symbol -> . STRING
INFO:root:    (183) aggregate -> . ( comp_assoc )
INFO:root:    (184) aggregate -> . ( expression WITH value_s )
INFO:root:    (185) aggregate -> . ( expression WITH NuLL RECORD )
INFO:root:    (186) aggregate -> . ( NuLL RECORD )
INFO:root:
INFO:root:    +               shift and go to state 148
INFO:root:    -               shift and go to state 136
INFO:root:    NOT             shift and go to state 131
INFO:root:    ABS             shift and go to state 132
INFO:root:    INT             shift and go to state 120
INFO:root:    FLOAT           shift and go to state 128
INFO:root:    NuLL            shift and go to state 130
INFO:root:    NEW             shift and go to state 137
INFO:root:    (               shift and go to state 125
INFO:root:    IDENTIFIER      shift and go to state 33
INFO:root:    STRING          shift and go to state 149
INFO:root:
INFO:root:    literal                        shift and go to state 121
INFO:root:    allocator                      shift and go to state 122
INFO:root:    simple_name                    shift and go to state 163
INFO:root:    indexed_comp                   shift and go to state 140
INFO:root:    name                           shift and go to state 142
INFO:root:    selected_comp                  shift and go to state 139
INFO:root:    factor                         shift and go to state 126
INFO:root:    expression                     shift and go to state 684
INFO:root:    unary                          shift and go to state 144
INFO:root:    qualified                      shift and go to state 145
INFO:root:    aggregate                      shift and go to state 143
INFO:root:    simple_expression              shift and go to state 129
INFO:root:    term                           shift and go to state 146
INFO:root:    operator_symbol                shift and go to state 133
INFO:root:    parenthesized_primary          shift and go to state 147
INFO:root:    attribute                      shift and go to state 134
INFO:root:    primary                        shift and go to state 135
INFO:root:    relation                       shift and go to state 138
INFO:root:
INFO:root:state 561
INFO:root:
INFO:root:    (68) integer_type -> range_spec .
INFO:root:
INFO:root:    ;               reduce using rule 68 (integer_type -> range_spec .)
INFO:root:
INFO:root:
INFO:root:state 562
INFO:root:
INFO:root:    (42) type_def -> enumeration_type .
INFO:root:
INFO:root:    ;               reduce using rule 42 (type_def -> enumeration_type .)
INFO:root:
INFO:root:
INFO:root:state 563
INFO:root:
INFO:root:    (46) type_def -> record_type .
INFO:root:
INFO:root:    ;               reduce using rule 46 (type_def -> record_type .)
INFO:root:
INFO:root:
INFO:root:state 564
INFO:root:
INFO:root:    (63) enumeration_type -> ( . enum_id_s )
INFO:root:    (64) enum_id_s -> . enum_id
INFO:root:    (65) enum_id_s -> . enum_id_s , enum_id
INFO:root:    (66) enum_id -> . IDENTIFIER
INFO:root:    (67) enum_id -> . CHAR
INFO:root:
INFO:root:    IDENTIFIER      shift and go to state 685
INFO:root:    CHAR            shift and go to state 687
INFO:root:
INFO:root:    enum_id                        shift and go to state 688
INFO:root:    enum_id_s                      shift and go to state 686
INFO:root:
INFO:root:state 565
INFO:root:
INFO:root:    (95) record_type -> tagged_opt . limited_opt record_def
INFO:root:    (334) private_type -> tagged_opt . limited_opt PRIVATE
INFO:root:    (335) limited_opt -> .
INFO:root:    (336) limited_opt -> . LIMITED
INFO:root:
INFO:root:    PRIVATE         reduce using rule 335 (limited_opt -> .)
INFO:root:    RECORD          reduce using rule 335 (limited_opt -> .)
INFO:root:    NuLL            reduce using rule 335 (limited_opt -> .)
INFO:root:    LIMITED         shift and go to state 670
INFO:root:
INFO:root:    limited_opt                    shift and go to state 689
INFO:root:
INFO:root:state 566
INFO:root:
INFO:root:    (59) derived_type -> ABSTRACT . NEW subtype_ind WITH PRIVATE
INFO:root:    (60) derived_type -> ABSTRACT . NEW subtype_ind WITH record_def
INFO:root:    (100) tagged_opt -> ABSTRACT . TAGGED
INFO:root:
INFO:root:    NEW             shift and go to state 690
INFO:root:    TAGGED          shift and go to state 661
INFO:root:
INFO:root:
INFO:root:state 567
INFO:root:
INFO:root:    (75) float_type -> DIGITS . expression range_spec_opt
INFO:root:    (188) expression -> . relation
INFO:root:    (189) expression -> . expression logical relation
INFO:root:    (190) expression -> . expression short_circuit relation
INFO:root:    (196) relation -> . simple_expression
INFO:root:    (197) relation -> . simple_expression relational simple_expression
INFO:root:    (198) relation -> . simple_expression membership range
INFO:root:    (199) relation -> . simple_expression membership name
INFO:root:    (208) simple_expression -> . unary term
INFO:root:    (209) simple_expression -> . term
INFO:root:    (210) simple_expression -> . simple_expression adding term
INFO:root:    (211) unary -> . +
INFO:root:    (212) unary -> . -
INFO:root:    (216) term -> . factor
INFO:root:    (217) term -> . term multiplying factor
INFO:root:    (223) factor -> . primary
INFO:root:    (224) factor -> . NOT primary
INFO:root:    (225) factor -> . ABS primary
INFO:root:    (226) primary -> . literal
INFO:root:    (227) primary -> . name
INFO:root:    (228) primary -> . allocator
INFO:root:    (229) primary -> . qualified
INFO:root:    (230) primary -> . parenthesized_primary
INFO:root:    (180) literal -> . INT
INFO:root:    (181) literal -> . FLOAT
INFO:root:    (182) literal -> . NuLL
INFO:root:    (149) name -> . simple_name
INFO:root:    (150) name -> . indexed_comp
INFO:root:    (151) name -> . selected_comp
INFO:root:    (152) name -> . attribute
INFO:root:    (153) name -> . operator_symbol
INFO:root:    (234) allocator -> . NEW name
INFO:root:    (235) allocator -> . NEW qualified
INFO:root:    (233) qualified -> . name TICK parenthesized_primary
INFO:root:    (231) parenthesized_primary -> . aggregate
INFO:root:    (232) parenthesized_primary -> . ( expression )
INFO:root:    (157) simple_name -> . IDENTIFIER
INFO:root:    (164) indexed_comp -> . name ( value_s )
INFO:root:    (171) selected_comp -> . name . simple_name
INFO:root:    (172) selected_comp -> . name . used_char
INFO:root:    (173) selected_comp -> . name . operator_symbol
INFO:root:    (174) selected_comp -> . name . ALL
INFO:root:    (175) attribute -> . name TICK attribute_id
INFO:root:    (163) operator_symbol -> . STRING
INFO:root:    (183) aggregate -> . ( comp_assoc )
INFO:root:    (184) aggregate -> . ( expression WITH value_s )
INFO:root:    (185) aggregate -> . ( expression WITH NuLL RECORD )
INFO:root:    (186) aggregate -> . ( NuLL RECORD )
INFO:root:
INFO:root:    +               shift and go to state 148
INFO:root:    -               shift and go to state 136
INFO:root:    NOT             shift and go to state 131
INFO:root:    ABS             shift and go to state 132
INFO:root:    INT             shift and go to state 120
INFO:root:    FLOAT           shift and go to state 128
INFO:root:    NuLL            shift and go to state 130
INFO:root:    NEW             shift and go to state 137
INFO:root:    (               shift and go to state 125
INFO:root:    IDENTIFIER      shift and go to state 33
INFO:root:    STRING          shift and go to state 149
INFO:root:
INFO:root:    literal                        shift and go to state 121
INFO:root:    allocator                      shift and go to state 122
INFO:root:    simple_name                    shift and go to state 163
INFO:root:    indexed_comp                   shift and go to state 140
INFO:root:    name                           shift and go to state 142
INFO:root:    selected_comp                  shift and go to state 139
INFO:root:    factor                         shift and go to state 126
INFO:root:    expression                     shift and go to state 691
INFO:root:    unary                          shift and go to state 144
INFO:root:    qualified                      shift and go to state 145
INFO:root:    aggregate                      shift and go to state 143
INFO:root:    simple_expression              shift and go to state 129
INFO:root:    term                           shift and go to state 146
INFO:root:    operator_symbol                shift and go to state 133
INFO:root:    parenthesized_primary          shift and go to state 147
INFO:root:    attribute                      shift and go to state 134
INFO:root:    primary                        shift and go to state 135
INFO:root:    relation                       shift and go to state 138
INFO:root:
INFO:root:state 568
INFO:root:
INFO:root:    (47) type_def -> access_type .
INFO:root:
INFO:root:    ;               reduce using rule 47 (type_def -> access_type .)
INFO:root:
INFO:root:
INFO:root:state 569
INFO:root:
INFO:root:    (45) type_def -> array_type .
INFO:root:
INFO:root:    ;               reduce using rule 45 (type_def -> array_type .)
INFO:root:
INFO:root:
INFO:root:state 570
INFO:root:
INFO:root:    (70) range_spec -> range_constraint .
INFO:root:
INFO:root:    ;               reduce using rule 70 (range_spec -> range_constraint .)
INFO:root:
INFO:root:
INFO:root:state 571
INFO:root:
INFO:root:    (76) fixed_type -> DELTA . expression range_spec
INFO:root:    (77) fixed_type -> DELTA . expression DIGITS expression range_spec_opt
INFO:root:    (188) expression -> . relation
INFO:root:    (189) expression -> . expression logical relation
INFO:root:    (190) expression -> . expression short_circuit relation
INFO:root:    (196) relation -> . simple_expression
INFO:root:    (197) relation -> . simple_expression relational simple_expression
INFO:root:    (198) relation -> . simple_expression membership range
INFO:root:    (199) relation -> . simple_expression membership name
INFO:root:    (208) simple_expression -> . unary term
INFO:root:    (209) simple_expression -> . term
INFO:root:    (210) simple_expression -> . simple_expression adding term
INFO:root:    (211) unary -> . +
INFO:root:    (212) unary -> . -
INFO:root:    (216) term -> . factor
INFO:root:    (217) term -> . term multiplying factor
INFO:root:    (223) factor -> . primary
INFO:root:    (224) factor -> . NOT primary
INFO:root:    (225) factor -> . ABS primary
INFO:root:    (226) primary -> . literal
INFO:root:    (227) primary -> . name
INFO:root:    (228) primary -> . allocator
INFO:root:    (229) primary -> . qualified
INFO:root:    (230) primary -> . parenthesized_primary
INFO:root:    (180) literal -> . INT
INFO:root:    (181) literal -> . FLOAT
INFO:root:    (182) literal -> . NuLL
INFO:root:    (149) name -> . simple_name
INFO:root:    (150) name -> . indexed_comp
INFO:root:    (151) name -> . selected_comp
INFO:root:    (152) name -> . attribute
INFO:root:    (153) name -> . operator_symbol
INFO:root:    (234) allocator -> . NEW name
INFO:root:    (235) allocator -> . NEW qualified
INFO:root:    (233) qualified -> . name TICK parenthesized_primary
INFO:root:    (231) parenthesized_primary -> . aggregate
INFO:root:    (232) parenthesized_primary -> . ( expression )
INFO:root:    (157) simple_name -> . IDENTIFIER
INFO:root:    (164) indexed_comp -> . name ( value_s )
INFO:root:    (171) selected_comp -> . name . simple_name
INFO:root:    (172) selected_comp -> . name . used_char
INFO:root:    (173) selected_comp -> . name . operator_symbol
INFO:root:    (174) selected_comp -> . name . ALL
INFO:root:    (175) attribute -> . name TICK attribute_id
INFO:root:    (163) operator_symbol -> . STRING
INFO:root:    (183) aggregate -> . ( comp_assoc )
INFO:root:    (184) aggregate -> . ( expression WITH value_s )
INFO:root:    (185) aggregate -> . ( expression WITH NuLL RECORD )
INFO:root:    (186) aggregate -> . ( NuLL RECORD )
INFO:root:
INFO:root:    +               shift and go to state 148
INFO:root:    -               shift and go to state 136
INFO:root:    NOT             shift and go to state 131
INFO:root:    ABS             shift and go to state 132
INFO:root:    INT             shift and go to state 120
INFO:root:    FLOAT           shift and go to state 128
INFO:root:    NuLL            shift and go to state 130
INFO:root:    NEW             shift and go to state 137
INFO:root:    (               shift and go to state 125
INFO:root:    IDENTIFIER      shift and go to state 33
INFO:root:    STRING          shift and go to state 149
INFO:root:
INFO:root:    literal                        shift and go to state 121
INFO:root:    allocator                      shift and go to state 122
INFO:root:    simple_name                    shift and go to state 163
INFO:root:    indexed_comp                   shift and go to state 140
INFO:root:    name                           shift and go to state 142
INFO:root:    selected_comp                  shift and go to state 139
INFO:root:    factor                         shift and go to state 126
INFO:root:    expression                     shift and go to state 692
INFO:root:    unary                          shift and go to state 144
INFO:root:    qualified                      shift and go to state 145
INFO:root:    aggregate                      shift and go to state 143
INFO:root:    simple_expression              shift and go to state 129
INFO:root:    term                           shift and go to state 146
INFO:root:    operator_symbol                shift and go to state 133
INFO:root:    parenthesized_primary          shift and go to state 147
INFO:root:    attribute                      shift and go to state 134
INFO:root:    primary                        shift and go to state 135
INFO:root:    relation                       shift and go to state 138
INFO:root:
INFO:root:state 572
INFO:root:
INFO:root:    (41) type_completion -> IS type_def .
INFO:root:
INFO:root:    ;               reduce using rule 41 (type_completion -> IS type_def .)
INFO:root:
INFO:root:
INFO:root:state 573
INFO:root:
INFO:root:    (73) real_type -> float_type .
INFO:root:
INFO:root:    ;               reduce using rule 73 (real_type -> float_type .)
INFO:root:
INFO:root:
INFO:root:state 574
INFO:root:
INFO:root:    (39) discrim_part_opt -> ( BOX ) .
INFO:root:
INFO:root:    IS              reduce using rule 39 (discrim_part_opt -> ( BOX ) .)
INFO:root:    ;               reduce using rule 39 (discrim_part_opt -> ( BOX ) .)
INFO:root:
INFO:root:
INFO:root:state 575
INFO:root:
INFO:root:    (80) unconstr_array_type -> ARRAY ( . index_s ) OF component_subtype_def
INFO:root:    (88) iter_index_constraint -> ( . iter_discrete_range_s )
INFO:root:    (85) index_s -> . index
INFO:root:    (86) index_s -> . index_s , index
INFO:root:    (89) iter_discrete_range_s -> . discrete_range
INFO:root:    (90) iter_discrete_range_s -> . iter_discrete_range_s , discrete_range
INFO:root:    (87) index -> . name RANGE BOX
INFO:root:    (91) discrete_range -> . name range_constr_opt
INFO:root:    (92) discrete_range -> . range
INFO:root:    (149) name -> . simple_name
INFO:root:    (150) name -> . indexed_comp
INFO:root:    (151) name -> . selected_comp
INFO:root:    (152) name -> . attribute
INFO:root:    (153) name -> . operator_symbol
INFO:root:    (62) range -> . simple_expression DOTDOT simple_expression
INFO:root:    (157) simple_name -> . IDENTIFIER
INFO:root:    (164) indexed_comp -> . name ( value_s )
INFO:root:    (171) selected_comp -> . name . simple_name
INFO:root:    (172) selected_comp -> . name . used_char
INFO:root:    (173) selected_comp -> . name . operator_symbol
INFO:root:    (174) selected_comp -> . name . ALL
INFO:root:    (175) attribute -> . name TICK attribute_id
INFO:root:    (163) operator_symbol -> . STRING
INFO:root:    (208) simple_expression -> . unary term
INFO:root:    (209) simple_expression -> . term
INFO:root:    (210) simple_expression -> . simple_expression adding term
INFO:root:    (211) unary -> . +
INFO:root:    (212) unary -> . -
INFO:root:    (216) term -> . factor
INFO:root:    (217) term -> . term multiplying factor
INFO:root:    (223) factor -> . primary
INFO:root:    (224) factor -> . NOT primary
INFO:root:    (225) factor -> . ABS primary
INFO:root:    (226) primary -> . literal
INFO:root:    (227) primary -> . name
INFO:root:    (228) primary -> . allocator
INFO:root:    (229) primary -> . qualified
INFO:root:    (230) primary -> . parenthesized_primary
INFO:root:    (180) literal -> . INT
INFO:root:    (181) literal -> . FLOAT
INFO:root:    (182) literal -> . NuLL
INFO:root:    (234) allocator -> . NEW name
INFO:root:    (235) allocator -> . NEW qualified
INFO:root:    (233) qualified -> . name TICK parenthesized_primary
INFO:root:    (231) parenthesized_primary -> . aggregate
INFO:root:    (232) parenthesized_primary -> . ( expression )
INFO:root:    (183) aggregate -> . ( comp_assoc )
INFO:root:    (184) aggregate -> . ( expression WITH value_s )
INFO:root:    (185) aggregate -> . ( expression WITH NuLL RECORD )
INFO:root:    (186) aggregate -> . ( NuLL RECORD )
INFO:root:
INFO:root:    IDENTIFIER      shift and go to state 33
INFO:root:    STRING          shift and go to state 149
INFO:root:    +               shift and go to state 148
INFO:root:    -               shift and go to state 136
INFO:root:    NOT             shift and go to state 131
INFO:root:    ABS             shift and go to state 132
INFO:root:    INT             shift and go to state 120
INFO:root:    FLOAT           shift and go to state 128
INFO:root:    NuLL            shift and go to state 130
INFO:root:    NEW             shift and go to state 137
INFO:root:    (               shift and go to state 125
INFO:root:
INFO:root:    index_s                        shift and go to state 694
INFO:root:    selected_comp                  shift and go to state 139
INFO:root:    allocator                      shift and go to state 122
INFO:root:    factor                         shift and go to state 126
INFO:root:    indexed_comp                   shift and go to state 140
INFO:root:    attribute                      shift and go to state 134
INFO:root:    name                           shift and go to state 695
INFO:root:    iter_discrete_range_s          shift and go to state 693
INFO:root:    index                          shift and go to state 696
INFO:root:    literal                        shift and go to state 121
INFO:root:    simple_name                    shift and go to state 163
INFO:root:    discrete_range                 shift and go to state 697
INFO:root:    aggregate                      shift and go to state 143
INFO:root:    unary                          shift and go to state 144
INFO:root:    term                           shift and go to state 146
INFO:root:    simple_expression              shift and go to state 366
INFO:root:    operator_symbol                shift and go to state 133
INFO:root:    parenthesized_primary          shift and go to state 147
INFO:root:    primary                        shift and go to state 135
INFO:root:    qualified                      shift and go to state 145
INFO:root:    range                          shift and go to state 698
INFO:root:
INFO:root:state 576
INFO:root:
INFO:root:    (81) constr_array_type -> ARRAY iter_index_constraint . OF component_subtype_def
INFO:root:
INFO:root:    OF              shift and go to state 699
INFO:root:
INFO:root:
INFO:root:state 577
INFO:root:
INFO:root:    (55) decimal_digits_constraint -> DIGITS . expression range_constr_opt
INFO:root:    (188) expression -> . relation
INFO:root:    (189) expression -> . expression logical relation
INFO:root:    (190) expression -> . expression short_circuit relation
INFO:root:    (196) relation -> . simple_expression
INFO:root:    (197) relation -> . simple_expression relational simple_expression
INFO:root:    (198) relation -> . simple_expression membership range
INFO:root:    (199) relation -> . simple_expression membership name
INFO:root:    (208) simple_expression -> . unary term
INFO:root:    (209) simple_expression -> . term
INFO:root:    (210) simple_expression -> . simple_expression adding term
INFO:root:    (211) unary -> . +
INFO:root:    (212) unary -> . -
INFO:root:    (216) term -> . factor
INFO:root:    (217) term -> . term multiplying factor
INFO:root:    (223) factor -> . primary
INFO:root:    (224) factor -> . NOT primary
INFO:root:    (225) factor -> . ABS primary
INFO:root:    (226) primary -> . literal
INFO:root:    (227) primary -> . name
INFO:root:    (228) primary -> . allocator
INFO:root:    (229) primary -> . qualified
INFO:root:    (230) primary -> . parenthesized_primary
INFO:root:    (180) literal -> . INT
INFO:root:    (181) literal -> . FLOAT
INFO:root:    (182) literal -> . NuLL
INFO:root:    (149) name -> . simple_name
INFO:root:    (150) name -> . indexed_comp
INFO:root:    (151) name -> . selected_comp
INFO:root:    (152) name -> . attribute
INFO:root:    (153) name -> . operator_symbol
INFO:root:    (234) allocator -> . NEW name
INFO:root:    (235) allocator -> . NEW qualified
INFO:root:    (233) qualified -> . name TICK parenthesized_primary
INFO:root:    (231) parenthesized_primary -> . aggregate
INFO:root:    (232) parenthesized_primary -> . ( expression )
INFO:root:    (157) simple_name -> . IDENTIFIER
INFO:root:    (164) indexed_comp -> . name ( value_s )
INFO:root:    (171) selected_comp -> . name . simple_name
INFO:root:    (172) selected_comp -> . name . used_char
INFO:root:    (173) selected_comp -> . name . operator_symbol
INFO:root:    (174) selected_comp -> . name . ALL
INFO:root:    (175) attribute -> . name TICK attribute_id
INFO:root:    (163) operator_symbol -> . STRING
INFO:root:    (183) aggregate -> . ( comp_assoc )
INFO:root:    (184) aggregate -> . ( expression WITH value_s )
INFO:root:    (185) aggregate -> . ( expression WITH NuLL RECORD )
INFO:root:    (186) aggregate -> . ( NuLL RECORD )
INFO:root:
INFO:root:    +               shift and go to state 148
INFO:root:    -               shift and go to state 136
INFO:root:    NOT             shift and go to state 131
INFO:root:    ABS             shift and go to state 132
INFO:root:    INT             shift and go to state 120
INFO:root:    FLOAT           shift and go to state 128
INFO:root:    NuLL            shift and go to state 130
INFO:root:    NEW             shift and go to state 137
INFO:root:    (               shift and go to state 125
INFO:root:    IDENTIFIER      shift and go to state 33
INFO:root:    STRING          shift and go to state 149
INFO:root:
INFO:root:    literal                        shift and go to state 121
INFO:root:    allocator                      shift and go to state 122
INFO:root:    simple_name                    shift and go to state 163
INFO:root:    indexed_comp                   shift and go to state 140
INFO:root:    name                           shift and go to state 142
INFO:root:    selected_comp                  shift and go to state 139
INFO:root:    factor                         shift and go to state 126
INFO:root:    expression                     shift and go to state 700
INFO:root:    unary                          shift and go to state 144
INFO:root:    qualified                      shift and go to state 145
INFO:root:    aggregate                      shift and go to state 143
INFO:root:    simple_expression              shift and go to state 129
INFO:root:    term                           shift and go to state 146
INFO:root:    operator_symbol                shift and go to state 133
INFO:root:    parenthesized_primary          shift and go to state 147
INFO:root:    attribute                      shift and go to state 134
INFO:root:    primary                        shift and go to state 135
INFO:root:    relation                       shift and go to state 138
INFO:root:
INFO:root:state 578
INFO:root:
INFO:root:    (53) constraint -> range_constraint .
INFO:root:
INFO:root:    RENAMES         reduce using rule 53 (constraint -> range_constraint .)
INFO:root:    ASSIGN          reduce using rule 53 (constraint -> range_constraint .)
INFO:root:    ;               reduce using rule 53 (constraint -> range_constraint .)
INFO:root:    WITH            reduce using rule 53 (constraint -> range_constraint .)
INFO:root:
INFO:root:
INFO:root:state 579
INFO:root:
INFO:root:    (51) subtype_ind -> name constraint .
INFO:root:
INFO:root:    RENAMES         reduce using rule 51 (subtype_ind -> name constraint .)
INFO:root:    ASSIGN          reduce using rule 51 (subtype_ind -> name constraint .)
INFO:root:    ;               reduce using rule 51 (subtype_ind -> name constraint .)
INFO:root:    WITH            reduce using rule 51 (subtype_ind -> name constraint .)
INFO:root:
INFO:root:
INFO:root:state 580
INFO:root:
INFO:root:    (54) constraint -> decimal_digits_constraint .
INFO:root:
INFO:root:    RENAMES         reduce using rule 54 (constraint -> decimal_digits_constraint .)
INFO:root:    ASSIGN          reduce using rule 54 (constraint -> decimal_digits_constraint .)
INFO:root:    ;               reduce using rule 54 (constraint -> decimal_digits_constraint .)
INFO:root:    WITH            reduce using rule 54 (constraint -> decimal_digits_constraint .)
INFO:root:
INFO:root:
INFO:root:state 581
INFO:root:
INFO:root:    (341) rename_decl -> def_id_s : object_qualifier_opt subtype_ind renames . ;
INFO:root:
INFO:root:    ;               shift and go to state 701
INFO:root:
INFO:root:
INFO:root:state 582
INFO:root:
INFO:root:    (23) object_decl -> def_id_s : object_qualifier_opt object_subtype_def init_opt . ;
INFO:root:
INFO:root:    ;               shift and go to state 702
INFO:root:
INFO:root:
INFO:root:state 583
INFO:root:
INFO:root:    (35) number_decl -> def_id_s : CONSTANT ASSIGN expression . ;
INFO:root:    (189) expression -> expression . logical relation
INFO:root:    (190) expression -> expression . short_circuit relation
INFO:root:    (191) logical -> . AND
INFO:root:    (192) logical -> . OR
INFO:root:    (193) logical -> . XOR
INFO:root:    (194) short_circuit -> . AND THEN
INFO:root:    (195) short_circuit -> . OR ELSE
INFO:root:
INFO:root:    ;               shift and go to state 703
INFO:root:    AND             shift and go to state 215
INFO:root:    OR              shift and go to state 216
INFO:root:    XOR             shift and go to state 214
INFO:root:
INFO:root:    short_circuit                  shift and go to state 212
INFO:root:    logical                        shift and go to state 213
INFO:root:
INFO:root:state 584
INFO:root:
INFO:root:    (342) rename_decl -> def_id_s : EXCEPTION renames ; .
INFO:root:
INFO:root:    PACKAGE         reduce using rule 342 (rename_decl -> def_id_s : EXCEPTION renames ; .)
INFO:root:    TASK            reduce using rule 342 (rename_decl -> def_id_s : EXCEPTION renames ; .)
INFO:root:    PROTECTED       reduce using rule 342 (rename_decl -> def_id_s : EXCEPTION renames ; .)
INFO:root:    error           reduce using rule 342 (rename_decl -> def_id_s : EXCEPTION renames ; .)
INFO:root:    USE             reduce using rule 342 (rename_decl -> def_id_s : EXCEPTION renames ; .)
INFO:root:    PRAGMA          reduce using rule 342 (rename_decl -> def_id_s : EXCEPTION renames ; .)
INFO:root:    TYPE            reduce using rule 342 (rename_decl -> def_id_s : EXCEPTION renames ; .)
INFO:root:    SUBTYPE         reduce using rule 342 (rename_decl -> def_id_s : EXCEPTION renames ; .)
INFO:root:    FOR             reduce using rule 342 (rename_decl -> def_id_s : EXCEPTION renames ; .)
INFO:root:    PROCEDURE       reduce using rule 342 (rename_decl -> def_id_s : EXCEPTION renames ; .)
INFO:root:    FUNCTION        reduce using rule 342 (rename_decl -> def_id_s : EXCEPTION renames ; .)
INFO:root:    GENERIC         reduce using rule 342 (rename_decl -> def_id_s : EXCEPTION renames ; .)
INFO:root:    IDENTIFIER      reduce using rule 342 (rename_decl -> def_id_s : EXCEPTION renames ; .)
INFO:root:    BEGIN           reduce using rule 342 (rename_decl -> def_id_s : EXCEPTION renames ; .)
INFO:root:    END             reduce using rule 342 (rename_decl -> def_id_s : EXCEPTION renames ; .)
INFO:root:    PRIVATE         reduce using rule 342 (rename_decl -> def_id_s : EXCEPTION renames ; .)
INFO:root:
INFO:root:
INFO:root:state 585
INFO:root:
INFO:root:    (351) task_spec -> TASK TYPE simple_name discrim_part_opt task_def .
INFO:root:
INFO:root:    ;               reduce using rule 351 (task_spec -> TASK TYPE simple_name discrim_part_opt task_def .)
INFO:root:
INFO:root:
INFO:root:state 586
INFO:root:
INFO:root:    (442) body_stub -> TASK BODY simple_name IS SEPARATE . ;
INFO:root:
INFO:root:    ;               shift and go to state 704
INFO:root:
INFO:root:
INFO:root:state 587
INFO:root:
INFO:root:    (356) task_body -> TASK BODY simple_name IS decl_part . block_body END id_opt ;
INFO:root:    (290) block_body -> . BEGIN handled_stmt_s
INFO:root:
INFO:root:    BEGIN           shift and go to state 195
INFO:root:
INFO:root:    block_body                     shift and go to state 705
INFO:root:
INFO:root:state 588
INFO:root:
INFO:root:    (380) entry_decl_s -> entry_decl_s entry_decl . pragma_s
INFO:root:    (8) pragma_s -> .
INFO:root:    (9) pragma_s -> . pragma_s pragma
INFO:root:
INFO:root:    PRAGMA          reduce using rule 8 (pragma_s -> .)
INFO:root:    ENTRY           reduce using rule 8 (pragma_s -> .)
INFO:root:    PRIVATE         reduce using rule 8 (pragma_s -> .)
INFO:root:    FOR             reduce using rule 8 (pragma_s -> .)
INFO:root:    END             reduce using rule 8 (pragma_s -> .)
INFO:root:
INFO:root:    pragma_s                       shift and go to state 706
INFO:root:
INFO:root:state 589
INFO:root:
INFO:root:    (353) task_def -> IS entry_decl_s rep_spec_s . task_private_opt END id_opt
INFO:root:    (388) rep_spec_s -> rep_spec_s . rep_spec pragma_s
INFO:root:    (354) task_private_opt -> .
INFO:root:    (355) task_private_opt -> . PRIVATE entry_decl_s rep_spec_s
INFO:root:    (491) rep_spec -> . attrib_def
INFO:root:    (492) rep_spec -> . record_type_spec
INFO:root:    (493) rep_spec -> . address_spec
INFO:root:    (494) attrib_def -> . FOR mark USE expression ;
INFO:root:    (495) record_type_spec -> . FOR mark USE RECORD align_opt comp_loc_s END RECORD ;
INFO:root:    (500) address_spec -> . FOR mark USE AT expression ;
INFO:root:
INFO:root:    END             reduce using rule 354 (task_private_opt -> .)
INFO:root:    PRIVATE         shift and go to state 707
INFO:root:    FOR             shift and go to state 102
INFO:root:
INFO:root:    record_type_spec               shift and go to state 108
INFO:root:    rep_spec                       shift and go to state 708
INFO:root:    address_spec                   shift and go to state 83
INFO:root:    attrib_def                     shift and go to state 92
INFO:root:    task_private_opt               shift and go to state 709
INFO:root:
INFO:root:state 590
INFO:root:
INFO:root:    (381) entry_decl -> ENTRY . IDENTIFIER formal_part_opt ;
INFO:root:    (382) entry_decl -> ENTRY . IDENTIFIER ( discrete_range ) formal_part_opt ;
INFO:root:
INFO:root:    IDENTIFIER      shift and go to state 710
INFO:root:
INFO:root:
INFO:root:state 591
INFO:root:
INFO:root:    (445) body_stub -> PROTECTED BODY simple_name IS SEPARATE . ;
INFO:root:
INFO:root:    ;               shift and go to state 711
INFO:root:
INFO:root:
INFO:root:state 592
INFO:root:
INFO:root:    (374) prot_op_body_s -> pragma_s .
INFO:root:    (9) pragma_s -> pragma_s . pragma
INFO:root:    (2) pragma -> . PRAGMA IDENTIFIER ;
INFO:root:    (3) pragma -> . PRAGMA simple_name ( pragma_arg_s ) ;
INFO:root:
INFO:root:    END             reduce using rule 374 (prot_op_body_s -> pragma_s .)
INFO:root:    ENTRY           reduce using rule 374 (prot_op_body_s -> pragma_s .)
INFO:root:    PROCEDURE       reduce using rule 374 (prot_op_body_s -> pragma_s .)
INFO:root:    FUNCTION        reduce using rule 374 (prot_op_body_s -> pragma_s .)
INFO:root:    PRAGMA          shift and go to state 2
INFO:root:
INFO:root:    pragma                         shift and go to state 43
INFO:root:
INFO:root:state 593
INFO:root:
INFO:root:    (373) prot_body -> PROTECTED BODY simple_name IS prot_op_body_s . END id_opt ;
INFO:root:    (375) prot_op_body_s -> prot_op_body_s . prot_op_body pragma_s
INFO:root:    (376) prot_op_body -> . entry_body
INFO:root:    (377) prot_op_body -> . subprog_body
INFO:root:    (378) prot_op_body -> . subprog_spec ;
INFO:root:    (383) entry_body -> . ENTRY IDENTIFIER formal_part_opt WHEN condition entry_body_part
INFO:root:    (384) entry_body -> . ENTRY IDENTIFIER ( iter_part discrete_range ) formal_part_opt WHEN condition entry_body_part
INFO:root:    (322) subprog_body -> . subprog_spec_is_push decl_part block_body END id_opt ;
INFO:root:    (304) subprog_spec -> . PROCEDURE compound_name formal_part_opt
INFO:root:    (305) subprog_spec -> . FUNCTION designator formal_part_opt RETURN name
INFO:root:    (306) subprog_spec -> . FUNCTION designator
INFO:root:    (321) subprog_spec_is_push -> . subprog_spec IS
INFO:root:
INFO:root:    END             shift and go to state 713
INFO:root:    ENTRY           shift and go to state 715
INFO:root:    PROCEDURE       shift and go to state 17
INFO:root:    FUNCTION        shift and go to state 23
INFO:root:
INFO:root:    entry_body                     shift and go to state 712
INFO:root:    subprog_spec                   shift and go to state 714
INFO:root:    subprog_body                   shift and go to state 716
INFO:root:    subprog_spec_is_push           shift and go to state 415
INFO:root:    prot_op_body                   shift and go to state 717
INFO:root:
INFO:root:state 594
INFO:root:
INFO:root:    (359) prot_spec -> PROTECTED TYPE simple_name discrim_part_opt prot_def .
INFO:root:
INFO:root:    ;               reduce using rule 359 (prot_spec -> PROTECTED TYPE simple_name discrim_part_opt prot_def .)
INFO:root:
INFO:root:
INFO:root:state 595
INFO:root:
INFO:root:    (364) prot_op_decl_s -> prot_op_decl_s prot_op_decl .
INFO:root:
INFO:root:    PRIVATE         reduce using rule 364 (prot_op_decl_s -> prot_op_decl_s prot_op_decl .)
INFO:root:    ENTRY           reduce using rule 364 (prot_op_decl_s -> prot_op_decl_s prot_op_decl .)
INFO:root:    PROCEDURE       reduce using rule 364 (prot_op_decl_s -> prot_op_decl_s prot_op_decl .)
INFO:root:    FUNCTION        reduce using rule 364 (prot_op_decl_s -> prot_op_decl_s prot_op_decl .)
INFO:root:    PRAGMA          reduce using rule 364 (prot_op_decl_s -> prot_op_decl_s prot_op_decl .)
INFO:root:    FOR             reduce using rule 364 (prot_op_decl_s -> prot_op_decl_s prot_op_decl .)
INFO:root:    END             reduce using rule 364 (prot_op_decl_s -> prot_op_decl_s prot_op_decl .)
INFO:root:
INFO:root:
INFO:root:state 596
INFO:root:
INFO:root:    (368) prot_op_decl -> pragma .
INFO:root:
INFO:root:    PRIVATE         reduce using rule 368 (prot_op_decl -> pragma .)
INFO:root:    ENTRY           reduce using rule 368 (prot_op_decl -> pragma .)
INFO:root:    PROCEDURE       reduce using rule 368 (prot_op_decl -> pragma .)
INFO:root:    FUNCTION        reduce using rule 368 (prot_op_decl -> pragma .)
INFO:root:    PRAGMA          reduce using rule 368 (prot_op_decl -> pragma .)
INFO:root:    FOR             reduce using rule 368 (prot_op_decl -> pragma .)
INFO:root:    END             reduce using rule 368 (prot_op_decl -> pragma .)
INFO:root:    error           reduce using rule 368 (prot_op_decl -> pragma .)
INFO:root:    IDENTIFIER      reduce using rule 368 (prot_op_decl -> pragma .)
INFO:root:
INFO:root:
INFO:root:state 597
INFO:root:
INFO:root:    (366) prot_op_decl -> subprog_spec . ;
INFO:root:
INFO:root:    ;               shift and go to state 718
INFO:root:
INFO:root:
INFO:root:state 598
INFO:root:
INFO:root:    (360) prot_def -> IS prot_op_decl_s prot_private_opt . END id_opt
INFO:root:
INFO:root:    END             shift and go to state 719
INFO:root:
INFO:root:
INFO:root:state 599
INFO:root:
INFO:root:    (362) prot_private_opt -> PRIVATE . prot_elem_decl_s
INFO:root:    (369) prot_elem_decl_s -> .
INFO:root:    (370) prot_elem_decl_s -> . prot_elem_decl_s prot_elem_decl
INFO:root:
INFO:root:    error           reduce using rule 369 (prot_elem_decl_s -> .)
INFO:root:    ENTRY           reduce using rule 369 (prot_elem_decl_s -> .)
INFO:root:    PROCEDURE       reduce using rule 369 (prot_elem_decl_s -> .)
INFO:root:    FUNCTION        reduce using rule 369 (prot_elem_decl_s -> .)
INFO:root:    PRAGMA          reduce using rule 369 (prot_elem_decl_s -> .)
INFO:root:    FOR             reduce using rule 369 (prot_elem_decl_s -> .)
INFO:root:    IDENTIFIER      reduce using rule 369 (prot_elem_decl_s -> .)
INFO:root:    END             reduce using rule 369 (prot_elem_decl_s -> .)
INFO:root:
INFO:root:    prot_elem_decl_s               shift and go to state 720
INFO:root:
INFO:root:state 600
INFO:root:
INFO:root:    (365) prot_op_decl -> entry_decl .
INFO:root:
INFO:root:    PRIVATE         reduce using rule 365 (prot_op_decl -> entry_decl .)
INFO:root:    ENTRY           reduce using rule 365 (prot_op_decl -> entry_decl .)
INFO:root:    PROCEDURE       reduce using rule 365 (prot_op_decl -> entry_decl .)
INFO:root:    FUNCTION        reduce using rule 365 (prot_op_decl -> entry_decl .)
INFO:root:    PRAGMA          reduce using rule 365 (prot_op_decl -> entry_decl .)
INFO:root:    FOR             reduce using rule 365 (prot_op_decl -> entry_decl .)
INFO:root:    END             reduce using rule 365 (prot_op_decl -> entry_decl .)
INFO:root:    error           reduce using rule 365 (prot_op_decl -> entry_decl .)
INFO:root:    IDENTIFIER      reduce using rule 365 (prot_op_decl -> entry_decl .)
INFO:root:
INFO:root:
INFO:root:state 601
INFO:root:
INFO:root:    (367) prot_op_decl -> rep_spec .
INFO:root:
INFO:root:    PRIVATE         reduce using rule 367 (prot_op_decl -> rep_spec .)
INFO:root:    ENTRY           reduce using rule 367 (prot_op_decl -> rep_spec .)
INFO:root:    PROCEDURE       reduce using rule 367 (prot_op_decl -> rep_spec .)
INFO:root:    FUNCTION        reduce using rule 367 (prot_op_decl -> rep_spec .)
INFO:root:    PRAGMA          reduce using rule 367 (prot_op_decl -> rep_spec .)
INFO:root:    FOR             reduce using rule 367 (prot_op_decl -> rep_spec .)
INFO:root:    END             reduce using rule 367 (prot_op_decl -> rep_spec .)
INFO:root:    error           reduce using rule 367 (prot_op_decl -> rep_spec .)
INFO:root:    IDENTIFIER      reduce using rule 367 (prot_op_decl -> rep_spec .)
INFO:root:
INFO:root:
INFO:root:state 602
INFO:root:
INFO:root:    (494) attrib_def -> FOR mark USE expression ; .
INFO:root:
INFO:root:    PRAGMA          reduce using rule 494 (attrib_def -> FOR mark USE expression ; .)
INFO:root:    FOR             reduce using rule 494 (attrib_def -> FOR mark USE expression ; .)
INFO:root:    END             reduce using rule 494 (attrib_def -> FOR mark USE expression ; .)
INFO:root:    PRIVATE         reduce using rule 494 (attrib_def -> FOR mark USE expression ; .)
INFO:root:    ENTRY           reduce using rule 494 (attrib_def -> FOR mark USE expression ; .)
INFO:root:    PROCEDURE       reduce using rule 494 (attrib_def -> FOR mark USE expression ; .)
INFO:root:    FUNCTION        reduce using rule 494 (attrib_def -> FOR mark USE expression ; .)
INFO:root:    PACKAGE         reduce using rule 494 (attrib_def -> FOR mark USE expression ; .)
INFO:root:    TASK            reduce using rule 494 (attrib_def -> FOR mark USE expression ; .)
INFO:root:    PROTECTED       reduce using rule 494 (attrib_def -> FOR mark USE expression ; .)
INFO:root:    error           reduce using rule 494 (attrib_def -> FOR mark USE expression ; .)
INFO:root:    USE             reduce using rule 494 (attrib_def -> FOR mark USE expression ; .)
INFO:root:    TYPE            reduce using rule 494 (attrib_def -> FOR mark USE expression ; .)
INFO:root:    SUBTYPE         reduce using rule 494 (attrib_def -> FOR mark USE expression ; .)
INFO:root:    GENERIC         reduce using rule 494 (attrib_def -> FOR mark USE expression ; .)
INFO:root:    IDENTIFIER      reduce using rule 494 (attrib_def -> FOR mark USE expression ; .)
INFO:root:    BEGIN           reduce using rule 494 (attrib_def -> FOR mark USE expression ; .)
INFO:root:
INFO:root:
INFO:root:state 603
INFO:root:
INFO:root:    (500) address_spec -> FOR mark USE AT expression . ;
INFO:root:    (189) expression -> expression . logical relation
INFO:root:    (190) expression -> expression . short_circuit relation
INFO:root:    (191) logical -> . AND
INFO:root:    (192) logical -> . OR
INFO:root:    (193) logical -> . XOR
INFO:root:    (194) short_circuit -> . AND THEN
INFO:root:    (195) short_circuit -> . OR ELSE
INFO:root:
INFO:root:    ;               shift and go to state 721
INFO:root:    AND             shift and go to state 215
INFO:root:    OR              shift and go to state 216
INFO:root:    XOR             shift and go to state 214
INFO:root:
INFO:root:    short_circuit                  shift and go to state 212
INFO:root:    logical                        shift and go to state 213
INFO:root:
INFO:root:state 604
INFO:root:
INFO:root:    (497) align_opt -> AT . MOD expression ;
INFO:root:
INFO:root:    MOD             shift and go to state 722
INFO:root:
INFO:root:
INFO:root:state 605
INFO:root:
INFO:root:    (495) record_type_spec -> FOR mark USE RECORD align_opt . comp_loc_s END RECORD ;
INFO:root:    (498) comp_loc_s -> .
INFO:root:    (499) comp_loc_s -> . comp_loc_s mark AT expression RANGE range ;
INFO:root:
INFO:root:    END             reduce using rule 498 (comp_loc_s -> .)
INFO:root:    IDENTIFIER      reduce using rule 498 (comp_loc_s -> .)
INFO:root:
INFO:root:    comp_loc_s                     shift and go to state 723
INFO:root:
INFO:root:state 606
INFO:root:
INFO:root:    (322) subprog_body -> subprog_spec_is_push decl_part block_body END id_opt ; .
INFO:root:
INFO:root:    PACKAGE         reduce using rule 322 (subprog_body -> subprog_spec_is_push decl_part block_body END id_opt ; .)
INFO:root:    TASK            reduce using rule 322 (subprog_body -> subprog_spec_is_push decl_part block_body END id_opt ; .)
INFO:root:    PROTECTED       reduce using rule 322 (subprog_body -> subprog_spec_is_push decl_part block_body END id_opt ; .)
INFO:root:    error           reduce using rule 322 (subprog_body -> subprog_spec_is_push decl_part block_body END id_opt ; .)
INFO:root:    USE             reduce using rule 322 (subprog_body -> subprog_spec_is_push decl_part block_body END id_opt ; .)
INFO:root:    PRAGMA          reduce using rule 322 (subprog_body -> subprog_spec_is_push decl_part block_body END id_opt ; .)
INFO:root:    TYPE            reduce using rule 322 (subprog_body -> subprog_spec_is_push decl_part block_body END id_opt ; .)
INFO:root:    SUBTYPE         reduce using rule 322 (subprog_body -> subprog_spec_is_push decl_part block_body END id_opt ; .)
INFO:root:    FOR             reduce using rule 322 (subprog_body -> subprog_spec_is_push decl_part block_body END id_opt ; .)
INFO:root:    PROCEDURE       reduce using rule 322 (subprog_body -> subprog_spec_is_push decl_part block_body END id_opt ; .)
INFO:root:    FUNCTION        reduce using rule 322 (subprog_body -> subprog_spec_is_push decl_part block_body END id_opt ; .)
INFO:root:    GENERIC         reduce using rule 322 (subprog_body -> subprog_spec_is_push decl_part block_body END id_opt ; .)
INFO:root:    IDENTIFIER      reduce using rule 322 (subprog_body -> subprog_spec_is_push decl_part block_body END id_opt ; .)
INFO:root:    BEGIN           reduce using rule 322 (subprog_body -> subprog_spec_is_push decl_part block_body END id_opt ; .)
INFO:root:    PRIVATE         reduce using rule 322 (subprog_body -> subprog_spec_is_push decl_part block_body END id_opt ; .)
INFO:root:    WITH            reduce using rule 322 (subprog_body -> subprog_spec_is_push decl_part block_body END id_opt ; .)
INFO:root:    SEPARATE        reduce using rule 322 (subprog_body -> subprog_spec_is_push decl_part block_body END id_opt ; .)
INFO:root:    $end            reduce using rule 322 (subprog_body -> subprog_spec_is_push decl_part block_body END id_opt ; .)
INFO:root:    END             reduce using rule 322 (subprog_body -> subprog_spec_is_push decl_part block_body END id_opt ; .)
INFO:root:    ENTRY           reduce using rule 322 (subprog_body -> subprog_spec_is_push decl_part block_body END id_opt ; .)
INFO:root:
INFO:root:
INFO:root:state 607
INFO:root:
INFO:root:    (300) return_stmt -> RETURN expression ; .
INFO:root:
INFO:root:    LL              reduce using rule 300 (return_stmt -> RETURN expression ; .)
INFO:root:    error           reduce using rule 300 (return_stmt -> RETURN expression ; .)
INFO:root:    NuLL            reduce using rule 300 (return_stmt -> RETURN expression ; .)
INFO:root:    EXIT            reduce using rule 300 (return_stmt -> RETURN expression ; .)
INFO:root:    RETURN          reduce using rule 300 (return_stmt -> RETURN expression ; .)
INFO:root:    DELAY           reduce using rule 300 (return_stmt -> RETURN expression ; .)
INFO:root:    ABORT           reduce using rule 300 (return_stmt -> RETURN expression ; .)
INFO:root:    RAISE           reduce using rule 300 (return_stmt -> RETURN expression ; .)
INFO:root:    REQUEUE         reduce using rule 300 (return_stmt -> RETURN expression ; .)
INFO:root:    IF              reduce using rule 300 (return_stmt -> RETURN expression ; .)
INFO:root:    CASE            reduce using rule 300 (return_stmt -> RETURN expression ; .)
INFO:root:    IDENTIFIER      reduce using rule 300 (return_stmt -> RETURN expression ; .)
INFO:root:    ACCEPT          reduce using rule 300 (return_stmt -> RETURN expression ; .)
INFO:root:    SELECT          reduce using rule 300 (return_stmt -> RETURN expression ; .)
INFO:root:    STRING          reduce using rule 300 (return_stmt -> RETURN expression ; .)
INFO:root:    WHILE           reduce using rule 300 (return_stmt -> RETURN expression ; .)
INFO:root:    DECLARE         reduce using rule 300 (return_stmt -> RETURN expression ; .)
INFO:root:    FOR             reduce using rule 300 (return_stmt -> RETURN expression ; .)
INFO:root:    LOOP            reduce using rule 300 (return_stmt -> RETURN expression ; .)
INFO:root:    BEGIN           reduce using rule 300 (return_stmt -> RETURN expression ; .)
INFO:root:    ELSIF           reduce using rule 300 (return_stmt -> RETURN expression ; .)
INFO:root:    ELSE            reduce using rule 300 (return_stmt -> RETURN expression ; .)
INFO:root:    END             reduce using rule 300 (return_stmt -> RETURN expression ; .)
INFO:root:    OR              reduce using rule 300 (return_stmt -> RETURN expression ; .)
INFO:root:    WHEN            reduce using rule 300 (return_stmt -> RETURN expression ; .)
INFO:root:    THEN            reduce using rule 300 (return_stmt -> RETURN expression ; .)
INFO:root:    EXCEPTION       reduce using rule 300 (return_stmt -> RETURN expression ; .)
INFO:root:
INFO:root:
INFO:root:state 608
INFO:root:
INFO:root:    (392) accept_hdr -> ACCEPT entry_name formal_part_opt .
INFO:root:
INFO:root:    ;               reduce using rule 392 (accept_hdr -> ACCEPT entry_name formal_part_opt .)
INFO:root:    DO              reduce using rule 392 (accept_hdr -> ACCEPT entry_name formal_part_opt .)
INFO:root:
INFO:root:
INFO:root:state 609
INFO:root:
INFO:root:    (394) entry_name -> entry_name ( . expression )
INFO:root:    (311) formal_part -> ( . param_s )
INFO:root:    (188) expression -> . relation
INFO:root:    (189) expression -> . expression logical relation
INFO:root:    (190) expression -> . expression short_circuit relation
INFO:root:    (312) param_s -> . param
INFO:root:    (313) param_s -> . param_s ; param
INFO:root:    (196) relation -> . simple_expression
INFO:root:    (197) relation -> . simple_expression relational simple_expression
INFO:root:    (198) relation -> . simple_expression membership range
INFO:root:    (199) relation -> . simple_expression membership name
INFO:root:    (314) param -> . def_id_s : mode mark init_opt
INFO:root:    (315) param -> . error
INFO:root:    (208) simple_expression -> . unary term
INFO:root:    (209) simple_expression -> . term
INFO:root:    (210) simple_expression -> . simple_expression adding term
INFO:root:    (24) def_id_s -> . def_id
INFO:root:    (25) def_id_s -> . def_id_s , def_id
INFO:root:    (211) unary -> . +
INFO:root:    (212) unary -> . -
INFO:root:    (216) term -> . factor
INFO:root:    (217) term -> . term multiplying factor
INFO:root:    (26) def_id -> . IDENTIFIER
INFO:root:    (223) factor -> . primary
INFO:root:    (224) factor -> . NOT primary
INFO:root:    (225) factor -> . ABS primary
INFO:root:    (226) primary -> . literal
INFO:root:    (227) primary -> . name
INFO:root:    (228) primary -> . allocator
INFO:root:    (229) primary -> . qualified
INFO:root:    (230) primary -> . parenthesized_primary
INFO:root:    (180) literal -> . INT
INFO:root:    (181) literal -> . FLOAT
INFO:root:    (182) literal -> . NuLL
INFO:root:    (149) name -> . simple_name
INFO:root:    (150) name -> . indexed_comp
INFO:root:    (151) name -> . selected_comp
INFO:root:    (152) name -> . attribute
INFO:root:    (153) name -> . operator_symbol
INFO:root:    (234) allocator -> . NEW name
INFO:root:    (235) allocator -> . NEW qualified
INFO:root:    (233) qualified -> . name TICK parenthesized_primary
INFO:root:    (231) parenthesized_primary -> . aggregate
INFO:root:    (232) parenthesized_primary -> . ( expression )
INFO:root:    (157) simple_name -> . IDENTIFIER
INFO:root:    (164) indexed_comp -> . name ( value_s )
INFO:root:    (171) selected_comp -> . name . simple_name
INFO:root:    (172) selected_comp -> . name . used_char
INFO:root:    (173) selected_comp -> . name . operator_symbol
INFO:root:    (174) selected_comp -> . name . ALL
INFO:root:    (175) attribute -> . name TICK attribute_id
INFO:root:    (163) operator_symbol -> . STRING
INFO:root:    (183) aggregate -> . ( comp_assoc )
INFO:root:    (184) aggregate -> . ( expression WITH value_s )
INFO:root:    (185) aggregate -> . ( expression WITH NuLL RECORD )
INFO:root:    (186) aggregate -> . ( NuLL RECORD )
INFO:root:
INFO:root:    error           shift and go to state 55
INFO:root:    +               shift and go to state 148
INFO:root:    -               shift and go to state 136
INFO:root:    IDENTIFIER      shift and go to state 725
INFO:root:    NOT             shift and go to state 131
INFO:root:    ABS             shift and go to state 132
INFO:root:    INT             shift and go to state 120
INFO:root:    FLOAT           shift and go to state 128
INFO:root:    NuLL            shift and go to state 130
INFO:root:    NEW             shift and go to state 137
INFO:root:    (               shift and go to state 125
INFO:root:    STRING          shift and go to state 149
INFO:root:
INFO:root:    literal                        shift and go to state 121
INFO:root:    allocator                      shift and go to state 122
INFO:root:    simple_name                    shift and go to state 163
INFO:root:    indexed_comp                   shift and go to state 140
INFO:root:    name                           shift and go to state 142
INFO:root:    operator_symbol                shift and go to state 133
INFO:root:    selected_comp                  shift and go to state 139
INFO:root:    factor                         shift and go to state 126
INFO:root:    param_s                        shift and go to state 247
INFO:root:    expression                     shift and go to state 724
INFO:root:    unary                          shift and go to state 144
INFO:root:    term                           shift and go to state 146
INFO:root:    aggregate                      shift and go to state 143
INFO:root:    simple_expression              shift and go to state 129
INFO:root:    def_id_s                       shift and go to state 56
INFO:root:    def_id                         shift and go to state 57
INFO:root:    parenthesized_primary          shift and go to state 147
INFO:root:    attribute                      shift and go to state 134
INFO:root:    primary                        shift and go to state 135
INFO:root:    qualified                      shift and go to state 145
INFO:root:    relation                       shift and go to state 138
INFO:root:    param                          shift and go to state 248
INFO:root:
INFO:root:state 610
INFO:root:
INFO:root:    (271) case_hdr -> CASE expression IS .
INFO:root:
INFO:root:    PRAGMA          reduce using rule 271 (case_hdr -> CASE expression IS .)
INFO:root:    END             reduce using rule 271 (case_hdr -> CASE expression IS .)
INFO:root:    WHEN            reduce using rule 271 (case_hdr -> CASE expression IS .)
INFO:root:
INFO:root:
INFO:root:state 611
INFO:root:
INFO:root:    (275) loop_stmt -> label_opt iteration basic_loop . id_opt ;
INFO:root:    (285) id_opt -> .
INFO:root:    (286) id_opt -> . designator
INFO:root:    (307) designator -> . compound_name
INFO:root:    (308) designator -> . STRING
INFO:root:    (158) compound_name -> . simple_name
INFO:root:    (159) compound_name -> . compound_name . simple_name
INFO:root:    (157) simple_name -> . IDENTIFIER
INFO:root:
INFO:root:    ;               reduce using rule 285 (id_opt -> .)
INFO:root:    STRING          shift and go to state 62
INFO:root:    IDENTIFIER      shift and go to state 33
INFO:root:
INFO:root:    designator                     shift and go to state 455
INFO:root:    id_opt                         shift and go to state 726
INFO:root:    simple_name                    shift and go to state 34
INFO:root:    compound_name                  shift and go to state 64
INFO:root:
INFO:root:state 612
INFO:root:
INFO:root:    (284) basic_loop -> LOOP . statement_s END LOOP
INFO:root:    (236) statement_s -> . statement
INFO:root:    (237) statement_s -> . statement_s statement
INFO:root:    (238) statement -> . unlabeled
INFO:root:    (239) statement -> . label statement
INFO:root:    (240) unlabeled -> . simple_stmt
INFO:root:    (241) unlabeled -> . compound_stmt
INFO:root:    (259) label -> . LL IDENTIFIER RR
INFO:root:    (242) simple_stmt -> . null_stmt
INFO:root:    (243) simple_stmt -> . assign_stmt
INFO:root:    (244) simple_stmt -> . exit_stmt
INFO:root:    (245) simple_stmt -> . return_stmt
INFO:root:    (246) simple_stmt -> . procedure_call
INFO:root:    (247) simple_stmt -> . delay_stmt
INFO:root:    (248) simple_stmt -> . abort_stmt
INFO:root:    (249) simple_stmt -> . raise_stmt
INFO:root:    (250) simple_stmt -> . code_stmt
INFO:root:    (251) simple_stmt -> . requeue_stmt
INFO:root:    (252) simple_stmt -> . error ;
INFO:root:    (253) compound_stmt -> . if_stmt
INFO:root:    (254) compound_stmt -> . case_stmt
INFO:root:    (255) compound_stmt -> . loop_stmt
INFO:root:    (256) compound_stmt -> . block
INFO:root:    (257) compound_stmt -> . accept_stmt
INFO:root:    (258) compound_stmt -> . select_stmt
INFO:root:    (260) null_stmt -> . NuLL ;
INFO:root:    (261) assign_stmt -> . name ASSIGN expression ;
INFO:root:    (294) exit_stmt -> . EXIT name_opt when_opt ;
INFO:root:    (299) return_stmt -> . RETURN ;
INFO:root:    (300) return_stmt -> . RETURN expression ;
INFO:root:    (323) procedure_call -> . name ;
INFO:root:    (395) delay_stmt -> . DELAY expression ;
INFO:root:    (396) delay_stmt -> . DELAY UNTIL expression ;
INFO:root:    (416) abort_stmt -> . ABORT name_s ;
INFO:root:    (455) raise_stmt -> . RAISE name_opt ;
INFO:root:    (501) code_stmt -> . qualified ;
INFO:root:    (456) requeue_stmt -> . REQUEUE name ;
INFO:root:    (457) requeue_stmt -> . REQUEUE name WITH ABORT ;
INFO:root:    (262) if_stmt -> . IF cond_clause_s else_opt END IF ;
INFO:root:    (270) case_stmt -> . case_hdr pragma_s alternative_s END CASE ;
INFO:root:    (275) loop_stmt -> . label_opt iteration basic_loop id_opt ;
INFO:root:    (287) block -> . label_opt block_decl block_body END id_opt ;
INFO:root:    (390) accept_stmt -> . accept_hdr ;
INFO:root:    (391) accept_stmt -> . accept_hdr DO handled_stmt_s END id_opt ;
INFO:root:    (397) select_stmt -> . select_wait
INFO:root:    (398) select_stmt -> . async_select
INFO:root:    (399) select_stmt -> . timed_entry_call
INFO:root:    (400) select_stmt -> . cond_entry_call
INFO:root:    (149) name -> . simple_name
INFO:root:    (150) name -> . indexed_comp
INFO:root:    (151) name -> . selected_comp
INFO:root:    (152) name -> . attribute
INFO:root:    (153) name -> . operator_symbol
INFO:root:    (233) qualified -> . name TICK parenthesized_primary
INFO:root:    (271) case_hdr -> . CASE expression IS
INFO:root:    (276) label_opt -> .
INFO:root:    (277) label_opt -> . IDENTIFIER :
INFO:root:    (392) accept_hdr -> . ACCEPT entry_name formal_part_opt
INFO:root:    (401) select_wait -> . SELECT guarded_select_alt or_select else_opt END SELECT ;
INFO:root:    (411) async_select -> . SELECT delay_or_entry_alt THEN ABORT statement_s END SELECT ;
INFO:root:    (412) timed_entry_call -> . SELECT entry_call stmts_opt OR delay_stmt stmts_opt END SELECT ;
INFO:root:    (413) cond_entry_call -> . SELECT entry_call stmts_opt ELSE statement_s END SELECT ;
INFO:root:    (157) simple_name -> . IDENTIFIER
INFO:root:    (164) indexed_comp -> . name ( value_s )
INFO:root:    (171) selected_comp -> . name . simple_name
INFO:root:    (172) selected_comp -> . name . used_char
INFO:root:    (173) selected_comp -> . name . operator_symbol
INFO:root:    (174) selected_comp -> . name . ALL
INFO:root:    (175) attribute -> . name TICK attribute_id
INFO:root:    (163) operator_symbol -> . STRING
INFO:root:
INFO:root:    LL              shift and go to state 344
INFO:root:    error           shift and go to state 341
INFO:root:    NuLL            shift and go to state 347
INFO:root:    EXIT            shift and go to state 340
INFO:root:    RETURN          shift and go to state 303
INFO:root:    DELAY           shift and go to state 332
INFO:root:    ABORT           shift and go to state 326
INFO:root:    RAISE           shift and go to state 314
INFO:root:    REQUEUE         shift and go to state 317
INFO:root:    IF              shift and go to state 327
INFO:root:    CASE            shift and go to state 312
INFO:root:    WHILE           reduce using rule 276 (label_opt -> .)
INFO:root:    DECLARE         reduce using rule 276 (label_opt -> .)
INFO:root:    FOR             reduce using rule 276 (label_opt -> .)
INFO:root:    LOOP            reduce using rule 276 (label_opt -> .)
INFO:root:    BEGIN           reduce using rule 276 (label_opt -> .)
INFO:root:    IDENTIFIER      shift and go to state 322
INFO:root:    ACCEPT          shift and go to state 310
INFO:root:    SELECT          shift and go to state 320
INFO:root:    STRING          shift and go to state 149
INFO:root:
INFO:root:    cond_entry_call                shift and go to state 345
INFO:root:    simple_stmt                    shift and go to state 302
INFO:root:    async_select                   shift and go to state 328
INFO:root:    simple_name                    shift and go to state 163
INFO:root:    requeue_stmt                   shift and go to state 329
INFO:root:    if_stmt                        shift and go to state 304
INFO:root:    procedure_call                 shift and go to state 305
INFO:root:    select_wait                    shift and go to state 330
INFO:root:    indexed_comp                   shift and go to state 140
INFO:root:    timed_entry_call               shift and go to state 307
INFO:root:    statement                      shift and go to state 308
INFO:root:    operator_symbol                shift and go to state 133
INFO:root:    exit_stmt                      shift and go to state 306
INFO:root:    code_stmt                      shift and go to state 331
INFO:root:    loop_stmt                      shift and go to state 333
INFO:root:    null_stmt                      shift and go to state 334
INFO:root:    label                          shift and go to state 335
INFO:root:    select_stmt                    shift and go to state 311
INFO:root:    label_opt                      shift and go to state 313
INFO:root:    assign_stmt                    shift and go to state 336
INFO:root:    selected_comp                  shift and go to state 139
INFO:root:    abort_stmt                     shift and go to state 315
INFO:root:    attribute                      shift and go to state 134
INFO:root:    name                           shift and go to state 316
INFO:root:    accept_hdr                     shift and go to state 318
INFO:root:    accept_stmt                    shift and go to state 337
INFO:root:    case_hdr                       shift and go to state 319
INFO:root:    delay_stmt                     shift and go to state 338
INFO:root:    statement_s                    shift and go to state 727
INFO:root:    compound_stmt                  shift and go to state 309
INFO:root:    raise_stmt                     shift and go to state 342
INFO:root:    qualified                      shift and go to state 321
INFO:root:    return_stmt                    shift and go to state 323
INFO:root:    case_stmt                      shift and go to state 324
INFO:root:    block                          shift and go to state 325
INFO:root:    unlabeled                      shift and go to state 346
INFO:root:
INFO:root:state 613
INFO:root:
INFO:root:    (287) block -> label_opt block_decl block_body . END id_opt ;
INFO:root:
INFO:root:    END             shift and go to state 728
INFO:root:
INFO:root:
INFO:root:state 614
INFO:root:
INFO:root:    (281) iter_part -> FOR IDENTIFIER . IN
INFO:root:
INFO:root:    IN              shift and go to state 729
INFO:root:
INFO:root:
INFO:root:state 615
INFO:root:
INFO:root:    (279) iteration -> WHILE condition .
INFO:root:
INFO:root:    LOOP            reduce using rule 279 (iteration -> WHILE condition .)
INFO:root:
INFO:root:
INFO:root:state 616
INFO:root:
INFO:root:    (289) block_decl -> DECLARE decl_part .
INFO:root:
INFO:root:    BEGIN           reduce using rule 289 (block_decl -> DECLARE decl_part .)
INFO:root:
INFO:root:
INFO:root:state 617
INFO:root:
INFO:root:    (283) reverse_opt -> REVERSE .
INFO:root:
INFO:root:    IDENTIFIER      reduce using rule 283 (reverse_opt -> REVERSE .)
INFO:root:    STRING          reduce using rule 283 (reverse_opt -> REVERSE .)
INFO:root:    +               reduce using rule 283 (reverse_opt -> REVERSE .)
INFO:root:    -               reduce using rule 283 (reverse_opt -> REVERSE .)
INFO:root:    NOT             reduce using rule 283 (reverse_opt -> REVERSE .)
INFO:root:    ABS             reduce using rule 283 (reverse_opt -> REVERSE .)
INFO:root:    INT             reduce using rule 283 (reverse_opt -> REVERSE .)
INFO:root:    FLOAT           reduce using rule 283 (reverse_opt -> REVERSE .)
INFO:root:    NuLL            reduce using rule 283 (reverse_opt -> REVERSE .)
INFO:root:    NEW             reduce using rule 283 (reverse_opt -> REVERSE .)
INFO:root:    (               reduce using rule 283 (reverse_opt -> REVERSE .)
INFO:root:
INFO:root:
INFO:root:state 618
INFO:root:
INFO:root:    (280) iteration -> iter_part reverse_opt . discrete_range
INFO:root:    (91) discrete_range -> . name range_constr_opt
INFO:root:    (92) discrete_range -> . range
INFO:root:    (149) name -> . simple_name
INFO:root:    (150) name -> . indexed_comp
INFO:root:    (151) name -> . selected_comp
INFO:root:    (152) name -> . attribute
INFO:root:    (153) name -> . operator_symbol
INFO:root:    (62) range -> . simple_expression DOTDOT simple_expression
INFO:root:    (157) simple_name -> . IDENTIFIER
INFO:root:    (164) indexed_comp -> . name ( value_s )
INFO:root:    (171) selected_comp -> . name . simple_name
INFO:root:    (172) selected_comp -> . name . used_char
INFO:root:    (173) selected_comp -> . name . operator_symbol
INFO:root:    (174) selected_comp -> . name . ALL
INFO:root:    (175) attribute -> . name TICK attribute_id
INFO:root:    (163) operator_symbol -> . STRING
INFO:root:    (208) simple_expression -> . unary term
INFO:root:    (209) simple_expression -> . term
INFO:root:    (210) simple_expression -> . simple_expression adding term
INFO:root:    (211) unary -> . +
INFO:root:    (212) unary -> . -
INFO:root:    (216) term -> . factor
INFO:root:    (217) term -> . term multiplying factor
INFO:root:    (223) factor -> . primary
INFO:root:    (224) factor -> . NOT primary
INFO:root:    (225) factor -> . ABS primary
INFO:root:    (226) primary -> . literal
INFO:root:    (227) primary -> . name
INFO:root:    (228) primary -> . allocator
INFO:root:    (229) primary -> . qualified
INFO:root:    (230) primary -> . parenthesized_primary
INFO:root:    (180) literal -> . INT
INFO:root:    (181) literal -> . FLOAT
INFO:root:    (182) literal -> . NuLL
INFO:root:    (234) allocator -> . NEW name
INFO:root:    (235) allocator -> . NEW qualified
INFO:root:    (233) qualified -> . name TICK parenthesized_primary
INFO:root:    (231) parenthesized_primary -> . aggregate
INFO:root:    (232) parenthesized_primary -> . ( expression )
INFO:root:    (183) aggregate -> . ( comp_assoc )
INFO:root:    (184) aggregate -> . ( expression WITH value_s )
INFO:root:    (185) aggregate -> . ( expression WITH NuLL RECORD )
INFO:root:    (186) aggregate -> . ( NuLL RECORD )
INFO:root:
INFO:root:    IDENTIFIER      shift and go to state 33
INFO:root:    STRING          shift and go to state 149
INFO:root:    +               shift and go to state 148
INFO:root:    -               shift and go to state 136
INFO:root:    NOT             shift and go to state 131
INFO:root:    ABS             shift and go to state 132
INFO:root:    INT             shift and go to state 120
INFO:root:    FLOAT           shift and go to state 128
INFO:root:    NuLL            shift and go to state 130
INFO:root:    NEW             shift and go to state 137
INFO:root:    (               shift and go to state 125
INFO:root:
INFO:root:    selected_comp                  shift and go to state 139
INFO:root:    allocator                      shift and go to state 122
INFO:root:    simple_name                    shift and go to state 163
INFO:root:    indexed_comp                   shift and go to state 140
INFO:root:    attribute                      shift and go to state 134
INFO:root:    name                           shift and go to state 730
INFO:root:    literal                        shift and go to state 121
INFO:root:    discrete_range                 shift and go to state 731
INFO:root:    parenthesized_primary          shift and go to state 147
INFO:root:    aggregate                      shift and go to state 143
INFO:root:    unary                          shift and go to state 144
INFO:root:    simple_expression              shift and go to state 366
INFO:root:    term                           shift and go to state 146
INFO:root:    operator_symbol                shift and go to state 133
INFO:root:    primary                        shift and go to state 135
INFO:root:    qualified                      shift and go to state 145
INFO:root:    range                          shift and go to state 698
INFO:root:    factor                         shift and go to state 126
INFO:root:
INFO:root:state 619
INFO:root:
INFO:root:    (455) raise_stmt -> RAISE name_opt ; .
INFO:root:
INFO:root:    END             reduce using rule 455 (raise_stmt -> RAISE name_opt ; .)
INFO:root:    LL              reduce using rule 455 (raise_stmt -> RAISE name_opt ; .)
INFO:root:    error           reduce using rule 455 (raise_stmt -> RAISE name_opt ; .)
INFO:root:    NuLL            reduce using rule 455 (raise_stmt -> RAISE name_opt ; .)
INFO:root:    EXIT            reduce using rule 455 (raise_stmt -> RAISE name_opt ; .)
INFO:root:    RETURN          reduce using rule 455 (raise_stmt -> RAISE name_opt ; .)
INFO:root:    DELAY           reduce using rule 455 (raise_stmt -> RAISE name_opt ; .)
INFO:root:    ABORT           reduce using rule 455 (raise_stmt -> RAISE name_opt ; .)
INFO:root:    RAISE           reduce using rule 455 (raise_stmt -> RAISE name_opt ; .)
INFO:root:    REQUEUE         reduce using rule 455 (raise_stmt -> RAISE name_opt ; .)
INFO:root:    IF              reduce using rule 455 (raise_stmt -> RAISE name_opt ; .)
INFO:root:    CASE            reduce using rule 455 (raise_stmt -> RAISE name_opt ; .)
INFO:root:    IDENTIFIER      reduce using rule 455 (raise_stmt -> RAISE name_opt ; .)
INFO:root:    ACCEPT          reduce using rule 455 (raise_stmt -> RAISE name_opt ; .)
INFO:root:    SELECT          reduce using rule 455 (raise_stmt -> RAISE name_opt ; .)
INFO:root:    STRING          reduce using rule 455 (raise_stmt -> RAISE name_opt ; .)
INFO:root:    WHILE           reduce using rule 455 (raise_stmt -> RAISE name_opt ; .)
INFO:root:    DECLARE         reduce using rule 455 (raise_stmt -> RAISE name_opt ; .)
INFO:root:    FOR             reduce using rule 455 (raise_stmt -> RAISE name_opt ; .)
INFO:root:    LOOP            reduce using rule 455 (raise_stmt -> RAISE name_opt ; .)
INFO:root:    BEGIN           reduce using rule 455 (raise_stmt -> RAISE name_opt ; .)
INFO:root:    OR              reduce using rule 455 (raise_stmt -> RAISE name_opt ; .)
INFO:root:    ELSE            reduce using rule 455 (raise_stmt -> RAISE name_opt ; .)
INFO:root:    THEN            reduce using rule 455 (raise_stmt -> RAISE name_opt ; .)
INFO:root:    EXCEPTION       reduce using rule 455 (raise_stmt -> RAISE name_opt ; .)
INFO:root:    WHEN            reduce using rule 455 (raise_stmt -> RAISE name_opt ; .)
INFO:root:    ELSIF           reduce using rule 455 (raise_stmt -> RAISE name_opt ; .)
INFO:root:
INFO:root:
INFO:root:state 620
INFO:root:
INFO:root:    (261) assign_stmt -> name ASSIGN expression . ;
INFO:root:    (189) expression -> expression . logical relation
INFO:root:    (190) expression -> expression . short_circuit relation
INFO:root:    (191) logical -> . AND
INFO:root:    (192) logical -> . OR
INFO:root:    (193) logical -> . XOR
INFO:root:    (194) short_circuit -> . AND THEN
INFO:root:    (195) short_circuit -> . OR ELSE
INFO:root:
INFO:root:    ;               shift and go to state 732
INFO:root:    AND             shift and go to state 215
INFO:root:    OR              shift and go to state 216
INFO:root:    XOR             shift and go to state 214
INFO:root:
INFO:root:    short_circuit                  shift and go to state 212
INFO:root:    logical                        shift and go to state 213
INFO:root:
INFO:root:state 621
INFO:root:
INFO:root:    (457) requeue_stmt -> REQUEUE name WITH . ABORT ;
INFO:root:
INFO:root:    ABORT           shift and go to state 733
INFO:root:
INFO:root:
INFO:root:state 622
INFO:root:
INFO:root:    (456) requeue_stmt -> REQUEUE name ; .
INFO:root:
INFO:root:    LL              reduce using rule 456 (requeue_stmt -> REQUEUE name ; .)
INFO:root:    error           reduce using rule 456 (requeue_stmt -> REQUEUE name ; .)
INFO:root:    NuLL            reduce using rule 456 (requeue_stmt -> REQUEUE name ; .)
INFO:root:    EXIT            reduce using rule 456 (requeue_stmt -> REQUEUE name ; .)
INFO:root:    RETURN          reduce using rule 456 (requeue_stmt -> REQUEUE name ; .)
INFO:root:    DELAY           reduce using rule 456 (requeue_stmt -> REQUEUE name ; .)
INFO:root:    ABORT           reduce using rule 456 (requeue_stmt -> REQUEUE name ; .)
INFO:root:    RAISE           reduce using rule 456 (requeue_stmt -> REQUEUE name ; .)
INFO:root:    REQUEUE         reduce using rule 456 (requeue_stmt -> REQUEUE name ; .)
INFO:root:    IF              reduce using rule 456 (requeue_stmt -> REQUEUE name ; .)
INFO:root:    CASE            reduce using rule 456 (requeue_stmt -> REQUEUE name ; .)
INFO:root:    IDENTIFIER      reduce using rule 456 (requeue_stmt -> REQUEUE name ; .)
INFO:root:    ACCEPT          reduce using rule 456 (requeue_stmt -> REQUEUE name ; .)
INFO:root:    SELECT          reduce using rule 456 (requeue_stmt -> REQUEUE name ; .)
INFO:root:    STRING          reduce using rule 456 (requeue_stmt -> REQUEUE name ; .)
INFO:root:    WHILE           reduce using rule 456 (requeue_stmt -> REQUEUE name ; .)
INFO:root:    DECLARE         reduce using rule 456 (requeue_stmt -> REQUEUE name ; .)
INFO:root:    FOR             reduce using rule 456 (requeue_stmt -> REQUEUE name ; .)
INFO:root:    LOOP            reduce using rule 456 (requeue_stmt -> REQUEUE name ; .)
INFO:root:    BEGIN           reduce using rule 456 (requeue_stmt -> REQUEUE name ; .)
INFO:root:    THEN            reduce using rule 456 (requeue_stmt -> REQUEUE name ; .)
INFO:root:    OR              reduce using rule 456 (requeue_stmt -> REQUEUE name ; .)
INFO:root:    ELSE            reduce using rule 456 (requeue_stmt -> REQUEUE name ; .)
INFO:root:    END             reduce using rule 456 (requeue_stmt -> REQUEUE name ; .)
INFO:root:    EXCEPTION       reduce using rule 456 (requeue_stmt -> REQUEUE name ; .)
INFO:root:    ELSIF           reduce using rule 456 (requeue_stmt -> REQUEUE name ; .)
INFO:root:    WHEN            reduce using rule 456 (requeue_stmt -> REQUEUE name ; .)
INFO:root:
INFO:root:
INFO:root:state 623
INFO:root:
INFO:root:    (391) accept_stmt -> accept_hdr DO handled_stmt_s . END id_opt ;
INFO:root:
INFO:root:    END             shift and go to state 734
INFO:root:
INFO:root:
INFO:root:state 624
INFO:root:
INFO:root:    (270) case_stmt -> case_hdr pragma_s alternative_s . END CASE ;
INFO:root:    (273) alternative_s -> alternative_s . alternative
INFO:root:    (274) alternative -> . WHEN choice_s ARROW statement_s
INFO:root:
INFO:root:    END             shift and go to state 736
INFO:root:    WHEN            shift and go to state 737
INFO:root:
INFO:root:    alternative                    shift and go to state 735
INFO:root:
INFO:root:state 625
INFO:root:
INFO:root:    (412) timed_entry_call -> SELECT entry_call stmts_opt . OR delay_stmt stmts_opt END SELECT ;
INFO:root:    (413) cond_entry_call -> SELECT entry_call stmts_opt . ELSE statement_s END SELECT ;
INFO:root:    (410) delay_or_entry_alt -> entry_call stmts_opt .
INFO:root:
INFO:root:    OR              shift and go to state 739
INFO:root:    ELSE            shift and go to state 738
INFO:root:    THEN            reduce using rule 410 (delay_or_entry_alt -> entry_call stmts_opt .)
INFO:root:
INFO:root:
INFO:root:state 626
INFO:root:
INFO:root:    (415) stmts_opt -> statement_s .
INFO:root:    (237) statement_s -> statement_s . statement
INFO:root:    (238) statement -> . unlabeled
INFO:root:    (239) statement -> . label statement
INFO:root:    (240) unlabeled -> . simple_stmt
INFO:root:    (241) unlabeled -> . compound_stmt
INFO:root:    (259) label -> . LL IDENTIFIER RR
INFO:root:    (242) simple_stmt -> . null_stmt
INFO:root:    (243) simple_stmt -> . assign_stmt
INFO:root:    (244) simple_stmt -> . exit_stmt
INFO:root:    (245) simple_stmt -> . return_stmt
INFO:root:    (246) simple_stmt -> . procedure_call
INFO:root:    (247) simple_stmt -> . delay_stmt
INFO:root:    (248) simple_stmt -> . abort_stmt
INFO:root:    (249) simple_stmt -> . raise_stmt
INFO:root:    (250) simple_stmt -> . code_stmt
INFO:root:    (251) simple_stmt -> . requeue_stmt
INFO:root:    (252) simple_stmt -> . error ;
INFO:root:    (253) compound_stmt -> . if_stmt
INFO:root:    (254) compound_stmt -> . case_stmt
INFO:root:    (255) compound_stmt -> . loop_stmt
INFO:root:    (256) compound_stmt -> . block
INFO:root:    (257) compound_stmt -> . accept_stmt
INFO:root:    (258) compound_stmt -> . select_stmt
INFO:root:    (260) null_stmt -> . NuLL ;
INFO:root:    (261) assign_stmt -> . name ASSIGN expression ;
INFO:root:    (294) exit_stmt -> . EXIT name_opt when_opt ;
INFO:root:    (299) return_stmt -> . RETURN ;
INFO:root:    (300) return_stmt -> . RETURN expression ;
INFO:root:    (323) procedure_call -> . name ;
INFO:root:    (395) delay_stmt -> . DELAY expression ;
INFO:root:    (396) delay_stmt -> . DELAY UNTIL expression ;
INFO:root:    (416) abort_stmt -> . ABORT name_s ;
INFO:root:    (455) raise_stmt -> . RAISE name_opt ;
INFO:root:    (501) code_stmt -> . qualified ;
INFO:root:    (456) requeue_stmt -> . REQUEUE name ;
INFO:root:    (457) requeue_stmt -> . REQUEUE name WITH ABORT ;
INFO:root:    (262) if_stmt -> . IF cond_clause_s else_opt END IF ;
INFO:root:    (270) case_stmt -> . case_hdr pragma_s alternative_s END CASE ;
INFO:root:    (275) loop_stmt -> . label_opt iteration basic_loop id_opt ;
INFO:root:    (287) block -> . label_opt block_decl block_body END id_opt ;
INFO:root:    (390) accept_stmt -> . accept_hdr ;
INFO:root:    (391) accept_stmt -> . accept_hdr DO handled_stmt_s END id_opt ;
INFO:root:    (397) select_stmt -> . select_wait
INFO:root:    (398) select_stmt -> . async_select
INFO:root:    (399) select_stmt -> . timed_entry_call
INFO:root:    (400) select_stmt -> . cond_entry_call
INFO:root:    (149) name -> . simple_name
INFO:root:    (150) name -> . indexed_comp
INFO:root:    (151) name -> . selected_comp
INFO:root:    (152) name -> . attribute
INFO:root:    (153) name -> . operator_symbol
INFO:root:    (233) qualified -> . name TICK parenthesized_primary
INFO:root:    (271) case_hdr -> . CASE expression IS
INFO:root:    (276) label_opt -> .
INFO:root:    (277) label_opt -> . IDENTIFIER :
INFO:root:    (392) accept_hdr -> . ACCEPT entry_name formal_part_opt
INFO:root:    (401) select_wait -> . SELECT guarded_select_alt or_select else_opt END SELECT ;
INFO:root:    (411) async_select -> . SELECT delay_or_entry_alt THEN ABORT statement_s END SELECT ;
INFO:root:    (412) timed_entry_call -> . SELECT entry_call stmts_opt OR delay_stmt stmts_opt END SELECT ;
INFO:root:    (413) cond_entry_call -> . SELECT entry_call stmts_opt ELSE statement_s END SELECT ;
INFO:root:    (157) simple_name -> . IDENTIFIER
INFO:root:    (164) indexed_comp -> . name ( value_s )
INFO:root:    (171) selected_comp -> . name . simple_name
INFO:root:    (172) selected_comp -> . name . used_char
INFO:root:    (173) selected_comp -> . name . operator_symbol
INFO:root:    (174) selected_comp -> . name . ALL
INFO:root:    (175) attribute -> . name TICK attribute_id
INFO:root:    (163) operator_symbol -> . STRING
INFO:root:
INFO:root:    OR              reduce using rule 415 (stmts_opt -> statement_s .)
INFO:root:    ELSE            reduce using rule 415 (stmts_opt -> statement_s .)
INFO:root:    END             reduce using rule 415 (stmts_opt -> statement_s .)
INFO:root:    THEN            reduce using rule 415 (stmts_opt -> statement_s .)
INFO:root:    LL              shift and go to state 344
INFO:root:    error           shift and go to state 341
INFO:root:    NuLL            shift and go to state 347
INFO:root:    EXIT            shift and go to state 340
INFO:root:    RETURN          shift and go to state 303
INFO:root:    DELAY           shift and go to state 332
INFO:root:    ABORT           shift and go to state 326
INFO:root:    RAISE           shift and go to state 314
INFO:root:    REQUEUE         shift and go to state 317
INFO:root:    IF              shift and go to state 327
INFO:root:    CASE            shift and go to state 312
INFO:root:    WHILE           reduce using rule 276 (label_opt -> .)
INFO:root:    DECLARE         reduce using rule 276 (label_opt -> .)
INFO:root:    FOR             reduce using rule 276 (label_opt -> .)
INFO:root:    LOOP            reduce using rule 276 (label_opt -> .)
INFO:root:    BEGIN           reduce using rule 276 (label_opt -> .)
INFO:root:    IDENTIFIER      shift and go to state 322
INFO:root:    ACCEPT          shift and go to state 310
INFO:root:    SELECT          shift and go to state 320
INFO:root:    STRING          shift and go to state 149
INFO:root:
INFO:root:    cond_entry_call                shift and go to state 345
INFO:root:    simple_stmt                    shift and go to state 302
INFO:root:    async_select                   shift and go to state 328
INFO:root:    simple_name                    shift and go to state 163
INFO:root:    requeue_stmt                   shift and go to state 329
INFO:root:    if_stmt                        shift and go to state 304
INFO:root:    procedure_call                 shift and go to state 305
INFO:root:    select_wait                    shift and go to state 330
INFO:root:    indexed_comp                   shift and go to state 140
INFO:root:    timed_entry_call               shift and go to state 307
INFO:root:    statement                      shift and go to state 497
INFO:root:    operator_symbol                shift and go to state 133
INFO:root:    exit_stmt                      shift and go to state 306
INFO:root:    code_stmt                      shift and go to state 331
INFO:root:    loop_stmt                      shift and go to state 333
INFO:root:    null_stmt                      shift and go to state 334
INFO:root:    label                          shift and go to state 335
INFO:root:    select_stmt                    shift and go to state 311
INFO:root:    label_opt                      shift and go to state 313
INFO:root:    assign_stmt                    shift and go to state 336
INFO:root:    selected_comp                  shift and go to state 139
INFO:root:    abort_stmt                     shift and go to state 315
INFO:root:    attribute                      shift and go to state 134
INFO:root:    name                           shift and go to state 316
INFO:root:    accept_hdr                     shift and go to state 318
INFO:root:    accept_stmt                    shift and go to state 337
INFO:root:    case_hdr                       shift and go to state 319
INFO:root:    delay_stmt                     shift and go to state 338
INFO:root:    compound_stmt                  shift and go to state 309
INFO:root:    raise_stmt                     shift and go to state 342
INFO:root:    qualified                      shift and go to state 321
INFO:root:    return_stmt                    shift and go to state 323
INFO:root:    case_stmt                      shift and go to state 324
INFO:root:    block                          shift and go to state 325
INFO:root:    unlabeled                      shift and go to state 346
INFO:root:
INFO:root:state 627
INFO:root:
INFO:root:    (401) select_wait -> SELECT guarded_select_alt or_select . else_opt END SELECT ;
INFO:root:    (405) or_select -> or_select . OR guarded_select_alt
INFO:root:    (268) else_opt -> .
INFO:root:    (269) else_opt -> . ELSE statement_s
INFO:root:
INFO:root:    OR              shift and go to state 740
INFO:root:    END             reduce using rule 268 (else_opt -> .)
INFO:root:    ELSE            shift and go to state 634
INFO:root:
INFO:root:    else_opt                       shift and go to state 741
INFO:root:
INFO:root:state 628
INFO:root:
INFO:root:    (408) select_alt -> TERMINATE ; .
INFO:root:
INFO:root:    OR              reduce using rule 408 (select_alt -> TERMINATE ; .)
INFO:root:    ELSE            reduce using rule 408 (select_alt -> TERMINATE ; .)
INFO:root:    END             reduce using rule 408 (select_alt -> TERMINATE ; .)
INFO:root:
INFO:root:
INFO:root:state 629
INFO:root:
INFO:root:    (411) async_select -> SELECT delay_or_entry_alt THEN . ABORT statement_s END SELECT ;
INFO:root:
INFO:root:    ABORT           shift and go to state 742
INFO:root:
INFO:root:
INFO:root:state 630
INFO:root:
INFO:root:    (406) select_alt -> accept_stmt stmts_opt .
INFO:root:
INFO:root:    OR              reduce using rule 406 (select_alt -> accept_stmt stmts_opt .)
INFO:root:    ELSE            reduce using rule 406 (select_alt -> accept_stmt stmts_opt .)
INFO:root:    END             reduce using rule 406 (select_alt -> accept_stmt stmts_opt .)
INFO:root:
INFO:root:
INFO:root:state 631
INFO:root:
INFO:root:    (409) delay_or_entry_alt -> delay_stmt stmts_opt .
INFO:root:    (407) select_alt -> delay_stmt stmts_opt .
INFO:root:
INFO:root:    THEN            reduce using rule 409 (delay_or_entry_alt -> delay_stmt stmts_opt .)
INFO:root:    OR              reduce using rule 407 (select_alt -> delay_stmt stmts_opt .)
INFO:root:    ELSE            reduce using rule 407 (select_alt -> delay_stmt stmts_opt .)
INFO:root:    END             reduce using rule 407 (select_alt -> delay_stmt stmts_opt .)
INFO:root:
INFO:root:
INFO:root:state 632
INFO:root:
INFO:root:    (403) guarded_select_alt -> WHEN condition . ARROW select_alt
INFO:root:
INFO:root:    ARROW           shift and go to state 743
INFO:root:
INFO:root:
INFO:root:state 633
INFO:root:
INFO:root:    (416) abort_stmt -> ABORT name_s ; .
INFO:root:
INFO:root:    END             reduce using rule 416 (abort_stmt -> ABORT name_s ; .)
INFO:root:    LL              reduce using rule 416 (abort_stmt -> ABORT name_s ; .)
INFO:root:    error           reduce using rule 416 (abort_stmt -> ABORT name_s ; .)
INFO:root:    NuLL            reduce using rule 416 (abort_stmt -> ABORT name_s ; .)
INFO:root:    EXIT            reduce using rule 416 (abort_stmt -> ABORT name_s ; .)
INFO:root:    RETURN          reduce using rule 416 (abort_stmt -> ABORT name_s ; .)
INFO:root:    DELAY           reduce using rule 416 (abort_stmt -> ABORT name_s ; .)
INFO:root:    ABORT           reduce using rule 416 (abort_stmt -> ABORT name_s ; .)
INFO:root:    RAISE           reduce using rule 416 (abort_stmt -> ABORT name_s ; .)
INFO:root:    REQUEUE         reduce using rule 416 (abort_stmt -> ABORT name_s ; .)
INFO:root:    IF              reduce using rule 416 (abort_stmt -> ABORT name_s ; .)
INFO:root:    CASE            reduce using rule 416 (abort_stmt -> ABORT name_s ; .)
INFO:root:    IDENTIFIER      reduce using rule 416 (abort_stmt -> ABORT name_s ; .)
INFO:root:    ACCEPT          reduce using rule 416 (abort_stmt -> ABORT name_s ; .)
INFO:root:    SELECT          reduce using rule 416 (abort_stmt -> ABORT name_s ; .)
INFO:root:    STRING          reduce using rule 416 (abort_stmt -> ABORT name_s ; .)
INFO:root:    WHILE           reduce using rule 416 (abort_stmt -> ABORT name_s ; .)
INFO:root:    DECLARE         reduce using rule 416 (abort_stmt -> ABORT name_s ; .)
INFO:root:    FOR             reduce using rule 416 (abort_stmt -> ABORT name_s ; .)
INFO:root:    LOOP            reduce using rule 416 (abort_stmt -> ABORT name_s ; .)
INFO:root:    BEGIN           reduce using rule 416 (abort_stmt -> ABORT name_s ; .)
INFO:root:    EXCEPTION       reduce using rule 416 (abort_stmt -> ABORT name_s ; .)
INFO:root:    WHEN            reduce using rule 416 (abort_stmt -> ABORT name_s ; .)
INFO:root:    OR              reduce using rule 416 (abort_stmt -> ABORT name_s ; .)
INFO:root:    ELSE            reduce using rule 416 (abort_stmt -> ABORT name_s ; .)
INFO:root:    THEN            reduce using rule 416 (abort_stmt -> ABORT name_s ; .)
INFO:root:    ELSIF           reduce using rule 416 (abort_stmt -> ABORT name_s ; .)
INFO:root:
INFO:root:
INFO:root:state 634
INFO:root:
INFO:root:    (269) else_opt -> ELSE . statement_s
INFO:root:    (236) statement_s -> . statement
INFO:root:    (237) statement_s -> . statement_s statement
INFO:root:    (238) statement -> . unlabeled
INFO:root:    (239) statement -> . label statement
INFO:root:    (240) unlabeled -> . simple_stmt
INFO:root:    (241) unlabeled -> . compound_stmt
INFO:root:    (259) label -> . LL IDENTIFIER RR
INFO:root:    (242) simple_stmt -> . null_stmt
INFO:root:    (243) simple_stmt -> . assign_stmt
INFO:root:    (244) simple_stmt -> . exit_stmt
INFO:root:    (245) simple_stmt -> . return_stmt
INFO:root:    (246) simple_stmt -> . procedure_call
INFO:root:    (247) simple_stmt -> . delay_stmt
INFO:root:    (248) simple_stmt -> . abort_stmt
INFO:root:    (249) simple_stmt -> . raise_stmt
INFO:root:    (250) simple_stmt -> . code_stmt
INFO:root:    (251) simple_stmt -> . requeue_stmt
INFO:root:    (252) simple_stmt -> . error ;
INFO:root:    (253) compound_stmt -> . if_stmt
INFO:root:    (254) compound_stmt -> . case_stmt
INFO:root:    (255) compound_stmt -> . loop_stmt
INFO:root:    (256) compound_stmt -> . block
INFO:root:    (257) compound_stmt -> . accept_stmt
INFO:root:    (258) compound_stmt -> . select_stmt
INFO:root:    (260) null_stmt -> . NuLL ;
INFO:root:    (261) assign_stmt -> . name ASSIGN expression ;
INFO:root:    (294) exit_stmt -> . EXIT name_opt when_opt ;
INFO:root:    (299) return_stmt -> . RETURN ;
INFO:root:    (300) return_stmt -> . RETURN expression ;
INFO:root:    (323) procedure_call -> . name ;
INFO:root:    (395) delay_stmt -> . DELAY expression ;
INFO:root:    (396) delay_stmt -> . DELAY UNTIL expression ;
INFO:root:    (416) abort_stmt -> . ABORT name_s ;
INFO:root:    (455) raise_stmt -> . RAISE name_opt ;
INFO:root:    (501) code_stmt -> . qualified ;
INFO:root:    (456) requeue_stmt -> . REQUEUE name ;
INFO:root:    (457) requeue_stmt -> . REQUEUE name WITH ABORT ;
INFO:root:    (262) if_stmt -> . IF cond_clause_s else_opt END IF ;
INFO:root:    (270) case_stmt -> . case_hdr pragma_s alternative_s END CASE ;
INFO:root:    (275) loop_stmt -> . label_opt iteration basic_loop id_opt ;
INFO:root:    (287) block -> . label_opt block_decl block_body END id_opt ;
INFO:root:    (390) accept_stmt -> . accept_hdr ;
INFO:root:    (391) accept_stmt -> . accept_hdr DO handled_stmt_s END id_opt ;
INFO:root:    (397) select_stmt -> . select_wait
INFO:root:    (398) select_stmt -> . async_select
INFO:root:    (399) select_stmt -> . timed_entry_call
INFO:root:    (400) select_stmt -> . cond_entry_call
INFO:root:    (149) name -> . simple_name
INFO:root:    (150) name -> . indexed_comp
INFO:root:    (151) name -> . selected_comp
INFO:root:    (152) name -> . attribute
INFO:root:    (153) name -> . operator_symbol
INFO:root:    (233) qualified -> . name TICK parenthesized_primary
INFO:root:    (271) case_hdr -> . CASE expression IS
INFO:root:    (276) label_opt -> .
INFO:root:    (277) label_opt -> . IDENTIFIER :
INFO:root:    (392) accept_hdr -> . ACCEPT entry_name formal_part_opt
INFO:root:    (401) select_wait -> . SELECT guarded_select_alt or_select else_opt END SELECT ;
INFO:root:    (411) async_select -> . SELECT delay_or_entry_alt THEN ABORT statement_s END SELECT ;
INFO:root:    (412) timed_entry_call -> . SELECT entry_call stmts_opt OR delay_stmt stmts_opt END SELECT ;
INFO:root:    (413) cond_entry_call -> . SELECT entry_call stmts_opt ELSE statement_s END SELECT ;
INFO:root:    (157) simple_name -> . IDENTIFIER
INFO:root:    (164) indexed_comp -> . name ( value_s )
INFO:root:    (171) selected_comp -> . name . simple_name
INFO:root:    (172) selected_comp -> . name . used_char
INFO:root:    (173) selected_comp -> . name . operator_symbol
INFO:root:    (174) selected_comp -> . name . ALL
INFO:root:    (175) attribute -> . name TICK attribute_id
INFO:root:    (163) operator_symbol -> . STRING
INFO:root:
INFO:root:    LL              shift and go to state 344
INFO:root:    error           shift and go to state 341
INFO:root:    NuLL            shift and go to state 347
INFO:root:    EXIT            shift and go to state 340
INFO:root:    RETURN          shift and go to state 303
INFO:root:    DELAY           shift and go to state 332
INFO:root:    ABORT           shift and go to state 326
INFO:root:    RAISE           shift and go to state 314
INFO:root:    REQUEUE         shift and go to state 317
INFO:root:    IF              shift and go to state 327
INFO:root:    CASE            shift and go to state 312
INFO:root:    WHILE           reduce using rule 276 (label_opt -> .)
INFO:root:    DECLARE         reduce using rule 276 (label_opt -> .)
INFO:root:    FOR             reduce using rule 276 (label_opt -> .)
INFO:root:    LOOP            reduce using rule 276 (label_opt -> .)
INFO:root:    BEGIN           reduce using rule 276 (label_opt -> .)
INFO:root:    IDENTIFIER      shift and go to state 322
INFO:root:    ACCEPT          shift and go to state 310
INFO:root:    SELECT          shift and go to state 320
INFO:root:    STRING          shift and go to state 149
INFO:root:
INFO:root:    cond_entry_call                shift and go to state 345
INFO:root:    simple_stmt                    shift and go to state 302
INFO:root:    async_select                   shift and go to state 328
INFO:root:    simple_name                    shift and go to state 163
INFO:root:    requeue_stmt                   shift and go to state 329
INFO:root:    if_stmt                        shift and go to state 304
INFO:root:    procedure_call                 shift and go to state 305
INFO:root:    select_wait                    shift and go to state 330
INFO:root:    indexed_comp                   shift and go to state 140
INFO:root:    timed_entry_call               shift and go to state 307
INFO:root:    statement                      shift and go to state 308
INFO:root:    operator_symbol                shift and go to state 133
INFO:root:    exit_stmt                      shift and go to state 306
INFO:root:    code_stmt                      shift and go to state 331
INFO:root:    loop_stmt                      shift and go to state 333
INFO:root:    null_stmt                      shift and go to state 334
INFO:root:    label                          shift and go to state 335
INFO:root:    select_stmt                    shift and go to state 311
INFO:root:    label_opt                      shift and go to state 313
INFO:root:    assign_stmt                    shift and go to state 336
INFO:root:    selected_comp                  shift and go to state 139
INFO:root:    abort_stmt                     shift and go to state 315
INFO:root:    attribute                      shift and go to state 134
INFO:root:    name                           shift and go to state 316
INFO:root:    accept_hdr                     shift and go to state 318
INFO:root:    accept_stmt                    shift and go to state 337
INFO:root:    case_hdr                       shift and go to state 319
INFO:root:    delay_stmt                     shift and go to state 338
INFO:root:    statement_s                    shift and go to state 744
INFO:root:    compound_stmt                  shift and go to state 309
INFO:root:    raise_stmt                     shift and go to state 342
INFO:root:    qualified                      shift and go to state 321
INFO:root:    return_stmt                    shift and go to state 323
INFO:root:    case_stmt                      shift and go to state 324
INFO:root:    block                          shift and go to state 325
INFO:root:    unlabeled                      shift and go to state 346
INFO:root:
INFO:root:state 635
INFO:root:
INFO:root:    (262) if_stmt -> IF cond_clause_s else_opt . END IF ;
INFO:root:
INFO:root:    END             shift and go to state 745
INFO:root:
INFO:root:
INFO:root:state 636
INFO:root:
INFO:root:    (264) cond_clause_s -> cond_clause_s ELSIF . cond_clause
INFO:root:    (265) cond_clause -> . cond_part statement_s
INFO:root:    (266) cond_part -> . condition THEN
INFO:root:    (267) condition -> . expression
INFO:root:    (188) expression -> . relation
INFO:root:    (189) expression -> . expression logical relation
INFO:root:    (190) expression -> . expression short_circuit relation
INFO:root:    (196) relation -> . simple_expression
INFO:root:    (197) relation -> . simple_expression relational simple_expression
INFO:root:    (198) relation -> . simple_expression membership range
INFO:root:    (199) relation -> . simple_expression membership name
INFO:root:    (208) simple_expression -> . unary term
INFO:root:    (209) simple_expression -> . term
INFO:root:    (210) simple_expression -> . simple_expression adding term
INFO:root:    (211) unary -> . +
INFO:root:    (212) unary -> . -
INFO:root:    (216) term -> . factor
INFO:root:    (217) term -> . term multiplying factor
INFO:root:    (223) factor -> . primary
INFO:root:    (224) factor -> . NOT primary
INFO:root:    (225) factor -> . ABS primary
INFO:root:    (226) primary -> . literal
INFO:root:    (227) primary -> . name
INFO:root:    (228) primary -> . allocator
INFO:root:    (229) primary -> . qualified
INFO:root:    (230) primary -> . parenthesized_primary
INFO:root:    (180) literal -> . INT
INFO:root:    (181) literal -> . FLOAT
INFO:root:    (182) literal -> . NuLL
INFO:root:    (149) name -> . simple_name
INFO:root:    (150) name -> . indexed_comp
INFO:root:    (151) name -> . selected_comp
INFO:root:    (152) name -> . attribute
INFO:root:    (153) name -> . operator_symbol
INFO:root:    (234) allocator -> . NEW name
INFO:root:    (235) allocator -> . NEW qualified
INFO:root:    (233) qualified -> . name TICK parenthesized_primary
INFO:root:    (231) parenthesized_primary -> . aggregate
INFO:root:    (232) parenthesized_primary -> . ( expression )
INFO:root:    (157) simple_name -> . IDENTIFIER
INFO:root:    (164) indexed_comp -> . name ( value_s )
INFO:root:    (171) selected_comp -> . name . simple_name
INFO:root:    (172) selected_comp -> . name . used_char
INFO:root:    (173) selected_comp -> . name . operator_symbol
INFO:root:    (174) selected_comp -> . name . ALL
INFO:root:    (175) attribute -> . name TICK attribute_id
INFO:root:    (163) operator_symbol -> . STRING
INFO:root:    (183) aggregate -> . ( comp_assoc )
INFO:root:    (184) aggregate -> . ( expression WITH value_s )
INFO:root:    (185) aggregate -> . ( expression WITH NuLL RECORD )
INFO:root:    (186) aggregate -> . ( NuLL RECORD )
INFO:root:
INFO:root:    +               shift and go to state 148
INFO:root:    -               shift and go to state 136
INFO:root:    NOT             shift and go to state 131
INFO:root:    ABS             shift and go to state 132
INFO:root:    INT             shift and go to state 120
INFO:root:    FLOAT           shift and go to state 128
INFO:root:    NuLL            shift and go to state 130
INFO:root:    NEW             shift and go to state 137
INFO:root:    (               shift and go to state 125
INFO:root:    IDENTIFIER      shift and go to state 33
INFO:root:    STRING          shift and go to state 149
INFO:root:
INFO:root:    literal                        shift and go to state 121
INFO:root:    allocator                      shift and go to state 122
INFO:root:    simple_name                    shift and go to state 163
INFO:root:    indexed_comp                   shift and go to state 140
INFO:root:    name                           shift and go to state 142
INFO:root:    condition                      shift and go to state 492
INFO:root:    selected_comp                  shift and go to state 139
INFO:root:    factor                         shift and go to state 126
INFO:root:    expression                     shift and go to state 489
INFO:root:    parenthesized_primary          shift and go to state 147
INFO:root:    unary                          shift and go to state 144
INFO:root:    qualified                      shift and go to state 145
INFO:root:    aggregate                      shift and go to state 143
INFO:root:    cond_part                      shift and go to state 493
INFO:root:    simple_expression              shift and go to state 129
INFO:root:    term                           shift and go to state 146
INFO:root:    cond_clause                    shift and go to state 746
INFO:root:    operator_symbol                shift and go to state 133
INFO:root:    attribute                      shift and go to state 134
INFO:root:    primary                        shift and go to state 135
INFO:root:    relation                       shift and go to state 138
INFO:root:
INFO:root:state 637
INFO:root:
INFO:root:    (266) cond_part -> condition THEN .
INFO:root:
INFO:root:    LL              reduce using rule 266 (cond_part -> condition THEN .)
INFO:root:    error           reduce using rule 266 (cond_part -> condition THEN .)
INFO:root:    NuLL            reduce using rule 266 (cond_part -> condition THEN .)
INFO:root:    EXIT            reduce using rule 266 (cond_part -> condition THEN .)
INFO:root:    RETURN          reduce using rule 266 (cond_part -> condition THEN .)
INFO:root:    DELAY           reduce using rule 266 (cond_part -> condition THEN .)
INFO:root:    ABORT           reduce using rule 266 (cond_part -> condition THEN .)
INFO:root:    RAISE           reduce using rule 266 (cond_part -> condition THEN .)
INFO:root:    REQUEUE         reduce using rule 266 (cond_part -> condition THEN .)
INFO:root:    IF              reduce using rule 266 (cond_part -> condition THEN .)
INFO:root:    CASE            reduce using rule 266 (cond_part -> condition THEN .)
INFO:root:    IDENTIFIER      reduce using rule 266 (cond_part -> condition THEN .)
INFO:root:    ACCEPT          reduce using rule 266 (cond_part -> condition THEN .)
INFO:root:    SELECT          reduce using rule 266 (cond_part -> condition THEN .)
INFO:root:    STRING          reduce using rule 266 (cond_part -> condition THEN .)
INFO:root:    WHILE           reduce using rule 266 (cond_part -> condition THEN .)
INFO:root:    DECLARE         reduce using rule 266 (cond_part -> condition THEN .)
INFO:root:    FOR             reduce using rule 266 (cond_part -> condition THEN .)
INFO:root:    LOOP            reduce using rule 266 (cond_part -> condition THEN .)
INFO:root:    BEGIN           reduce using rule 266 (cond_part -> condition THEN .)
INFO:root:
INFO:root:
INFO:root:state 638
INFO:root:
INFO:root:    (265) cond_clause -> cond_part statement_s .
INFO:root:    (237) statement_s -> statement_s . statement
INFO:root:    (238) statement -> . unlabeled
INFO:root:    (239) statement -> . label statement
INFO:root:    (240) unlabeled -> . simple_stmt
INFO:root:    (241) unlabeled -> . compound_stmt
INFO:root:    (259) label -> . LL IDENTIFIER RR
INFO:root:    (242) simple_stmt -> . null_stmt
INFO:root:    (243) simple_stmt -> . assign_stmt
INFO:root:    (244) simple_stmt -> . exit_stmt
INFO:root:    (245) simple_stmt -> . return_stmt
INFO:root:    (246) simple_stmt -> . procedure_call
INFO:root:    (247) simple_stmt -> . delay_stmt
INFO:root:    (248) simple_stmt -> . abort_stmt
INFO:root:    (249) simple_stmt -> . raise_stmt
INFO:root:    (250) simple_stmt -> . code_stmt
INFO:root:    (251) simple_stmt -> . requeue_stmt
INFO:root:    (252) simple_stmt -> . error ;
INFO:root:    (253) compound_stmt -> . if_stmt
INFO:root:    (254) compound_stmt -> . case_stmt
INFO:root:    (255) compound_stmt -> . loop_stmt
INFO:root:    (256) compound_stmt -> . block
INFO:root:    (257) compound_stmt -> . accept_stmt
INFO:root:    (258) compound_stmt -> . select_stmt
INFO:root:    (260) null_stmt -> . NuLL ;
INFO:root:    (261) assign_stmt -> . name ASSIGN expression ;
INFO:root:    (294) exit_stmt -> . EXIT name_opt when_opt ;
INFO:root:    (299) return_stmt -> . RETURN ;
INFO:root:    (300) return_stmt -> . RETURN expression ;
INFO:root:    (323) procedure_call -> . name ;
INFO:root:    (395) delay_stmt -> . DELAY expression ;
INFO:root:    (396) delay_stmt -> . DELAY UNTIL expression ;
INFO:root:    (416) abort_stmt -> . ABORT name_s ;
INFO:root:    (455) raise_stmt -> . RAISE name_opt ;
INFO:root:    (501) code_stmt -> . qualified ;
INFO:root:    (456) requeue_stmt -> . REQUEUE name ;
INFO:root:    (457) requeue_stmt -> . REQUEUE name WITH ABORT ;
INFO:root:    (262) if_stmt -> . IF cond_clause_s else_opt END IF ;
INFO:root:    (270) case_stmt -> . case_hdr pragma_s alternative_s END CASE ;
INFO:root:    (275) loop_stmt -> . label_opt iteration basic_loop id_opt ;
INFO:root:    (287) block -> . label_opt block_decl block_body END id_opt ;
INFO:root:    (390) accept_stmt -> . accept_hdr ;
INFO:root:    (391) accept_stmt -> . accept_hdr DO handled_stmt_s END id_opt ;
INFO:root:    (397) select_stmt -> . select_wait
INFO:root:    (398) select_stmt -> . async_select
INFO:root:    (399) select_stmt -> . timed_entry_call
INFO:root:    (400) select_stmt -> . cond_entry_call
INFO:root:    (149) name -> . simple_name
INFO:root:    (150) name -> . indexed_comp
INFO:root:    (151) name -> . selected_comp
INFO:root:    (152) name -> . attribute
INFO:root:    (153) name -> . operator_symbol
INFO:root:    (233) qualified -> . name TICK parenthesized_primary
INFO:root:    (271) case_hdr -> . CASE expression IS
INFO:root:    (276) label_opt -> .
INFO:root:    (277) label_opt -> . IDENTIFIER :
INFO:root:    (392) accept_hdr -> . ACCEPT entry_name formal_part_opt
INFO:root:    (401) select_wait -> . SELECT guarded_select_alt or_select else_opt END SELECT ;
INFO:root:    (411) async_select -> . SELECT delay_or_entry_alt THEN ABORT statement_s END SELECT ;
INFO:root:    (412) timed_entry_call -> . SELECT entry_call stmts_opt OR delay_stmt stmts_opt END SELECT ;
INFO:root:    (413) cond_entry_call -> . SELECT entry_call stmts_opt ELSE statement_s END SELECT ;
INFO:root:    (157) simple_name -> . IDENTIFIER
INFO:root:    (164) indexed_comp -> . name ( value_s )
INFO:root:    (171) selected_comp -> . name . simple_name
INFO:root:    (172) selected_comp -> . name . used_char
INFO:root:    (173) selected_comp -> . name . operator_symbol
INFO:root:    (174) selected_comp -> . name . ALL
INFO:root:    (175) attribute -> . name TICK attribute_id
INFO:root:    (163) operator_symbol -> . STRING
INFO:root:
INFO:root:    ELSIF           reduce using rule 265 (cond_clause -> cond_part statement_s .)
INFO:root:    ELSE            reduce using rule 265 (cond_clause -> cond_part statement_s .)
INFO:root:    END             reduce using rule 265 (cond_clause -> cond_part statement_s .)
INFO:root:    LL              shift and go to state 344
INFO:root:    error           shift and go to state 341
INFO:root:    NuLL            shift and go to state 347
INFO:root:    EXIT            shift and go to state 340
INFO:root:    RETURN          shift and go to state 303
INFO:root:    DELAY           shift and go to state 332
INFO:root:    ABORT           shift and go to state 326
INFO:root:    RAISE           shift and go to state 314
INFO:root:    REQUEUE         shift and go to state 317
INFO:root:    IF              shift and go to state 327
INFO:root:    CASE            shift and go to state 312
INFO:root:    WHILE           reduce using rule 276 (label_opt -> .)
INFO:root:    DECLARE         reduce using rule 276 (label_opt -> .)
INFO:root:    FOR             reduce using rule 276 (label_opt -> .)
INFO:root:    LOOP            reduce using rule 276 (label_opt -> .)
INFO:root:    BEGIN           reduce using rule 276 (label_opt -> .)
INFO:root:    IDENTIFIER      shift and go to state 322
INFO:root:    ACCEPT          shift and go to state 310
INFO:root:    SELECT          shift and go to state 320
INFO:root:    STRING          shift and go to state 149
INFO:root:
INFO:root:    cond_entry_call                shift and go to state 345
INFO:root:    simple_stmt                    shift and go to state 302
INFO:root:    async_select                   shift and go to state 328
INFO:root:    simple_name                    shift and go to state 163
INFO:root:    requeue_stmt                   shift and go to state 329
INFO:root:    if_stmt                        shift and go to state 304
INFO:root:    procedure_call                 shift and go to state 305
INFO:root:    select_wait                    shift and go to state 330
INFO:root:    indexed_comp                   shift and go to state 140
INFO:root:    timed_entry_call               shift and go to state 307
INFO:root:    statement                      shift and go to state 497
INFO:root:    operator_symbol                shift and go to state 133
INFO:root:    exit_stmt                      shift and go to state 306
INFO:root:    code_stmt                      shift and go to state 331
INFO:root:    loop_stmt                      shift and go to state 333
INFO:root:    null_stmt                      shift and go to state 334
INFO:root:    label                          shift and go to state 335
INFO:root:    select_stmt                    shift and go to state 311
INFO:root:    label_opt                      shift and go to state 313
INFO:root:    assign_stmt                    shift and go to state 336
INFO:root:    selected_comp                  shift and go to state 139
INFO:root:    abort_stmt                     shift and go to state 315
INFO:root:    attribute                      shift and go to state 134
INFO:root:    name                           shift and go to state 316
INFO:root:    accept_hdr                     shift and go to state 318
INFO:root:    accept_stmt                    shift and go to state 337
INFO:root:    case_hdr                       shift and go to state 319
INFO:root:    delay_stmt                     shift and go to state 338
INFO:root:    compound_stmt                  shift and go to state 309
INFO:root:    raise_stmt                     shift and go to state 342
INFO:root:    qualified                      shift and go to state 321
INFO:root:    return_stmt                    shift and go to state 323
INFO:root:    case_stmt                      shift and go to state 324
INFO:root:    block                          shift and go to state 325
INFO:root:    unlabeled                      shift and go to state 346
INFO:root:
INFO:root:state 639
INFO:root:
INFO:root:    (395) delay_stmt -> DELAY expression ; .
INFO:root:
INFO:root:    LL              reduce using rule 395 (delay_stmt -> DELAY expression ; .)
INFO:root:    error           reduce using rule 395 (delay_stmt -> DELAY expression ; .)
INFO:root:    NuLL            reduce using rule 395 (delay_stmt -> DELAY expression ; .)
INFO:root:    EXIT            reduce using rule 395 (delay_stmt -> DELAY expression ; .)
INFO:root:    RETURN          reduce using rule 395 (delay_stmt -> DELAY expression ; .)
INFO:root:    DELAY           reduce using rule 395 (delay_stmt -> DELAY expression ; .)
INFO:root:    ABORT           reduce using rule 395 (delay_stmt -> DELAY expression ; .)
INFO:root:    RAISE           reduce using rule 395 (delay_stmt -> DELAY expression ; .)
INFO:root:    REQUEUE         reduce using rule 395 (delay_stmt -> DELAY expression ; .)
INFO:root:    IF              reduce using rule 395 (delay_stmt -> DELAY expression ; .)
INFO:root:    CASE            reduce using rule 395 (delay_stmt -> DELAY expression ; .)
INFO:root:    IDENTIFIER      reduce using rule 395 (delay_stmt -> DELAY expression ; .)
INFO:root:    ACCEPT          reduce using rule 395 (delay_stmt -> DELAY expression ; .)
INFO:root:    SELECT          reduce using rule 395 (delay_stmt -> DELAY expression ; .)
INFO:root:    STRING          reduce using rule 395 (delay_stmt -> DELAY expression ; .)
INFO:root:    WHILE           reduce using rule 395 (delay_stmt -> DELAY expression ; .)
INFO:root:    DECLARE         reduce using rule 395 (delay_stmt -> DELAY expression ; .)
INFO:root:    FOR             reduce using rule 395 (delay_stmt -> DELAY expression ; .)
INFO:root:    LOOP            reduce using rule 395 (delay_stmt -> DELAY expression ; .)
INFO:root:    BEGIN           reduce using rule 395 (delay_stmt -> DELAY expression ; .)
INFO:root:    WHEN            reduce using rule 395 (delay_stmt -> DELAY expression ; .)
INFO:root:    END             reduce using rule 395 (delay_stmt -> DELAY expression ; .)
INFO:root:    OR              reduce using rule 395 (delay_stmt -> DELAY expression ; .)
INFO:root:    ELSE            reduce using rule 395 (delay_stmt -> DELAY expression ; .)
INFO:root:    EXCEPTION       reduce using rule 395 (delay_stmt -> DELAY expression ; .)
INFO:root:    ELSIF           reduce using rule 395 (delay_stmt -> DELAY expression ; .)
INFO:root:    THEN            reduce using rule 395 (delay_stmt -> DELAY expression ; .)
INFO:root:
INFO:root:
INFO:root:state 640
INFO:root:
INFO:root:    (396) delay_stmt -> DELAY UNTIL expression . ;
INFO:root:    (189) expression -> expression . logical relation
INFO:root:    (190) expression -> expression . short_circuit relation
INFO:root:    (191) logical -> . AND
INFO:root:    (192) logical -> . OR
INFO:root:    (193) logical -> . XOR
INFO:root:    (194) short_circuit -> . AND THEN
INFO:root:    (195) short_circuit -> . OR ELSE
INFO:root:
INFO:root:    ;               shift and go to state 747
INFO:root:    AND             shift and go to state 215
INFO:root:    OR              shift and go to state 216
INFO:root:    XOR             shift and go to state 214
INFO:root:
INFO:root:    short_circuit                  shift and go to state 212
INFO:root:    logical                        shift and go to state 213
INFO:root:
INFO:root:state 641
INFO:root:
INFO:root:    (447) except_handler_part -> EXCEPTION exception_handler .
INFO:root:
INFO:root:    WHEN            reduce using rule 447 (except_handler_part -> EXCEPTION exception_handler .)
INFO:root:    END             reduce using rule 447 (except_handler_part -> EXCEPTION exception_handler .)
INFO:root:
INFO:root:
INFO:root:state 642
INFO:root:
INFO:root:    (449) exception_handler -> WHEN . except_choice_s ARROW statement_s
INFO:root:    (450) exception_handler -> WHEN . IDENTIFIER : except_choice_s ARROW statement_s
INFO:root:    (451) except_choice_s -> . except_choice
INFO:root:    (452) except_choice_s -> . except_choice_s | except_choice
INFO:root:    (453) except_choice -> . name
INFO:root:    (454) except_choice -> . OTHERS
INFO:root:    (149) name -> . simple_name
INFO:root:    (150) name -> . indexed_comp
INFO:root:    (151) name -> . selected_comp
INFO:root:    (152) name -> . attribute
INFO:root:    (153) name -> . operator_symbol
INFO:root:    (157) simple_name -> . IDENTIFIER
INFO:root:    (164) indexed_comp -> . name ( value_s )
INFO:root:    (171) selected_comp -> . name . simple_name
INFO:root:    (172) selected_comp -> . name . used_char
INFO:root:    (173) selected_comp -> . name . operator_symbol
INFO:root:    (174) selected_comp -> . name . ALL
INFO:root:    (175) attribute -> . name TICK attribute_id
INFO:root:    (163) operator_symbol -> . STRING
INFO:root:
INFO:root:    IDENTIFIER      shift and go to state 752
INFO:root:    OTHERS          shift and go to state 749
INFO:root:    STRING          shift and go to state 149
INFO:root:
INFO:root:    except_choice                  shift and go to state 751
INFO:root:    selected_comp                  shift and go to state 139
INFO:root:    indexed_comp                   shift and go to state 140
INFO:root:    attribute                      shift and go to state 134
INFO:root:    name                           shift and go to state 748
INFO:root:    operator_symbol                shift and go to state 133
INFO:root:    simple_name                    shift and go to state 163
INFO:root:    except_choice_s                shift and go to state 750
INFO:root:
INFO:root:state 643
INFO:root:
INFO:root:    (448) except_handler_part -> except_handler_part exception_handler .
INFO:root:
INFO:root:    WHEN            reduce using rule 448 (except_handler_part -> except_handler_part exception_handler .)
INFO:root:    END             reduce using rule 448 (except_handler_part -> except_handler_part exception_handler .)
INFO:root:
INFO:root:
INFO:root:state 644
INFO:root:
INFO:root:    (294) exit_stmt -> EXIT name_opt when_opt . ;
INFO:root:
INFO:root:    ;               shift and go to state 753
INFO:root:
INFO:root:
INFO:root:state 645
INFO:root:
INFO:root:    (298) when_opt -> WHEN . condition
INFO:root:    (267) condition -> . expression
INFO:root:    (188) expression -> . relation
INFO:root:    (189) expression -> . expression logical relation
INFO:root:    (190) expression -> . expression short_circuit relation
INFO:root:    (196) relation -> . simple_expression
INFO:root:    (197) relation -> . simple_expression relational simple_expression
INFO:root:    (198) relation -> . simple_expression membership range
INFO:root:    (199) relation -> . simple_expression membership name
INFO:root:    (208) simple_expression -> . unary term
INFO:root:    (209) simple_expression -> . term
INFO:root:    (210) simple_expression -> . simple_expression adding term
INFO:root:    (211) unary -> . +
INFO:root:    (212) unary -> . -
INFO:root:    (216) term -> . factor
INFO:root:    (217) term -> . term multiplying factor
INFO:root:    (223) factor -> . primary
INFO:root:    (224) factor -> . NOT primary
INFO:root:    (225) factor -> . ABS primary
INFO:root:    (226) primary -> . literal
INFO:root:    (227) primary -> . name
INFO:root:    (228) primary -> . allocator
INFO:root:    (229) primary -> . qualified
INFO:root:    (230) primary -> . parenthesized_primary
INFO:root:    (180) literal -> . INT
INFO:root:    (181) literal -> . FLOAT
INFO:root:    (182) literal -> . NuLL
INFO:root:    (149) name -> . simple_name
INFO:root:    (150) name -> . indexed_comp
INFO:root:    (151) name -> . selected_comp
INFO:root:    (152) name -> . attribute
INFO:root:    (153) name -> . operator_symbol
INFO:root:    (234) allocator -> . NEW name
INFO:root:    (235) allocator -> . NEW qualified
INFO:root:    (233) qualified -> . name TICK parenthesized_primary
INFO:root:    (231) parenthesized_primary -> . aggregate
INFO:root:    (232) parenthesized_primary -> . ( expression )
INFO:root:    (157) simple_name -> . IDENTIFIER
INFO:root:    (164) indexed_comp -> . name ( value_s )
INFO:root:    (171) selected_comp -> . name . simple_name
INFO:root:    (172) selected_comp -> . name . used_char
INFO:root:    (173) selected_comp -> . name . operator_symbol
INFO:root:    (174) selected_comp -> . name . ALL
INFO:root:    (175) attribute -> . name TICK attribute_id
INFO:root:    (163) operator_symbol -> . STRING
INFO:root:    (183) aggregate -> . ( comp_assoc )
INFO:root:    (184) aggregate -> . ( expression WITH value_s )
INFO:root:    (185) aggregate -> . ( expression WITH NuLL RECORD )
INFO:root:    (186) aggregate -> . ( NuLL RECORD )
INFO:root:
INFO:root:    +               shift and go to state 148
INFO:root:    -               shift and go to state 136
INFO:root:    NOT             shift and go to state 131
INFO:root:    ABS             shift and go to state 132
INFO:root:    INT             shift and go to state 120
INFO:root:    FLOAT           shift and go to state 128
INFO:root:    NuLL            shift and go to state 130
INFO:root:    NEW             shift and go to state 137
INFO:root:    (               shift and go to state 125
INFO:root:    IDENTIFIER      shift and go to state 33
INFO:root:    STRING          shift and go to state 149
INFO:root:
INFO:root:    literal                        shift and go to state 121
INFO:root:    allocator                      shift and go to state 122
INFO:root:    simple_name                    shift and go to state 163
INFO:root:    indexed_comp                   shift and go to state 140
INFO:root:    name                           shift and go to state 142
INFO:root:    condition                      shift and go to state 754
INFO:root:    selected_comp                  shift and go to state 139
INFO:root:    factor                         shift and go to state 126
INFO:root:    expression                     shift and go to state 489
INFO:root:    unary                          shift and go to state 144
INFO:root:    qualified                      shift and go to state 145
INFO:root:    aggregate                      shift and go to state 143
INFO:root:    simple_expression              shift and go to state 129
INFO:root:    term                           shift and go to state 146
INFO:root:    operator_symbol                shift and go to state 133
INFO:root:    parenthesized_primary          shift and go to state 147
INFO:root:    attribute                      shift and go to state 134
INFO:root:    primary                        shift and go to state 135
INFO:root:    relation                       shift and go to state 138
INFO:root:
INFO:root:state 646
INFO:root:
INFO:root:    (259) label -> LL IDENTIFIER RR .
INFO:root:
INFO:root:    LL              reduce using rule 259 (label -> LL IDENTIFIER RR .)
INFO:root:    error           reduce using rule 259 (label -> LL IDENTIFIER RR .)
INFO:root:    NuLL            reduce using rule 259 (label -> LL IDENTIFIER RR .)
INFO:root:    EXIT            reduce using rule 259 (label -> LL IDENTIFIER RR .)
INFO:root:    RETURN          reduce using rule 259 (label -> LL IDENTIFIER RR .)
INFO:root:    DELAY           reduce using rule 259 (label -> LL IDENTIFIER RR .)
INFO:root:    ABORT           reduce using rule 259 (label -> LL IDENTIFIER RR .)
INFO:root:    RAISE           reduce using rule 259 (label -> LL IDENTIFIER RR .)
INFO:root:    REQUEUE         reduce using rule 259 (label -> LL IDENTIFIER RR .)
INFO:root:    IF              reduce using rule 259 (label -> LL IDENTIFIER RR .)
INFO:root:    CASE            reduce using rule 259 (label -> LL IDENTIFIER RR .)
INFO:root:    IDENTIFIER      reduce using rule 259 (label -> LL IDENTIFIER RR .)
INFO:root:    ACCEPT          reduce using rule 259 (label -> LL IDENTIFIER RR .)
INFO:root:    SELECT          reduce using rule 259 (label -> LL IDENTIFIER RR .)
INFO:root:    STRING          reduce using rule 259 (label -> LL IDENTIFIER RR .)
INFO:root:    WHILE           reduce using rule 259 (label -> LL IDENTIFIER RR .)
INFO:root:    DECLARE         reduce using rule 259 (label -> LL IDENTIFIER RR .)
INFO:root:    FOR             reduce using rule 259 (label -> LL IDENTIFIER RR .)
INFO:root:    LOOP            reduce using rule 259 (label -> LL IDENTIFIER RR .)
INFO:root:    BEGIN           reduce using rule 259 (label -> LL IDENTIFIER RR .)
INFO:root:
INFO:root:
INFO:root:state 647
INFO:root:
INFO:root:    (50) subtype_decl -> SUBTYPE IDENTIFIER IS subtype_ind ; .
INFO:root:
INFO:root:    PACKAGE         reduce using rule 50 (subtype_decl -> SUBTYPE IDENTIFIER IS subtype_ind ; .)
INFO:root:    TASK            reduce using rule 50 (subtype_decl -> SUBTYPE IDENTIFIER IS subtype_ind ; .)
INFO:root:    PROTECTED       reduce using rule 50 (subtype_decl -> SUBTYPE IDENTIFIER IS subtype_ind ; .)
INFO:root:    error           reduce using rule 50 (subtype_decl -> SUBTYPE IDENTIFIER IS subtype_ind ; .)
INFO:root:    USE             reduce using rule 50 (subtype_decl -> SUBTYPE IDENTIFIER IS subtype_ind ; .)
INFO:root:    PRAGMA          reduce using rule 50 (subtype_decl -> SUBTYPE IDENTIFIER IS subtype_ind ; .)
INFO:root:    TYPE            reduce using rule 50 (subtype_decl -> SUBTYPE IDENTIFIER IS subtype_ind ; .)
INFO:root:    SUBTYPE         reduce using rule 50 (subtype_decl -> SUBTYPE IDENTIFIER IS subtype_ind ; .)
INFO:root:    FOR             reduce using rule 50 (subtype_decl -> SUBTYPE IDENTIFIER IS subtype_ind ; .)
INFO:root:    PROCEDURE       reduce using rule 50 (subtype_decl -> SUBTYPE IDENTIFIER IS subtype_ind ; .)
INFO:root:    FUNCTION        reduce using rule 50 (subtype_decl -> SUBTYPE IDENTIFIER IS subtype_ind ; .)
INFO:root:    GENERIC         reduce using rule 50 (subtype_decl -> SUBTYPE IDENTIFIER IS subtype_ind ; .)
INFO:root:    IDENTIFIER      reduce using rule 50 (subtype_decl -> SUBTYPE IDENTIFIER IS subtype_ind ; .)
INFO:root:    BEGIN           reduce using rule 50 (subtype_decl -> SUBTYPE IDENTIFIER IS subtype_ind ; .)
INFO:root:    END             reduce using rule 50 (subtype_decl -> SUBTYPE IDENTIFIER IS subtype_ind ; .)
INFO:root:    PRIVATE         reduce using rule 50 (subtype_decl -> SUBTYPE IDENTIFIER IS subtype_ind ; .)
INFO:root:
INFO:root:
INFO:root:state 648
INFO:root:
INFO:root:    (185) aggregate -> ( expression WITH NuLL RECORD . )
INFO:root:
INFO:root:    )               shift and go to state 755
INFO:root:
INFO:root:
INFO:root:state 649
INFO:root:
INFO:root:    (184) aggregate -> ( expression WITH value_s ) .
INFO:root:
INFO:root:    *               reduce using rule 184 (aggregate -> ( expression WITH value_s ) .)
INFO:root:    /               reduce using rule 184 (aggregate -> ( expression WITH value_s ) .)
INFO:root:    MOD             reduce using rule 184 (aggregate -> ( expression WITH value_s ) .)
INFO:root:    REM             reduce using rule 184 (aggregate -> ( expression WITH value_s ) .)
INFO:root:    STARSTAR        reduce using rule 184 (aggregate -> ( expression WITH value_s ) .)
INFO:root:    =               reduce using rule 184 (aggregate -> ( expression WITH value_s ) .)
INFO:root:    NEQ             reduce using rule 184 (aggregate -> ( expression WITH value_s ) .)
INFO:root:    <               reduce using rule 184 (aggregate -> ( expression WITH value_s ) .)
INFO:root:    LEQ             reduce using rule 184 (aggregate -> ( expression WITH value_s ) .)
INFO:root:    >               reduce using rule 184 (aggregate -> ( expression WITH value_s ) .)
INFO:root:    GEQ             reduce using rule 184 (aggregate -> ( expression WITH value_s ) .)
INFO:root:    IN              reduce using rule 184 (aggregate -> ( expression WITH value_s ) .)
INFO:root:    NOT             reduce using rule 184 (aggregate -> ( expression WITH value_s ) .)
INFO:root:    +               reduce using rule 184 (aggregate -> ( expression WITH value_s ) .)
INFO:root:    -               reduce using rule 184 (aggregate -> ( expression WITH value_s ) .)
INFO:root:    &               reduce using rule 184 (aggregate -> ( expression WITH value_s ) .)
INFO:root:    AND             reduce using rule 184 (aggregate -> ( expression WITH value_s ) .)
INFO:root:    OR              reduce using rule 184 (aggregate -> ( expression WITH value_s ) .)
INFO:root:    XOR             reduce using rule 184 (aggregate -> ( expression WITH value_s ) .)
INFO:root:    RANGE           reduce using rule 184 (aggregate -> ( expression WITH value_s ) .)
INFO:root:    RENAMES         reduce using rule 184 (aggregate -> ( expression WITH value_s ) .)
INFO:root:    ASSIGN          reduce using rule 184 (aggregate -> ( expression WITH value_s ) .)
INFO:root:    ;               reduce using rule 184 (aggregate -> ( expression WITH value_s ) .)
INFO:root:    WITH            reduce using rule 184 (aggregate -> ( expression WITH value_s ) .)
INFO:root:    DOTDOT          reduce using rule 184 (aggregate -> ( expression WITH value_s ) .)
INFO:root:    IS              reduce using rule 184 (aggregate -> ( expression WITH value_s ) .)
INFO:root:    )               reduce using rule 184 (aggregate -> ( expression WITH value_s ) .)
INFO:root:    ,               reduce using rule 184 (aggregate -> ( expression WITH value_s ) .)
INFO:root:    ARROW           reduce using rule 184 (aggregate -> ( expression WITH value_s ) .)
INFO:root:    |               reduce using rule 184 (aggregate -> ( expression WITH value_s ) .)
INFO:root:    THEN            reduce using rule 184 (aggregate -> ( expression WITH value_s ) .)
INFO:root:    LOOP            reduce using rule 184 (aggregate -> ( expression WITH value_s ) .)
INFO:root:    DIGITS          reduce using rule 184 (aggregate -> ( expression WITH value_s ) .)
INFO:root:
INFO:root:
INFO:root:state 650
INFO:root:
INFO:root:    (166) value_s -> value_s , value .
INFO:root:
INFO:root:    )               reduce using rule 166 (value_s -> value_s , value .)
INFO:root:    ,               reduce using rule 166 (value_s -> value_s , value .)
INFO:root:
INFO:root:
INFO:root:state 651
INFO:root:
INFO:root:    (465) generic_formal -> WITH FUNCTION designator formal_part_opt RETURN name . subp_default ;
INFO:root:    (164) indexed_comp -> name . ( value_s )
INFO:root:    (171) selected_comp -> name . . simple_name
INFO:root:    (172) selected_comp -> name . . used_char
INFO:root:    (173) selected_comp -> name . . operator_symbol
INFO:root:    (174) selected_comp -> name . . ALL
INFO:root:    (175) attribute -> name . TICK attribute_id
INFO:root:    (472) subp_default -> .
INFO:root:    (473) subp_default -> . IS name
INFO:root:    (474) subp_default -> . IS BOX
INFO:root:
INFO:root:    (               shift and go to state 237
INFO:root:    .               shift and go to state 239
INFO:root:    TICK            shift and go to state 260
INFO:root:    ;               reduce using rule 472 (subp_default -> .)
INFO:root:    IS              shift and go to state 519
INFO:root:
INFO:root:    subp_default                   shift and go to state 756
INFO:root:
INFO:root:state 652
INFO:root:
INFO:root:    (464) generic_formal -> WITH PROCEDURE simple_name formal_part_opt subp_default ; .
INFO:root:
INFO:root:    PACKAGE         reduce using rule 464 (generic_formal -> WITH PROCEDURE simple_name formal_part_opt subp_default ; .)
INFO:root:    PROCEDURE       reduce using rule 464 (generic_formal -> WITH PROCEDURE simple_name formal_part_opt subp_default ; .)
INFO:root:    FUNCTION        reduce using rule 464 (generic_formal -> WITH PROCEDURE simple_name formal_part_opt subp_default ; .)
INFO:root:    TYPE            reduce using rule 464 (generic_formal -> WITH PROCEDURE simple_name formal_part_opt subp_default ; .)
INFO:root:    WITH            reduce using rule 464 (generic_formal -> WITH PROCEDURE simple_name formal_part_opt subp_default ; .)
INFO:root:    error           reduce using rule 464 (generic_formal -> WITH PROCEDURE simple_name formal_part_opt subp_default ; .)
INFO:root:    USE             reduce using rule 464 (generic_formal -> WITH PROCEDURE simple_name formal_part_opt subp_default ; .)
INFO:root:    IDENTIFIER      reduce using rule 464 (generic_formal -> WITH PROCEDURE simple_name formal_part_opt subp_default ; .)
INFO:root:
INFO:root:
INFO:root:state 653
INFO:root:
INFO:root:    (474) subp_default -> IS BOX .
INFO:root:
INFO:root:    ;               reduce using rule 474 (subp_default -> IS BOX .)
INFO:root:
INFO:root:
INFO:root:state 654
INFO:root:
INFO:root:    (473) subp_default -> IS name .
INFO:root:    (164) indexed_comp -> name . ( value_s )
INFO:root:    (171) selected_comp -> name . . simple_name
INFO:root:    (172) selected_comp -> name . . used_char
INFO:root:    (173) selected_comp -> name . . operator_symbol
INFO:root:    (174) selected_comp -> name . . ALL
INFO:root:    (175) attribute -> name . TICK attribute_id
INFO:root:
INFO:root:    ;               reduce using rule 473 (subp_default -> IS name .)
INFO:root:    (               shift and go to state 237
INFO:root:    .               shift and go to state 239
INFO:root:    TICK            shift and go to state 260
INFO:root:
INFO:root:
INFO:root:state 655
INFO:root:
INFO:root:    (466) generic_formal -> WITH PACKAGE simple_name IS NEW name . ( BOX ) ;
INFO:root:    (467) generic_formal -> WITH PACKAGE simple_name IS NEW name . ;
INFO:root:    (164) indexed_comp -> name . ( value_s )
INFO:root:    (171) selected_comp -> name . . simple_name
INFO:root:    (172) selected_comp -> name . . used_char
INFO:root:    (173) selected_comp -> name . . operator_symbol
INFO:root:    (174) selected_comp -> name . . ALL
INFO:root:    (175) attribute -> name . TICK attribute_id
INFO:root:
INFO:root:    (               shift and go to state 757
INFO:root:    ;               shift and go to state 758
INFO:root:    .               shift and go to state 239
INFO:root:    TICK            shift and go to state 260
INFO:root:
INFO:root:
INFO:root:state 656
INFO:root:
INFO:root:    (113) discrim_spec -> def_id_s : access_opt . mark init_opt
INFO:root:    (154) mark -> . simple_name
INFO:root:    (155) mark -> . mark TICK attribute_id
INFO:root:    (156) mark -> . mark . simple_name
INFO:root:    (157) simple_name -> . IDENTIFIER
INFO:root:
INFO:root:    IDENTIFIER      shift and go to state 33
INFO:root:
INFO:root:    mark                           shift and go to state 759
INFO:root:    simple_name                    shift and go to state 192
INFO:root:
INFO:root:state 657
INFO:root:
INFO:root:    (116) access_opt -> ACCESS .
INFO:root:
INFO:root:    IDENTIFIER      reduce using rule 116 (access_opt -> ACCESS .)
INFO:root:
INFO:root:
INFO:root:state 658
INFO:root:
INFO:root:    (112) discrim_spec_s -> discrim_spec_s ; discrim_spec .
INFO:root:
INFO:root:    )               reduce using rule 112 (discrim_spec_s -> discrim_spec_s ; discrim_spec .)
INFO:root:    ;               reduce using rule 112 (discrim_spec_s -> discrim_spec_s ; discrim_spec .)
INFO:root:
INFO:root:
INFO:root:state 659
INFO:root:
INFO:root:    (463) generic_formal -> TYPE simple_name generic_discrim_part_opt IS generic_type_def ; .
INFO:root:
INFO:root:    PACKAGE         reduce using rule 463 (generic_formal -> TYPE simple_name generic_discrim_part_opt IS generic_type_def ; .)
INFO:root:    PROCEDURE       reduce using rule 463 (generic_formal -> TYPE simple_name generic_discrim_part_opt IS generic_type_def ; .)
INFO:root:    FUNCTION        reduce using rule 463 (generic_formal -> TYPE simple_name generic_discrim_part_opt IS generic_type_def ; .)
INFO:root:    TYPE            reduce using rule 463 (generic_formal -> TYPE simple_name generic_discrim_part_opt IS generic_type_def ; .)
INFO:root:    WITH            reduce using rule 463 (generic_formal -> TYPE simple_name generic_discrim_part_opt IS generic_type_def ; .)
INFO:root:    error           reduce using rule 463 (generic_formal -> TYPE simple_name generic_discrim_part_opt IS generic_type_def ; .)
INFO:root:    USE             reduce using rule 463 (generic_formal -> TYPE simple_name generic_discrim_part_opt IS generic_type_def ; .)
INFO:root:    IDENTIFIER      reduce using rule 463 (generic_formal -> TYPE simple_name generic_discrim_part_opt IS generic_type_def ; .)
INFO:root:
INFO:root:
INFO:root:state 660
INFO:root:
INFO:root:    (475) generic_type_def -> ( BOX . )
INFO:root:
INFO:root:    )               shift and go to state 760
INFO:root:
INFO:root:
INFO:root:state 661
INFO:root:
INFO:root:    (100) tagged_opt -> ABSTRACT TAGGED .
INFO:root:
INFO:root:    LIMITED         reduce using rule 100 (tagged_opt -> ABSTRACT TAGGED .)
INFO:root:    PRIVATE         reduce using rule 100 (tagged_opt -> ABSTRACT TAGGED .)
INFO:root:    RECORD          reduce using rule 100 (tagged_opt -> ABSTRACT TAGGED .)
INFO:root:    NuLL            reduce using rule 100 (tagged_opt -> ABSTRACT TAGGED .)
INFO:root:
INFO:root:
INFO:root:state 662
INFO:root:
INFO:root:    (487) generic_derived_type -> ABSTRACT NEW . subtype_ind WITH PRIVATE
INFO:root:    (51) subtype_ind -> . name constraint
INFO:root:    (52) subtype_ind -> . name
INFO:root:    (149) name -> . simple_name
INFO:root:    (150) name -> . indexed_comp
INFO:root:    (151) name -> . selected_comp
INFO:root:    (152) name -> . attribute
INFO:root:    (153) name -> . operator_symbol
INFO:root:    (157) simple_name -> . IDENTIFIER
INFO:root:    (164) indexed_comp -> . name ( value_s )
INFO:root:    (171) selected_comp -> . name . simple_name
INFO:root:    (172) selected_comp -> . name . used_char
INFO:root:    (173) selected_comp -> . name . operator_symbol
INFO:root:    (174) selected_comp -> . name . ALL
INFO:root:    (175) attribute -> . name TICK attribute_id
INFO:root:    (163) operator_symbol -> . STRING
INFO:root:
INFO:root:    IDENTIFIER      shift and go to state 33
INFO:root:    STRING          shift and go to state 149
INFO:root:
INFO:root:    selected_comp                  shift and go to state 139
INFO:root:    simple_name                    shift and go to state 163
INFO:root:    indexed_comp                   shift and go to state 140
INFO:root:    attribute                      shift and go to state 134
INFO:root:    name                           shift and go to state 432
INFO:root:    operator_symbol                shift and go to state 133
INFO:root:    subtype_ind                    shift and go to state 761
INFO:root:
INFO:root:state 663
INFO:root:
INFO:root:    (477) generic_type_def -> MOD BOX .
INFO:root:
INFO:root:    ;               reduce using rule 477 (generic_type_def -> MOD BOX .)
INFO:root:
INFO:root:
INFO:root:state 664
INFO:root:
INFO:root:    (480) generic_type_def -> DIGITS BOX .
INFO:root:
INFO:root:    ;               reduce using rule 480 (generic_type_def -> DIGITS BOX .)
INFO:root:
INFO:root:
INFO:root:state 665
INFO:root:
INFO:root:    (128) access_type -> ACCESS subtype_ind .
INFO:root:
INFO:root:    ;               reduce using rule 128 (access_type -> ACCESS subtype_ind .)
INFO:root:
INFO:root:
INFO:root:state 666
INFO:root:
INFO:root:    (129) access_type -> ACCESS CONSTANT . subtype_ind
INFO:root:    (51) subtype_ind -> . name constraint
INFO:root:    (52) subtype_ind -> . name
INFO:root:    (149) name -> . simple_name
INFO:root:    (150) name -> . indexed_comp
INFO:root:    (151) name -> . selected_comp
INFO:root:    (152) name -> . attribute
INFO:root:    (153) name -> . operator_symbol
INFO:root:    (157) simple_name -> . IDENTIFIER
INFO:root:    (164) indexed_comp -> . name ( value_s )
INFO:root:    (171) selected_comp -> . name . simple_name
INFO:root:    (172) selected_comp -> . name . used_char
INFO:root:    (173) selected_comp -> . name . operator_symbol
INFO:root:    (174) selected_comp -> . name . ALL
INFO:root:    (175) attribute -> . name TICK attribute_id
INFO:root:    (163) operator_symbol -> . STRING
INFO:root:
INFO:root:    IDENTIFIER      shift and go to state 33
INFO:root:    STRING          shift and go to state 149
INFO:root:
INFO:root:    selected_comp                  shift and go to state 139
INFO:root:    simple_name                    shift and go to state 163
INFO:root:    indexed_comp                   shift and go to state 140
INFO:root:    attribute                      shift and go to state 134
INFO:root:    name                           shift and go to state 432
INFO:root:    operator_symbol                shift and go to state 133
INFO:root:    subtype_ind                    shift and go to state 762
INFO:root:
INFO:root:state 667
INFO:root:
INFO:root:    (130) access_type -> ACCESS ALL . subtype_ind
INFO:root:    (51) subtype_ind -> . name constraint
INFO:root:    (52) subtype_ind -> . name
INFO:root:    (149) name -> . simple_name
INFO:root:    (150) name -> . indexed_comp
INFO:root:    (151) name -> . selected_comp
INFO:root:    (152) name -> . attribute
INFO:root:    (153) name -> . operator_symbol
INFO:root:    (157) simple_name -> . IDENTIFIER
INFO:root:    (164) indexed_comp -> . name ( value_s )
INFO:root:    (171) selected_comp -> . name . simple_name
INFO:root:    (172) selected_comp -> . name . used_char
INFO:root:    (173) selected_comp -> . name . operator_symbol
INFO:root:    (174) selected_comp -> . name . ALL
INFO:root:    (175) attribute -> . name TICK attribute_id
INFO:root:    (163) operator_symbol -> . STRING
INFO:root:
INFO:root:    IDENTIFIER      shift and go to state 33
INFO:root:    STRING          shift and go to state 149
INFO:root:
INFO:root:    selected_comp                  shift and go to state 139
INFO:root:    simple_name                    shift and go to state 163
INFO:root:    indexed_comp                   shift and go to state 140
INFO:root:    attribute                      shift and go to state 134
INFO:root:    name                           shift and go to state 432
INFO:root:    operator_symbol                shift and go to state 133
INFO:root:    subtype_ind                    shift and go to state 763
INFO:root:
INFO:root:state 668
INFO:root:
INFO:root:    (476) generic_type_def -> RANGE BOX .
INFO:root:
INFO:root:    ;               reduce using rule 476 (generic_type_def -> RANGE BOX .)
INFO:root:
INFO:root:
INFO:root:state 669
INFO:root:
INFO:root:    (478) generic_type_def -> DELTA BOX .
INFO:root:    (479) generic_type_def -> DELTA BOX . DIGITS BOX
INFO:root:
INFO:root:    ;               reduce using rule 478 (generic_type_def -> DELTA BOX .)
INFO:root:    DIGITS          shift and go to state 764
INFO:root:
INFO:root:
INFO:root:state 670
INFO:root:
INFO:root:    (336) limited_opt -> LIMITED .
INFO:root:
INFO:root:    PRIVATE         reduce using rule 336 (limited_opt -> LIMITED .)
INFO:root:    RECORD          reduce using rule 336 (limited_opt -> LIMITED .)
INFO:root:    NuLL            reduce using rule 336 (limited_opt -> LIMITED .)
INFO:root:
INFO:root:
INFO:root:state 671
INFO:root:
INFO:root:    (334) private_type -> tagged_opt limited_opt . PRIVATE
INFO:root:
INFO:root:    PRIVATE         shift and go to state 765
INFO:root:
INFO:root:
INFO:root:state 672
INFO:root:
INFO:root:    (485) generic_derived_type -> NEW subtype_ind .
INFO:root:    (486) generic_derived_type -> NEW subtype_ind . WITH PRIVATE
INFO:root:
INFO:root:    ;               reduce using rule 485 (generic_derived_type -> NEW subtype_ind .)
INFO:root:    WITH            shift and go to state 766
INFO:root:
INFO:root:
INFO:root:state 673
INFO:root:
INFO:root:    (34) init_opt -> ASSIGN expression .
INFO:root:    (189) expression -> expression . logical relation
INFO:root:    (190) expression -> expression . short_circuit relation
INFO:root:    (191) logical -> . AND
INFO:root:    (192) logical -> . OR
INFO:root:    (193) logical -> . XOR
INFO:root:    (194) short_circuit -> . AND THEN
INFO:root:    (195) short_circuit -> . OR ELSE
INFO:root:
INFO:root:    )               reduce using rule 34 (init_opt -> ASSIGN expression .)
INFO:root:    ;               reduce using rule 34 (init_opt -> ASSIGN expression .)
INFO:root:    AND             shift and go to state 215
INFO:root:    OR              shift and go to state 216
INFO:root:    XOR             shift and go to state 214
INFO:root:
INFO:root:    short_circuit                  shift and go to state 212
INFO:root:    logical                        shift and go to state 213
INFO:root:
INFO:root:state 674
INFO:root:
INFO:root:    (356) task_body -> TASK BODY simple_name . IS decl_part block_body END id_opt ;
INFO:root:
INFO:root:    IS              shift and go to state 767
INFO:root:
INFO:root:
INFO:root:state 675
INFO:root:
INFO:root:    (373) prot_body -> PROTECTED BODY simple_name . IS prot_op_body_s END id_opt ;
INFO:root:
INFO:root:    IS              shift and go to state 768
INFO:root:
INFO:root:
INFO:root:state 676
INFO:root:
INFO:root:    (443) body_stub -> PACKAGE BODY compound_name IS . SEPARATE ;
INFO:root:
INFO:root:    SEPARATE        shift and go to state 552
INFO:root:
INFO:root:
INFO:root:state 677
INFO:root:
INFO:root:    (442) body_stub -> TASK BODY simple_name IS . SEPARATE ;
INFO:root:
INFO:root:    SEPARATE        shift and go to state 586
INFO:root:
INFO:root:
INFO:root:state 678
INFO:root:
INFO:root:    (445) body_stub -> PROTECTED BODY simple_name IS . SEPARATE ;
INFO:root:
INFO:root:    SEPARATE        shift and go to state 591
INFO:root:
INFO:root:
INFO:root:state 679
INFO:root:
INFO:root:    (330) c_id_opt -> compound_name .
INFO:root:    (159) compound_name -> compound_name . . simple_name
INFO:root:
INFO:root:    ;               reduce using rule 330 (c_id_opt -> compound_name .)
INFO:root:    .               shift and go to state 116
INFO:root:
INFO:root:
INFO:root:state 680
INFO:root:
INFO:root:    (326) pkg_spec -> PACKAGE compound_name IS decl_item_s private_part END c_id_opt .
INFO:root:
INFO:root:    ;               reduce using rule 326 (pkg_spec -> PACKAGE compound_name IS decl_item_s private_part END c_id_opt .)
INFO:root:
INFO:root:
INFO:root:state 681
INFO:root:
INFO:root:    (331) pkg_body -> PACKAGE BODY compound_name IS decl_part body_opt END . c_id_opt ;
INFO:root:    (329) c_id_opt -> .
INFO:root:    (330) c_id_opt -> . compound_name
INFO:root:    (158) compound_name -> . simple_name
INFO:root:    (159) compound_name -> . compound_name . simple_name
INFO:root:    (157) simple_name -> . IDENTIFIER
INFO:root:
INFO:root:    ;               reduce using rule 329 (c_id_opt -> .)
INFO:root:    IDENTIFIER      shift and go to state 33
INFO:root:
INFO:root:    simple_name                    shift and go to state 34
INFO:root:    compound_name                  shift and go to state 679
INFO:root:    c_id_opt                       shift and go to state 769
INFO:root:
INFO:root:state 682
INFO:root:
INFO:root:    (443) body_stub -> PACKAGE BODY compound_name IS SEPARATE ; .
INFO:root:
INFO:root:    error           reduce using rule 443 (body_stub -> PACKAGE BODY compound_name IS SEPARATE ; .)
INFO:root:    USE             reduce using rule 443 (body_stub -> PACKAGE BODY compound_name IS SEPARATE ; .)
INFO:root:    PRAGMA          reduce using rule 443 (body_stub -> PACKAGE BODY compound_name IS SEPARATE ; .)
INFO:root:    TYPE            reduce using rule 443 (body_stub -> PACKAGE BODY compound_name IS SEPARATE ; .)
INFO:root:    SUBTYPE         reduce using rule 443 (body_stub -> PACKAGE BODY compound_name IS SEPARATE ; .)
INFO:root:    TASK            reduce using rule 443 (body_stub -> PACKAGE BODY compound_name IS SEPARATE ; .)
INFO:root:    PACKAGE         reduce using rule 443 (body_stub -> PACKAGE BODY compound_name IS SEPARATE ; .)
INFO:root:    PROTECTED       reduce using rule 443 (body_stub -> PACKAGE BODY compound_name IS SEPARATE ; .)
INFO:root:    FOR             reduce using rule 443 (body_stub -> PACKAGE BODY compound_name IS SEPARATE ; .)
INFO:root:    PROCEDURE       reduce using rule 443 (body_stub -> PACKAGE BODY compound_name IS SEPARATE ; .)
INFO:root:    FUNCTION        reduce using rule 443 (body_stub -> PACKAGE BODY compound_name IS SEPARATE ; .)
INFO:root:    GENERIC         reduce using rule 443 (body_stub -> PACKAGE BODY compound_name IS SEPARATE ; .)
INFO:root:    IDENTIFIER      reduce using rule 443 (body_stub -> PACKAGE BODY compound_name IS SEPARATE ; .)
INFO:root:    PRIVATE         reduce using rule 443 (body_stub -> PACKAGE BODY compound_name IS SEPARATE ; .)
INFO:root:    END             reduce using rule 443 (body_stub -> PACKAGE BODY compound_name IS SEPARATE ; .)
INFO:root:    BEGIN           reduce using rule 443 (body_stub -> PACKAGE BODY compound_name IS SEPARATE ; .)
INFO:root:
INFO:root:
INFO:root:state 683
INFO:root:
INFO:root:    (56) derived_type -> NEW subtype_ind .
INFO:root:    (57) derived_type -> NEW subtype_ind . WITH PRIVATE
INFO:root:    (58) derived_type -> NEW subtype_ind . WITH record_def
INFO:root:
INFO:root:    ;               reduce using rule 56 (derived_type -> NEW subtype_ind .)
INFO:root:    WITH            shift and go to state 770
INFO:root:
INFO:root:
INFO:root:state 684
INFO:root:
INFO:root:    (69) integer_type -> MOD expression .
INFO:root:    (189) expression -> expression . logical relation
INFO:root:    (190) expression -> expression . short_circuit relation
INFO:root:    (191) logical -> . AND
INFO:root:    (192) logical -> . OR
INFO:root:    (193) logical -> . XOR
INFO:root:    (194) short_circuit -> . AND THEN
INFO:root:    (195) short_circuit -> . OR ELSE
INFO:root:
INFO:root:    ;               reduce using rule 69 (integer_type -> MOD expression .)
INFO:root:    AND             shift and go to state 215
INFO:root:    OR              shift and go to state 216
INFO:root:    XOR             shift and go to state 214
INFO:root:
INFO:root:    short_circuit                  shift and go to state 212
INFO:root:    logical                        shift and go to state 213
INFO:root:
INFO:root:state 685
INFO:root:
INFO:root:    (66) enum_id -> IDENTIFIER .
INFO:root:
INFO:root:    )               reduce using rule 66 (enum_id -> IDENTIFIER .)
INFO:root:    ,               reduce using rule 66 (enum_id -> IDENTIFIER .)
INFO:root:
INFO:root:
INFO:root:state 686
INFO:root:
INFO:root:    (63) enumeration_type -> ( enum_id_s . )
INFO:root:    (65) enum_id_s -> enum_id_s . , enum_id
INFO:root:
INFO:root:    )               shift and go to state 771
INFO:root:    ,               shift and go to state 772
INFO:root:
INFO:root:
INFO:root:state 687
INFO:root:
INFO:root:    (67) enum_id -> CHAR .
INFO:root:
INFO:root:    )               reduce using rule 67 (enum_id -> CHAR .)
INFO:root:    ,               reduce using rule 67 (enum_id -> CHAR .)
INFO:root:
INFO:root:
INFO:root:state 688
INFO:root:
INFO:root:    (64) enum_id_s -> enum_id .
INFO:root:
INFO:root:    )               reduce using rule 64 (enum_id_s -> enum_id .)
INFO:root:    ,               reduce using rule 64 (enum_id_s -> enum_id .)
INFO:root:
INFO:root:
INFO:root:state 689
INFO:root:
INFO:root:    (95) record_type -> tagged_opt limited_opt . record_def
INFO:root:    (334) private_type -> tagged_opt limited_opt . PRIVATE
INFO:root:    (96) record_def -> . RECORD pragma_s comp_list END RECORD
INFO:root:    (97) record_def -> . NuLL RECORD
INFO:root:
INFO:root:    PRIVATE         shift and go to state 765
INFO:root:    RECORD          shift and go to state 775
INFO:root:    NuLL            shift and go to state 774
INFO:root:
INFO:root:    record_def                     shift and go to state 773
INFO:root:
INFO:root:state 690
INFO:root:
INFO:root:    (59) derived_type -> ABSTRACT NEW . subtype_ind WITH PRIVATE
INFO:root:    (60) derived_type -> ABSTRACT NEW . subtype_ind WITH record_def
INFO:root:    (51) subtype_ind -> . name constraint
INFO:root:    (52) subtype_ind -> . name
INFO:root:    (149) name -> . simple_name
INFO:root:    (150) name -> . indexed_comp
INFO:root:    (151) name -> . selected_comp
INFO:root:    (152) name -> . attribute
INFO:root:    (153) name -> . operator_symbol
INFO:root:    (157) simple_name -> . IDENTIFIER
INFO:root:    (164) indexed_comp -> . name ( value_s )
INFO:root:    (171) selected_comp -> . name . simple_name
INFO:root:    (172) selected_comp -> . name . used_char
INFO:root:    (173) selected_comp -> . name . operator_symbol
INFO:root:    (174) selected_comp -> . name . ALL
INFO:root:    (175) attribute -> . name TICK attribute_id
INFO:root:    (163) operator_symbol -> . STRING
INFO:root:
INFO:root:    IDENTIFIER      shift and go to state 33
INFO:root:    STRING          shift and go to state 149
INFO:root:
INFO:root:    selected_comp                  shift and go to state 139
INFO:root:    indexed_comp                   shift and go to state 140
INFO:root:    attribute                      shift and go to state 134
INFO:root:    name                           shift and go to state 432
INFO:root:    operator_symbol                shift and go to state 133
INFO:root:    subtype_ind                    shift and go to state 776
INFO:root:    simple_name                    shift and go to state 163
INFO:root:
INFO:root:state 691
INFO:root:
INFO:root:    (75) float_type -> DIGITS expression . range_spec_opt
INFO:root:    (189) expression -> expression . logical relation
INFO:root:    (190) expression -> expression . short_circuit relation
INFO:root:    (71) range_spec_opt -> .
INFO:root:    (72) range_spec_opt -> . range_spec
INFO:root:    (191) logical -> . AND
INFO:root:    (192) logical -> . OR
INFO:root:    (193) logical -> . XOR
INFO:root:    (194) short_circuit -> . AND THEN
INFO:root:    (195) short_circuit -> . OR ELSE
INFO:root:    (70) range_spec -> . range_constraint
INFO:root:    (61) range_constraint -> . RANGE range
INFO:root:
INFO:root:    ;               reduce using rule 71 (range_spec_opt -> .)
INFO:root:    AND             shift and go to state 215
INFO:root:    OR              shift and go to state 216
INFO:root:    XOR             shift and go to state 214
INFO:root:    RANGE           shift and go to state 358
INFO:root:
INFO:root:    range_spec                     shift and go to state 777
INFO:root:    short_circuit                  shift and go to state 212
INFO:root:    logical                        shift and go to state 213
INFO:root:    range_constraint               shift and go to state 570
INFO:root:    range_spec_opt                 shift and go to state 778
INFO:root:
INFO:root:state 692
INFO:root:
INFO:root:    (76) fixed_type -> DELTA expression . range_spec
INFO:root:    (77) fixed_type -> DELTA expression . DIGITS expression range_spec_opt
INFO:root:    (189) expression -> expression . logical relation
INFO:root:    (190) expression -> expression . short_circuit relation
INFO:root:    (70) range_spec -> . range_constraint
INFO:root:    (191) logical -> . AND
INFO:root:    (192) logical -> . OR
INFO:root:    (193) logical -> . XOR
INFO:root:    (194) short_circuit -> . AND THEN
INFO:root:    (195) short_circuit -> . OR ELSE
INFO:root:    (61) range_constraint -> . RANGE range
INFO:root:
INFO:root:    DIGITS          shift and go to state 780
INFO:root:    AND             shift and go to state 215
INFO:root:    OR              shift and go to state 216
INFO:root:    XOR             shift and go to state 214
INFO:root:    RANGE           shift and go to state 358
INFO:root:
INFO:root:    range_spec                     shift and go to state 779
INFO:root:    short_circuit                  shift and go to state 212
INFO:root:    logical                        shift and go to state 213
INFO:root:    range_constraint               shift and go to state 570
INFO:root:
INFO:root:state 693
INFO:root:
INFO:root:    (88) iter_index_constraint -> ( iter_discrete_range_s . )
INFO:root:    (90) iter_discrete_range_s -> iter_discrete_range_s . , discrete_range
INFO:root:
INFO:root:    )               shift and go to state 781
INFO:root:    ,               shift and go to state 782
INFO:root:
INFO:root:
INFO:root:state 694
INFO:root:
INFO:root:    (80) unconstr_array_type -> ARRAY ( index_s . ) OF component_subtype_def
INFO:root:    (86) index_s -> index_s . , index
INFO:root:
INFO:root:    )               shift and go to state 783
INFO:root:    ,               shift and go to state 784
INFO:root:
INFO:root:
INFO:root:state 695
INFO:root:
INFO:root:    (87) index -> name . RANGE BOX
INFO:root:    (91) discrete_range -> name . range_constr_opt
INFO:root:    (164) indexed_comp -> name . ( value_s )
INFO:root:    (171) selected_comp -> name . . simple_name
INFO:root:    (172) selected_comp -> name . . used_char
INFO:root:    (173) selected_comp -> name . . operator_symbol
INFO:root:    (174) selected_comp -> name . . ALL
INFO:root:    (175) attribute -> name . TICK attribute_id
INFO:root:    (227) primary -> name .
INFO:root:    (233) qualified -> name . TICK parenthesized_primary
INFO:root:    (93) range_constr_opt -> .
INFO:root:    (94) range_constr_opt -> . range_constraint
INFO:root:    (61) range_constraint -> . RANGE range
INFO:root:
INFO:root:    RANGE           shift and go to state 785
INFO:root:    (               shift and go to state 237
INFO:root:    .               shift and go to state 239
INFO:root:    TICK            shift and go to state 359
INFO:root:    *               reduce using rule 227 (primary -> name .)
INFO:root:    /               reduce using rule 227 (primary -> name .)
INFO:root:    MOD             reduce using rule 227 (primary -> name .)
INFO:root:    REM             reduce using rule 227 (primary -> name .)
INFO:root:    STARSTAR        reduce using rule 227 (primary -> name .)
INFO:root:    DOTDOT          reduce using rule 227 (primary -> name .)
INFO:root:    +               reduce using rule 227 (primary -> name .)
INFO:root:    -               reduce using rule 227 (primary -> name .)
INFO:root:    &               reduce using rule 227 (primary -> name .)
INFO:root:    )               reduce using rule 93 (range_constr_opt -> .)
INFO:root:    ,               reduce using rule 93 (range_constr_opt -> .)
INFO:root:
INFO:root:    range_constr_opt               shift and go to state 787
INFO:root:    range_constraint               shift and go to state 786
INFO:root:
INFO:root:state 696
INFO:root:
INFO:root:    (85) index_s -> index .
INFO:root:
INFO:root:    )               reduce using rule 85 (index_s -> index .)
INFO:root:    ,               reduce using rule 85 (index_s -> index .)
INFO:root:
INFO:root:
INFO:root:state 697
INFO:root:
INFO:root:    (89) iter_discrete_range_s -> discrete_range .
INFO:root:
INFO:root:    )               reduce using rule 89 (iter_discrete_range_s -> discrete_range .)
INFO:root:    ,               reduce using rule 89 (iter_discrete_range_s -> discrete_range .)
INFO:root:
INFO:root:
INFO:root:state 698
INFO:root:
INFO:root:    (92) discrete_range -> range .
INFO:root:
INFO:root:    )               reduce using rule 92 (discrete_range -> range .)
INFO:root:    ,               reduce using rule 92 (discrete_range -> range .)
INFO:root:    LOOP            reduce using rule 92 (discrete_range -> range .)
INFO:root:
INFO:root:
INFO:root:state 699
INFO:root:
INFO:root:    (81) constr_array_type -> ARRAY iter_index_constraint OF . component_subtype_def
INFO:root:    (82) component_subtype_def -> . aliased_opt subtype_ind
INFO:root:    (83) aliased_opt -> .
INFO:root:    (84) aliased_opt -> . ALIASED
INFO:root:
INFO:root:    IDENTIFIER      reduce using rule 83 (aliased_opt -> .)
INFO:root:    STRING          reduce using rule 83 (aliased_opt -> .)
INFO:root:    ALIASED         shift and go to state 788
INFO:root:
INFO:root:    component_subtype_def          shift and go to state 789
INFO:root:    aliased_opt                    shift and go to state 790
INFO:root:
INFO:root:state 700
INFO:root:
INFO:root:    (55) decimal_digits_constraint -> DIGITS expression . range_constr_opt
INFO:root:    (189) expression -> expression . logical relation
INFO:root:    (190) expression -> expression . short_circuit relation
INFO:root:    (93) range_constr_opt -> .
INFO:root:    (94) range_constr_opt -> . range_constraint
INFO:root:    (191) logical -> . AND
INFO:root:    (192) logical -> . OR
INFO:root:    (193) logical -> . XOR
INFO:root:    (194) short_circuit -> . AND THEN
INFO:root:    (195) short_circuit -> . OR ELSE
INFO:root:    (61) range_constraint -> . RANGE range
INFO:root:
INFO:root:    RENAMES         reduce using rule 93 (range_constr_opt -> .)
INFO:root:    ASSIGN          reduce using rule 93 (range_constr_opt -> .)
INFO:root:    ;               reduce using rule 93 (range_constr_opt -> .)
INFO:root:    WITH            reduce using rule 93 (range_constr_opt -> .)
INFO:root:    AND             shift and go to state 215
INFO:root:    OR              shift and go to state 216
INFO:root:    XOR             shift and go to state 214
INFO:root:    RANGE           shift and go to state 358
INFO:root:
INFO:root:    short_circuit                  shift and go to state 212
INFO:root:    range_constr_opt               shift and go to state 791
INFO:root:    logical                        shift and go to state 213
INFO:root:    range_constraint               shift and go to state 786
INFO:root:
INFO:root:state 701
INFO:root:
INFO:root:    (341) rename_decl -> def_id_s : object_qualifier_opt subtype_ind renames ; .
INFO:root:
INFO:root:    PACKAGE         reduce using rule 341 (rename_decl -> def_id_s : object_qualifier_opt subtype_ind renames ; .)
INFO:root:    TASK            reduce using rule 341 (rename_decl -> def_id_s : object_qualifier_opt subtype_ind renames ; .)
INFO:root:    PROTECTED       reduce using rule 341 (rename_decl -> def_id_s : object_qualifier_opt subtype_ind renames ; .)
INFO:root:    error           reduce using rule 341 (rename_decl -> def_id_s : object_qualifier_opt subtype_ind renames ; .)
INFO:root:    USE             reduce using rule 341 (rename_decl -> def_id_s : object_qualifier_opt subtype_ind renames ; .)
INFO:root:    PRAGMA          reduce using rule 341 (rename_decl -> def_id_s : object_qualifier_opt subtype_ind renames ; .)
INFO:root:    TYPE            reduce using rule 341 (rename_decl -> def_id_s : object_qualifier_opt subtype_ind renames ; .)
INFO:root:    SUBTYPE         reduce using rule 341 (rename_decl -> def_id_s : object_qualifier_opt subtype_ind renames ; .)
INFO:root:    FOR             reduce using rule 341 (rename_decl -> def_id_s : object_qualifier_opt subtype_ind renames ; .)
INFO:root:    PROCEDURE       reduce using rule 341 (rename_decl -> def_id_s : object_qualifier_opt subtype_ind renames ; .)
INFO:root:    FUNCTION        reduce using rule 341 (rename_decl -> def_id_s : object_qualifier_opt subtype_ind renames ; .)
INFO:root:    GENERIC         reduce using rule 341 (rename_decl -> def_id_s : object_qualifier_opt subtype_ind renames ; .)
INFO:root:    IDENTIFIER      reduce using rule 341 (rename_decl -> def_id_s : object_qualifier_opt subtype_ind renames ; .)
INFO:root:    BEGIN           reduce using rule 341 (rename_decl -> def_id_s : object_qualifier_opt subtype_ind renames ; .)
INFO:root:    END             reduce using rule 341 (rename_decl -> def_id_s : object_qualifier_opt subtype_ind renames ; .)
INFO:root:    PRIVATE         reduce using rule 341 (rename_decl -> def_id_s : object_qualifier_opt subtype_ind renames ; .)
INFO:root:
INFO:root:
INFO:root:state 702
INFO:root:
INFO:root:    (23) object_decl -> def_id_s : object_qualifier_opt object_subtype_def init_opt ; .
INFO:root:
INFO:root:    PACKAGE         reduce using rule 23 (object_decl -> def_id_s : object_qualifier_opt object_subtype_def init_opt ; .)
INFO:root:    TASK            reduce using rule 23 (object_decl -> def_id_s : object_qualifier_opt object_subtype_def init_opt ; .)
INFO:root:    PROTECTED       reduce using rule 23 (object_decl -> def_id_s : object_qualifier_opt object_subtype_def init_opt ; .)
INFO:root:    error           reduce using rule 23 (object_decl -> def_id_s : object_qualifier_opt object_subtype_def init_opt ; .)
INFO:root:    USE             reduce using rule 23 (object_decl -> def_id_s : object_qualifier_opt object_subtype_def init_opt ; .)
INFO:root:    PRAGMA          reduce using rule 23 (object_decl -> def_id_s : object_qualifier_opt object_subtype_def init_opt ; .)
INFO:root:    TYPE            reduce using rule 23 (object_decl -> def_id_s : object_qualifier_opt object_subtype_def init_opt ; .)
INFO:root:    SUBTYPE         reduce using rule 23 (object_decl -> def_id_s : object_qualifier_opt object_subtype_def init_opt ; .)
INFO:root:    FOR             reduce using rule 23 (object_decl -> def_id_s : object_qualifier_opt object_subtype_def init_opt ; .)
INFO:root:    PROCEDURE       reduce using rule 23 (object_decl -> def_id_s : object_qualifier_opt object_subtype_def init_opt ; .)
INFO:root:    FUNCTION        reduce using rule 23 (object_decl -> def_id_s : object_qualifier_opt object_subtype_def init_opt ; .)
INFO:root:    GENERIC         reduce using rule 23 (object_decl -> def_id_s : object_qualifier_opt object_subtype_def init_opt ; .)
INFO:root:    IDENTIFIER      reduce using rule 23 (object_decl -> def_id_s : object_qualifier_opt object_subtype_def init_opt ; .)
INFO:root:    BEGIN           reduce using rule 23 (object_decl -> def_id_s : object_qualifier_opt object_subtype_def init_opt ; .)
INFO:root:    PRIVATE         reduce using rule 23 (object_decl -> def_id_s : object_qualifier_opt object_subtype_def init_opt ; .)
INFO:root:    END             reduce using rule 23 (object_decl -> def_id_s : object_qualifier_opt object_subtype_def init_opt ; .)
INFO:root:
INFO:root:
INFO:root:state 703
INFO:root:
INFO:root:    (35) number_decl -> def_id_s : CONSTANT ASSIGN expression ; .
INFO:root:
INFO:root:    PACKAGE         reduce using rule 35 (number_decl -> def_id_s : CONSTANT ASSIGN expression ; .)
INFO:root:    TASK            reduce using rule 35 (number_decl -> def_id_s : CONSTANT ASSIGN expression ; .)
INFO:root:    PROTECTED       reduce using rule 35 (number_decl -> def_id_s : CONSTANT ASSIGN expression ; .)
INFO:root:    error           reduce using rule 35 (number_decl -> def_id_s : CONSTANT ASSIGN expression ; .)
INFO:root:    USE             reduce using rule 35 (number_decl -> def_id_s : CONSTANT ASSIGN expression ; .)
INFO:root:    PRAGMA          reduce using rule 35 (number_decl -> def_id_s : CONSTANT ASSIGN expression ; .)
INFO:root:    TYPE            reduce using rule 35 (number_decl -> def_id_s : CONSTANT ASSIGN expression ; .)
INFO:root:    SUBTYPE         reduce using rule 35 (number_decl -> def_id_s : CONSTANT ASSIGN expression ; .)
INFO:root:    FOR             reduce using rule 35 (number_decl -> def_id_s : CONSTANT ASSIGN expression ; .)
INFO:root:    PROCEDURE       reduce using rule 35 (number_decl -> def_id_s : CONSTANT ASSIGN expression ; .)
INFO:root:    FUNCTION        reduce using rule 35 (number_decl -> def_id_s : CONSTANT ASSIGN expression ; .)
INFO:root:    GENERIC         reduce using rule 35 (number_decl -> def_id_s : CONSTANT ASSIGN expression ; .)
INFO:root:    IDENTIFIER      reduce using rule 35 (number_decl -> def_id_s : CONSTANT ASSIGN expression ; .)
INFO:root:    BEGIN           reduce using rule 35 (number_decl -> def_id_s : CONSTANT ASSIGN expression ; .)
INFO:root:    END             reduce using rule 35 (number_decl -> def_id_s : CONSTANT ASSIGN expression ; .)
INFO:root:    PRIVATE         reduce using rule 35 (number_decl -> def_id_s : CONSTANT ASSIGN expression ; .)
INFO:root:
INFO:root:
INFO:root:state 704
INFO:root:
INFO:root:    (442) body_stub -> TASK BODY simple_name IS SEPARATE ; .
INFO:root:
INFO:root:    error           reduce using rule 442 (body_stub -> TASK BODY simple_name IS SEPARATE ; .)
INFO:root:    USE             reduce using rule 442 (body_stub -> TASK BODY simple_name IS SEPARATE ; .)
INFO:root:    PRAGMA          reduce using rule 442 (body_stub -> TASK BODY simple_name IS SEPARATE ; .)
INFO:root:    TYPE            reduce using rule 442 (body_stub -> TASK BODY simple_name IS SEPARATE ; .)
INFO:root:    SUBTYPE         reduce using rule 442 (body_stub -> TASK BODY simple_name IS SEPARATE ; .)
INFO:root:    TASK            reduce using rule 442 (body_stub -> TASK BODY simple_name IS SEPARATE ; .)
INFO:root:    PACKAGE         reduce using rule 442 (body_stub -> TASK BODY simple_name IS SEPARATE ; .)
INFO:root:    PROTECTED       reduce using rule 442 (body_stub -> TASK BODY simple_name IS SEPARATE ; .)
INFO:root:    FOR             reduce using rule 442 (body_stub -> TASK BODY simple_name IS SEPARATE ; .)
INFO:root:    PROCEDURE       reduce using rule 442 (body_stub -> TASK BODY simple_name IS SEPARATE ; .)
INFO:root:    FUNCTION        reduce using rule 442 (body_stub -> TASK BODY simple_name IS SEPARATE ; .)
INFO:root:    GENERIC         reduce using rule 442 (body_stub -> TASK BODY simple_name IS SEPARATE ; .)
INFO:root:    IDENTIFIER      reduce using rule 442 (body_stub -> TASK BODY simple_name IS SEPARATE ; .)
INFO:root:    PRIVATE         reduce using rule 442 (body_stub -> TASK BODY simple_name IS SEPARATE ; .)
INFO:root:    END             reduce using rule 442 (body_stub -> TASK BODY simple_name IS SEPARATE ; .)
INFO:root:    BEGIN           reduce using rule 442 (body_stub -> TASK BODY simple_name IS SEPARATE ; .)
INFO:root:
INFO:root:
INFO:root:state 705
INFO:root:
INFO:root:    (356) task_body -> TASK BODY simple_name IS decl_part block_body . END id_opt ;
INFO:root:
INFO:root:    END             shift and go to state 792
INFO:root:
INFO:root:
INFO:root:state 706
INFO:root:
INFO:root:    (380) entry_decl_s -> entry_decl_s entry_decl pragma_s .
INFO:root:    (9) pragma_s -> pragma_s . pragma
INFO:root:    (2) pragma -> . PRAGMA IDENTIFIER ;
INFO:root:    (3) pragma -> . PRAGMA simple_name ( pragma_arg_s ) ;
INFO:root:
INFO:root:    ENTRY           reduce using rule 380 (entry_decl_s -> entry_decl_s entry_decl pragma_s .)
INFO:root:    FOR             reduce using rule 380 (entry_decl_s -> entry_decl_s entry_decl pragma_s .)
INFO:root:    END             reduce using rule 380 (entry_decl_s -> entry_decl_s entry_decl pragma_s .)
INFO:root:    PRIVATE         reduce using rule 380 (entry_decl_s -> entry_decl_s entry_decl pragma_s .)
INFO:root:    PRAGMA          shift and go to state 2
INFO:root:
INFO:root:    pragma                         shift and go to state 43
INFO:root:
INFO:root:state 707
INFO:root:
INFO:root:    (355) task_private_opt -> PRIVATE . entry_decl_s rep_spec_s
INFO:root:    (379) entry_decl_s -> . pragma_s
INFO:root:    (380) entry_decl_s -> . entry_decl_s entry_decl pragma_s
INFO:root:    (8) pragma_s -> .
INFO:root:    (9) pragma_s -> . pragma_s pragma
INFO:root:
INFO:root:    PRAGMA          reduce using rule 8 (pragma_s -> .)
INFO:root:    ENTRY           reduce using rule 8 (pragma_s -> .)
INFO:root:    FOR             reduce using rule 8 (pragma_s -> .)
INFO:root:    END             reduce using rule 8 (pragma_s -> .)
INFO:root:
INFO:root:    pragma_s                       shift and go to state 445
INFO:root:    entry_decl_s                   shift and go to state 793
INFO:root:
INFO:root:state 708
INFO:root:
INFO:root:    (388) rep_spec_s -> rep_spec_s rep_spec . pragma_s
INFO:root:    (8) pragma_s -> .
INFO:root:    (9) pragma_s -> . pragma_s pragma
INFO:root:
INFO:root:    PRAGMA          reduce using rule 8 (pragma_s -> .)
INFO:root:    PRIVATE         reduce using rule 8 (pragma_s -> .)
INFO:root:    FOR             reduce using rule 8 (pragma_s -> .)
INFO:root:    END             reduce using rule 8 (pragma_s -> .)
INFO:root:
INFO:root:    pragma_s                       shift and go to state 794
INFO:root:
INFO:root:state 709
INFO:root:
INFO:root:    (353) task_def -> IS entry_decl_s rep_spec_s task_private_opt . END id_opt
INFO:root:
INFO:root:    END             shift and go to state 795
INFO:root:
INFO:root:
INFO:root:state 710
INFO:root:
INFO:root:    (381) entry_decl -> ENTRY IDENTIFIER . formal_part_opt ;
INFO:root:    (382) entry_decl -> ENTRY IDENTIFIER . ( discrete_range ) formal_part_opt ;
INFO:root:    (309) formal_part_opt -> .
INFO:root:    (310) formal_part_opt -> . formal_part
INFO:root:    (311) formal_part -> . ( param_s )
INFO:root:
INFO:root:    (               shift and go to state 797
INFO:root:    ;               reduce using rule 309 (formal_part_opt -> .)
INFO:root:
INFO:root:    formal_part_opt                shift and go to state 796
INFO:root:    formal_part                    shift and go to state 152
INFO:root:
INFO:root:state 711
INFO:root:
INFO:root:    (445) body_stub -> PROTECTED BODY simple_name IS SEPARATE ; .
INFO:root:
INFO:root:    error           reduce using rule 445 (body_stub -> PROTECTED BODY simple_name IS SEPARATE ; .)
INFO:root:    USE             reduce using rule 445 (body_stub -> PROTECTED BODY simple_name IS SEPARATE ; .)
INFO:root:    PRAGMA          reduce using rule 445 (body_stub -> PROTECTED BODY simple_name IS SEPARATE ; .)
INFO:root:    TYPE            reduce using rule 445 (body_stub -> PROTECTED BODY simple_name IS SEPARATE ; .)
INFO:root:    SUBTYPE         reduce using rule 445 (body_stub -> PROTECTED BODY simple_name IS SEPARATE ; .)
INFO:root:    TASK            reduce using rule 445 (body_stub -> PROTECTED BODY simple_name IS SEPARATE ; .)
INFO:root:    PACKAGE         reduce using rule 445 (body_stub -> PROTECTED BODY simple_name IS SEPARATE ; .)
INFO:root:    PROTECTED       reduce using rule 445 (body_stub -> PROTECTED BODY simple_name IS SEPARATE ; .)
INFO:root:    FOR             reduce using rule 445 (body_stub -> PROTECTED BODY simple_name IS SEPARATE ; .)
INFO:root:    PROCEDURE       reduce using rule 445 (body_stub -> PROTECTED BODY simple_name IS SEPARATE ; .)
INFO:root:    FUNCTION        reduce using rule 445 (body_stub -> PROTECTED BODY simple_name IS SEPARATE ; .)
INFO:root:    GENERIC         reduce using rule 445 (body_stub -> PROTECTED BODY simple_name IS SEPARATE ; .)
INFO:root:    IDENTIFIER      reduce using rule 445 (body_stub -> PROTECTED BODY simple_name IS SEPARATE ; .)
INFO:root:    PRIVATE         reduce using rule 445 (body_stub -> PROTECTED BODY simple_name IS SEPARATE ; .)
INFO:root:    END             reduce using rule 445 (body_stub -> PROTECTED BODY simple_name IS SEPARATE ; .)
INFO:root:    BEGIN           reduce using rule 445 (body_stub -> PROTECTED BODY simple_name IS SEPARATE ; .)
INFO:root:
INFO:root:
INFO:root:state 712
INFO:root:
INFO:root:    (376) prot_op_body -> entry_body .
INFO:root:
INFO:root:    PRAGMA          reduce using rule 376 (prot_op_body -> entry_body .)
INFO:root:    END             reduce using rule 376 (prot_op_body -> entry_body .)
INFO:root:    ENTRY           reduce using rule 376 (prot_op_body -> entry_body .)
INFO:root:    PROCEDURE       reduce using rule 376 (prot_op_body -> entry_body .)
INFO:root:    FUNCTION        reduce using rule 376 (prot_op_body -> entry_body .)
INFO:root:
INFO:root:
INFO:root:state 713
INFO:root:
INFO:root:    (373) prot_body -> PROTECTED BODY simple_name IS prot_op_body_s END . id_opt ;
INFO:root:    (285) id_opt -> .
INFO:root:    (286) id_opt -> . designator
INFO:root:    (307) designator -> . compound_name
INFO:root:    (308) designator -> . STRING
INFO:root:    (158) compound_name -> . simple_name
INFO:root:    (159) compound_name -> . compound_name . simple_name
INFO:root:    (157) simple_name -> . IDENTIFIER
INFO:root:
INFO:root:    ;               reduce using rule 285 (id_opt -> .)
INFO:root:    STRING          shift and go to state 62
INFO:root:    IDENTIFIER      shift and go to state 33
INFO:root:
INFO:root:    designator                     shift and go to state 455
INFO:root:    id_opt                         shift and go to state 798
INFO:root:    compound_name                  shift and go to state 64
INFO:root:    simple_name                    shift and go to state 34
INFO:root:
INFO:root:state 714
INFO:root:
INFO:root:    (378) prot_op_body -> subprog_spec . ;
INFO:root:    (321) subprog_spec_is_push -> subprog_spec . IS
INFO:root:
INFO:root:    ;               shift and go to state 799
INFO:root:    IS              shift and go to state 542
INFO:root:
INFO:root:
INFO:root:state 715
INFO:root:
INFO:root:    (383) entry_body -> ENTRY . IDENTIFIER formal_part_opt WHEN condition entry_body_part
INFO:root:    (384) entry_body -> ENTRY . IDENTIFIER ( iter_part discrete_range ) formal_part_opt WHEN condition entry_body_part
INFO:root:
INFO:root:    IDENTIFIER      shift and go to state 800
INFO:root:
INFO:root:
INFO:root:state 716
INFO:root:
INFO:root:    (377) prot_op_body -> subprog_body .
INFO:root:
INFO:root:    PRAGMA          reduce using rule 377 (prot_op_body -> subprog_body .)
INFO:root:    END             reduce using rule 377 (prot_op_body -> subprog_body .)
INFO:root:    ENTRY           reduce using rule 377 (prot_op_body -> subprog_body .)
INFO:root:    PROCEDURE       reduce using rule 377 (prot_op_body -> subprog_body .)
INFO:root:    FUNCTION        reduce using rule 377 (prot_op_body -> subprog_body .)
INFO:root:
INFO:root:
INFO:root:state 717
INFO:root:
INFO:root:    (375) prot_op_body_s -> prot_op_body_s prot_op_body . pragma_s
INFO:root:    (8) pragma_s -> .
INFO:root:    (9) pragma_s -> . pragma_s pragma
INFO:root:
INFO:root:    PRAGMA          reduce using rule 8 (pragma_s -> .)
INFO:root:    END             reduce using rule 8 (pragma_s -> .)
INFO:root:    ENTRY           reduce using rule 8 (pragma_s -> .)
INFO:root:    PROCEDURE       reduce using rule 8 (pragma_s -> .)
INFO:root:    FUNCTION        reduce using rule 8 (pragma_s -> .)
INFO:root:
INFO:root:    pragma_s                       shift and go to state 801
INFO:root:
INFO:root:state 718
INFO:root:
INFO:root:    (366) prot_op_decl -> subprog_spec ; .
INFO:root:
INFO:root:    PRIVATE         reduce using rule 366 (prot_op_decl -> subprog_spec ; .)
INFO:root:    ENTRY           reduce using rule 366 (prot_op_decl -> subprog_spec ; .)
INFO:root:    PROCEDURE       reduce using rule 366 (prot_op_decl -> subprog_spec ; .)
INFO:root:    FUNCTION        reduce using rule 366 (prot_op_decl -> subprog_spec ; .)
INFO:root:    PRAGMA          reduce using rule 366 (prot_op_decl -> subprog_spec ; .)
INFO:root:    FOR             reduce using rule 366 (prot_op_decl -> subprog_spec ; .)
INFO:root:    END             reduce using rule 366 (prot_op_decl -> subprog_spec ; .)
INFO:root:    error           reduce using rule 366 (prot_op_decl -> subprog_spec ; .)
INFO:root:    IDENTIFIER      reduce using rule 366 (prot_op_decl -> subprog_spec ; .)
INFO:root:
INFO:root:
INFO:root:state 719
INFO:root:
INFO:root:    (360) prot_def -> IS prot_op_decl_s prot_private_opt END . id_opt
INFO:root:    (285) id_opt -> .
INFO:root:    (286) id_opt -> . designator
INFO:root:    (307) designator -> . compound_name
INFO:root:    (308) designator -> . STRING
INFO:root:    (158) compound_name -> . simple_name
INFO:root:    (159) compound_name -> . compound_name . simple_name
INFO:root:    (157) simple_name -> . IDENTIFIER
INFO:root:
INFO:root:    ;               reduce using rule 285 (id_opt -> .)
INFO:root:    STRING          shift and go to state 62
INFO:root:    IDENTIFIER      shift and go to state 33
INFO:root:
INFO:root:    designator                     shift and go to state 455
INFO:root:    id_opt                         shift and go to state 802
INFO:root:    simple_name                    shift and go to state 34
INFO:root:    compound_name                  shift and go to state 64
INFO:root:
INFO:root:state 720
INFO:root:
INFO:root:    (362) prot_private_opt -> PRIVATE prot_elem_decl_s .
INFO:root:    (370) prot_elem_decl_s -> prot_elem_decl_s . prot_elem_decl
INFO:root:    (371) prot_elem_decl -> . prot_op_decl
INFO:root:    (372) prot_elem_decl -> . comp_decl
INFO:root:    (365) prot_op_decl -> . entry_decl
INFO:root:    (366) prot_op_decl -> . subprog_spec ;
INFO:root:    (367) prot_op_decl -> . rep_spec
INFO:root:    (368) prot_op_decl -> . pragma
INFO:root:    (108) comp_decl -> . def_id_s : component_subtype_def init_opt ;
INFO:root:    (109) comp_decl -> . error ;
INFO:root:    (381) entry_decl -> . ENTRY IDENTIFIER formal_part_opt ;
INFO:root:    (382) entry_decl -> . ENTRY IDENTIFIER ( discrete_range ) formal_part_opt ;
INFO:root:    (304) subprog_spec -> . PROCEDURE compound_name formal_part_opt
INFO:root:    (305) subprog_spec -> . FUNCTION designator formal_part_opt RETURN name
INFO:root:    (306) subprog_spec -> . FUNCTION designator
INFO:root:    (491) rep_spec -> . attrib_def
INFO:root:    (492) rep_spec -> . record_type_spec
INFO:root:    (493) rep_spec -> . address_spec
INFO:root:    (2) pragma -> . PRAGMA IDENTIFIER ;
INFO:root:    (3) pragma -> . PRAGMA simple_name ( pragma_arg_s ) ;
INFO:root:    (24) def_id_s -> . def_id
INFO:root:    (25) def_id_s -> . def_id_s , def_id
INFO:root:    (494) attrib_def -> . FOR mark USE expression ;
INFO:root:    (495) record_type_spec -> . FOR mark USE RECORD align_opt comp_loc_s END RECORD ;
INFO:root:    (500) address_spec -> . FOR mark USE AT expression ;
INFO:root:    (26) def_id -> . IDENTIFIER
INFO:root:
INFO:root:    END             reduce using rule 362 (prot_private_opt -> PRIVATE prot_elem_decl_s .)
INFO:root:    error           shift and go to state 807
INFO:root:    ENTRY           shift and go to state 590
INFO:root:    PROCEDURE       shift and go to state 17
INFO:root:    FUNCTION        shift and go to state 23
INFO:root:    PRAGMA          shift and go to state 2
INFO:root:    FOR             shift and go to state 102
INFO:root:    IDENTIFIER      shift and go to state 52
INFO:root:
INFO:root:    prot_op_decl                   shift and go to state 804
INFO:root:    pragma                         shift and go to state 596
INFO:root:    subprog_spec                   shift and go to state 597
INFO:root:    comp_decl                      shift and go to state 805
INFO:root:    record_type_spec               shift and go to state 108
INFO:root:    entry_decl                     shift and go to state 600
INFO:root:    def_id_s                       shift and go to state 806
INFO:root:    def_id                         shift and go to state 57
INFO:root:    rep_spec                       shift and go to state 601
INFO:root:    address_spec                   shift and go to state 83
INFO:root:    attrib_def                     shift and go to state 92
INFO:root:    prot_elem_decl                 shift and go to state 803
INFO:root:
INFO:root:state 721
INFO:root:
INFO:root:    (500) address_spec -> FOR mark USE AT expression ; .
INFO:root:
INFO:root:    error           reduce using rule 500 (address_spec -> FOR mark USE AT expression ; .)
INFO:root:    USE             reduce using rule 500 (address_spec -> FOR mark USE AT expression ; .)
INFO:root:    PRAGMA          reduce using rule 500 (address_spec -> FOR mark USE AT expression ; .)
INFO:root:    TYPE            reduce using rule 500 (address_spec -> FOR mark USE AT expression ; .)
INFO:root:    SUBTYPE         reduce using rule 500 (address_spec -> FOR mark USE AT expression ; .)
INFO:root:    TASK            reduce using rule 500 (address_spec -> FOR mark USE AT expression ; .)
INFO:root:    PACKAGE         reduce using rule 500 (address_spec -> FOR mark USE AT expression ; .)
INFO:root:    PROTECTED       reduce using rule 500 (address_spec -> FOR mark USE AT expression ; .)
INFO:root:    FOR             reduce using rule 500 (address_spec -> FOR mark USE AT expression ; .)
INFO:root:    PROCEDURE       reduce using rule 500 (address_spec -> FOR mark USE AT expression ; .)
INFO:root:    FUNCTION        reduce using rule 500 (address_spec -> FOR mark USE AT expression ; .)
INFO:root:    GENERIC         reduce using rule 500 (address_spec -> FOR mark USE AT expression ; .)
INFO:root:    IDENTIFIER      reduce using rule 500 (address_spec -> FOR mark USE AT expression ; .)
INFO:root:    PRIVATE         reduce using rule 500 (address_spec -> FOR mark USE AT expression ; .)
INFO:root:    END             reduce using rule 500 (address_spec -> FOR mark USE AT expression ; .)
INFO:root:    BEGIN           reduce using rule 500 (address_spec -> FOR mark USE AT expression ; .)
INFO:root:    ENTRY           reduce using rule 500 (address_spec -> FOR mark USE AT expression ; .)
INFO:root:
INFO:root:
INFO:root:state 722
INFO:root:
INFO:root:    (497) align_opt -> AT MOD . expression ;
INFO:root:    (188) expression -> . relation
INFO:root:    (189) expression -> . expression logical relation
INFO:root:    (190) expression -> . expression short_circuit relation
INFO:root:    (196) relation -> . simple_expression
INFO:root:    (197) relation -> . simple_expression relational simple_expression
INFO:root:    (198) relation -> . simple_expression membership range
INFO:root:    (199) relation -> . simple_expression membership name
INFO:root:    (208) simple_expression -> . unary term
INFO:root:    (209) simple_expression -> . term
INFO:root:    (210) simple_expression -> . simple_expression adding term
INFO:root:    (211) unary -> . +
INFO:root:    (212) unary -> . -
INFO:root:    (216) term -> . factor
INFO:root:    (217) term -> . term multiplying factor
INFO:root:    (223) factor -> . primary
INFO:root:    (224) factor -> . NOT primary
INFO:root:    (225) factor -> . ABS primary
INFO:root:    (226) primary -> . literal
INFO:root:    (227) primary -> . name
INFO:root:    (228) primary -> . allocator
INFO:root:    (229) primary -> . qualified
INFO:root:    (230) primary -> . parenthesized_primary
INFO:root:    (180) literal -> . INT
INFO:root:    (181) literal -> . FLOAT
INFO:root:    (182) literal -> . NuLL
INFO:root:    (149) name -> . simple_name
INFO:root:    (150) name -> . indexed_comp
INFO:root:    (151) name -> . selected_comp
INFO:root:    (152) name -> . attribute
INFO:root:    (153) name -> . operator_symbol
INFO:root:    (234) allocator -> . NEW name
INFO:root:    (235) allocator -> . NEW qualified
INFO:root:    (233) qualified -> . name TICK parenthesized_primary
INFO:root:    (231) parenthesized_primary -> . aggregate
INFO:root:    (232) parenthesized_primary -> . ( expression )
INFO:root:    (157) simple_name -> . IDENTIFIER
INFO:root:    (164) indexed_comp -> . name ( value_s )
INFO:root:    (171) selected_comp -> . name . simple_name
INFO:root:    (172) selected_comp -> . name . used_char
INFO:root:    (173) selected_comp -> . name . operator_symbol
INFO:root:    (174) selected_comp -> . name . ALL
INFO:root:    (175) attribute -> . name TICK attribute_id
INFO:root:    (163) operator_symbol -> . STRING
INFO:root:    (183) aggregate -> . ( comp_assoc )
INFO:root:    (184) aggregate -> . ( expression WITH value_s )
INFO:root:    (185) aggregate -> . ( expression WITH NuLL RECORD )
INFO:root:    (186) aggregate -> . ( NuLL RECORD )
INFO:root:
INFO:root:    +               shift and go to state 148
INFO:root:    -               shift and go to state 136
INFO:root:    NOT             shift and go to state 131
INFO:root:    ABS             shift and go to state 132
INFO:root:    INT             shift and go to state 120
INFO:root:    FLOAT           shift and go to state 128
INFO:root:    NuLL            shift and go to state 130
INFO:root:    NEW             shift and go to state 137
INFO:root:    (               shift and go to state 125
INFO:root:    IDENTIFIER      shift and go to state 33
INFO:root:    STRING          shift and go to state 149
INFO:root:
INFO:root:    literal                        shift and go to state 121
INFO:root:    allocator                      shift and go to state 122
INFO:root:    simple_name                    shift and go to state 163
INFO:root:    indexed_comp                   shift and go to state 140
INFO:root:    name                           shift and go to state 142
INFO:root:    selected_comp                  shift and go to state 139
INFO:root:    factor                         shift and go to state 126
INFO:root:    expression                     shift and go to state 808
INFO:root:    unary                          shift and go to state 144
INFO:root:    qualified                      shift and go to state 145
INFO:root:    aggregate                      shift and go to state 143
INFO:root:    simple_expression              shift and go to state 129
INFO:root:    term                           shift and go to state 146
INFO:root:    operator_symbol                shift and go to state 133
INFO:root:    parenthesized_primary          shift and go to state 147
INFO:root:    attribute                      shift and go to state 134
INFO:root:    primary                        shift and go to state 135
INFO:root:    relation                       shift and go to state 138
INFO:root:
INFO:root:state 723
INFO:root:
INFO:root:    (495) record_type_spec -> FOR mark USE RECORD align_opt comp_loc_s . END RECORD ;
INFO:root:    (499) comp_loc_s -> comp_loc_s . mark AT expression RANGE range ;
INFO:root:    (154) mark -> . simple_name
INFO:root:    (155) mark -> . mark TICK attribute_id
INFO:root:    (156) mark -> . mark . simple_name
INFO:root:    (157) simple_name -> . IDENTIFIER
INFO:root:
INFO:root:    END             shift and go to state 809
INFO:root:    IDENTIFIER      shift and go to state 33
INFO:root:
INFO:root:    mark                           shift and go to state 810
INFO:root:    simple_name                    shift and go to state 192
INFO:root:
INFO:root:state 724
INFO:root:
INFO:root:    (394) entry_name -> entry_name ( expression . )
INFO:root:    (189) expression -> expression . logical relation
INFO:root:    (190) expression -> expression . short_circuit relation
INFO:root:    (191) logical -> . AND
INFO:root:    (192) logical -> . OR
INFO:root:    (193) logical -> . XOR
INFO:root:    (194) short_circuit -> . AND THEN
INFO:root:    (195) short_circuit -> . OR ELSE
INFO:root:
INFO:root:    )               shift and go to state 811
INFO:root:    AND             shift and go to state 215
INFO:root:    OR              shift and go to state 216
INFO:root:    XOR             shift and go to state 214
INFO:root:
INFO:root:    short_circuit                  shift and go to state 212
INFO:root:    logical                        shift and go to state 213
INFO:root:
INFO:root:state 725
INFO:root:
INFO:root:    (26) def_id -> IDENTIFIER .
INFO:root:    (157) simple_name -> IDENTIFIER .
INFO:root:
INFO:root:    :               reduce using rule 26 (def_id -> IDENTIFIER .)
INFO:root:    ,               reduce using rule 26 (def_id -> IDENTIFIER .)
INFO:root:    TICK            reduce using rule 157 (simple_name -> IDENTIFIER .)
INFO:root:    (               reduce using rule 157 (simple_name -> IDENTIFIER .)
INFO:root:    .               reduce using rule 157 (simple_name -> IDENTIFIER .)
INFO:root:    *               reduce using rule 157 (simple_name -> IDENTIFIER .)
INFO:root:    /               reduce using rule 157 (simple_name -> IDENTIFIER .)
INFO:root:    MOD             reduce using rule 157 (simple_name -> IDENTIFIER .)
INFO:root:    REM             reduce using rule 157 (simple_name -> IDENTIFIER .)
INFO:root:    STARSTAR        reduce using rule 157 (simple_name -> IDENTIFIER .)
INFO:root:    =               reduce using rule 157 (simple_name -> IDENTIFIER .)
INFO:root:    NEQ             reduce using rule 157 (simple_name -> IDENTIFIER .)
INFO:root:    <               reduce using rule 157 (simple_name -> IDENTIFIER .)
INFO:root:    LEQ             reduce using rule 157 (simple_name -> IDENTIFIER .)
INFO:root:    >               reduce using rule 157 (simple_name -> IDENTIFIER .)
INFO:root:    GEQ             reduce using rule 157 (simple_name -> IDENTIFIER .)
INFO:root:    IN              reduce using rule 157 (simple_name -> IDENTIFIER .)
INFO:root:    NOT             reduce using rule 157 (simple_name -> IDENTIFIER .)
INFO:root:    +               reduce using rule 157 (simple_name -> IDENTIFIER .)
INFO:root:    -               reduce using rule 157 (simple_name -> IDENTIFIER .)
INFO:root:    &               reduce using rule 157 (simple_name -> IDENTIFIER .)
INFO:root:    )               reduce using rule 157 (simple_name -> IDENTIFIER .)
INFO:root:    AND             reduce using rule 157 (simple_name -> IDENTIFIER .)
INFO:root:    OR              reduce using rule 157 (simple_name -> IDENTIFIER .)
INFO:root:    XOR             reduce using rule 157 (simple_name -> IDENTIFIER .)
INFO:root:
INFO:root:
INFO:root:state 726
INFO:root:
INFO:root:    (275) loop_stmt -> label_opt iteration basic_loop id_opt . ;
INFO:root:
INFO:root:    ;               shift and go to state 812
INFO:root:
INFO:root:
INFO:root:state 727
INFO:root:
INFO:root:    (284) basic_loop -> LOOP statement_s . END LOOP
INFO:root:    (237) statement_s -> statement_s . statement
INFO:root:    (238) statement -> . unlabeled
INFO:root:    (239) statement -> . label statement
INFO:root:    (240) unlabeled -> . simple_stmt
INFO:root:    (241) unlabeled -> . compound_stmt
INFO:root:    (259) label -> . LL IDENTIFIER RR
INFO:root:    (242) simple_stmt -> . null_stmt
INFO:root:    (243) simple_stmt -> . assign_stmt
INFO:root:    (244) simple_stmt -> . exit_stmt
INFO:root:    (245) simple_stmt -> . return_stmt
INFO:root:    (246) simple_stmt -> . procedure_call
INFO:root:    (247) simple_stmt -> . delay_stmt
INFO:root:    (248) simple_stmt -> . abort_stmt
INFO:root:    (249) simple_stmt -> . raise_stmt
INFO:root:    (250) simple_stmt -> . code_stmt
INFO:root:    (251) simple_stmt -> . requeue_stmt
INFO:root:    (252) simple_stmt -> . error ;
INFO:root:    (253) compound_stmt -> . if_stmt
INFO:root:    (254) compound_stmt -> . case_stmt
INFO:root:    (255) compound_stmt -> . loop_stmt
INFO:root:    (256) compound_stmt -> . block
INFO:root:    (257) compound_stmt -> . accept_stmt
INFO:root:    (258) compound_stmt -> . select_stmt
INFO:root:    (260) null_stmt -> . NuLL ;
INFO:root:    (261) assign_stmt -> . name ASSIGN expression ;
INFO:root:    (294) exit_stmt -> . EXIT name_opt when_opt ;
INFO:root:    (299) return_stmt -> . RETURN ;
INFO:root:    (300) return_stmt -> . RETURN expression ;
INFO:root:    (323) procedure_call -> . name ;
INFO:root:    (395) delay_stmt -> . DELAY expression ;
INFO:root:    (396) delay_stmt -> . DELAY UNTIL expression ;
INFO:root:    (416) abort_stmt -> . ABORT name_s ;
INFO:root:    (455) raise_stmt -> . RAISE name_opt ;
INFO:root:    (501) code_stmt -> . qualified ;
INFO:root:    (456) requeue_stmt -> . REQUEUE name ;
INFO:root:    (457) requeue_stmt -> . REQUEUE name WITH ABORT ;
INFO:root:    (262) if_stmt -> . IF cond_clause_s else_opt END IF ;
INFO:root:    (270) case_stmt -> . case_hdr pragma_s alternative_s END CASE ;
INFO:root:    (275) loop_stmt -> . label_opt iteration basic_loop id_opt ;
INFO:root:    (287) block -> . label_opt block_decl block_body END id_opt ;
INFO:root:    (390) accept_stmt -> . accept_hdr ;
INFO:root:    (391) accept_stmt -> . accept_hdr DO handled_stmt_s END id_opt ;
INFO:root:    (397) select_stmt -> . select_wait
INFO:root:    (398) select_stmt -> . async_select
INFO:root:    (399) select_stmt -> . timed_entry_call
INFO:root:    (400) select_stmt -> . cond_entry_call
INFO:root:    (149) name -> . simple_name
INFO:root:    (150) name -> . indexed_comp
INFO:root:    (151) name -> . selected_comp
INFO:root:    (152) name -> . attribute
INFO:root:    (153) name -> . operator_symbol
INFO:root:    (233) qualified -> . name TICK parenthesized_primary
INFO:root:    (271) case_hdr -> . CASE expression IS
INFO:root:    (276) label_opt -> .
INFO:root:    (277) label_opt -> . IDENTIFIER :
INFO:root:    (392) accept_hdr -> . ACCEPT entry_name formal_part_opt
INFO:root:    (401) select_wait -> . SELECT guarded_select_alt or_select else_opt END SELECT ;
INFO:root:    (411) async_select -> . SELECT delay_or_entry_alt THEN ABORT statement_s END SELECT ;
INFO:root:    (412) timed_entry_call -> . SELECT entry_call stmts_opt OR delay_stmt stmts_opt END SELECT ;
INFO:root:    (413) cond_entry_call -> . SELECT entry_call stmts_opt ELSE statement_s END SELECT ;
INFO:root:    (157) simple_name -> . IDENTIFIER
INFO:root:    (164) indexed_comp -> . name ( value_s )
INFO:root:    (171) selected_comp -> . name . simple_name
INFO:root:    (172) selected_comp -> . name . used_char
INFO:root:    (173) selected_comp -> . name . operator_symbol
INFO:root:    (174) selected_comp -> . name . ALL
INFO:root:    (175) attribute -> . name TICK attribute_id
INFO:root:    (163) operator_symbol -> . STRING
INFO:root:
INFO:root:    END             shift and go to state 813
INFO:root:    LL              shift and go to state 344
INFO:root:    error           shift and go to state 341
INFO:root:    NuLL            shift and go to state 347
INFO:root:    EXIT            shift and go to state 340
INFO:root:    RETURN          shift and go to state 303
INFO:root:    DELAY           shift and go to state 332
INFO:root:    ABORT           shift and go to state 326
INFO:root:    RAISE           shift and go to state 314
INFO:root:    REQUEUE         shift and go to state 317
INFO:root:    IF              shift and go to state 327
INFO:root:    CASE            shift and go to state 312
INFO:root:    WHILE           reduce using rule 276 (label_opt -> .)
INFO:root:    DECLARE         reduce using rule 276 (label_opt -> .)
INFO:root:    FOR             reduce using rule 276 (label_opt -> .)
INFO:root:    LOOP            reduce using rule 276 (label_opt -> .)
INFO:root:    BEGIN           reduce using rule 276 (label_opt -> .)
INFO:root:    IDENTIFIER      shift and go to state 322
INFO:root:    ACCEPT          shift and go to state 310
INFO:root:    SELECT          shift and go to state 320
INFO:root:    STRING          shift and go to state 149
INFO:root:
INFO:root:    cond_entry_call                shift and go to state 345
INFO:root:    simple_stmt                    shift and go to state 302
INFO:root:    async_select                   shift and go to state 328
INFO:root:    simple_name                    shift and go to state 163
INFO:root:    requeue_stmt                   shift and go to state 329
INFO:root:    if_stmt                        shift and go to state 304
INFO:root:    procedure_call                 shift and go to state 305
INFO:root:    select_wait                    shift and go to state 330
INFO:root:    indexed_comp                   shift and go to state 140
INFO:root:    timed_entry_call               shift and go to state 307
INFO:root:    statement                      shift and go to state 497
INFO:root:    operator_symbol                shift and go to state 133
INFO:root:    exit_stmt                      shift and go to state 306
INFO:root:    code_stmt                      shift and go to state 331
INFO:root:    loop_stmt                      shift and go to state 333
INFO:root:    null_stmt                      shift and go to state 334
INFO:root:    label                          shift and go to state 335
INFO:root:    select_stmt                    shift and go to state 311
INFO:root:    label_opt                      shift and go to state 313
INFO:root:    assign_stmt                    shift and go to state 336
INFO:root:    selected_comp                  shift and go to state 139
INFO:root:    abort_stmt                     shift and go to state 315
INFO:root:    attribute                      shift and go to state 134
INFO:root:    name                           shift and go to state 316
INFO:root:    accept_hdr                     shift and go to state 318
INFO:root:    accept_stmt                    shift and go to state 337
INFO:root:    case_hdr                       shift and go to state 319
INFO:root:    delay_stmt                     shift and go to state 338
INFO:root:    compound_stmt                  shift and go to state 309
INFO:root:    raise_stmt                     shift and go to state 342
INFO:root:    qualified                      shift and go to state 321
INFO:root:    return_stmt                    shift and go to state 323
INFO:root:    case_stmt                      shift and go to state 324
INFO:root:    block                          shift and go to state 325
INFO:root:    unlabeled                      shift and go to state 346
INFO:root:
INFO:root:state 728
INFO:root:
INFO:root:    (287) block -> label_opt block_decl block_body END . id_opt ;
INFO:root:    (285) id_opt -> .
INFO:root:    (286) id_opt -> . designator
INFO:root:    (307) designator -> . compound_name
INFO:root:    (308) designator -> . STRING
INFO:root:    (158) compound_name -> . simple_name
INFO:root:    (159) compound_name -> . compound_name . simple_name
INFO:root:    (157) simple_name -> . IDENTIFIER
INFO:root:
INFO:root:    ;               reduce using rule 285 (id_opt -> .)
INFO:root:    STRING          shift and go to state 62
INFO:root:    IDENTIFIER      shift and go to state 33
INFO:root:
INFO:root:    designator                     shift and go to state 455
INFO:root:    id_opt                         shift and go to state 814
INFO:root:    simple_name                    shift and go to state 34
INFO:root:    compound_name                  shift and go to state 64
INFO:root:
INFO:root:state 729
INFO:root:
INFO:root:    (281) iter_part -> FOR IDENTIFIER IN .
INFO:root:
INFO:root:    IDENTIFIER      reduce using rule 281 (iter_part -> FOR IDENTIFIER IN .)
INFO:root:    STRING          reduce using rule 281 (iter_part -> FOR IDENTIFIER IN .)
INFO:root:    +               reduce using rule 281 (iter_part -> FOR IDENTIFIER IN .)
INFO:root:    -               reduce using rule 281 (iter_part -> FOR IDENTIFIER IN .)
INFO:root:    NOT             reduce using rule 281 (iter_part -> FOR IDENTIFIER IN .)
INFO:root:    ABS             reduce using rule 281 (iter_part -> FOR IDENTIFIER IN .)
INFO:root:    INT             reduce using rule 281 (iter_part -> FOR IDENTIFIER IN .)
INFO:root:    FLOAT           reduce using rule 281 (iter_part -> FOR IDENTIFIER IN .)
INFO:root:    NuLL            reduce using rule 281 (iter_part -> FOR IDENTIFIER IN .)
INFO:root:    NEW             reduce using rule 281 (iter_part -> FOR IDENTIFIER IN .)
INFO:root:    (               reduce using rule 281 (iter_part -> FOR IDENTIFIER IN .)
INFO:root:    REVERSE         reduce using rule 281 (iter_part -> FOR IDENTIFIER IN .)
INFO:root:
INFO:root:
INFO:root:state 730
INFO:root:
INFO:root:    (91) discrete_range -> name . range_constr_opt
INFO:root:    (164) indexed_comp -> name . ( value_s )
INFO:root:    (171) selected_comp -> name . . simple_name
INFO:root:    (172) selected_comp -> name . . used_char
INFO:root:    (173) selected_comp -> name . . operator_symbol
INFO:root:    (174) selected_comp -> name . . ALL
INFO:root:    (175) attribute -> name . TICK attribute_id
INFO:root:    (227) primary -> name .
INFO:root:    (233) qualified -> name . TICK parenthesized_primary
INFO:root:    (93) range_constr_opt -> .
INFO:root:    (94) range_constr_opt -> . range_constraint
INFO:root:    (61) range_constraint -> . RANGE range
INFO:root:
INFO:root:    (               shift and go to state 237
INFO:root:    .               shift and go to state 239
INFO:root:    TICK            shift and go to state 359
INFO:root:    *               reduce using rule 227 (primary -> name .)
INFO:root:    /               reduce using rule 227 (primary -> name .)
INFO:root:    MOD             reduce using rule 227 (primary -> name .)
INFO:root:    REM             reduce using rule 227 (primary -> name .)
INFO:root:    STARSTAR        reduce using rule 227 (primary -> name .)
INFO:root:    DOTDOT          reduce using rule 227 (primary -> name .)
INFO:root:    +               reduce using rule 227 (primary -> name .)
INFO:root:    -               reduce using rule 227 (primary -> name .)
INFO:root:    &               reduce using rule 227 (primary -> name .)
INFO:root:    LOOP            reduce using rule 93 (range_constr_opt -> .)
INFO:root:    )               reduce using rule 93 (range_constr_opt -> .)
INFO:root:    ,               reduce using rule 93 (range_constr_opt -> .)
INFO:root:    RANGE           shift and go to state 358
INFO:root:
INFO:root:    range_constr_opt               shift and go to state 787
INFO:root:    range_constraint               shift and go to state 786
INFO:root:
INFO:root:state 731
INFO:root:
INFO:root:    (280) iteration -> iter_part reverse_opt discrete_range .
INFO:root:
INFO:root:    LOOP            reduce using rule 280 (iteration -> iter_part reverse_opt discrete_range .)
INFO:root:
INFO:root:
INFO:root:state 732
INFO:root:
INFO:root:    (261) assign_stmt -> name ASSIGN expression ; .
INFO:root:
INFO:root:    LL              reduce using rule 261 (assign_stmt -> name ASSIGN expression ; .)
INFO:root:    error           reduce using rule 261 (assign_stmt -> name ASSIGN expression ; .)
INFO:root:    NuLL            reduce using rule 261 (assign_stmt -> name ASSIGN expression ; .)
INFO:root:    EXIT            reduce using rule 261 (assign_stmt -> name ASSIGN expression ; .)
INFO:root:    RETURN          reduce using rule 261 (assign_stmt -> name ASSIGN expression ; .)
INFO:root:    DELAY           reduce using rule 261 (assign_stmt -> name ASSIGN expression ; .)
INFO:root:    ABORT           reduce using rule 261 (assign_stmt -> name ASSIGN expression ; .)
INFO:root:    RAISE           reduce using rule 261 (assign_stmt -> name ASSIGN expression ; .)
INFO:root:    REQUEUE         reduce using rule 261 (assign_stmt -> name ASSIGN expression ; .)
INFO:root:    IF              reduce using rule 261 (assign_stmt -> name ASSIGN expression ; .)
INFO:root:    CASE            reduce using rule 261 (assign_stmt -> name ASSIGN expression ; .)
INFO:root:    IDENTIFIER      reduce using rule 261 (assign_stmt -> name ASSIGN expression ; .)
INFO:root:    ACCEPT          reduce using rule 261 (assign_stmt -> name ASSIGN expression ; .)
INFO:root:    SELECT          reduce using rule 261 (assign_stmt -> name ASSIGN expression ; .)
INFO:root:    STRING          reduce using rule 261 (assign_stmt -> name ASSIGN expression ; .)
INFO:root:    WHILE           reduce using rule 261 (assign_stmt -> name ASSIGN expression ; .)
INFO:root:    DECLARE         reduce using rule 261 (assign_stmt -> name ASSIGN expression ; .)
INFO:root:    FOR             reduce using rule 261 (assign_stmt -> name ASSIGN expression ; .)
INFO:root:    LOOP            reduce using rule 261 (assign_stmt -> name ASSIGN expression ; .)
INFO:root:    BEGIN           reduce using rule 261 (assign_stmt -> name ASSIGN expression ; .)
INFO:root:    WHEN            reduce using rule 261 (assign_stmt -> name ASSIGN expression ; .)
INFO:root:    END             reduce using rule 261 (assign_stmt -> name ASSIGN expression ; .)
INFO:root:    ELSIF           reduce using rule 261 (assign_stmt -> name ASSIGN expression ; .)
INFO:root:    ELSE            reduce using rule 261 (assign_stmt -> name ASSIGN expression ; .)
INFO:root:    OR              reduce using rule 261 (assign_stmt -> name ASSIGN expression ; .)
INFO:root:    THEN            reduce using rule 261 (assign_stmt -> name ASSIGN expression ; .)
INFO:root:    EXCEPTION       reduce using rule 261 (assign_stmt -> name ASSIGN expression ; .)
INFO:root:
INFO:root:
INFO:root:state 733
INFO:root:
INFO:root:    (457) requeue_stmt -> REQUEUE name WITH ABORT . ;
INFO:root:
INFO:root:    ;               shift and go to state 815
INFO:root:
INFO:root:
INFO:root:state 734
INFO:root:
INFO:root:    (391) accept_stmt -> accept_hdr DO handled_stmt_s END . id_opt ;
INFO:root:    (285) id_opt -> .
INFO:root:    (286) id_opt -> . designator
INFO:root:    (307) designator -> . compound_name
INFO:root:    (308) designator -> . STRING
INFO:root:    (158) compound_name -> . simple_name
INFO:root:    (159) compound_name -> . compound_name . simple_name
INFO:root:    (157) simple_name -> . IDENTIFIER
INFO:root:
INFO:root:    ;               reduce using rule 285 (id_opt -> .)
INFO:root:    STRING          shift and go to state 62
INFO:root:    IDENTIFIER      shift and go to state 33
INFO:root:
INFO:root:    designator                     shift and go to state 455
INFO:root:    id_opt                         shift and go to state 816
INFO:root:    simple_name                    shift and go to state 34
INFO:root:    compound_name                  shift and go to state 64
INFO:root:
INFO:root:state 735
INFO:root:
INFO:root:    (273) alternative_s -> alternative_s alternative .
INFO:root:
INFO:root:    END             reduce using rule 273 (alternative_s -> alternative_s alternative .)
INFO:root:    WHEN            reduce using rule 273 (alternative_s -> alternative_s alternative .)
INFO:root:
INFO:root:
INFO:root:state 736
INFO:root:
INFO:root:    (270) case_stmt -> case_hdr pragma_s alternative_s END . CASE ;
INFO:root:
INFO:root:    CASE            shift and go to state 817
INFO:root:
INFO:root:
INFO:root:state 737
INFO:root:
INFO:root:    (274) alternative -> WHEN . choice_s ARROW statement_s
INFO:root:    (121) choice_s -> . choice
INFO:root:    (122) choice_s -> . choice_s | choice
INFO:root:    (123) choice -> . expression
INFO:root:    (124) choice -> . discrete_with_range
INFO:root:    (125) choice -> . OTHERS
INFO:root:    (188) expression -> . relation
INFO:root:    (189) expression -> . expression logical relation
INFO:root:    (190) expression -> . expression short_circuit relation
INFO:root:    (126) discrete_with_range -> . name range_constraint
INFO:root:    (127) discrete_with_range -> . range
INFO:root:    (196) relation -> . simple_expression
INFO:root:    (197) relation -> . simple_expression relational simple_expression
INFO:root:    (198) relation -> . simple_expression membership range
INFO:root:    (199) relation -> . simple_expression membership name
INFO:root:    (149) name -> . simple_name
INFO:root:    (150) name -> . indexed_comp
INFO:root:    (151) name -> . selected_comp
INFO:root:    (152) name -> . attribute
INFO:root:    (153) name -> . operator_symbol
INFO:root:    (62) range -> . simple_expression DOTDOT simple_expression
INFO:root:    (208) simple_expression -> . unary term
INFO:root:    (209) simple_expression -> . term
INFO:root:    (210) simple_expression -> . simple_expression adding term
INFO:root:    (157) simple_name -> . IDENTIFIER
INFO:root:    (164) indexed_comp -> . name ( value_s )
INFO:root:    (171) selected_comp -> . name . simple_name
INFO:root:    (172) selected_comp -> . name . used_char
INFO:root:    (173) selected_comp -> . name . operator_symbol
INFO:root:    (174) selected_comp -> . name . ALL
INFO:root:    (175) attribute -> . name TICK attribute_id
INFO:root:    (163) operator_symbol -> . STRING
INFO:root:    (211) unary -> . +
INFO:root:    (212) unary -> . -
INFO:root:    (216) term -> . factor
INFO:root:    (217) term -> . term multiplying factor
INFO:root:    (223) factor -> . primary
INFO:root:    (224) factor -> . NOT primary
INFO:root:    (225) factor -> . ABS primary
INFO:root:    (226) primary -> . literal
INFO:root:    (227) primary -> . name
INFO:root:    (228) primary -> . allocator
INFO:root:    (229) primary -> . qualified
INFO:root:    (230) primary -> . parenthesized_primary
INFO:root:    (180) literal -> . INT
INFO:root:    (181) literal -> . FLOAT
INFO:root:    (182) literal -> . NuLL
INFO:root:    (234) allocator -> . NEW name
INFO:root:    (235) allocator -> . NEW qualified
INFO:root:    (233) qualified -> . name TICK parenthesized_primary
INFO:root:    (231) parenthesized_primary -> . aggregate
INFO:root:    (232) parenthesized_primary -> . ( expression )
INFO:root:    (183) aggregate -> . ( comp_assoc )
INFO:root:    (184) aggregate -> . ( expression WITH value_s )
INFO:root:    (185) aggregate -> . ( expression WITH NuLL RECORD )
INFO:root:    (186) aggregate -> . ( NuLL RECORD )
INFO:root:
INFO:root:    OTHERS          shift and go to state 204
INFO:root:    IDENTIFIER      shift and go to state 33
INFO:root:    STRING          shift and go to state 149
INFO:root:    +               shift and go to state 148
INFO:root:    -               shift and go to state 136
INFO:root:    NOT             shift and go to state 131
INFO:root:    ABS             shift and go to state 132
INFO:root:    INT             shift and go to state 120
INFO:root:    FLOAT           shift and go to state 128
INFO:root:    NuLL            shift and go to state 130
INFO:root:    NEW             shift and go to state 137
INFO:root:    (               shift and go to state 125
INFO:root:
INFO:root:    selected_comp                  shift and go to state 139
INFO:root:    attribute                      shift and go to state 134
INFO:root:    factor                         shift and go to state 126
INFO:root:    indexed_comp                   shift and go to state 140
INFO:root:    name                           shift and go to state 377
INFO:root:    literal                        shift and go to state 121
INFO:root:    simple_name                    shift and go to state 163
INFO:root:    expression                     shift and go to state 507
INFO:root:    simple_expression              shift and go to state 374
INFO:root:    parenthesized_primary          shift and go to state 147
INFO:root:    unary                          shift and go to state 144
INFO:root:    allocator                      shift and go to state 122
INFO:root:    aggregate                      shift and go to state 143
INFO:root:    discrete_with_range            shift and go to state 210
INFO:root:    term                           shift and go to state 146
INFO:root:    operator_symbol                shift and go to state 133
INFO:root:    choice_s                       shift and go to state 818
INFO:root:    primary                        shift and go to state 135
INFO:root:    qualified                      shift and go to state 145
INFO:root:    relation                       shift and go to state 138
INFO:root:    range                          shift and go to state 211
INFO:root:    choice                         shift and go to state 207
INFO:root:
INFO:root:state 738
INFO:root:
INFO:root:    (413) cond_entry_call -> SELECT entry_call stmts_opt ELSE . statement_s END SELECT ;
INFO:root:    (236) statement_s -> . statement
INFO:root:    (237) statement_s -> . statement_s statement
INFO:root:    (238) statement -> . unlabeled
INFO:root:    (239) statement -> . label statement
INFO:root:    (240) unlabeled -> . simple_stmt
INFO:root:    (241) unlabeled -> . compound_stmt
INFO:root:    (259) label -> . LL IDENTIFIER RR
INFO:root:    (242) simple_stmt -> . null_stmt
INFO:root:    (243) simple_stmt -> . assign_stmt
INFO:root:    (244) simple_stmt -> . exit_stmt
INFO:root:    (245) simple_stmt -> . return_stmt
INFO:root:    (246) simple_stmt -> . procedure_call
INFO:root:    (247) simple_stmt -> . delay_stmt
INFO:root:    (248) simple_stmt -> . abort_stmt
INFO:root:    (249) simple_stmt -> . raise_stmt
INFO:root:    (250) simple_stmt -> . code_stmt
INFO:root:    (251) simple_stmt -> . requeue_stmt
INFO:root:    (252) simple_stmt -> . error ;
INFO:root:    (253) compound_stmt -> . if_stmt
INFO:root:    (254) compound_stmt -> . case_stmt
INFO:root:    (255) compound_stmt -> . loop_stmt
INFO:root:    (256) compound_stmt -> . block
INFO:root:    (257) compound_stmt -> . accept_stmt
INFO:root:    (258) compound_stmt -> . select_stmt
INFO:root:    (260) null_stmt -> . NuLL ;
INFO:root:    (261) assign_stmt -> . name ASSIGN expression ;
INFO:root:    (294) exit_stmt -> . EXIT name_opt when_opt ;
INFO:root:    (299) return_stmt -> . RETURN ;
INFO:root:    (300) return_stmt -> . RETURN expression ;
INFO:root:    (323) procedure_call -> . name ;
INFO:root:    (395) delay_stmt -> . DELAY expression ;
INFO:root:    (396) delay_stmt -> . DELAY UNTIL expression ;
INFO:root:    (416) abort_stmt -> . ABORT name_s ;
INFO:root:    (455) raise_stmt -> . RAISE name_opt ;
INFO:root:    (501) code_stmt -> . qualified ;
INFO:root:    (456) requeue_stmt -> . REQUEUE name ;
INFO:root:    (457) requeue_stmt -> . REQUEUE name WITH ABORT ;
INFO:root:    (262) if_stmt -> . IF cond_clause_s else_opt END IF ;
INFO:root:    (270) case_stmt -> . case_hdr pragma_s alternative_s END CASE ;
INFO:root:    (275) loop_stmt -> . label_opt iteration basic_loop id_opt ;
INFO:root:    (287) block -> . label_opt block_decl block_body END id_opt ;
INFO:root:    (390) accept_stmt -> . accept_hdr ;
INFO:root:    (391) accept_stmt -> . accept_hdr DO handled_stmt_s END id_opt ;
INFO:root:    (397) select_stmt -> . select_wait
INFO:root:    (398) select_stmt -> . async_select
INFO:root:    (399) select_stmt -> . timed_entry_call
INFO:root:    (400) select_stmt -> . cond_entry_call
INFO:root:    (149) name -> . simple_name
INFO:root:    (150) name -> . indexed_comp
INFO:root:    (151) name -> . selected_comp
INFO:root:    (152) name -> . attribute
INFO:root:    (153) name -> . operator_symbol
INFO:root:    (233) qualified -> . name TICK parenthesized_primary
INFO:root:    (271) case_hdr -> . CASE expression IS
INFO:root:    (276) label_opt -> .
INFO:root:    (277) label_opt -> . IDENTIFIER :
INFO:root:    (392) accept_hdr -> . ACCEPT entry_name formal_part_opt
INFO:root:    (401) select_wait -> . SELECT guarded_select_alt or_select else_opt END SELECT ;
INFO:root:    (411) async_select -> . SELECT delay_or_entry_alt THEN ABORT statement_s END SELECT ;
INFO:root:    (412) timed_entry_call -> . SELECT entry_call stmts_opt OR delay_stmt stmts_opt END SELECT ;
INFO:root:    (413) cond_entry_call -> . SELECT entry_call stmts_opt ELSE statement_s END SELECT ;
INFO:root:    (157) simple_name -> . IDENTIFIER
INFO:root:    (164) indexed_comp -> . name ( value_s )
INFO:root:    (171) selected_comp -> . name . simple_name
INFO:root:    (172) selected_comp -> . name . used_char
INFO:root:    (173) selected_comp -> . name . operator_symbol
INFO:root:    (174) selected_comp -> . name . ALL
INFO:root:    (175) attribute -> . name TICK attribute_id
INFO:root:    (163) operator_symbol -> . STRING
INFO:root:
INFO:root:    LL              shift and go to state 344
INFO:root:    error           shift and go to state 341
INFO:root:    NuLL            shift and go to state 347
INFO:root:    EXIT            shift and go to state 340
INFO:root:    RETURN          shift and go to state 303
INFO:root:    DELAY           shift and go to state 332
INFO:root:    ABORT           shift and go to state 326
INFO:root:    RAISE           shift and go to state 314
INFO:root:    REQUEUE         shift and go to state 317
INFO:root:    IF              shift and go to state 327
INFO:root:    CASE            shift and go to state 312
INFO:root:    WHILE           reduce using rule 276 (label_opt -> .)
INFO:root:    DECLARE         reduce using rule 276 (label_opt -> .)
INFO:root:    FOR             reduce using rule 276 (label_opt -> .)
INFO:root:    LOOP            reduce using rule 276 (label_opt -> .)
INFO:root:    BEGIN           reduce using rule 276 (label_opt -> .)
INFO:root:    IDENTIFIER      shift and go to state 322
INFO:root:    ACCEPT          shift and go to state 310
INFO:root:    SELECT          shift and go to state 320
INFO:root:    STRING          shift and go to state 149
INFO:root:
INFO:root:    cond_entry_call                shift and go to state 345
INFO:root:    simple_stmt                    shift and go to state 302
INFO:root:    async_select                   shift and go to state 328
INFO:root:    selected_comp                  shift and go to state 139
INFO:root:    simple_name                    shift and go to state 163
INFO:root:    requeue_stmt                   shift and go to state 329
INFO:root:    if_stmt                        shift and go to state 304
INFO:root:    procedure_call                 shift and go to state 305
INFO:root:    exit_stmt                      shift and go to state 306
INFO:root:    timed_entry_call               shift and go to state 307
INFO:root:    statement                      shift and go to state 308
INFO:root:    operator_symbol                shift and go to state 133
INFO:root:    code_stmt                      shift and go to state 331
INFO:root:    loop_stmt                      shift and go to state 333
INFO:root:    null_stmt                      shift and go to state 334
INFO:root:    label                          shift and go to state 335
INFO:root:    select_stmt                    shift and go to state 311
INFO:root:    label_opt                      shift and go to state 313
INFO:root:    assign_stmt                    shift and go to state 336
INFO:root:    select_wait                    shift and go to state 330
INFO:root:    abort_stmt                     shift and go to state 315
INFO:root:    attribute                      shift and go to state 134
INFO:root:    name                           shift and go to state 316
INFO:root:    accept_hdr                     shift and go to state 318
INFO:root:    accept_stmt                    shift and go to state 337
INFO:root:    case_hdr                       shift and go to state 319
INFO:root:    delay_stmt                     shift and go to state 338
INFO:root:    statement_s                    shift and go to state 819
INFO:root:    compound_stmt                  shift and go to state 309
INFO:root:    raise_stmt                     shift and go to state 342
INFO:root:    qualified                      shift and go to state 321
INFO:root:    return_stmt                    shift and go to state 323
INFO:root:    case_stmt                      shift and go to state 324
INFO:root:    block                          shift and go to state 325
INFO:root:    indexed_comp                   shift and go to state 140
INFO:root:    unlabeled                      shift and go to state 346
INFO:root:
INFO:root:state 739
INFO:root:
INFO:root:    (412) timed_entry_call -> SELECT entry_call stmts_opt OR . delay_stmt stmts_opt END SELECT ;
INFO:root:    (395) delay_stmt -> . DELAY expression ;
INFO:root:    (396) delay_stmt -> . DELAY UNTIL expression ;
INFO:root:
INFO:root:    DELAY           shift and go to state 332
INFO:root:
INFO:root:    delay_stmt                     shift and go to state 820
INFO:root:
INFO:root:state 740
INFO:root:
INFO:root:    (405) or_select -> or_select OR . guarded_select_alt
INFO:root:    (402) guarded_select_alt -> . select_alt
INFO:root:    (403) guarded_select_alt -> . WHEN condition ARROW select_alt
INFO:root:    (406) select_alt -> . accept_stmt stmts_opt
INFO:root:    (407) select_alt -> . delay_stmt stmts_opt
INFO:root:    (408) select_alt -> . TERMINATE ;
INFO:root:    (390) accept_stmt -> . accept_hdr ;
INFO:root:    (391) accept_stmt -> . accept_hdr DO handled_stmt_s END id_opt ;
INFO:root:    (395) delay_stmt -> . DELAY expression ;
INFO:root:    (396) delay_stmt -> . DELAY UNTIL expression ;
INFO:root:    (392) accept_hdr -> . ACCEPT entry_name formal_part_opt
INFO:root:
INFO:root:    WHEN            shift and go to state 484
INFO:root:    TERMINATE       shift and go to state 479
INFO:root:    DELAY           shift and go to state 332
INFO:root:    ACCEPT          shift and go to state 310
INFO:root:
INFO:root:    select_alt                     shift and go to state 485
INFO:root:    accept_stmt                    shift and go to state 482
INFO:root:    accept_hdr                     shift and go to state 318
INFO:root:    delay_stmt                     shift and go to state 821
INFO:root:    guarded_select_alt             shift and go to state 822
INFO:root:
INFO:root:state 741
INFO:root:
INFO:root:    (401) select_wait -> SELECT guarded_select_alt or_select else_opt . END SELECT ;
INFO:root:
INFO:root:    END             shift and go to state 823
INFO:root:
INFO:root:
INFO:root:state 742
INFO:root:
INFO:root:    (411) async_select -> SELECT delay_or_entry_alt THEN ABORT . statement_s END SELECT ;
INFO:root:    (236) statement_s -> . statement
INFO:root:    (237) statement_s -> . statement_s statement
INFO:root:    (238) statement -> . unlabeled
INFO:root:    (239) statement -> . label statement
INFO:root:    (240) unlabeled -> . simple_stmt
INFO:root:    (241) unlabeled -> . compound_stmt
INFO:root:    (259) label -> . LL IDENTIFIER RR
INFO:root:    (242) simple_stmt -> . null_stmt
INFO:root:    (243) simple_stmt -> . assign_stmt
INFO:root:    (244) simple_stmt -> . exit_stmt
INFO:root:    (245) simple_stmt -> . return_stmt
INFO:root:    (246) simple_stmt -> . procedure_call
INFO:root:    (247) simple_stmt -> . delay_stmt
INFO:root:    (248) simple_stmt -> . abort_stmt
INFO:root:    (249) simple_stmt -> . raise_stmt
INFO:root:    (250) simple_stmt -> . code_stmt
INFO:root:    (251) simple_stmt -> . requeue_stmt
INFO:root:    (252) simple_stmt -> . error ;
INFO:root:    (253) compound_stmt -> . if_stmt
INFO:root:    (254) compound_stmt -> . case_stmt
INFO:root:    (255) compound_stmt -> . loop_stmt
INFO:root:    (256) compound_stmt -> . block
INFO:root:    (257) compound_stmt -> . accept_stmt
INFO:root:    (258) compound_stmt -> . select_stmt
INFO:root:    (260) null_stmt -> . NuLL ;
INFO:root:    (261) assign_stmt -> . name ASSIGN expression ;
INFO:root:    (294) exit_stmt -> . EXIT name_opt when_opt ;
INFO:root:    (299) return_stmt -> . RETURN ;
INFO:root:    (300) return_stmt -> . RETURN expression ;
INFO:root:    (323) procedure_call -> . name ;
INFO:root:    (395) delay_stmt -> . DELAY expression ;
INFO:root:    (396) delay_stmt -> . DELAY UNTIL expression ;
INFO:root:    (416) abort_stmt -> . ABORT name_s ;
INFO:root:    (455) raise_stmt -> . RAISE name_opt ;
INFO:root:    (501) code_stmt -> . qualified ;
INFO:root:    (456) requeue_stmt -> . REQUEUE name ;
INFO:root:    (457) requeue_stmt -> . REQUEUE name WITH ABORT ;
INFO:root:    (262) if_stmt -> . IF cond_clause_s else_opt END IF ;
INFO:root:    (270) case_stmt -> . case_hdr pragma_s alternative_s END CASE ;
INFO:root:    (275) loop_stmt -> . label_opt iteration basic_loop id_opt ;
INFO:root:    (287) block -> . label_opt block_decl block_body END id_opt ;
INFO:root:    (390) accept_stmt -> . accept_hdr ;
INFO:root:    (391) accept_stmt -> . accept_hdr DO handled_stmt_s END id_opt ;
INFO:root:    (397) select_stmt -> . select_wait
INFO:root:    (398) select_stmt -> . async_select
INFO:root:    (399) select_stmt -> . timed_entry_call
INFO:root:    (400) select_stmt -> . cond_entry_call
INFO:root:    (149) name -> . simple_name
INFO:root:    (150) name -> . indexed_comp
INFO:root:    (151) name -> . selected_comp
INFO:root:    (152) name -> . attribute
INFO:root:    (153) name -> . operator_symbol
INFO:root:    (233) qualified -> . name TICK parenthesized_primary
INFO:root:    (271) case_hdr -> . CASE expression IS
INFO:root:    (276) label_opt -> .
INFO:root:    (277) label_opt -> . IDENTIFIER :
INFO:root:    (392) accept_hdr -> . ACCEPT entry_name formal_part_opt
INFO:root:    (401) select_wait -> . SELECT guarded_select_alt or_select else_opt END SELECT ;
INFO:root:    (411) async_select -> . SELECT delay_or_entry_alt THEN ABORT statement_s END SELECT ;
INFO:root:    (412) timed_entry_call -> . SELECT entry_call stmts_opt OR delay_stmt stmts_opt END SELECT ;
INFO:root:    (413) cond_entry_call -> . SELECT entry_call stmts_opt ELSE statement_s END SELECT ;
INFO:root:    (157) simple_name -> . IDENTIFIER
INFO:root:    (164) indexed_comp -> . name ( value_s )
INFO:root:    (171) selected_comp -> . name . simple_name
INFO:root:    (172) selected_comp -> . name . used_char
INFO:root:    (173) selected_comp -> . name . operator_symbol
INFO:root:    (174) selected_comp -> . name . ALL
INFO:root:    (175) attribute -> . name TICK attribute_id
INFO:root:    (163) operator_symbol -> . STRING
INFO:root:
INFO:root:    LL              shift and go to state 344
INFO:root:    error           shift and go to state 341
INFO:root:    NuLL            shift and go to state 347
INFO:root:    EXIT            shift and go to state 340
INFO:root:    RETURN          shift and go to state 303
INFO:root:    DELAY           shift and go to state 332
INFO:root:    ABORT           shift and go to state 326
INFO:root:    RAISE           shift and go to state 314
INFO:root:    REQUEUE         shift and go to state 317
INFO:root:    IF              shift and go to state 327
INFO:root:    CASE            shift and go to state 312
INFO:root:    WHILE           reduce using rule 276 (label_opt -> .)
INFO:root:    DECLARE         reduce using rule 276 (label_opt -> .)
INFO:root:    FOR             reduce using rule 276 (label_opt -> .)
INFO:root:    LOOP            reduce using rule 276 (label_opt -> .)
INFO:root:    BEGIN           reduce using rule 276 (label_opt -> .)
INFO:root:    IDENTIFIER      shift and go to state 322
INFO:root:    ACCEPT          shift and go to state 310
INFO:root:    SELECT          shift and go to state 320
INFO:root:    STRING          shift and go to state 149
INFO:root:
INFO:root:    cond_entry_call                shift and go to state 345
INFO:root:    simple_stmt                    shift and go to state 302
INFO:root:    async_select                   shift and go to state 328
INFO:root:    simple_name                    shift and go to state 163
INFO:root:    requeue_stmt                   shift and go to state 329
INFO:root:    abort_stmt                     shift and go to state 315
INFO:root:    if_stmt                        shift and go to state 304
INFO:root:    procedure_call                 shift and go to state 305
INFO:root:    select_wait                    shift and go to state 330
INFO:root:    indexed_comp                   shift and go to state 140
INFO:root:    timed_entry_call               shift and go to state 307
INFO:root:    statement                      shift and go to state 308
INFO:root:    operator_symbol                shift and go to state 133
INFO:root:    exit_stmt                      shift and go to state 306
INFO:root:    code_stmt                      shift and go to state 331
INFO:root:    loop_stmt                      shift and go to state 333
INFO:root:    null_stmt                      shift and go to state 334
INFO:root:    label                          shift and go to state 335
INFO:root:    select_stmt                    shift and go to state 311
INFO:root:    label_opt                      shift and go to state 313
INFO:root:    assign_stmt                    shift and go to state 336
INFO:root:    selected_comp                  shift and go to state 139
INFO:root:    attribute                      shift and go to state 134
INFO:root:    name                           shift and go to state 316
INFO:root:    accept_hdr                     shift and go to state 318
INFO:root:    accept_stmt                    shift and go to state 337
INFO:root:    case_hdr                       shift and go to state 319
INFO:root:    delay_stmt                     shift and go to state 338
INFO:root:    statement_s                    shift and go to state 824
INFO:root:    compound_stmt                  shift and go to state 309
INFO:root:    raise_stmt                     shift and go to state 342
INFO:root:    qualified                      shift and go to state 321
INFO:root:    return_stmt                    shift and go to state 323
INFO:root:    case_stmt                      shift and go to state 324
INFO:root:    block                          shift and go to state 325
INFO:root:    unlabeled                      shift and go to state 346
INFO:root:
INFO:root:state 743
INFO:root:
INFO:root:    (403) guarded_select_alt -> WHEN condition ARROW . select_alt
INFO:root:    (406) select_alt -> . accept_stmt stmts_opt
INFO:root:    (407) select_alt -> . delay_stmt stmts_opt
INFO:root:    (408) select_alt -> . TERMINATE ;
INFO:root:    (390) accept_stmt -> . accept_hdr ;
INFO:root:    (391) accept_stmt -> . accept_hdr DO handled_stmt_s END id_opt ;
INFO:root:    (395) delay_stmt -> . DELAY expression ;
INFO:root:    (396) delay_stmt -> . DELAY UNTIL expression ;
INFO:root:    (392) accept_hdr -> . ACCEPT entry_name formal_part_opt
INFO:root:
INFO:root:    TERMINATE       shift and go to state 479
INFO:root:    DELAY           shift and go to state 332
INFO:root:    ACCEPT          shift and go to state 310
INFO:root:
INFO:root:    select_alt                     shift and go to state 825
INFO:root:    accept_stmt                    shift and go to state 482
INFO:root:    accept_hdr                     shift and go to state 318
INFO:root:    delay_stmt                     shift and go to state 821
INFO:root:
INFO:root:state 744
INFO:root:
INFO:root:    (269) else_opt -> ELSE statement_s .
INFO:root:    (237) statement_s -> statement_s . statement
INFO:root:    (238) statement -> . unlabeled
INFO:root:    (239) statement -> . label statement
INFO:root:    (240) unlabeled -> . simple_stmt
INFO:root:    (241) unlabeled -> . compound_stmt
INFO:root:    (259) label -> . LL IDENTIFIER RR
INFO:root:    (242) simple_stmt -> . null_stmt
INFO:root:    (243) simple_stmt -> . assign_stmt
INFO:root:    (244) simple_stmt -> . exit_stmt
INFO:root:    (245) simple_stmt -> . return_stmt
INFO:root:    (246) simple_stmt -> . procedure_call
INFO:root:    (247) simple_stmt -> . delay_stmt
INFO:root:    (248) simple_stmt -> . abort_stmt
INFO:root:    (249) simple_stmt -> . raise_stmt
INFO:root:    (250) simple_stmt -> . code_stmt
INFO:root:    (251) simple_stmt -> . requeue_stmt
INFO:root:    (252) simple_stmt -> . error ;
INFO:root:    (253) compound_stmt -> . if_stmt
INFO:root:    (254) compound_stmt -> . case_stmt
INFO:root:    (255) compound_stmt -> . loop_stmt
INFO:root:    (256) compound_stmt -> . block
INFO:root:    (257) compound_stmt -> . accept_stmt
INFO:root:    (258) compound_stmt -> . select_stmt
INFO:root:    (260) null_stmt -> . NuLL ;
INFO:root:    (261) assign_stmt -> . name ASSIGN expression ;
INFO:root:    (294) exit_stmt -> . EXIT name_opt when_opt ;
INFO:root:    (299) return_stmt -> . RETURN ;
INFO:root:    (300) return_stmt -> . RETURN expression ;
INFO:root:    (323) procedure_call -> . name ;
INFO:root:    (395) delay_stmt -> . DELAY expression ;
INFO:root:    (396) delay_stmt -> . DELAY UNTIL expression ;
INFO:root:    (416) abort_stmt -> . ABORT name_s ;
INFO:root:    (455) raise_stmt -> . RAISE name_opt ;
INFO:root:    (501) code_stmt -> . qualified ;
INFO:root:    (456) requeue_stmt -> . REQUEUE name ;
INFO:root:    (457) requeue_stmt -> . REQUEUE name WITH ABORT ;
INFO:root:    (262) if_stmt -> . IF cond_clause_s else_opt END IF ;
INFO:root:    (270) case_stmt -> . case_hdr pragma_s alternative_s END CASE ;
INFO:root:    (275) loop_stmt -> . label_opt iteration basic_loop id_opt ;
INFO:root:    (287) block -> . label_opt block_decl block_body END id_opt ;
INFO:root:    (390) accept_stmt -> . accept_hdr ;
INFO:root:    (391) accept_stmt -> . accept_hdr DO handled_stmt_s END id_opt ;
INFO:root:    (397) select_stmt -> . select_wait
INFO:root:    (398) select_stmt -> . async_select
INFO:root:    (399) select_stmt -> . timed_entry_call
INFO:root:    (400) select_stmt -> . cond_entry_call
INFO:root:    (149) name -> . simple_name
INFO:root:    (150) name -> . indexed_comp
INFO:root:    (151) name -> . selected_comp
INFO:root:    (152) name -> . attribute
INFO:root:    (153) name -> . operator_symbol
INFO:root:    (233) qualified -> . name TICK parenthesized_primary
INFO:root:    (271) case_hdr -> . CASE expression IS
INFO:root:    (276) label_opt -> .
INFO:root:    (277) label_opt -> . IDENTIFIER :
INFO:root:    (392) accept_hdr -> . ACCEPT entry_name formal_part_opt
INFO:root:    (401) select_wait -> . SELECT guarded_select_alt or_select else_opt END SELECT ;
INFO:root:    (411) async_select -> . SELECT delay_or_entry_alt THEN ABORT statement_s END SELECT ;
INFO:root:    (412) timed_entry_call -> . SELECT entry_call stmts_opt OR delay_stmt stmts_opt END SELECT ;
INFO:root:    (413) cond_entry_call -> . SELECT entry_call stmts_opt ELSE statement_s END SELECT ;
INFO:root:    (157) simple_name -> . IDENTIFIER
INFO:root:    (164) indexed_comp -> . name ( value_s )
INFO:root:    (171) selected_comp -> . name . simple_name
INFO:root:    (172) selected_comp -> . name . used_char
INFO:root:    (173) selected_comp -> . name . operator_symbol
INFO:root:    (174) selected_comp -> . name . ALL
INFO:root:    (175) attribute -> . name TICK attribute_id
INFO:root:    (163) operator_symbol -> . STRING
INFO:root:
INFO:root:    END             reduce using rule 269 (else_opt -> ELSE statement_s .)
INFO:root:    LL              shift and go to state 344
INFO:root:    error           shift and go to state 341
INFO:root:    NuLL            shift and go to state 347
INFO:root:    EXIT            shift and go to state 340
INFO:root:    RETURN          shift and go to state 303
INFO:root:    DELAY           shift and go to state 332
INFO:root:    ABORT           shift and go to state 326
INFO:root:    RAISE           shift and go to state 314
INFO:root:    REQUEUE         shift and go to state 317
INFO:root:    IF              shift and go to state 327
INFO:root:    CASE            shift and go to state 312
INFO:root:    WHILE           reduce using rule 276 (label_opt -> .)
INFO:root:    DECLARE         reduce using rule 276 (label_opt -> .)
INFO:root:    FOR             reduce using rule 276 (label_opt -> .)
INFO:root:    LOOP            reduce using rule 276 (label_opt -> .)
INFO:root:    BEGIN           reduce using rule 276 (label_opt -> .)
INFO:root:    IDENTIFIER      shift and go to state 322
INFO:root:    ACCEPT          shift and go to state 310
INFO:root:    SELECT          shift and go to state 320
INFO:root:    STRING          shift and go to state 149
INFO:root:
INFO:root:    cond_entry_call                shift and go to state 345
INFO:root:    simple_stmt                    shift and go to state 302
INFO:root:    async_select                   shift and go to state 328
INFO:root:    simple_name                    shift and go to state 163
INFO:root:    requeue_stmt                   shift and go to state 329
INFO:root:    if_stmt                        shift and go to state 304
INFO:root:    procedure_call                 shift and go to state 305
INFO:root:    select_wait                    shift and go to state 330
INFO:root:    indexed_comp                   shift and go to state 140
INFO:root:    timed_entry_call               shift and go to state 307
INFO:root:    statement                      shift and go to state 497
INFO:root:    operator_symbol                shift and go to state 133
INFO:root:    exit_stmt                      shift and go to state 306
INFO:root:    code_stmt                      shift and go to state 331
INFO:root:    loop_stmt                      shift and go to state 333
INFO:root:    null_stmt                      shift and go to state 334
INFO:root:    label                          shift and go to state 335
INFO:root:    select_stmt                    shift and go to state 311
INFO:root:    label_opt                      shift and go to state 313
INFO:root:    assign_stmt                    shift and go to state 336
INFO:root:    selected_comp                  shift and go to state 139
INFO:root:    abort_stmt                     shift and go to state 315
INFO:root:    attribute                      shift and go to state 134
INFO:root:    name                           shift and go to state 316
INFO:root:    accept_hdr                     shift and go to state 318
INFO:root:    accept_stmt                    shift and go to state 337
INFO:root:    case_hdr                       shift and go to state 319
INFO:root:    delay_stmt                     shift and go to state 338
INFO:root:    compound_stmt                  shift and go to state 309
INFO:root:    raise_stmt                     shift and go to state 342
INFO:root:    qualified                      shift and go to state 321
INFO:root:    return_stmt                    shift and go to state 323
INFO:root:    case_stmt                      shift and go to state 324
INFO:root:    block                          shift and go to state 325
INFO:root:    unlabeled                      shift and go to state 346
INFO:root:
INFO:root:state 745
INFO:root:
INFO:root:    (262) if_stmt -> IF cond_clause_s else_opt END . IF ;
INFO:root:
INFO:root:    IF              shift and go to state 826
INFO:root:
INFO:root:
INFO:root:state 746
INFO:root:
INFO:root:    (264) cond_clause_s -> cond_clause_s ELSIF cond_clause .
INFO:root:
INFO:root:    ELSIF           reduce using rule 264 (cond_clause_s -> cond_clause_s ELSIF cond_clause .)
INFO:root:    ELSE            reduce using rule 264 (cond_clause_s -> cond_clause_s ELSIF cond_clause .)
INFO:root:    END             reduce using rule 264 (cond_clause_s -> cond_clause_s ELSIF cond_clause .)
INFO:root:
INFO:root:
INFO:root:state 747
INFO:root:
INFO:root:    (396) delay_stmt -> DELAY UNTIL expression ; .
INFO:root:
INFO:root:    LL              reduce using rule 396 (delay_stmt -> DELAY UNTIL expression ; .)
INFO:root:    error           reduce using rule 396 (delay_stmt -> DELAY UNTIL expression ; .)
INFO:root:    NuLL            reduce using rule 396 (delay_stmt -> DELAY UNTIL expression ; .)
INFO:root:    EXIT            reduce using rule 396 (delay_stmt -> DELAY UNTIL expression ; .)
INFO:root:    RETURN          reduce using rule 396 (delay_stmt -> DELAY UNTIL expression ; .)
INFO:root:    DELAY           reduce using rule 396 (delay_stmt -> DELAY UNTIL expression ; .)
INFO:root:    ABORT           reduce using rule 396 (delay_stmt -> DELAY UNTIL expression ; .)
INFO:root:    RAISE           reduce using rule 396 (delay_stmt -> DELAY UNTIL expression ; .)
INFO:root:    REQUEUE         reduce using rule 396 (delay_stmt -> DELAY UNTIL expression ; .)
INFO:root:    IF              reduce using rule 396 (delay_stmt -> DELAY UNTIL expression ; .)
INFO:root:    CASE            reduce using rule 396 (delay_stmt -> DELAY UNTIL expression ; .)
INFO:root:    IDENTIFIER      reduce using rule 396 (delay_stmt -> DELAY UNTIL expression ; .)
INFO:root:    ACCEPT          reduce using rule 396 (delay_stmt -> DELAY UNTIL expression ; .)
INFO:root:    SELECT          reduce using rule 396 (delay_stmt -> DELAY UNTIL expression ; .)
INFO:root:    STRING          reduce using rule 396 (delay_stmt -> DELAY UNTIL expression ; .)
INFO:root:    WHILE           reduce using rule 396 (delay_stmt -> DELAY UNTIL expression ; .)
INFO:root:    DECLARE         reduce using rule 396 (delay_stmt -> DELAY UNTIL expression ; .)
INFO:root:    FOR             reduce using rule 396 (delay_stmt -> DELAY UNTIL expression ; .)
INFO:root:    LOOP            reduce using rule 396 (delay_stmt -> DELAY UNTIL expression ; .)
INFO:root:    BEGIN           reduce using rule 396 (delay_stmt -> DELAY UNTIL expression ; .)
INFO:root:    WHEN            reduce using rule 396 (delay_stmt -> DELAY UNTIL expression ; .)
INFO:root:    END             reduce using rule 396 (delay_stmt -> DELAY UNTIL expression ; .)
INFO:root:    OR              reduce using rule 396 (delay_stmt -> DELAY UNTIL expression ; .)
INFO:root:    ELSE            reduce using rule 396 (delay_stmt -> DELAY UNTIL expression ; .)
INFO:root:    EXCEPTION       reduce using rule 396 (delay_stmt -> DELAY UNTIL expression ; .)
INFO:root:    ELSIF           reduce using rule 396 (delay_stmt -> DELAY UNTIL expression ; .)
INFO:root:    THEN            reduce using rule 396 (delay_stmt -> DELAY UNTIL expression ; .)
INFO:root:
INFO:root:
INFO:root:state 748
INFO:root:
INFO:root:    (453) except_choice -> name .
INFO:root:    (164) indexed_comp -> name . ( value_s )
INFO:root:    (171) selected_comp -> name . . simple_name
INFO:root:    (172) selected_comp -> name . . used_char
INFO:root:    (173) selected_comp -> name . . operator_symbol
INFO:root:    (174) selected_comp -> name . . ALL
INFO:root:    (175) attribute -> name . TICK attribute_id
INFO:root:
INFO:root:    ARROW           reduce using rule 453 (except_choice -> name .)
INFO:root:    |               reduce using rule 453 (except_choice -> name .)
INFO:root:    (               shift and go to state 237
INFO:root:    .               shift and go to state 239
INFO:root:    TICK            shift and go to state 260
INFO:root:
INFO:root:
INFO:root:state 749
INFO:root:
INFO:root:    (454) except_choice -> OTHERS .
INFO:root:
INFO:root:    ARROW           reduce using rule 454 (except_choice -> OTHERS .)
INFO:root:    |               reduce using rule 454 (except_choice -> OTHERS .)
INFO:root:
INFO:root:
INFO:root:state 750
INFO:root:
INFO:root:    (449) exception_handler -> WHEN except_choice_s . ARROW statement_s
INFO:root:    (452) except_choice_s -> except_choice_s . | except_choice
INFO:root:
INFO:root:    ARROW           shift and go to state 827
INFO:root:    |               shift and go to state 828
INFO:root:
INFO:root:
INFO:root:state 751
INFO:root:
INFO:root:    (451) except_choice_s -> except_choice .
INFO:root:
INFO:root:    ARROW           reduce using rule 451 (except_choice_s -> except_choice .)
INFO:root:    |               reduce using rule 451 (except_choice_s -> except_choice .)
INFO:root:
INFO:root:
INFO:root:state 752
INFO:root:
INFO:root:    (450) exception_handler -> WHEN IDENTIFIER . : except_choice_s ARROW statement_s
INFO:root:    (157) simple_name -> IDENTIFIER .
INFO:root:
INFO:root:    :               shift and go to state 829
INFO:root:    (               reduce using rule 157 (simple_name -> IDENTIFIER .)
INFO:root:    .               reduce using rule 157 (simple_name -> IDENTIFIER .)
INFO:root:    TICK            reduce using rule 157 (simple_name -> IDENTIFIER .)
INFO:root:    ARROW           reduce using rule 157 (simple_name -> IDENTIFIER .)
INFO:root:    |               reduce using rule 157 (simple_name -> IDENTIFIER .)
INFO:root:
INFO:root:
INFO:root:state 753
INFO:root:
INFO:root:    (294) exit_stmt -> EXIT name_opt when_opt ; .
INFO:root:
INFO:root:    END             reduce using rule 294 (exit_stmt -> EXIT name_opt when_opt ; .)
INFO:root:    LL              reduce using rule 294 (exit_stmt -> EXIT name_opt when_opt ; .)
INFO:root:    error           reduce using rule 294 (exit_stmt -> EXIT name_opt when_opt ; .)
INFO:root:    NuLL            reduce using rule 294 (exit_stmt -> EXIT name_opt when_opt ; .)
INFO:root:    EXIT            reduce using rule 294 (exit_stmt -> EXIT name_opt when_opt ; .)
INFO:root:    RETURN          reduce using rule 294 (exit_stmt -> EXIT name_opt when_opt ; .)
INFO:root:    DELAY           reduce using rule 294 (exit_stmt -> EXIT name_opt when_opt ; .)
INFO:root:    ABORT           reduce using rule 294 (exit_stmt -> EXIT name_opt when_opt ; .)
INFO:root:    RAISE           reduce using rule 294 (exit_stmt -> EXIT name_opt when_opt ; .)
INFO:root:    REQUEUE         reduce using rule 294 (exit_stmt -> EXIT name_opt when_opt ; .)
INFO:root:    IF              reduce using rule 294 (exit_stmt -> EXIT name_opt when_opt ; .)
INFO:root:    CASE            reduce using rule 294 (exit_stmt -> EXIT name_opt when_opt ; .)
INFO:root:    IDENTIFIER      reduce using rule 294 (exit_stmt -> EXIT name_opt when_opt ; .)
INFO:root:    ACCEPT          reduce using rule 294 (exit_stmt -> EXIT name_opt when_opt ; .)
INFO:root:    SELECT          reduce using rule 294 (exit_stmt -> EXIT name_opt when_opt ; .)
INFO:root:    STRING          reduce using rule 294 (exit_stmt -> EXIT name_opt when_opt ; .)
INFO:root:    WHILE           reduce using rule 294 (exit_stmt -> EXIT name_opt when_opt ; .)
INFO:root:    DECLARE         reduce using rule 294 (exit_stmt -> EXIT name_opt when_opt ; .)
INFO:root:    FOR             reduce using rule 294 (exit_stmt -> EXIT name_opt when_opt ; .)
INFO:root:    LOOP            reduce using rule 294 (exit_stmt -> EXIT name_opt when_opt ; .)
INFO:root:    BEGIN           reduce using rule 294 (exit_stmt -> EXIT name_opt when_opt ; .)
INFO:root:    WHEN            reduce using rule 294 (exit_stmt -> EXIT name_opt when_opt ; .)
INFO:root:    EXCEPTION       reduce using rule 294 (exit_stmt -> EXIT name_opt when_opt ; .)
INFO:root:    THEN            reduce using rule 294 (exit_stmt -> EXIT name_opt when_opt ; .)
INFO:root:    OR              reduce using rule 294 (exit_stmt -> EXIT name_opt when_opt ; .)
INFO:root:    ELSE            reduce using rule 294 (exit_stmt -> EXIT name_opt when_opt ; .)
INFO:root:    ELSIF           reduce using rule 294 (exit_stmt -> EXIT name_opt when_opt ; .)
INFO:root:
INFO:root:
INFO:root:state 754
INFO:root:
INFO:root:    (298) when_opt -> WHEN condition .
INFO:root:
INFO:root:    ;               reduce using rule 298 (when_opt -> WHEN condition .)
INFO:root:
INFO:root:
INFO:root:state 755
INFO:root:
INFO:root:    (185) aggregate -> ( expression WITH NuLL RECORD ) .
INFO:root:
INFO:root:    *               reduce using rule 185 (aggregate -> ( expression WITH NuLL RECORD ) .)
INFO:root:    /               reduce using rule 185 (aggregate -> ( expression WITH NuLL RECORD ) .)
INFO:root:    MOD             reduce using rule 185 (aggregate -> ( expression WITH NuLL RECORD ) .)
INFO:root:    REM             reduce using rule 185 (aggregate -> ( expression WITH NuLL RECORD ) .)
INFO:root:    STARSTAR        reduce using rule 185 (aggregate -> ( expression WITH NuLL RECORD ) .)
INFO:root:    =               reduce using rule 185 (aggregate -> ( expression WITH NuLL RECORD ) .)
INFO:root:    NEQ             reduce using rule 185 (aggregate -> ( expression WITH NuLL RECORD ) .)
INFO:root:    <               reduce using rule 185 (aggregate -> ( expression WITH NuLL RECORD ) .)
INFO:root:    LEQ             reduce using rule 185 (aggregate -> ( expression WITH NuLL RECORD ) .)
INFO:root:    >               reduce using rule 185 (aggregate -> ( expression WITH NuLL RECORD ) .)
INFO:root:    GEQ             reduce using rule 185 (aggregate -> ( expression WITH NuLL RECORD ) .)
INFO:root:    IN              reduce using rule 185 (aggregate -> ( expression WITH NuLL RECORD ) .)
INFO:root:    NOT             reduce using rule 185 (aggregate -> ( expression WITH NuLL RECORD ) .)
INFO:root:    +               reduce using rule 185 (aggregate -> ( expression WITH NuLL RECORD ) .)
INFO:root:    -               reduce using rule 185 (aggregate -> ( expression WITH NuLL RECORD ) .)
INFO:root:    &               reduce using rule 185 (aggregate -> ( expression WITH NuLL RECORD ) .)
INFO:root:    AND             reduce using rule 185 (aggregate -> ( expression WITH NuLL RECORD ) .)
INFO:root:    OR              reduce using rule 185 (aggregate -> ( expression WITH NuLL RECORD ) .)
INFO:root:    XOR             reduce using rule 185 (aggregate -> ( expression WITH NuLL RECORD ) .)
INFO:root:    RANGE           reduce using rule 185 (aggregate -> ( expression WITH NuLL RECORD ) .)
INFO:root:    RENAMES         reduce using rule 185 (aggregate -> ( expression WITH NuLL RECORD ) .)
INFO:root:    ASSIGN          reduce using rule 185 (aggregate -> ( expression WITH NuLL RECORD ) .)
INFO:root:    ;               reduce using rule 185 (aggregate -> ( expression WITH NuLL RECORD ) .)
INFO:root:    WITH            reduce using rule 185 (aggregate -> ( expression WITH NuLL RECORD ) .)
INFO:root:    DOTDOT          reduce using rule 185 (aggregate -> ( expression WITH NuLL RECORD ) .)
INFO:root:    IS              reduce using rule 185 (aggregate -> ( expression WITH NuLL RECORD ) .)
INFO:root:    )               reduce using rule 185 (aggregate -> ( expression WITH NuLL RECORD ) .)
INFO:root:    ,               reduce using rule 185 (aggregate -> ( expression WITH NuLL RECORD ) .)
INFO:root:    ARROW           reduce using rule 185 (aggregate -> ( expression WITH NuLL RECORD ) .)
INFO:root:    |               reduce using rule 185 (aggregate -> ( expression WITH NuLL RECORD ) .)
INFO:root:    THEN            reduce using rule 185 (aggregate -> ( expression WITH NuLL RECORD ) .)
INFO:root:    LOOP            reduce using rule 185 (aggregate -> ( expression WITH NuLL RECORD ) .)
INFO:root:    DIGITS          reduce using rule 185 (aggregate -> ( expression WITH NuLL RECORD ) .)
INFO:root:
INFO:root:
INFO:root:state 756
INFO:root:
INFO:root:    (465) generic_formal -> WITH FUNCTION designator formal_part_opt RETURN name subp_default . ;
INFO:root:
INFO:root:    ;               shift and go to state 830
INFO:root:
INFO:root:
INFO:root:state 757
INFO:root:
INFO:root:    (466) generic_formal -> WITH PACKAGE simple_name IS NEW name ( . BOX ) ;
INFO:root:    (164) indexed_comp -> name ( . value_s )
INFO:root:    (165) value_s -> . value
INFO:root:    (166) value_s -> . value_s , value
INFO:root:    (167) value -> . expression
INFO:root:    (168) value -> . comp_assoc
INFO:root:    (169) value -> . discrete_with_range
INFO:root:    (170) value -> . error
INFO:root:    (188) expression -> . relation
INFO:root:    (189) expression -> . expression logical relation
INFO:root:    (190) expression -> . expression short_circuit relation
INFO:root:    (187) comp_assoc -> . choice_s ARROW expression
INFO:root:    (126) discrete_with_range -> . name range_constraint
INFO:root:    (127) discrete_with_range -> . range
INFO:root:    (196) relation -> . simple_expression
INFO:root:    (197) relation -> . simple_expression relational simple_expression
INFO:root:    (198) relation -> . simple_expression membership range
INFO:root:    (199) relation -> . simple_expression membership name
INFO:root:    (121) choice_s -> . choice
INFO:root:    (122) choice_s -> . choice_s | choice
INFO:root:    (149) name -> . simple_name
INFO:root:    (150) name -> . indexed_comp
INFO:root:    (151) name -> . selected_comp
INFO:root:    (152) name -> . attribute
INFO:root:    (153) name -> . operator_symbol
INFO:root:    (62) range -> . simple_expression DOTDOT simple_expression
INFO:root:    (208) simple_expression -> . unary term
INFO:root:    (209) simple_expression -> . term
INFO:root:    (210) simple_expression -> . simple_expression adding term
INFO:root:    (123) choice -> . expression
INFO:root:    (124) choice -> . discrete_with_range
INFO:root:    (125) choice -> . OTHERS
INFO:root:    (157) simple_name -> . IDENTIFIER
INFO:root:    (164) indexed_comp -> . name ( value_s )
INFO:root:    (171) selected_comp -> . name . simple_name
INFO:root:    (172) selected_comp -> . name . used_char
INFO:root:    (173) selected_comp -> . name . operator_symbol
INFO:root:    (174) selected_comp -> . name . ALL
INFO:root:    (175) attribute -> . name TICK attribute_id
INFO:root:    (163) operator_symbol -> . STRING
INFO:root:    (211) unary -> . +
INFO:root:    (212) unary -> . -
INFO:root:    (216) term -> . factor
INFO:root:    (217) term -> . term multiplying factor
INFO:root:    (223) factor -> . primary
INFO:root:    (224) factor -> . NOT primary
INFO:root:    (225) factor -> . ABS primary
INFO:root:    (226) primary -> . literal
INFO:root:    (227) primary -> . name
INFO:root:    (228) primary -> . allocator
INFO:root:    (229) primary -> . qualified
INFO:root:    (230) primary -> . parenthesized_primary
INFO:root:    (180) literal -> . INT
INFO:root:    (181) literal -> . FLOAT
INFO:root:    (182) literal -> . NuLL
INFO:root:    (234) allocator -> . NEW name
INFO:root:    (235) allocator -> . NEW qualified
INFO:root:    (233) qualified -> . name TICK parenthesized_primary
INFO:root:    (231) parenthesized_primary -> . aggregate
INFO:root:    (232) parenthesized_primary -> . ( expression )
INFO:root:    (183) aggregate -> . ( comp_assoc )
INFO:root:    (184) aggregate -> . ( expression WITH value_s )
INFO:root:    (185) aggregate -> . ( expression WITH NuLL RECORD )
INFO:root:    (186) aggregate -> . ( NuLL RECORD )
INFO:root:
INFO:root:    BOX             shift and go to state 831
INFO:root:    error           shift and go to state 379
INFO:root:    OTHERS          shift and go to state 204
INFO:root:    IDENTIFIER      shift and go to state 33
INFO:root:    STRING          shift and go to state 149
INFO:root:    +               shift and go to state 148
INFO:root:    -               shift and go to state 136
INFO:root:    NOT             shift and go to state 131
INFO:root:    ABS             shift and go to state 132
INFO:root:    INT             shift and go to state 120
INFO:root:    FLOAT           shift and go to state 128
INFO:root:    NuLL            shift and go to state 130
INFO:root:    NEW             shift and go to state 137
INFO:root:    (               shift and go to state 125
INFO:root:
INFO:root:    value                          shift and go to state 372
INFO:root:    comp_assoc                     shift and go to state 376
INFO:root:    factor                         shift and go to state 126
INFO:root:    indexed_comp                   shift and go to state 140
INFO:root:    name                           shift and go to state 377
INFO:root:    literal                        shift and go to state 121
INFO:root:    selected_comp                  shift and go to state 139
INFO:root:    simple_name                    shift and go to state 163
INFO:root:    expression                     shift and go to state 373
INFO:root:    discrete_with_range            shift and go to state 378
INFO:root:    parenthesized_primary          shift and go to state 147
INFO:root:    unary                          shift and go to state 144
INFO:root:    term                           shift and go to state 146
INFO:root:    aggregate                      shift and go to state 143
INFO:root:    simple_expression              shift and go to state 374
INFO:root:    value_s                        shift and go to state 375
INFO:root:    operator_symbol                shift and go to state 133
INFO:root:    qualified                      shift and go to state 145
INFO:root:    choice_s                       shift and go to state 202
INFO:root:    primary                        shift and go to state 135
INFO:root:    attribute                      shift and go to state 134
INFO:root:    relation                       shift and go to state 138
INFO:root:    range                          shift and go to state 211
INFO:root:    allocator                      shift and go to state 122
INFO:root:    choice                         shift and go to state 207
INFO:root:
INFO:root:state 758
INFO:root:
INFO:root:    (467) generic_formal -> WITH PACKAGE simple_name IS NEW name ; .
INFO:root:
INFO:root:    PACKAGE         reduce using rule 467 (generic_formal -> WITH PACKAGE simple_name IS NEW name ; .)
INFO:root:    PROCEDURE       reduce using rule 467 (generic_formal -> WITH PACKAGE simple_name IS NEW name ; .)
INFO:root:    FUNCTION        reduce using rule 467 (generic_formal -> WITH PACKAGE simple_name IS NEW name ; .)
INFO:root:    TYPE            reduce using rule 467 (generic_formal -> WITH PACKAGE simple_name IS NEW name ; .)
INFO:root:    WITH            reduce using rule 467 (generic_formal -> WITH PACKAGE simple_name IS NEW name ; .)
INFO:root:    error           reduce using rule 467 (generic_formal -> WITH PACKAGE simple_name IS NEW name ; .)
INFO:root:    USE             reduce using rule 467 (generic_formal -> WITH PACKAGE simple_name IS NEW name ; .)
INFO:root:    IDENTIFIER      reduce using rule 467 (generic_formal -> WITH PACKAGE simple_name IS NEW name ; .)
INFO:root:
INFO:root:
INFO:root:state 759
INFO:root:
INFO:root:    (113) discrim_spec -> def_id_s : access_opt mark . init_opt
INFO:root:    (155) mark -> mark . TICK attribute_id
INFO:root:    (156) mark -> mark . . simple_name
INFO:root:    (33) init_opt -> .
INFO:root:    (34) init_opt -> . ASSIGN expression
INFO:root:
INFO:root:    TICK            shift and go to state 300
INFO:root:    .               shift and go to state 298
INFO:root:    )               reduce using rule 33 (init_opt -> .)
INFO:root:    ;               reduce using rule 33 (init_opt -> .)
INFO:root:    ASSIGN          shift and go to state 540
INFO:root:
INFO:root:    init_opt                       shift and go to state 832
INFO:root:
INFO:root:state 760
INFO:root:
INFO:root:    (475) generic_type_def -> ( BOX ) .
INFO:root:
INFO:root:    ;               reduce using rule 475 (generic_type_def -> ( BOX ) .)
INFO:root:
INFO:root:
INFO:root:state 761
INFO:root:
INFO:root:    (487) generic_derived_type -> ABSTRACT NEW subtype_ind . WITH PRIVATE
INFO:root:
INFO:root:    WITH            shift and go to state 833
INFO:root:
INFO:root:
INFO:root:state 762
INFO:root:
INFO:root:    (129) access_type -> ACCESS CONSTANT subtype_ind .
INFO:root:
INFO:root:    ;               reduce using rule 129 (access_type -> ACCESS CONSTANT subtype_ind .)
INFO:root:
INFO:root:
INFO:root:state 763
INFO:root:
INFO:root:    (130) access_type -> ACCESS ALL subtype_ind .
INFO:root:
INFO:root:    ;               reduce using rule 130 (access_type -> ACCESS ALL subtype_ind .)
INFO:root:
INFO:root:
INFO:root:state 764
INFO:root:
INFO:root:    (479) generic_type_def -> DELTA BOX DIGITS . BOX
INFO:root:
INFO:root:    BOX             shift and go to state 834
INFO:root:
INFO:root:
INFO:root:state 765
INFO:root:
INFO:root:    (334) private_type -> tagged_opt limited_opt PRIVATE .
INFO:root:
INFO:root:    ;               reduce using rule 334 (private_type -> tagged_opt limited_opt PRIVATE .)
INFO:root:
INFO:root:
INFO:root:state 766
INFO:root:
INFO:root:    (486) generic_derived_type -> NEW subtype_ind WITH . PRIVATE
INFO:root:
INFO:root:    PRIVATE         shift and go to state 835
INFO:root:
INFO:root:
INFO:root:state 767
INFO:root:
INFO:root:    (356) task_body -> TASK BODY simple_name IS . decl_part block_body END id_opt ;
INFO:root:    (131) decl_part -> .
INFO:root:    (132) decl_part -> . decl_item_or_body_s1
INFO:root:    (141) decl_item_or_body_s1 -> . decl_item_or_body
INFO:root:    (142) decl_item_or_body_s1 -> . decl_item_or_body_s1 decl_item_or_body
INFO:root:    (143) decl_item_or_body -> . body
INFO:root:    (144) decl_item_or_body -> . decl_item
INFO:root:    (145) body -> . subprog_body
INFO:root:    (146) body -> . pkg_body
INFO:root:    (147) body -> . task_body
INFO:root:    (148) body -> . prot_body
INFO:root:    (137) decl_item -> . decl
INFO:root:    (138) decl_item -> . use_clause
INFO:root:    (139) decl_item -> . rep_spec
INFO:root:    (140) decl_item -> . pragma
INFO:root:    (322) subprog_body -> . subprog_spec_is_push decl_part block_body END id_opt ;
INFO:root:    (331) pkg_body -> . PACKAGE BODY compound_name IS decl_part body_opt END c_id_opt ;
INFO:root:    (356) task_body -> . TASK BODY simple_name IS decl_part block_body END id_opt ;
INFO:root:    (373) prot_body -> . PROTECTED BODY simple_name IS prot_op_body_s END id_opt ;
INFO:root:    (10) decl -> . object_decl
INFO:root:    (11) decl -> . number_decl
INFO:root:    (12) decl -> . type_decl
INFO:root:    (13) decl -> . subtype_decl
INFO:root:    (14) decl -> . subprog_decl
INFO:root:    (15) decl -> . pkg_decl
INFO:root:    (16) decl -> . task_decl
INFO:root:    (17) decl -> . prot_decl
INFO:root:    (18) decl -> . exception_decl
INFO:root:    (19) decl -> . rename_decl
INFO:root:    (20) decl -> . generic_decl
INFO:root:    (21) decl -> . body_stub
INFO:root:    (22) decl -> . error ;
INFO:root:    (337) use_clause -> . USE name_s ;
INFO:root:    (338) use_clause -> . USE TYPE name_s ;
INFO:root:    (491) rep_spec -> . attrib_def
INFO:root:    (492) rep_spec -> . record_type_spec
INFO:root:    (493) rep_spec -> . address_spec
INFO:root:    (2) pragma -> . PRAGMA IDENTIFIER ;
INFO:root:    (3) pragma -> . PRAGMA simple_name ( pragma_arg_s ) ;
INFO:root:    (321) subprog_spec_is_push -> . subprog_spec IS
INFO:root:    (23) object_decl -> . def_id_s : object_qualifier_opt object_subtype_def init_opt ;
INFO:root:    (35) number_decl -> . def_id_s : CONSTANT ASSIGN expression ;
INFO:root:    (36) type_decl -> . TYPE IDENTIFIER discrim_part_opt type_completion ;
INFO:root:    (50) subtype_decl -> . SUBTYPE IDENTIFIER IS subtype_ind ;
INFO:root:    (301) subprog_decl -> . subprog_spec ;
INFO:root:    (302) subprog_decl -> . generic_subp_inst ;
INFO:root:    (303) subprog_decl -> . subprog_spec_is_push ABSTRACT ;
INFO:root:    (324) pkg_decl -> . pkg_spec ;
INFO:root:    (325) pkg_decl -> . generic_pkg_inst ;
INFO:root:    (349) task_decl -> . task_spec ;
INFO:root:    (357) prot_decl -> . prot_spec ;
INFO:root:    (446) exception_decl -> . def_id_s : EXCEPTION ;
INFO:root:    (341) rename_decl -> . def_id_s : object_qualifier_opt subtype_ind renames ;
INFO:root:    (342) rename_decl -> . def_id_s : EXCEPTION renames ;
INFO:root:    (343) rename_decl -> . rename_unit
INFO:root:    (458) generic_decl -> . generic_formal_part subprog_spec ;
INFO:root:    (459) generic_decl -> . generic_formal_part pkg_spec ;
INFO:root:    (442) body_stub -> . TASK BODY simple_name IS SEPARATE ;
INFO:root:    (443) body_stub -> . PACKAGE BODY compound_name IS SEPARATE ;
INFO:root:    (444) body_stub -> . subprog_spec IS SEPARATE ;
INFO:root:    (445) body_stub -> . PROTECTED BODY simple_name IS SEPARATE ;
INFO:root:    (494) attrib_def -> . FOR mark USE expression ;
INFO:root:    (495) record_type_spec -> . FOR mark USE RECORD align_opt comp_loc_s END RECORD ;
INFO:root:    (500) address_spec -> . FOR mark USE AT expression ;
INFO:root:    (304) subprog_spec -> . PROCEDURE compound_name formal_part_opt
INFO:root:    (305) subprog_spec -> . FUNCTION designator formal_part_opt RETURN name
INFO:root:    (306) subprog_spec -> . FUNCTION designator
INFO:root:    (24) def_id_s -> . def_id
INFO:root:    (25) def_id_s -> . def_id_s , def_id
INFO:root:    (488) generic_subp_inst -> . subprog_spec IS generic_inst
INFO:root:    (326) pkg_spec -> . PACKAGE compound_name IS decl_item_s private_part END c_id_opt
INFO:root:    (489) generic_pkg_inst -> . PACKAGE compound_name IS generic_inst
INFO:root:    (350) task_spec -> . TASK simple_name task_def
INFO:root:    (351) task_spec -> . TASK TYPE simple_name discrim_part_opt task_def
INFO:root:    (358) prot_spec -> . PROTECTED IDENTIFIER prot_def
INFO:root:    (359) prot_spec -> . PROTECTED TYPE simple_name discrim_part_opt prot_def
INFO:root:    (344) rename_unit -> . PACKAGE compound_name renames ;
INFO:root:    (345) rename_unit -> . subprog_spec renames ;
INFO:root:    (346) rename_unit -> . generic_formal_part PACKAGE compound_name renames ;
INFO:root:    (347) rename_unit -> . generic_formal_part subprog_spec renames ;
INFO:root:    (460) generic_formal_part -> . GENERIC
INFO:root:    (461) generic_formal_part -> . generic_formal_part generic_formal
INFO:root:    (26) def_id -> . IDENTIFIER
INFO:root:
INFO:root:    BEGIN           reduce using rule 131 (decl_part -> .)
INFO:root:    PACKAGE         shift and go to state 73
INFO:root:    TASK            shift and go to state 84
INFO:root:    PROTECTED       shift and go to state 99
INFO:root:    error           shift and go to state 107
INFO:root:    USE             shift and go to state 53
INFO:root:    PRAGMA          shift and go to state 2
INFO:root:    TYPE            shift and go to state 74
INFO:root:    SUBTYPE         shift and go to state 110
INFO:root:    FOR             shift and go to state 102
INFO:root:    PROCEDURE       shift and go to state 17
INFO:root:    FUNCTION        shift and go to state 23
INFO:root:    GENERIC         shift and go to state 26
INFO:root:    IDENTIFIER      shift and go to state 52
INFO:root:
INFO:root:    generic_formal_part            shift and go to state 20
INFO:root:    pkg_decl                       shift and go to state 93
INFO:root:    pragma                         shift and go to state 94
INFO:root:    generic_pkg_inst               shift and go to state 19
INFO:root:    prot_decl                      shift and go to state 95
INFO:root:    body                           shift and go to state 75
INFO:root:    task_decl                      shift and go to state 76
INFO:root:    generic_decl                   shift and go to state 88
INFO:root:    subprog_decl                   shift and go to state 77
INFO:root:    type_decl                      shift and go to state 81
INFO:root:    def_id_s                       shift and go to state 79
INFO:root:    def_id                         shift and go to state 57
INFO:root:    rep_spec                       shift and go to state 72
INFO:root:    use_clause                     shift and go to state 97
INFO:root:    rename_decl                    shift and go to state 98
INFO:root:    body_stub                      shift and go to state 80
INFO:root:    address_spec                   shift and go to state 83
INFO:root:    task_spec                      shift and go to state 82
INFO:root:    number_decl                    shift and go to state 101
INFO:root:    generic_subp_inst              shift and go to state 24
INFO:root:    decl_item_or_body_s1           shift and go to state 103
INFO:root:    prot_spec                      shift and go to state 85
INFO:root:    rename_unit                    shift and go to state 104
INFO:root:    subprog_spec                   shift and go to state 86
INFO:root:    object_decl                    shift and go to state 87
INFO:root:    subtype_decl                   shift and go to state 105
INFO:root:    task_body                      shift and go to state 96
INFO:root:    prot_body                      shift and go to state 100
INFO:root:    pkg_body                       shift and go to state 90
INFO:root:    decl_part                      shift and go to state 587
INFO:root:    pkg_spec                       shift and go to state 16
INFO:root:    record_type_spec               shift and go to state 108
INFO:root:    decl                           shift and go to state 109
INFO:root:    decl_item                      shift and go to state 78
INFO:root:    exception_decl                 shift and go to state 91
INFO:root:    subprog_body                   shift and go to state 113
INFO:root:    attrib_def                     shift and go to state 92
INFO:root:    subprog_spec_is_push           shift and go to state 111
INFO:root:    decl_item_or_body              shift and go to state 112
INFO:root:
INFO:root:state 768
INFO:root:
INFO:root:    (373) prot_body -> PROTECTED BODY simple_name IS . prot_op_body_s END id_opt ;
INFO:root:    (374) prot_op_body_s -> . pragma_s
INFO:root:    (375) prot_op_body_s -> . prot_op_body_s prot_op_body pragma_s
INFO:root:    (8) pragma_s -> .
INFO:root:    (9) pragma_s -> . pragma_s pragma
INFO:root:
INFO:root:    PRAGMA          reduce using rule 8 (pragma_s -> .)
INFO:root:    END             reduce using rule 8 (pragma_s -> .)
INFO:root:    ENTRY           reduce using rule 8 (pragma_s -> .)
INFO:root:    PROCEDURE       reduce using rule 8 (pragma_s -> .)
INFO:root:    FUNCTION        reduce using rule 8 (pragma_s -> .)
INFO:root:
INFO:root:    pragma_s                       shift and go to state 592
INFO:root:    prot_op_body_s                 shift and go to state 593
INFO:root:
INFO:root:state 769
INFO:root:
INFO:root:    (331) pkg_body -> PACKAGE BODY compound_name IS decl_part body_opt END c_id_opt . ;
INFO:root:
INFO:root:    ;               shift and go to state 836
INFO:root:
INFO:root:
INFO:root:state 770
INFO:root:
INFO:root:    (57) derived_type -> NEW subtype_ind WITH . PRIVATE
INFO:root:    (58) derived_type -> NEW subtype_ind WITH . record_def
INFO:root:    (96) record_def -> . RECORD pragma_s comp_list END RECORD
INFO:root:    (97) record_def -> . NuLL RECORD
INFO:root:
INFO:root:    PRIVATE         shift and go to state 838
INFO:root:    RECORD          shift and go to state 775
INFO:root:    NuLL            shift and go to state 774
INFO:root:
INFO:root:    record_def                     shift and go to state 837
INFO:root:
INFO:root:state 771
INFO:root:
INFO:root:    (63) enumeration_type -> ( enum_id_s ) .
INFO:root:
INFO:root:    ;               reduce using rule 63 (enumeration_type -> ( enum_id_s ) .)
INFO:root:
INFO:root:
INFO:root:state 772
INFO:root:
INFO:root:    (65) enum_id_s -> enum_id_s , . enum_id
INFO:root:    (66) enum_id -> . IDENTIFIER
INFO:root:    (67) enum_id -> . CHAR
INFO:root:
INFO:root:    IDENTIFIER      shift and go to state 685
INFO:root:    CHAR            shift and go to state 687
INFO:root:
INFO:root:    enum_id                        shift and go to state 839
INFO:root:
INFO:root:state 773
INFO:root:
INFO:root:    (95) record_type -> tagged_opt limited_opt record_def .
INFO:root:
INFO:root:    ;               reduce using rule 95 (record_type -> tagged_opt limited_opt record_def .)
INFO:root:
INFO:root:
INFO:root:state 774
INFO:root:
INFO:root:    (97) record_def -> NuLL . RECORD
INFO:root:
INFO:root:    RECORD          shift and go to state 840
INFO:root:
INFO:root:
INFO:root:state 775
INFO:root:
INFO:root:    (96) record_def -> RECORD . pragma_s comp_list END RECORD
INFO:root:    (8) pragma_s -> .
INFO:root:    (9) pragma_s -> . pragma_s pragma
INFO:root:
INFO:root:    NuLL            reduce using rule 8 (pragma_s -> .)
INFO:root:    PRAGMA          reduce using rule 8 (pragma_s -> .)
INFO:root:    CASE            reduce using rule 8 (pragma_s -> .)
INFO:root:    error           reduce using rule 8 (pragma_s -> .)
INFO:root:    IDENTIFIER      reduce using rule 8 (pragma_s -> .)
INFO:root:
INFO:root:    pragma_s                       shift and go to state 841
INFO:root:
INFO:root:state 776
INFO:root:
INFO:root:    (59) derived_type -> ABSTRACT NEW subtype_ind . WITH PRIVATE
INFO:root:    (60) derived_type -> ABSTRACT NEW subtype_ind . WITH record_def
INFO:root:
INFO:root:    WITH            shift and go to state 842
INFO:root:
INFO:root:
INFO:root:state 777
INFO:root:
INFO:root:    (72) range_spec_opt -> range_spec .
INFO:root:
INFO:root:    ;               reduce using rule 72 (range_spec_opt -> range_spec .)
INFO:root:
INFO:root:
INFO:root:state 778
INFO:root:
INFO:root:    (75) float_type -> DIGITS expression range_spec_opt .
INFO:root:
INFO:root:    ;               reduce using rule 75 (float_type -> DIGITS expression range_spec_opt .)
INFO:root:
INFO:root:
INFO:root:state 779
INFO:root:
INFO:root:    (76) fixed_type -> DELTA expression range_spec .
INFO:root:
INFO:root:    ;               reduce using rule 76 (fixed_type -> DELTA expression range_spec .)
INFO:root:
INFO:root:
INFO:root:state 780
INFO:root:
INFO:root:    (77) fixed_type -> DELTA expression DIGITS . expression range_spec_opt
INFO:root:    (188) expression -> . relation
INFO:root:    (189) expression -> . expression logical relation
INFO:root:    (190) expression -> . expression short_circuit relation
INFO:root:    (196) relation -> . simple_expression
INFO:root:    (197) relation -> . simple_expression relational simple_expression
INFO:root:    (198) relation -> . simple_expression membership range
INFO:root:    (199) relation -> . simple_expression membership name
INFO:root:    (208) simple_expression -> . unary term
INFO:root:    (209) simple_expression -> . term
INFO:root:    (210) simple_expression -> . simple_expression adding term
INFO:root:    (211) unary -> . +
INFO:root:    (212) unary -> . -
INFO:root:    (216) term -> . factor
INFO:root:    (217) term -> . term multiplying factor
INFO:root:    (223) factor -> . primary
INFO:root:    (224) factor -> . NOT primary
INFO:root:    (225) factor -> . ABS primary
INFO:root:    (226) primary -> . literal
INFO:root:    (227) primary -> . name
INFO:root:    (228) primary -> . allocator
INFO:root:    (229) primary -> . qualified
INFO:root:    (230) primary -> . parenthesized_primary
INFO:root:    (180) literal -> . INT
INFO:root:    (181) literal -> . FLOAT
INFO:root:    (182) literal -> . NuLL
INFO:root:    (149) name -> . simple_name
INFO:root:    (150) name -> . indexed_comp
INFO:root:    (151) name -> . selected_comp
INFO:root:    (152) name -> . attribute
INFO:root:    (153) name -> . operator_symbol
INFO:root:    (234) allocator -> . NEW name
INFO:root:    (235) allocator -> . NEW qualified
INFO:root:    (233) qualified -> . name TICK parenthesized_primary
INFO:root:    (231) parenthesized_primary -> . aggregate
INFO:root:    (232) parenthesized_primary -> . ( expression )
INFO:root:    (157) simple_name -> . IDENTIFIER
INFO:root:    (164) indexed_comp -> . name ( value_s )
INFO:root:    (171) selected_comp -> . name . simple_name
INFO:root:    (172) selected_comp -> . name . used_char
INFO:root:    (173) selected_comp -> . name . operator_symbol
INFO:root:    (174) selected_comp -> . name . ALL
INFO:root:    (175) attribute -> . name TICK attribute_id
INFO:root:    (163) operator_symbol -> . STRING
INFO:root:    (183) aggregate -> . ( comp_assoc )
INFO:root:    (184) aggregate -> . ( expression WITH value_s )
INFO:root:    (185) aggregate -> . ( expression WITH NuLL RECORD )
INFO:root:    (186) aggregate -> . ( NuLL RECORD )
INFO:root:
INFO:root:    +               shift and go to state 148
INFO:root:    -               shift and go to state 136
INFO:root:    NOT             shift and go to state 131
INFO:root:    ABS             shift and go to state 132
INFO:root:    INT             shift and go to state 120
INFO:root:    FLOAT           shift and go to state 128
INFO:root:    NuLL            shift and go to state 130
INFO:root:    NEW             shift and go to state 137
INFO:root:    (               shift and go to state 125
INFO:root:    IDENTIFIER      shift and go to state 33
INFO:root:    STRING          shift and go to state 149
INFO:root:
INFO:root:    literal                        shift and go to state 121
INFO:root:    allocator                      shift and go to state 122
INFO:root:    simple_name                    shift and go to state 163
INFO:root:    indexed_comp                   shift and go to state 140
INFO:root:    name                           shift and go to state 142
INFO:root:    selected_comp                  shift and go to state 139
INFO:root:    factor                         shift and go to state 126
INFO:root:    expression                     shift and go to state 843
INFO:root:    unary                          shift and go to state 144
INFO:root:    qualified                      shift and go to state 145
INFO:root:    aggregate                      shift and go to state 143
INFO:root:    simple_expression              shift and go to state 129
INFO:root:    term                           shift and go to state 146
INFO:root:    operator_symbol                shift and go to state 133
INFO:root:    parenthesized_primary          shift and go to state 147
INFO:root:    attribute                      shift and go to state 134
INFO:root:    primary                        shift and go to state 135
INFO:root:    relation                       shift and go to state 138
INFO:root:
INFO:root:state 781
INFO:root:
INFO:root:    (88) iter_index_constraint -> ( iter_discrete_range_s ) .
INFO:root:
INFO:root:    OF              reduce using rule 88 (iter_index_constraint -> ( iter_discrete_range_s ) .)
INFO:root:
INFO:root:
INFO:root:state 782
INFO:root:
INFO:root:    (90) iter_discrete_range_s -> iter_discrete_range_s , . discrete_range
INFO:root:    (91) discrete_range -> . name range_constr_opt
INFO:root:    (92) discrete_range -> . range
INFO:root:    (149) name -> . simple_name
INFO:root:    (150) name -> . indexed_comp
INFO:root:    (151) name -> . selected_comp
INFO:root:    (152) name -> . attribute
INFO:root:    (153) name -> . operator_symbol
INFO:root:    (62) range -> . simple_expression DOTDOT simple_expression
INFO:root:    (157) simple_name -> . IDENTIFIER
INFO:root:    (164) indexed_comp -> . name ( value_s )
INFO:root:    (171) selected_comp -> . name . simple_name
INFO:root:    (172) selected_comp -> . name . used_char
INFO:root:    (173) selected_comp -> . name . operator_symbol
INFO:root:    (174) selected_comp -> . name . ALL
INFO:root:    (175) attribute -> . name TICK attribute_id
INFO:root:    (163) operator_symbol -> . STRING
INFO:root:    (208) simple_expression -> . unary term
INFO:root:    (209) simple_expression -> . term
INFO:root:    (210) simple_expression -> . simple_expression adding term
INFO:root:    (211) unary -> . +
INFO:root:    (212) unary -> . -
INFO:root:    (216) term -> . factor
INFO:root:    (217) term -> . term multiplying factor
INFO:root:    (223) factor -> . primary
INFO:root:    (224) factor -> . NOT primary
INFO:root:    (225) factor -> . ABS primary
INFO:root:    (226) primary -> . literal
INFO:root:    (227) primary -> . name
INFO:root:    (228) primary -> . allocator
INFO:root:    (229) primary -> . qualified
INFO:root:    (230) primary -> . parenthesized_primary
INFO:root:    (180) literal -> . INT
INFO:root:    (181) literal -> . FLOAT
INFO:root:    (182) literal -> . NuLL
INFO:root:    (234) allocator -> . NEW name
INFO:root:    (235) allocator -> . NEW qualified
INFO:root:    (233) qualified -> . name TICK parenthesized_primary
INFO:root:    (231) parenthesized_primary -> . aggregate
INFO:root:    (232) parenthesized_primary -> . ( expression )
INFO:root:    (183) aggregate -> . ( comp_assoc )
INFO:root:    (184) aggregate -> . ( expression WITH value_s )
INFO:root:    (185) aggregate -> . ( expression WITH NuLL RECORD )
INFO:root:    (186) aggregate -> . ( NuLL RECORD )
INFO:root:
INFO:root:    IDENTIFIER      shift and go to state 33
INFO:root:    STRING          shift and go to state 149
INFO:root:    +               shift and go to state 148
INFO:root:    -               shift and go to state 136
INFO:root:    NOT             shift and go to state 131
INFO:root:    ABS             shift and go to state 132
INFO:root:    INT             shift and go to state 120
INFO:root:    FLOAT           shift and go to state 128
INFO:root:    NuLL            shift and go to state 130
INFO:root:    NEW             shift and go to state 137
INFO:root:    (               shift and go to state 125
INFO:root:
INFO:root:    selected_comp                  shift and go to state 139
INFO:root:    allocator                      shift and go to state 122
INFO:root:    factor                         shift and go to state 126
INFO:root:    indexed_comp                   shift and go to state 140
INFO:root:    attribute                      shift and go to state 134
INFO:root:    name                           shift and go to state 730
INFO:root:    literal                        shift and go to state 121
INFO:root:    simple_name                    shift and go to state 163
INFO:root:    discrete_range                 shift and go to state 844
INFO:root:    aggregate                      shift and go to state 143
INFO:root:    unary                          shift and go to state 144
INFO:root:    term                           shift and go to state 146
INFO:root:    simple_expression              shift and go to state 366
INFO:root:    operator_symbol                shift and go to state 133
INFO:root:    parenthesized_primary          shift and go to state 147
INFO:root:    primary                        shift and go to state 135
INFO:root:    qualified                      shift and go to state 145
INFO:root:    range                          shift and go to state 698
INFO:root:
INFO:root:state 783
INFO:root:
INFO:root:    (80) unconstr_array_type -> ARRAY ( index_s ) . OF component_subtype_def
INFO:root:
INFO:root:    OF              shift and go to state 845
INFO:root:
INFO:root:
INFO:root:state 784
INFO:root:
INFO:root:    (86) index_s -> index_s , . index
INFO:root:    (87) index -> . name RANGE BOX
INFO:root:    (149) name -> . simple_name
INFO:root:    (150) name -> . indexed_comp
INFO:root:    (151) name -> . selected_comp
INFO:root:    (152) name -> . attribute
INFO:root:    (153) name -> . operator_symbol
INFO:root:    (157) simple_name -> . IDENTIFIER
INFO:root:    (164) indexed_comp -> . name ( value_s )
INFO:root:    (171) selected_comp -> . name . simple_name
INFO:root:    (172) selected_comp -> . name . used_char
INFO:root:    (173) selected_comp -> . name . operator_symbol
INFO:root:    (174) selected_comp -> . name . ALL
INFO:root:    (175) attribute -> . name TICK attribute_id
INFO:root:    (163) operator_symbol -> . STRING
INFO:root:
INFO:root:    IDENTIFIER      shift and go to state 33
INFO:root:    STRING          shift and go to state 149
INFO:root:
INFO:root:    selected_comp                  shift and go to state 139
INFO:root:    simple_name                    shift and go to state 163
INFO:root:    indexed_comp                   shift and go to state 140
INFO:root:    attribute                      shift and go to state 134
INFO:root:    name                           shift and go to state 846
INFO:root:    operator_symbol                shift and go to state 133
INFO:root:    index                          shift and go to state 847
INFO:root:
INFO:root:state 785
INFO:root:
INFO:root:    (87) index -> name RANGE . BOX
INFO:root:    (61) range_constraint -> RANGE . range
INFO:root:    (62) range -> . simple_expression DOTDOT simple_expression
INFO:root:    (208) simple_expression -> . unary term
INFO:root:    (209) simple_expression -> . term
INFO:root:    (210) simple_expression -> . simple_expression adding term
INFO:root:    (211) unary -> . +
INFO:root:    (212) unary -> . -
INFO:root:    (216) term -> . factor
INFO:root:    (217) term -> . term multiplying factor
INFO:root:    (223) factor -> . primary
INFO:root:    (224) factor -> . NOT primary
INFO:root:    (225) factor -> . ABS primary
INFO:root:    (226) primary -> . literal
INFO:root:    (227) primary -> . name
INFO:root:    (228) primary -> . allocator
INFO:root:    (229) primary -> . qualified
INFO:root:    (230) primary -> . parenthesized_primary
INFO:root:    (180) literal -> . INT
INFO:root:    (181) literal -> . FLOAT
INFO:root:    (182) literal -> . NuLL
INFO:root:    (149) name -> . simple_name
INFO:root:    (150) name -> . indexed_comp
INFO:root:    (151) name -> . selected_comp
INFO:root:    (152) name -> . attribute
INFO:root:    (153) name -> . operator_symbol
INFO:root:    (234) allocator -> . NEW name
INFO:root:    (235) allocator -> . NEW qualified
INFO:root:    (233) qualified -> . name TICK parenthesized_primary
INFO:root:    (231) parenthesized_primary -> . aggregate
INFO:root:    (232) parenthesized_primary -> . ( expression )
INFO:root:    (157) simple_name -> . IDENTIFIER
INFO:root:    (164) indexed_comp -> . name ( value_s )
INFO:root:    (171) selected_comp -> . name . simple_name
INFO:root:    (172) selected_comp -> . name . used_char
INFO:root:    (173) selected_comp -> . name . operator_symbol
INFO:root:    (174) selected_comp -> . name . ALL
INFO:root:    (175) attribute -> . name TICK attribute_id
INFO:root:    (163) operator_symbol -> . STRING
INFO:root:    (183) aggregate -> . ( comp_assoc )
INFO:root:    (184) aggregate -> . ( expression WITH value_s )
INFO:root:    (185) aggregate -> . ( expression WITH NuLL RECORD )
INFO:root:    (186) aggregate -> . ( NuLL RECORD )
INFO:root:
INFO:root:    BOX             shift and go to state 848
INFO:root:    +               shift and go to state 148
INFO:root:    -               shift and go to state 136
INFO:root:    NOT             shift and go to state 131
INFO:root:    ABS             shift and go to state 132
INFO:root:    INT             shift and go to state 120
INFO:root:    FLOAT           shift and go to state 128
INFO:root:    NuLL            shift and go to state 130
INFO:root:    NEW             shift and go to state 137
INFO:root:    (               shift and go to state 125
INFO:root:    IDENTIFIER      shift and go to state 33
INFO:root:    STRING          shift and go to state 149
INFO:root:
INFO:root:    literal                        shift and go to state 121
INFO:root:    allocator                      shift and go to state 122
INFO:root:    simple_name                    shift and go to state 163
INFO:root:    indexed_comp                   shift and go to state 140
INFO:root:    attribute                      shift and go to state 134
INFO:root:    name                           shift and go to state 142
INFO:root:    selected_comp                  shift and go to state 139
INFO:root:    factor                         shift and go to state 126
INFO:root:    aggregate                      shift and go to state 143
INFO:root:    unary                          shift and go to state 144
INFO:root:    term                           shift and go to state 146
INFO:root:    simple_expression              shift and go to state 366
INFO:root:    operator_symbol                shift and go to state 133
INFO:root:    parenthesized_primary          shift and go to state 147
INFO:root:    primary                        shift and go to state 135
INFO:root:    qualified                      shift and go to state 145
INFO:root:    range                          shift and go to state 513
INFO:root:
INFO:root:state 786
INFO:root:
INFO:root:    (94) range_constr_opt -> range_constraint .
INFO:root:
INFO:root:    LOOP            reduce using rule 94 (range_constr_opt -> range_constraint .)
INFO:root:    )               reduce using rule 94 (range_constr_opt -> range_constraint .)
INFO:root:    ,               reduce using rule 94 (range_constr_opt -> range_constraint .)
INFO:root:    RENAMES         reduce using rule 94 (range_constr_opt -> range_constraint .)
INFO:root:    ASSIGN          reduce using rule 94 (range_constr_opt -> range_constraint .)
INFO:root:    ;               reduce using rule 94 (range_constr_opt -> range_constraint .)
INFO:root:    WITH            reduce using rule 94 (range_constr_opt -> range_constraint .)
INFO:root:
INFO:root:
INFO:root:state 787
INFO:root:
INFO:root:    (91) discrete_range -> name range_constr_opt .
INFO:root:
INFO:root:    )               reduce using rule 91 (discrete_range -> name range_constr_opt .)
INFO:root:    ,               reduce using rule 91 (discrete_range -> name range_constr_opt .)
INFO:root:    LOOP            reduce using rule 91 (discrete_range -> name range_constr_opt .)
INFO:root:
INFO:root:
INFO:root:state 788
INFO:root:
INFO:root:    (84) aliased_opt -> ALIASED .
INFO:root:
INFO:root:    IDENTIFIER      reduce using rule 84 (aliased_opt -> ALIASED .)
INFO:root:    STRING          reduce using rule 84 (aliased_opt -> ALIASED .)
INFO:root:
INFO:root:
INFO:root:state 789
INFO:root:
INFO:root:    (81) constr_array_type -> ARRAY iter_index_constraint OF component_subtype_def .
INFO:root:
INFO:root:    ;               reduce using rule 81 (constr_array_type -> ARRAY iter_index_constraint OF component_subtype_def .)
INFO:root:    ASSIGN          reduce using rule 81 (constr_array_type -> ARRAY iter_index_constraint OF component_subtype_def .)
INFO:root:
INFO:root:
INFO:root:state 790
INFO:root:
INFO:root:    (82) component_subtype_def -> aliased_opt . subtype_ind
INFO:root:    (51) subtype_ind -> . name constraint
INFO:root:    (52) subtype_ind -> . name
INFO:root:    (149) name -> . simple_name
INFO:root:    (150) name -> . indexed_comp
INFO:root:    (151) name -> . selected_comp
INFO:root:    (152) name -> . attribute
INFO:root:    (153) name -> . operator_symbol
INFO:root:    (157) simple_name -> . IDENTIFIER
INFO:root:    (164) indexed_comp -> . name ( value_s )
INFO:root:    (171) selected_comp -> . name . simple_name
INFO:root:    (172) selected_comp -> . name . used_char
INFO:root:    (173) selected_comp -> . name . operator_symbol
INFO:root:    (174) selected_comp -> . name . ALL
INFO:root:    (175) attribute -> . name TICK attribute_id
INFO:root:    (163) operator_symbol -> . STRING
INFO:root:
INFO:root:    IDENTIFIER      shift and go to state 33
INFO:root:    STRING          shift and go to state 149
INFO:root:
INFO:root:    selected_comp                  shift and go to state 139
INFO:root:    indexed_comp                   shift and go to state 140
INFO:root:    attribute                      shift and go to state 134
INFO:root:    name                           shift and go to state 432
INFO:root:    operator_symbol                shift and go to state 133
INFO:root:    subtype_ind                    shift and go to state 849
INFO:root:    simple_name                    shift and go to state 163
INFO:root:
INFO:root:state 791
INFO:root:
INFO:root:    (55) decimal_digits_constraint -> DIGITS expression range_constr_opt .
INFO:root:
INFO:root:    RENAMES         reduce using rule 55 (decimal_digits_constraint -> DIGITS expression range_constr_opt .)
INFO:root:    ASSIGN          reduce using rule 55 (decimal_digits_constraint -> DIGITS expression range_constr_opt .)
INFO:root:    ;               reduce using rule 55 (decimal_digits_constraint -> DIGITS expression range_constr_opt .)
INFO:root:    WITH            reduce using rule 55 (decimal_digits_constraint -> DIGITS expression range_constr_opt .)
INFO:root:
INFO:root:
INFO:root:state 792
INFO:root:
INFO:root:    (356) task_body -> TASK BODY simple_name IS decl_part block_body END . id_opt ;
INFO:root:    (285) id_opt -> .
INFO:root:    (286) id_opt -> . designator
INFO:root:    (307) designator -> . compound_name
INFO:root:    (308) designator -> . STRING
INFO:root:    (158) compound_name -> . simple_name
INFO:root:    (159) compound_name -> . compound_name . simple_name
INFO:root:    (157) simple_name -> . IDENTIFIER
INFO:root:
INFO:root:    ;               reduce using rule 285 (id_opt -> .)
INFO:root:    STRING          shift and go to state 62
INFO:root:    IDENTIFIER      shift and go to state 33
INFO:root:
INFO:root:    designator                     shift and go to state 455
INFO:root:    id_opt                         shift and go to state 850
INFO:root:    simple_name                    shift and go to state 34
INFO:root:    compound_name                  shift and go to state 64
INFO:root:
INFO:root:state 793
INFO:root:
INFO:root:    (355) task_private_opt -> PRIVATE entry_decl_s . rep_spec_s
INFO:root:    (380) entry_decl_s -> entry_decl_s . entry_decl pragma_s
INFO:root:    (387) rep_spec_s -> .
INFO:root:    (388) rep_spec_s -> . rep_spec_s rep_spec pragma_s
INFO:root:    (381) entry_decl -> . ENTRY IDENTIFIER formal_part_opt ;
INFO:root:    (382) entry_decl -> . ENTRY IDENTIFIER ( discrete_range ) formal_part_opt ;
INFO:root:
INFO:root:    FOR             reduce using rule 387 (rep_spec_s -> .)
INFO:root:    END             reduce using rule 387 (rep_spec_s -> .)
INFO:root:    ENTRY           shift and go to state 590
INFO:root:
INFO:root:    entry_decl                     shift and go to state 588
INFO:root:    rep_spec_s                     shift and go to state 851
INFO:root:
INFO:root:state 794
INFO:root:
INFO:root:    (388) rep_spec_s -> rep_spec_s rep_spec pragma_s .
INFO:root:    (9) pragma_s -> pragma_s . pragma
INFO:root:    (2) pragma -> . PRAGMA IDENTIFIER ;
INFO:root:    (3) pragma -> . PRAGMA simple_name ( pragma_arg_s ) ;
INFO:root:
INFO:root:    PRIVATE         reduce using rule 388 (rep_spec_s -> rep_spec_s rep_spec pragma_s .)
INFO:root:    FOR             reduce using rule 388 (rep_spec_s -> rep_spec_s rep_spec pragma_s .)
INFO:root:    END             reduce using rule 388 (rep_spec_s -> rep_spec_s rep_spec pragma_s .)
INFO:root:    PRAGMA          shift and go to state 2
INFO:root:
INFO:root:    pragma                         shift and go to state 43
INFO:root:
INFO:root:state 795
INFO:root:
INFO:root:    (353) task_def -> IS entry_decl_s rep_spec_s task_private_opt END . id_opt
INFO:root:    (285) id_opt -> .
INFO:root:    (286) id_opt -> . designator
INFO:root:    (307) designator -> . compound_name
INFO:root:    (308) designator -> . STRING
INFO:root:    (158) compound_name -> . simple_name
INFO:root:    (159) compound_name -> . compound_name . simple_name
INFO:root:    (157) simple_name -> . IDENTIFIER
INFO:root:
INFO:root:    ;               reduce using rule 285 (id_opt -> .)
INFO:root:    STRING          shift and go to state 62
INFO:root:    IDENTIFIER      shift and go to state 33
INFO:root:
INFO:root:    designator                     shift and go to state 455
INFO:root:    id_opt                         shift and go to state 852
INFO:root:    simple_name                    shift and go to state 34
INFO:root:    compound_name                  shift and go to state 64
INFO:root:
INFO:root:state 796
INFO:root:
INFO:root:    (381) entry_decl -> ENTRY IDENTIFIER formal_part_opt . ;
INFO:root:
INFO:root:    ;               shift and go to state 853
INFO:root:
INFO:root:
INFO:root:state 797
INFO:root:
INFO:root:    (382) entry_decl -> ENTRY IDENTIFIER ( . discrete_range ) formal_part_opt ;
INFO:root:    (311) formal_part -> ( . param_s )
INFO:root:    (91) discrete_range -> . name range_constr_opt
INFO:root:    (92) discrete_range -> . range
INFO:root:    (312) param_s -> . param
INFO:root:    (313) param_s -> . param_s ; param
INFO:root:    (149) name -> . simple_name
INFO:root:    (150) name -> . indexed_comp
INFO:root:    (151) name -> . selected_comp
INFO:root:    (152) name -> . attribute
INFO:root:    (153) name -> . operator_symbol
INFO:root:    (62) range -> . simple_expression DOTDOT simple_expression
INFO:root:    (314) param -> . def_id_s : mode mark init_opt
INFO:root:    (315) param -> . error
INFO:root:    (157) simple_name -> . IDENTIFIER
INFO:root:    (164) indexed_comp -> . name ( value_s )
INFO:root:    (171) selected_comp -> . name . simple_name
INFO:root:    (172) selected_comp -> . name . used_char
INFO:root:    (173) selected_comp -> . name . operator_symbol
INFO:root:    (174) selected_comp -> . name . ALL
INFO:root:    (175) attribute -> . name TICK attribute_id
INFO:root:    (163) operator_symbol -> . STRING
INFO:root:    (208) simple_expression -> . unary term
INFO:root:    (209) simple_expression -> . term
INFO:root:    (210) simple_expression -> . simple_expression adding term
INFO:root:    (24) def_id_s -> . def_id
INFO:root:    (25) def_id_s -> . def_id_s , def_id
INFO:root:    (211) unary -> . +
INFO:root:    (212) unary -> . -
INFO:root:    (216) term -> . factor
INFO:root:    (217) term -> . term multiplying factor
INFO:root:    (26) def_id -> . IDENTIFIER
INFO:root:    (223) factor -> . primary
INFO:root:    (224) factor -> . NOT primary
INFO:root:    (225) factor -> . ABS primary
INFO:root:    (226) primary -> . literal
INFO:root:    (227) primary -> . name
INFO:root:    (228) primary -> . allocator
INFO:root:    (229) primary -> . qualified
INFO:root:    (230) primary -> . parenthesized_primary
INFO:root:    (180) literal -> . INT
INFO:root:    (181) literal -> . FLOAT
INFO:root:    (182) literal -> . NuLL
INFO:root:    (234) allocator -> . NEW name
INFO:root:    (235) allocator -> . NEW qualified
INFO:root:    (233) qualified -> . name TICK parenthesized_primary
INFO:root:    (231) parenthesized_primary -> . aggregate
INFO:root:    (232) parenthesized_primary -> . ( expression )
INFO:root:    (183) aggregate -> . ( comp_assoc )
INFO:root:    (184) aggregate -> . ( expression WITH value_s )
INFO:root:    (185) aggregate -> . ( expression WITH NuLL RECORD )
INFO:root:    (186) aggregate -> . ( NuLL RECORD )
INFO:root:
INFO:root:    error           shift and go to state 55
INFO:root:    IDENTIFIER      shift and go to state 854
INFO:root:    STRING          shift and go to state 149
INFO:root:    +               shift and go to state 148
INFO:root:    -               shift and go to state 136
INFO:root:    NOT             shift and go to state 131
INFO:root:    ABS             shift and go to state 132
INFO:root:    INT             shift and go to state 120
INFO:root:    FLOAT           shift and go to state 128
INFO:root:    NuLL            shift and go to state 130
INFO:root:    NEW             shift and go to state 137
INFO:root:    (               shift and go to state 125
INFO:root:
INFO:root:    selected_comp                  shift and go to state 139
INFO:root:    allocator                      shift and go to state 122
INFO:root:    factor                         shift and go to state 126
INFO:root:    indexed_comp                   shift and go to state 140
INFO:root:    attribute                      shift and go to state 134
INFO:root:    name                           shift and go to state 730
INFO:root:    literal                        shift and go to state 121
INFO:root:    simple_name                    shift and go to state 163
INFO:root:    param_s                        shift and go to state 247
INFO:root:    discrete_range                 shift and go to state 855
INFO:root:    parenthesized_primary          shift and go to state 147
INFO:root:    aggregate                      shift and go to state 143
INFO:root:    unary                          shift and go to state 144
INFO:root:    simple_expression              shift and go to state 366
INFO:root:    def_id_s                       shift and go to state 56
INFO:root:    def_id                         shift and go to state 57
INFO:root:    operator_symbol                shift and go to state 133
INFO:root:    term                           shift and go to state 146
INFO:root:    primary                        shift and go to state 135
INFO:root:    qualified                      shift and go to state 145
INFO:root:    range                          shift and go to state 698
INFO:root:    param                          shift and go to state 248
INFO:root:
INFO:root:state 798
INFO:root:
INFO:root:    (373) prot_body -> PROTECTED BODY simple_name IS prot_op_body_s END id_opt . ;
INFO:root:
INFO:root:    ;               shift and go to state 856
INFO:root:
INFO:root:
INFO:root:state 799
INFO:root:
INFO:root:    (378) prot_op_body -> subprog_spec ; .
INFO:root:
INFO:root:    PRAGMA          reduce using rule 378 (prot_op_body -> subprog_spec ; .)
INFO:root:    END             reduce using rule 378 (prot_op_body -> subprog_spec ; .)
INFO:root:    ENTRY           reduce using rule 378 (prot_op_body -> subprog_spec ; .)
INFO:root:    PROCEDURE       reduce using rule 378 (prot_op_body -> subprog_spec ; .)
INFO:root:    FUNCTION        reduce using rule 378 (prot_op_body -> subprog_spec ; .)
INFO:root:
INFO:root:
INFO:root:state 800
INFO:root:
INFO:root:    (383) entry_body -> ENTRY IDENTIFIER . formal_part_opt WHEN condition entry_body_part
INFO:root:    (384) entry_body -> ENTRY IDENTIFIER . ( iter_part discrete_range ) formal_part_opt WHEN condition entry_body_part
INFO:root:    (309) formal_part_opt -> .
INFO:root:    (310) formal_part_opt -> . formal_part
INFO:root:    (311) formal_part -> . ( param_s )
INFO:root:
INFO:root:    (               shift and go to state 858
INFO:root:    WHEN            reduce using rule 309 (formal_part_opt -> .)
INFO:root:
INFO:root:    formal_part_opt                shift and go to state 857
INFO:root:    formal_part                    shift and go to state 152
INFO:root:
INFO:root:state 801
INFO:root:
INFO:root:    (375) prot_op_body_s -> prot_op_body_s prot_op_body pragma_s .
INFO:root:    (9) pragma_s -> pragma_s . pragma
INFO:root:    (2) pragma -> . PRAGMA IDENTIFIER ;
INFO:root:    (3) pragma -> . PRAGMA simple_name ( pragma_arg_s ) ;
INFO:root:
INFO:root:    END             reduce using rule 375 (prot_op_body_s -> prot_op_body_s prot_op_body pragma_s .)
INFO:root:    ENTRY           reduce using rule 375 (prot_op_body_s -> prot_op_body_s prot_op_body pragma_s .)
INFO:root:    PROCEDURE       reduce using rule 375 (prot_op_body_s -> prot_op_body_s prot_op_body pragma_s .)
INFO:root:    FUNCTION        reduce using rule 375 (prot_op_body_s -> prot_op_body_s prot_op_body pragma_s .)
INFO:root:    PRAGMA          shift and go to state 2
INFO:root:
INFO:root:    pragma                         shift and go to state 43
INFO:root:
INFO:root:state 802
INFO:root:
INFO:root:    (360) prot_def -> IS prot_op_decl_s prot_private_opt END id_opt .
INFO:root:
INFO:root:    ;               reduce using rule 360 (prot_def -> IS prot_op_decl_s prot_private_opt END id_opt .)
INFO:root:
INFO:root:
INFO:root:state 803
INFO:root:
INFO:root:    (370) prot_elem_decl_s -> prot_elem_decl_s prot_elem_decl .
INFO:root:
INFO:root:    error           reduce using rule 370 (prot_elem_decl_s -> prot_elem_decl_s prot_elem_decl .)
INFO:root:    ENTRY           reduce using rule 370 (prot_elem_decl_s -> prot_elem_decl_s prot_elem_decl .)
INFO:root:    PROCEDURE       reduce using rule 370 (prot_elem_decl_s -> prot_elem_decl_s prot_elem_decl .)
INFO:root:    FUNCTION        reduce using rule 370 (prot_elem_decl_s -> prot_elem_decl_s prot_elem_decl .)
INFO:root:    PRAGMA          reduce using rule 370 (prot_elem_decl_s -> prot_elem_decl_s prot_elem_decl .)
INFO:root:    FOR             reduce using rule 370 (prot_elem_decl_s -> prot_elem_decl_s prot_elem_decl .)
INFO:root:    IDENTIFIER      reduce using rule 370 (prot_elem_decl_s -> prot_elem_decl_s prot_elem_decl .)
INFO:root:    END             reduce using rule 370 (prot_elem_decl_s -> prot_elem_decl_s prot_elem_decl .)
INFO:root:
INFO:root:
INFO:root:state 804
INFO:root:
INFO:root:    (371) prot_elem_decl -> prot_op_decl .
INFO:root:
INFO:root:    error           reduce using rule 371 (prot_elem_decl -> prot_op_decl .)
INFO:root:    ENTRY           reduce using rule 371 (prot_elem_decl -> prot_op_decl .)
INFO:root:    PROCEDURE       reduce using rule 371 (prot_elem_decl -> prot_op_decl .)
INFO:root:    FUNCTION        reduce using rule 371 (prot_elem_decl -> prot_op_decl .)
INFO:root:    PRAGMA          reduce using rule 371 (prot_elem_decl -> prot_op_decl .)
INFO:root:    FOR             reduce using rule 371 (prot_elem_decl -> prot_op_decl .)
INFO:root:    IDENTIFIER      reduce using rule 371 (prot_elem_decl -> prot_op_decl .)
INFO:root:    END             reduce using rule 371 (prot_elem_decl -> prot_op_decl .)
INFO:root:
INFO:root:
INFO:root:state 805
INFO:root:
INFO:root:    (372) prot_elem_decl -> comp_decl .
INFO:root:
INFO:root:    error           reduce using rule 372 (prot_elem_decl -> comp_decl .)
INFO:root:    ENTRY           reduce using rule 372 (prot_elem_decl -> comp_decl .)
INFO:root:    PROCEDURE       reduce using rule 372 (prot_elem_decl -> comp_decl .)
INFO:root:    FUNCTION        reduce using rule 372 (prot_elem_decl -> comp_decl .)
INFO:root:    PRAGMA          reduce using rule 372 (prot_elem_decl -> comp_decl .)
INFO:root:    FOR             reduce using rule 372 (prot_elem_decl -> comp_decl .)
INFO:root:    IDENTIFIER      reduce using rule 372 (prot_elem_decl -> comp_decl .)
INFO:root:    END             reduce using rule 372 (prot_elem_decl -> comp_decl .)
INFO:root:
INFO:root:
INFO:root:state 806
INFO:root:
INFO:root:    (108) comp_decl -> def_id_s . : component_subtype_def init_opt ;
INFO:root:    (25) def_id_s -> def_id_s . , def_id
INFO:root:
INFO:root:    :               shift and go to state 859
INFO:root:    ,               shift and go to state 165
INFO:root:
INFO:root:
INFO:root:state 807
INFO:root:
INFO:root:    (109) comp_decl -> error . ;
INFO:root:
INFO:root:    ;               shift and go to state 860
INFO:root:
INFO:root:
INFO:root:state 808
INFO:root:
INFO:root:    (497) align_opt -> AT MOD expression . ;
INFO:root:    (189) expression -> expression . logical relation
INFO:root:    (190) expression -> expression . short_circuit relation
INFO:root:    (191) logical -> . AND
INFO:root:    (192) logical -> . OR
INFO:root:    (193) logical -> . XOR
INFO:root:    (194) short_circuit -> . AND THEN
INFO:root:    (195) short_circuit -> . OR ELSE
INFO:root:
INFO:root:    ;               shift and go to state 861
INFO:root:    AND             shift and go to state 215
INFO:root:    OR              shift and go to state 216
INFO:root:    XOR             shift and go to state 214
INFO:root:
INFO:root:    short_circuit                  shift and go to state 212
INFO:root:    logical                        shift and go to state 213
INFO:root:
INFO:root:state 809
INFO:root:
INFO:root:    (495) record_type_spec -> FOR mark USE RECORD align_opt comp_loc_s END . RECORD ;
INFO:root:
INFO:root:    RECORD          shift and go to state 862
INFO:root:
INFO:root:
INFO:root:state 810
INFO:root:
INFO:root:    (499) comp_loc_s -> comp_loc_s mark . AT expression RANGE range ;
INFO:root:    (155) mark -> mark . TICK attribute_id
INFO:root:    (156) mark -> mark . . simple_name
INFO:root:
INFO:root:    AT              shift and go to state 863
INFO:root:    TICK            shift and go to state 300
INFO:root:    .               shift and go to state 298
INFO:root:
INFO:root:
INFO:root:state 811
INFO:root:
INFO:root:    (394) entry_name -> entry_name ( expression ) .
INFO:root:
INFO:root:    (               reduce using rule 394 (entry_name -> entry_name ( expression ) .)
INFO:root:    ;               reduce using rule 394 (entry_name -> entry_name ( expression ) .)
INFO:root:    DO              reduce using rule 394 (entry_name -> entry_name ( expression ) .)
INFO:root:
INFO:root:
INFO:root:state 812
INFO:root:
INFO:root:    (275) loop_stmt -> label_opt iteration basic_loop id_opt ; .
INFO:root:
INFO:root:    END             reduce using rule 275 (loop_stmt -> label_opt iteration basic_loop id_opt ; .)
INFO:root:    LL              reduce using rule 275 (loop_stmt -> label_opt iteration basic_loop id_opt ; .)
INFO:root:    error           reduce using rule 275 (loop_stmt -> label_opt iteration basic_loop id_opt ; .)
INFO:root:    NuLL            reduce using rule 275 (loop_stmt -> label_opt iteration basic_loop id_opt ; .)
INFO:root:    EXIT            reduce using rule 275 (loop_stmt -> label_opt iteration basic_loop id_opt ; .)
INFO:root:    RETURN          reduce using rule 275 (loop_stmt -> label_opt iteration basic_loop id_opt ; .)
INFO:root:    DELAY           reduce using rule 275 (loop_stmt -> label_opt iteration basic_loop id_opt ; .)
INFO:root:    ABORT           reduce using rule 275 (loop_stmt -> label_opt iteration basic_loop id_opt ; .)
INFO:root:    RAISE           reduce using rule 275 (loop_stmt -> label_opt iteration basic_loop id_opt ; .)
INFO:root:    REQUEUE         reduce using rule 275 (loop_stmt -> label_opt iteration basic_loop id_opt ; .)
INFO:root:    IF              reduce using rule 275 (loop_stmt -> label_opt iteration basic_loop id_opt ; .)
INFO:root:    CASE            reduce using rule 275 (loop_stmt -> label_opt iteration basic_loop id_opt ; .)
INFO:root:    IDENTIFIER      reduce using rule 275 (loop_stmt -> label_opt iteration basic_loop id_opt ; .)
INFO:root:    ACCEPT          reduce using rule 275 (loop_stmt -> label_opt iteration basic_loop id_opt ; .)
INFO:root:    SELECT          reduce using rule 275 (loop_stmt -> label_opt iteration basic_loop id_opt ; .)
INFO:root:    STRING          reduce using rule 275 (loop_stmt -> label_opt iteration basic_loop id_opt ; .)
INFO:root:    WHILE           reduce using rule 275 (loop_stmt -> label_opt iteration basic_loop id_opt ; .)
INFO:root:    DECLARE         reduce using rule 275 (loop_stmt -> label_opt iteration basic_loop id_opt ; .)
INFO:root:    FOR             reduce using rule 275 (loop_stmt -> label_opt iteration basic_loop id_opt ; .)
INFO:root:    LOOP            reduce using rule 275 (loop_stmt -> label_opt iteration basic_loop id_opt ; .)
INFO:root:    BEGIN           reduce using rule 275 (loop_stmt -> label_opt iteration basic_loop id_opt ; .)
INFO:root:    WHEN            reduce using rule 275 (loop_stmt -> label_opt iteration basic_loop id_opt ; .)
INFO:root:    OR              reduce using rule 275 (loop_stmt -> label_opt iteration basic_loop id_opt ; .)
INFO:root:    ELSE            reduce using rule 275 (loop_stmt -> label_opt iteration basic_loop id_opt ; .)
INFO:root:    THEN            reduce using rule 275 (loop_stmt -> label_opt iteration basic_loop id_opt ; .)
INFO:root:    EXCEPTION       reduce using rule 275 (loop_stmt -> label_opt iteration basic_loop id_opt ; .)
INFO:root:    ELSIF           reduce using rule 275 (loop_stmt -> label_opt iteration basic_loop id_opt ; .)
INFO:root:
INFO:root:
INFO:root:state 813
INFO:root:
INFO:root:    (284) basic_loop -> LOOP statement_s END . LOOP
INFO:root:
INFO:root:    LOOP            shift and go to state 864
INFO:root:
INFO:root:
INFO:root:state 814
INFO:root:
INFO:root:    (287) block -> label_opt block_decl block_body END id_opt . ;
INFO:root:
INFO:root:    ;               shift and go to state 865
INFO:root:
INFO:root:
INFO:root:state 815
INFO:root:
INFO:root:    (457) requeue_stmt -> REQUEUE name WITH ABORT ; .
INFO:root:
INFO:root:    LL              reduce using rule 457 (requeue_stmt -> REQUEUE name WITH ABORT ; .)
INFO:root:    error           reduce using rule 457 (requeue_stmt -> REQUEUE name WITH ABORT ; .)
INFO:root:    NuLL            reduce using rule 457 (requeue_stmt -> REQUEUE name WITH ABORT ; .)
INFO:root:    EXIT            reduce using rule 457 (requeue_stmt -> REQUEUE name WITH ABORT ; .)
INFO:root:    RETURN          reduce using rule 457 (requeue_stmt -> REQUEUE name WITH ABORT ; .)
INFO:root:    DELAY           reduce using rule 457 (requeue_stmt -> REQUEUE name WITH ABORT ; .)
INFO:root:    ABORT           reduce using rule 457 (requeue_stmt -> REQUEUE name WITH ABORT ; .)
INFO:root:    RAISE           reduce using rule 457 (requeue_stmt -> REQUEUE name WITH ABORT ; .)
INFO:root:    REQUEUE         reduce using rule 457 (requeue_stmt -> REQUEUE name WITH ABORT ; .)
INFO:root:    IF              reduce using rule 457 (requeue_stmt -> REQUEUE name WITH ABORT ; .)
INFO:root:    CASE            reduce using rule 457 (requeue_stmt -> REQUEUE name WITH ABORT ; .)
INFO:root:    IDENTIFIER      reduce using rule 457 (requeue_stmt -> REQUEUE name WITH ABORT ; .)
INFO:root:    ACCEPT          reduce using rule 457 (requeue_stmt -> REQUEUE name WITH ABORT ; .)
INFO:root:    SELECT          reduce using rule 457 (requeue_stmt -> REQUEUE name WITH ABORT ; .)
INFO:root:    STRING          reduce using rule 457 (requeue_stmt -> REQUEUE name WITH ABORT ; .)
INFO:root:    WHILE           reduce using rule 457 (requeue_stmt -> REQUEUE name WITH ABORT ; .)
INFO:root:    DECLARE         reduce using rule 457 (requeue_stmt -> REQUEUE name WITH ABORT ; .)
INFO:root:    FOR             reduce using rule 457 (requeue_stmt -> REQUEUE name WITH ABORT ; .)
INFO:root:    LOOP            reduce using rule 457 (requeue_stmt -> REQUEUE name WITH ABORT ; .)
INFO:root:    BEGIN           reduce using rule 457 (requeue_stmt -> REQUEUE name WITH ABORT ; .)
INFO:root:    THEN            reduce using rule 457 (requeue_stmt -> REQUEUE name WITH ABORT ; .)
INFO:root:    OR              reduce using rule 457 (requeue_stmt -> REQUEUE name WITH ABORT ; .)
INFO:root:    ELSE            reduce using rule 457 (requeue_stmt -> REQUEUE name WITH ABORT ; .)
INFO:root:    END             reduce using rule 457 (requeue_stmt -> REQUEUE name WITH ABORT ; .)
INFO:root:    EXCEPTION       reduce using rule 457 (requeue_stmt -> REQUEUE name WITH ABORT ; .)
INFO:root:    ELSIF           reduce using rule 457 (requeue_stmt -> REQUEUE name WITH ABORT ; .)
INFO:root:    WHEN            reduce using rule 457 (requeue_stmt -> REQUEUE name WITH ABORT ; .)
INFO:root:
INFO:root:
INFO:root:state 816
INFO:root:
INFO:root:    (391) accept_stmt -> accept_hdr DO handled_stmt_s END id_opt . ;
INFO:root:
INFO:root:    ;               shift and go to state 866
INFO:root:
INFO:root:
INFO:root:state 817
INFO:root:
INFO:root:    (270) case_stmt -> case_hdr pragma_s alternative_s END CASE . ;
INFO:root:
INFO:root:    ;               shift and go to state 867
INFO:root:
INFO:root:
INFO:root:state 818
INFO:root:
INFO:root:    (274) alternative -> WHEN choice_s . ARROW statement_s
INFO:root:    (122) choice_s -> choice_s . | choice
INFO:root:
INFO:root:    ARROW           shift and go to state 868
INFO:root:    |               shift and go to state 351
INFO:root:
INFO:root:
INFO:root:state 819
INFO:root:
INFO:root:    (413) cond_entry_call -> SELECT entry_call stmts_opt ELSE statement_s . END SELECT ;
INFO:root:    (237) statement_s -> statement_s . statement
INFO:root:    (238) statement -> . unlabeled
INFO:root:    (239) statement -> . label statement
INFO:root:    (240) unlabeled -> . simple_stmt
INFO:root:    (241) unlabeled -> . compound_stmt
INFO:root:    (259) label -> . LL IDENTIFIER RR
INFO:root:    (242) simple_stmt -> . null_stmt
INFO:root:    (243) simple_stmt -> . assign_stmt
INFO:root:    (244) simple_stmt -> . exit_stmt
INFO:root:    (245) simple_stmt -> . return_stmt
INFO:root:    (246) simple_stmt -> . procedure_call
INFO:root:    (247) simple_stmt -> . delay_stmt
INFO:root:    (248) simple_stmt -> . abort_stmt
INFO:root:    (249) simple_stmt -> . raise_stmt
INFO:root:    (250) simple_stmt -> . code_stmt
INFO:root:    (251) simple_stmt -> . requeue_stmt
INFO:root:    (252) simple_stmt -> . error ;
INFO:root:    (253) compound_stmt -> . if_stmt
INFO:root:    (254) compound_stmt -> . case_stmt
INFO:root:    (255) compound_stmt -> . loop_stmt
INFO:root:    (256) compound_stmt -> . block
INFO:root:    (257) compound_stmt -> . accept_stmt
INFO:root:    (258) compound_stmt -> . select_stmt
INFO:root:    (260) null_stmt -> . NuLL ;
INFO:root:    (261) assign_stmt -> . name ASSIGN expression ;
INFO:root:    (294) exit_stmt -> . EXIT name_opt when_opt ;
INFO:root:    (299) return_stmt -> . RETURN ;
INFO:root:    (300) return_stmt -> . RETURN expression ;
INFO:root:    (323) procedure_call -> . name ;
INFO:root:    (395) delay_stmt -> . DELAY expression ;
INFO:root:    (396) delay_stmt -> . DELAY UNTIL expression ;
INFO:root:    (416) abort_stmt -> . ABORT name_s ;
INFO:root:    (455) raise_stmt -> . RAISE name_opt ;
INFO:root:    (501) code_stmt -> . qualified ;
INFO:root:    (456) requeue_stmt -> . REQUEUE name ;
INFO:root:    (457) requeue_stmt -> . REQUEUE name WITH ABORT ;
INFO:root:    (262) if_stmt -> . IF cond_clause_s else_opt END IF ;
INFO:root:    (270) case_stmt -> . case_hdr pragma_s alternative_s END CASE ;
INFO:root:    (275) loop_stmt -> . label_opt iteration basic_loop id_opt ;
INFO:root:    (287) block -> . label_opt block_decl block_body END id_opt ;
INFO:root:    (390) accept_stmt -> . accept_hdr ;
INFO:root:    (391) accept_stmt -> . accept_hdr DO handled_stmt_s END id_opt ;
INFO:root:    (397) select_stmt -> . select_wait
INFO:root:    (398) select_stmt -> . async_select
INFO:root:    (399) select_stmt -> . timed_entry_call
INFO:root:    (400) select_stmt -> . cond_entry_call
INFO:root:    (149) name -> . simple_name
INFO:root:    (150) name -> . indexed_comp
INFO:root:    (151) name -> . selected_comp
INFO:root:    (152) name -> . attribute
INFO:root:    (153) name -> . operator_symbol
INFO:root:    (233) qualified -> . name TICK parenthesized_primary
INFO:root:    (271) case_hdr -> . CASE expression IS
INFO:root:    (276) label_opt -> .
INFO:root:    (277) label_opt -> . IDENTIFIER :
INFO:root:    (392) accept_hdr -> . ACCEPT entry_name formal_part_opt
INFO:root:    (401) select_wait -> . SELECT guarded_select_alt or_select else_opt END SELECT ;
INFO:root:    (411) async_select -> . SELECT delay_or_entry_alt THEN ABORT statement_s END SELECT ;
INFO:root:    (412) timed_entry_call -> . SELECT entry_call stmts_opt OR delay_stmt stmts_opt END SELECT ;
INFO:root:    (413) cond_entry_call -> . SELECT entry_call stmts_opt ELSE statement_s END SELECT ;
INFO:root:    (157) simple_name -> . IDENTIFIER
INFO:root:    (164) indexed_comp -> . name ( value_s )
INFO:root:    (171) selected_comp -> . name . simple_name
INFO:root:    (172) selected_comp -> . name . used_char
INFO:root:    (173) selected_comp -> . name . operator_symbol
INFO:root:    (174) selected_comp -> . name . ALL
INFO:root:    (175) attribute -> . name TICK attribute_id
INFO:root:    (163) operator_symbol -> . STRING
INFO:root:
INFO:root:    END             shift and go to state 869
INFO:root:    LL              shift and go to state 344
INFO:root:    error           shift and go to state 341
INFO:root:    NuLL            shift and go to state 347
INFO:root:    EXIT            shift and go to state 340
INFO:root:    RETURN          shift and go to state 303
INFO:root:    DELAY           shift and go to state 332
INFO:root:    ABORT           shift and go to state 326
INFO:root:    RAISE           shift and go to state 314
INFO:root:    REQUEUE         shift and go to state 317
INFO:root:    IF              shift and go to state 327
INFO:root:    CASE            shift and go to state 312
INFO:root:    WHILE           reduce using rule 276 (label_opt -> .)
INFO:root:    DECLARE         reduce using rule 276 (label_opt -> .)
INFO:root:    FOR             reduce using rule 276 (label_opt -> .)
INFO:root:    LOOP            reduce using rule 276 (label_opt -> .)
INFO:root:    BEGIN           reduce using rule 276 (label_opt -> .)
INFO:root:    IDENTIFIER      shift and go to state 322
INFO:root:    ACCEPT          shift and go to state 310
INFO:root:    SELECT          shift and go to state 320
INFO:root:    STRING          shift and go to state 149
INFO:root:
INFO:root:    cond_entry_call                shift and go to state 345
INFO:root:    simple_stmt                    shift and go to state 302
INFO:root:    async_select                   shift and go to state 328
INFO:root:    selected_comp                  shift and go to state 139
INFO:root:    simple_name                    shift and go to state 163
INFO:root:    requeue_stmt                   shift and go to state 329
INFO:root:    if_stmt                        shift and go to state 304
INFO:root:    procedure_call                 shift and go to state 305
INFO:root:    exit_stmt                      shift and go to state 306
INFO:root:    timed_entry_call               shift and go to state 307
INFO:root:    statement                      shift and go to state 497
INFO:root:    operator_symbol                shift and go to state 133
INFO:root:    code_stmt                      shift and go to state 331
INFO:root:    loop_stmt                      shift and go to state 333
INFO:root:    null_stmt                      shift and go to state 334
INFO:root:    label                          shift and go to state 335
INFO:root:    select_stmt                    shift and go to state 311
INFO:root:    label_opt                      shift and go to state 313
INFO:root:    assign_stmt                    shift and go to state 336
INFO:root:    select_wait                    shift and go to state 330
INFO:root:    abort_stmt                     shift and go to state 315
INFO:root:    attribute                      shift and go to state 134
INFO:root:    name                           shift and go to state 316
INFO:root:    accept_hdr                     shift and go to state 318
INFO:root:    accept_stmt                    shift and go to state 337
INFO:root:    case_hdr                       shift and go to state 319
INFO:root:    delay_stmt                     shift and go to state 338
INFO:root:    compound_stmt                  shift and go to state 309
INFO:root:    raise_stmt                     shift and go to state 342
INFO:root:    qualified                      shift and go to state 321
INFO:root:    return_stmt                    shift and go to state 323
INFO:root:    case_stmt                      shift and go to state 324
INFO:root:    block                          shift and go to state 325
INFO:root:    indexed_comp                   shift and go to state 140
INFO:root:    unlabeled                      shift and go to state 346
INFO:root:
INFO:root:state 820
INFO:root:
INFO:root:    (412) timed_entry_call -> SELECT entry_call stmts_opt OR delay_stmt . stmts_opt END SELECT ;
INFO:root:    (414) stmts_opt -> .
INFO:root:    (415) stmts_opt -> . statement_s
INFO:root:    (236) statement_s -> . statement
INFO:root:    (237) statement_s -> . statement_s statement
INFO:root:    (238) statement -> . unlabeled
INFO:root:    (239) statement -> . label statement
INFO:root:    (240) unlabeled -> . simple_stmt
INFO:root:    (241) unlabeled -> . compound_stmt
INFO:root:    (259) label -> . LL IDENTIFIER RR
INFO:root:    (242) simple_stmt -> . null_stmt
INFO:root:    (243) simple_stmt -> . assign_stmt
INFO:root:    (244) simple_stmt -> . exit_stmt
INFO:root:    (245) simple_stmt -> . return_stmt
INFO:root:    (246) simple_stmt -> . procedure_call
INFO:root:    (247) simple_stmt -> . delay_stmt
INFO:root:    (248) simple_stmt -> . abort_stmt
INFO:root:    (249) simple_stmt -> . raise_stmt
INFO:root:    (250) simple_stmt -> . code_stmt
INFO:root:    (251) simple_stmt -> . requeue_stmt
INFO:root:    (252) simple_stmt -> . error ;
INFO:root:    (253) compound_stmt -> . if_stmt
INFO:root:    (254) compound_stmt -> . case_stmt
INFO:root:    (255) compound_stmt -> . loop_stmt
INFO:root:    (256) compound_stmt -> . block
INFO:root:    (257) compound_stmt -> . accept_stmt
INFO:root:    (258) compound_stmt -> . select_stmt
INFO:root:    (260) null_stmt -> . NuLL ;
INFO:root:    (261) assign_stmt -> . name ASSIGN expression ;
INFO:root:    (294) exit_stmt -> . EXIT name_opt when_opt ;
INFO:root:    (299) return_stmt -> . RETURN ;
INFO:root:    (300) return_stmt -> . RETURN expression ;
INFO:root:    (323) procedure_call -> . name ;
INFO:root:    (395) delay_stmt -> . DELAY expression ;
INFO:root:    (396) delay_stmt -> . DELAY UNTIL expression ;
INFO:root:    (416) abort_stmt -> . ABORT name_s ;
INFO:root:    (455) raise_stmt -> . RAISE name_opt ;
INFO:root:    (501) code_stmt -> . qualified ;
INFO:root:    (456) requeue_stmt -> . REQUEUE name ;
INFO:root:    (457) requeue_stmt -> . REQUEUE name WITH ABORT ;
INFO:root:    (262) if_stmt -> . IF cond_clause_s else_opt END IF ;
INFO:root:    (270) case_stmt -> . case_hdr pragma_s alternative_s END CASE ;
INFO:root:    (275) loop_stmt -> . label_opt iteration basic_loop id_opt ;
INFO:root:    (287) block -> . label_opt block_decl block_body END id_opt ;
INFO:root:    (390) accept_stmt -> . accept_hdr ;
INFO:root:    (391) accept_stmt -> . accept_hdr DO handled_stmt_s END id_opt ;
INFO:root:    (397) select_stmt -> . select_wait
INFO:root:    (398) select_stmt -> . async_select
INFO:root:    (399) select_stmt -> . timed_entry_call
INFO:root:    (400) select_stmt -> . cond_entry_call
INFO:root:    (149) name -> . simple_name
INFO:root:    (150) name -> . indexed_comp
INFO:root:    (151) name -> . selected_comp
INFO:root:    (152) name -> . attribute
INFO:root:    (153) name -> . operator_symbol
INFO:root:    (233) qualified -> . name TICK parenthesized_primary
INFO:root:    (271) case_hdr -> . CASE expression IS
INFO:root:    (276) label_opt -> .
INFO:root:    (277) label_opt -> . IDENTIFIER :
INFO:root:    (392) accept_hdr -> . ACCEPT entry_name formal_part_opt
INFO:root:    (401) select_wait -> . SELECT guarded_select_alt or_select else_opt END SELECT ;
INFO:root:    (411) async_select -> . SELECT delay_or_entry_alt THEN ABORT statement_s END SELECT ;
INFO:root:    (412) timed_entry_call -> . SELECT entry_call stmts_opt OR delay_stmt stmts_opt END SELECT ;
INFO:root:    (413) cond_entry_call -> . SELECT entry_call stmts_opt ELSE statement_s END SELECT ;
INFO:root:    (157) simple_name -> . IDENTIFIER
INFO:root:    (164) indexed_comp -> . name ( value_s )
INFO:root:    (171) selected_comp -> . name . simple_name
INFO:root:    (172) selected_comp -> . name . used_char
INFO:root:    (173) selected_comp -> . name . operator_symbol
INFO:root:    (174) selected_comp -> . name . ALL
INFO:root:    (175) attribute -> . name TICK attribute_id
INFO:root:    (163) operator_symbol -> . STRING
INFO:root:
INFO:root:    END             reduce using rule 414 (stmts_opt -> .)
INFO:root:    LL              shift and go to state 344
INFO:root:    error           shift and go to state 341
INFO:root:    NuLL            shift and go to state 347
INFO:root:    EXIT            shift and go to state 340
INFO:root:    RETURN          shift and go to state 303
INFO:root:    DELAY           shift and go to state 332
INFO:root:    ABORT           shift and go to state 326
INFO:root:    RAISE           shift and go to state 314
INFO:root:    REQUEUE         shift and go to state 317
INFO:root:    IF              shift and go to state 327
INFO:root:    CASE            shift and go to state 312
INFO:root:    WHILE           reduce using rule 276 (label_opt -> .)
INFO:root:    DECLARE         reduce using rule 276 (label_opt -> .)
INFO:root:    FOR             reduce using rule 276 (label_opt -> .)
INFO:root:    LOOP            reduce using rule 276 (label_opt -> .)
INFO:root:    BEGIN           reduce using rule 276 (label_opt -> .)
INFO:root:    IDENTIFIER      shift and go to state 322
INFO:root:    ACCEPT          shift and go to state 310
INFO:root:    SELECT          shift and go to state 320
INFO:root:    STRING          shift and go to state 149
INFO:root:
INFO:root:    cond_entry_call                shift and go to state 345
INFO:root:    simple_stmt                    shift and go to state 302
INFO:root:    async_select                   shift and go to state 328
INFO:root:    selected_comp                  shift and go to state 139
INFO:root:    simple_name                    shift and go to state 163
INFO:root:    requeue_stmt                   shift and go to state 329
INFO:root:    if_stmt                        shift and go to state 304
INFO:root:    procedure_call                 shift and go to state 305
INFO:root:    exit_stmt                      shift and go to state 306
INFO:root:    timed_entry_call               shift and go to state 307
INFO:root:    statement                      shift and go to state 308
INFO:root:    operator_symbol                shift and go to state 133
INFO:root:    code_stmt                      shift and go to state 331
INFO:root:    loop_stmt                      shift and go to state 333
INFO:root:    null_stmt                      shift and go to state 334
INFO:root:    label                          shift and go to state 335
INFO:root:    select_stmt                    shift and go to state 311
INFO:root:    label_opt                      shift and go to state 313
INFO:root:    assign_stmt                    shift and go to state 336
INFO:root:    select_wait                    shift and go to state 330
INFO:root:    abort_stmt                     shift and go to state 315
INFO:root:    attribute                      shift and go to state 134
INFO:root:    name                           shift and go to state 316
INFO:root:    accept_hdr                     shift and go to state 318
INFO:root:    accept_stmt                    shift and go to state 337
INFO:root:    case_hdr                       shift and go to state 319
INFO:root:    delay_stmt                     shift and go to state 338
INFO:root:    statement_s                    shift and go to state 626
INFO:root:    compound_stmt                  shift and go to state 309
INFO:root:    raise_stmt                     shift and go to state 342
INFO:root:    qualified                      shift and go to state 321
INFO:root:    return_stmt                    shift and go to state 323
INFO:root:    stmts_opt                      shift and go to state 870
INFO:root:    case_stmt                      shift and go to state 324
INFO:root:    block                          shift and go to state 325
INFO:root:    indexed_comp                   shift and go to state 140
INFO:root:    unlabeled                      shift and go to state 346
INFO:root:
INFO:root:state 821
INFO:root:
INFO:root:    (407) select_alt -> delay_stmt . stmts_opt
INFO:root:    (414) stmts_opt -> .
INFO:root:    (415) stmts_opt -> . statement_s
INFO:root:    (236) statement_s -> . statement
INFO:root:    (237) statement_s -> . statement_s statement
INFO:root:    (238) statement -> . unlabeled
INFO:root:    (239) statement -> . label statement
INFO:root:    (240) unlabeled -> . simple_stmt
INFO:root:    (241) unlabeled -> . compound_stmt
INFO:root:    (259) label -> . LL IDENTIFIER RR
INFO:root:    (242) simple_stmt -> . null_stmt
INFO:root:    (243) simple_stmt -> . assign_stmt
INFO:root:    (244) simple_stmt -> . exit_stmt
INFO:root:    (245) simple_stmt -> . return_stmt
INFO:root:    (246) simple_stmt -> . procedure_call
INFO:root:    (247) simple_stmt -> . delay_stmt
INFO:root:    (248) simple_stmt -> . abort_stmt
INFO:root:    (249) simple_stmt -> . raise_stmt
INFO:root:    (250) simple_stmt -> . code_stmt
INFO:root:    (251) simple_stmt -> . requeue_stmt
INFO:root:    (252) simple_stmt -> . error ;
INFO:root:    (253) compound_stmt -> . if_stmt
INFO:root:    (254) compound_stmt -> . case_stmt
INFO:root:    (255) compound_stmt -> . loop_stmt
INFO:root:    (256) compound_stmt -> . block
INFO:root:    (257) compound_stmt -> . accept_stmt
INFO:root:    (258) compound_stmt -> . select_stmt
INFO:root:    (260) null_stmt -> . NuLL ;
INFO:root:    (261) assign_stmt -> . name ASSIGN expression ;
INFO:root:    (294) exit_stmt -> . EXIT name_opt when_opt ;
INFO:root:    (299) return_stmt -> . RETURN ;
INFO:root:    (300) return_stmt -> . RETURN expression ;
INFO:root:    (323) procedure_call -> . name ;
INFO:root:    (395) delay_stmt -> . DELAY expression ;
INFO:root:    (396) delay_stmt -> . DELAY UNTIL expression ;
INFO:root:    (416) abort_stmt -> . ABORT name_s ;
INFO:root:    (455) raise_stmt -> . RAISE name_opt ;
INFO:root:    (501) code_stmt -> . qualified ;
INFO:root:    (456) requeue_stmt -> . REQUEUE name ;
INFO:root:    (457) requeue_stmt -> . REQUEUE name WITH ABORT ;
INFO:root:    (262) if_stmt -> . IF cond_clause_s else_opt END IF ;
INFO:root:    (270) case_stmt -> . case_hdr pragma_s alternative_s END CASE ;
INFO:root:    (275) loop_stmt -> . label_opt iteration basic_loop id_opt ;
INFO:root:    (287) block -> . label_opt block_decl block_body END id_opt ;
INFO:root:    (390) accept_stmt -> . accept_hdr ;
INFO:root:    (391) accept_stmt -> . accept_hdr DO handled_stmt_s END id_opt ;
INFO:root:    (397) select_stmt -> . select_wait
INFO:root:    (398) select_stmt -> . async_select
INFO:root:    (399) select_stmt -> . timed_entry_call
INFO:root:    (400) select_stmt -> . cond_entry_call
INFO:root:    (149) name -> . simple_name
INFO:root:    (150) name -> . indexed_comp
INFO:root:    (151) name -> . selected_comp
INFO:root:    (152) name -> . attribute
INFO:root:    (153) name -> . operator_symbol
INFO:root:    (233) qualified -> . name TICK parenthesized_primary
INFO:root:    (271) case_hdr -> . CASE expression IS
INFO:root:    (276) label_opt -> .
INFO:root:    (277) label_opt -> . IDENTIFIER :
INFO:root:    (392) accept_hdr -> . ACCEPT entry_name formal_part_opt
INFO:root:    (401) select_wait -> . SELECT guarded_select_alt or_select else_opt END SELECT ;
INFO:root:    (411) async_select -> . SELECT delay_or_entry_alt THEN ABORT statement_s END SELECT ;
INFO:root:    (412) timed_entry_call -> . SELECT entry_call stmts_opt OR delay_stmt stmts_opt END SELECT ;
INFO:root:    (413) cond_entry_call -> . SELECT entry_call stmts_opt ELSE statement_s END SELECT ;
INFO:root:    (157) simple_name -> . IDENTIFIER
INFO:root:    (164) indexed_comp -> . name ( value_s )
INFO:root:    (171) selected_comp -> . name . simple_name
INFO:root:    (172) selected_comp -> . name . used_char
INFO:root:    (173) selected_comp -> . name . operator_symbol
INFO:root:    (174) selected_comp -> . name . ALL
INFO:root:    (175) attribute -> . name TICK attribute_id
INFO:root:    (163) operator_symbol -> . STRING
INFO:root:
INFO:root:    OR              reduce using rule 414 (stmts_opt -> .)
INFO:root:    ELSE            reduce using rule 414 (stmts_opt -> .)
INFO:root:    END             reduce using rule 414 (stmts_opt -> .)
INFO:root:    LL              shift and go to state 344
INFO:root:    error           shift and go to state 341
INFO:root:    NuLL            shift and go to state 347
INFO:root:    EXIT            shift and go to state 340
INFO:root:    RETURN          shift and go to state 303
INFO:root:    DELAY           shift and go to state 332
INFO:root:    ABORT           shift and go to state 326
INFO:root:    RAISE           shift and go to state 314
INFO:root:    REQUEUE         shift and go to state 317
INFO:root:    IF              shift and go to state 327
INFO:root:    CASE            shift and go to state 312
INFO:root:    WHILE           reduce using rule 276 (label_opt -> .)
INFO:root:    DECLARE         reduce using rule 276 (label_opt -> .)
INFO:root:    FOR             reduce using rule 276 (label_opt -> .)
INFO:root:    LOOP            reduce using rule 276 (label_opt -> .)
INFO:root:    BEGIN           reduce using rule 276 (label_opt -> .)
INFO:root:    IDENTIFIER      shift and go to state 322
INFO:root:    ACCEPT          shift and go to state 310
INFO:root:    SELECT          shift and go to state 320
INFO:root:    STRING          shift and go to state 149
INFO:root:
INFO:root:    cond_entry_call                shift and go to state 345
INFO:root:    simple_stmt                    shift and go to state 302
INFO:root:    async_select                   shift and go to state 328
INFO:root:    simple_name                    shift and go to state 163
INFO:root:    requeue_stmt                   shift and go to state 329
INFO:root:    if_stmt                        shift and go to state 304
INFO:root:    procedure_call                 shift and go to state 305
INFO:root:    select_wait                    shift and go to state 330
INFO:root:    indexed_comp                   shift and go to state 140
INFO:root:    timed_entry_call               shift and go to state 307
INFO:root:    statement                      shift and go to state 308
INFO:root:    operator_symbol                shift and go to state 133
INFO:root:    exit_stmt                      shift and go to state 306
INFO:root:    code_stmt                      shift and go to state 331
INFO:root:    loop_stmt                      shift and go to state 333
INFO:root:    null_stmt                      shift and go to state 334
INFO:root:    label                          shift and go to state 335
INFO:root:    select_stmt                    shift and go to state 311
INFO:root:    label_opt                      shift and go to state 313
INFO:root:    assign_stmt                    shift and go to state 336
INFO:root:    selected_comp                  shift and go to state 139
INFO:root:    abort_stmt                     shift and go to state 315
INFO:root:    attribute                      shift and go to state 134
INFO:root:    name                           shift and go to state 316
INFO:root:    accept_hdr                     shift and go to state 318
INFO:root:    accept_stmt                    shift and go to state 337
INFO:root:    case_hdr                       shift and go to state 319
INFO:root:    delay_stmt                     shift and go to state 338
INFO:root:    statement_s                    shift and go to state 626
INFO:root:    compound_stmt                  shift and go to state 309
INFO:root:    raise_stmt                     shift and go to state 342
INFO:root:    qualified                      shift and go to state 321
INFO:root:    return_stmt                    shift and go to state 323
INFO:root:    stmts_opt                      shift and go to state 871
INFO:root:    case_stmt                      shift and go to state 324
INFO:root:    block                          shift and go to state 325
INFO:root:    unlabeled                      shift and go to state 346
INFO:root:
INFO:root:state 822
INFO:root:
INFO:root:    (405) or_select -> or_select OR guarded_select_alt .
INFO:root:
INFO:root:    OR              reduce using rule 405 (or_select -> or_select OR guarded_select_alt .)
INFO:root:    ELSE            reduce using rule 405 (or_select -> or_select OR guarded_select_alt .)
INFO:root:    END             reduce using rule 405 (or_select -> or_select OR guarded_select_alt .)
INFO:root:
INFO:root:
INFO:root:state 823
INFO:root:
INFO:root:    (401) select_wait -> SELECT guarded_select_alt or_select else_opt END . SELECT ;
INFO:root:
INFO:root:    SELECT          shift and go to state 872
INFO:root:
INFO:root:
INFO:root:state 824
INFO:root:
INFO:root:    (411) async_select -> SELECT delay_or_entry_alt THEN ABORT statement_s . END SELECT ;
INFO:root:    (237) statement_s -> statement_s . statement
INFO:root:    (238) statement -> . unlabeled
INFO:root:    (239) statement -> . label statement
INFO:root:    (240) unlabeled -> . simple_stmt
INFO:root:    (241) unlabeled -> . compound_stmt
INFO:root:    (259) label -> . LL IDENTIFIER RR
INFO:root:    (242) simple_stmt -> . null_stmt
INFO:root:    (243) simple_stmt -> . assign_stmt
INFO:root:    (244) simple_stmt -> . exit_stmt
INFO:root:    (245) simple_stmt -> . return_stmt
INFO:root:    (246) simple_stmt -> . procedure_call
INFO:root:    (247) simple_stmt -> . delay_stmt
INFO:root:    (248) simple_stmt -> . abort_stmt
INFO:root:    (249) simple_stmt -> . raise_stmt
INFO:root:    (250) simple_stmt -> . code_stmt
INFO:root:    (251) simple_stmt -> . requeue_stmt
INFO:root:    (252) simple_stmt -> . error ;
INFO:root:    (253) compound_stmt -> . if_stmt
INFO:root:    (254) compound_stmt -> . case_stmt
INFO:root:    (255) compound_stmt -> . loop_stmt
INFO:root:    (256) compound_stmt -> . block
INFO:root:    (257) compound_stmt -> . accept_stmt
INFO:root:    (258) compound_stmt -> . select_stmt
INFO:root:    (260) null_stmt -> . NuLL ;
INFO:root:    (261) assign_stmt -> . name ASSIGN expression ;
INFO:root:    (294) exit_stmt -> . EXIT name_opt when_opt ;
INFO:root:    (299) return_stmt -> . RETURN ;
INFO:root:    (300) return_stmt -> . RETURN expression ;
INFO:root:    (323) procedure_call -> . name ;
INFO:root:    (395) delay_stmt -> . DELAY expression ;
INFO:root:    (396) delay_stmt -> . DELAY UNTIL expression ;
INFO:root:    (416) abort_stmt -> . ABORT name_s ;
INFO:root:    (455) raise_stmt -> . RAISE name_opt ;
INFO:root:    (501) code_stmt -> . qualified ;
INFO:root:    (456) requeue_stmt -> . REQUEUE name ;
INFO:root:    (457) requeue_stmt -> . REQUEUE name WITH ABORT ;
INFO:root:    (262) if_stmt -> . IF cond_clause_s else_opt END IF ;
INFO:root:    (270) case_stmt -> . case_hdr pragma_s alternative_s END CASE ;
INFO:root:    (275) loop_stmt -> . label_opt iteration basic_loop id_opt ;
INFO:root:    (287) block -> . label_opt block_decl block_body END id_opt ;
INFO:root:    (390) accept_stmt -> . accept_hdr ;
INFO:root:    (391) accept_stmt -> . accept_hdr DO handled_stmt_s END id_opt ;
INFO:root:    (397) select_stmt -> . select_wait
INFO:root:    (398) select_stmt -> . async_select
INFO:root:    (399) select_stmt -> . timed_entry_call
INFO:root:    (400) select_stmt -> . cond_entry_call
INFO:root:    (149) name -> . simple_name
INFO:root:    (150) name -> . indexed_comp
INFO:root:    (151) name -> . selected_comp
INFO:root:    (152) name -> . attribute
INFO:root:    (153) name -> . operator_symbol
INFO:root:    (233) qualified -> . name TICK parenthesized_primary
INFO:root:    (271) case_hdr -> . CASE expression IS
INFO:root:    (276) label_opt -> .
INFO:root:    (277) label_opt -> . IDENTIFIER :
INFO:root:    (392) accept_hdr -> . ACCEPT entry_name formal_part_opt
INFO:root:    (401) select_wait -> . SELECT guarded_select_alt or_select else_opt END SELECT ;
INFO:root:    (411) async_select -> . SELECT delay_or_entry_alt THEN ABORT statement_s END SELECT ;
INFO:root:    (412) timed_entry_call -> . SELECT entry_call stmts_opt OR delay_stmt stmts_opt END SELECT ;
INFO:root:    (413) cond_entry_call -> . SELECT entry_call stmts_opt ELSE statement_s END SELECT ;
INFO:root:    (157) simple_name -> . IDENTIFIER
INFO:root:    (164) indexed_comp -> . name ( value_s )
INFO:root:    (171) selected_comp -> . name . simple_name
INFO:root:    (172) selected_comp -> . name . used_char
INFO:root:    (173) selected_comp -> . name . operator_symbol
INFO:root:    (174) selected_comp -> . name . ALL
INFO:root:    (175) attribute -> . name TICK attribute_id
INFO:root:    (163) operator_symbol -> . STRING
INFO:root:
INFO:root:    END             shift and go to state 873
INFO:root:    LL              shift and go to state 344
INFO:root:    error           shift and go to state 341
INFO:root:    NuLL            shift and go to state 347
INFO:root:    EXIT            shift and go to state 340
INFO:root:    RETURN          shift and go to state 303
INFO:root:    DELAY           shift and go to state 332
INFO:root:    ABORT           shift and go to state 326
INFO:root:    RAISE           shift and go to state 314
INFO:root:    REQUEUE         shift and go to state 317
INFO:root:    IF              shift and go to state 327
INFO:root:    CASE            shift and go to state 312
INFO:root:    WHILE           reduce using rule 276 (label_opt -> .)
INFO:root:    DECLARE         reduce using rule 276 (label_opt -> .)
INFO:root:    FOR             reduce using rule 276 (label_opt -> .)
INFO:root:    LOOP            reduce using rule 276 (label_opt -> .)
INFO:root:    BEGIN           reduce using rule 276 (label_opt -> .)
INFO:root:    IDENTIFIER      shift and go to state 322
INFO:root:    ACCEPT          shift and go to state 310
INFO:root:    SELECT          shift and go to state 320
INFO:root:    STRING          shift and go to state 149
INFO:root:
INFO:root:    cond_entry_call                shift and go to state 345
INFO:root:    simple_stmt                    shift and go to state 302
INFO:root:    async_select                   shift and go to state 328
INFO:root:    simple_name                    shift and go to state 163
INFO:root:    requeue_stmt                   shift and go to state 329
INFO:root:    abort_stmt                     shift and go to state 315
INFO:root:    if_stmt                        shift and go to state 304
INFO:root:    procedure_call                 shift and go to state 305
INFO:root:    select_wait                    shift and go to state 330
INFO:root:    indexed_comp                   shift and go to state 140
INFO:root:    timed_entry_call               shift and go to state 307
INFO:root:    statement                      shift and go to state 497
INFO:root:    operator_symbol                shift and go to state 133
INFO:root:    exit_stmt                      shift and go to state 306
INFO:root:    code_stmt                      shift and go to state 331
INFO:root:    loop_stmt                      shift and go to state 333
INFO:root:    null_stmt                      shift and go to state 334
INFO:root:    label                          shift and go to state 335
INFO:root:    select_stmt                    shift and go to state 311
INFO:root:    label_opt                      shift and go to state 313
INFO:root:    assign_stmt                    shift and go to state 336
INFO:root:    selected_comp                  shift and go to state 139
INFO:root:    attribute                      shift and go to state 134
INFO:root:    name                           shift and go to state 316
INFO:root:    accept_hdr                     shift and go to state 318
INFO:root:    accept_stmt                    shift and go to state 337
INFO:root:    case_hdr                       shift and go to state 319
INFO:root:    delay_stmt                     shift and go to state 338
INFO:root:    compound_stmt                  shift and go to state 309
INFO:root:    raise_stmt                     shift and go to state 342
INFO:root:    qualified                      shift and go to state 321
INFO:root:    return_stmt                    shift and go to state 323
INFO:root:    case_stmt                      shift and go to state 324
INFO:root:    block                          shift and go to state 325
INFO:root:    unlabeled                      shift and go to state 346
INFO:root:
INFO:root:state 825
INFO:root:
INFO:root:    (403) guarded_select_alt -> WHEN condition ARROW select_alt .
INFO:root:
INFO:root:    OR              reduce using rule 403 (guarded_select_alt -> WHEN condition ARROW select_alt .)
INFO:root:    ELSE            reduce using rule 403 (guarded_select_alt -> WHEN condition ARROW select_alt .)
INFO:root:    END             reduce using rule 403 (guarded_select_alt -> WHEN condition ARROW select_alt .)
INFO:root:
INFO:root:
INFO:root:state 826
INFO:root:
INFO:root:    (262) if_stmt -> IF cond_clause_s else_opt END IF . ;
INFO:root:
INFO:root:    ;               shift and go to state 874
INFO:root:
INFO:root:
INFO:root:state 827
INFO:root:
INFO:root:    (449) exception_handler -> WHEN except_choice_s ARROW . statement_s
INFO:root:    (236) statement_s -> . statement
INFO:root:    (237) statement_s -> . statement_s statement
INFO:root:    (238) statement -> . unlabeled
INFO:root:    (239) statement -> . label statement
INFO:root:    (240) unlabeled -> . simple_stmt
INFO:root:    (241) unlabeled -> . compound_stmt
INFO:root:    (259) label -> . LL IDENTIFIER RR
INFO:root:    (242) simple_stmt -> . null_stmt
INFO:root:    (243) simple_stmt -> . assign_stmt
INFO:root:    (244) simple_stmt -> . exit_stmt
INFO:root:    (245) simple_stmt -> . return_stmt
INFO:root:    (246) simple_stmt -> . procedure_call
INFO:root:    (247) simple_stmt -> . delay_stmt
INFO:root:    (248) simple_stmt -> . abort_stmt
INFO:root:    (249) simple_stmt -> . raise_stmt
INFO:root:    (250) simple_stmt -> . code_stmt
INFO:root:    (251) simple_stmt -> . requeue_stmt
INFO:root:    (252) simple_stmt -> . error ;
INFO:root:    (253) compound_stmt -> . if_stmt
INFO:root:    (254) compound_stmt -> . case_stmt
INFO:root:    (255) compound_stmt -> . loop_stmt
INFO:root:    (256) compound_stmt -> . block
INFO:root:    (257) compound_stmt -> . accept_stmt
INFO:root:    (258) compound_stmt -> . select_stmt
INFO:root:    (260) null_stmt -> . NuLL ;
INFO:root:    (261) assign_stmt -> . name ASSIGN expression ;
INFO:root:    (294) exit_stmt -> . EXIT name_opt when_opt ;
INFO:root:    (299) return_stmt -> . RETURN ;
INFO:root:    (300) return_stmt -> . RETURN expression ;
INFO:root:    (323) procedure_call -> . name ;
INFO:root:    (395) delay_stmt -> . DELAY expression ;
INFO:root:    (396) delay_stmt -> . DELAY UNTIL expression ;
INFO:root:    (416) abort_stmt -> . ABORT name_s ;
INFO:root:    (455) raise_stmt -> . RAISE name_opt ;
INFO:root:    (501) code_stmt -> . qualified ;
INFO:root:    (456) requeue_stmt -> . REQUEUE name ;
INFO:root:    (457) requeue_stmt -> . REQUEUE name WITH ABORT ;
INFO:root:    (262) if_stmt -> . IF cond_clause_s else_opt END IF ;
INFO:root:    (270) case_stmt -> . case_hdr pragma_s alternative_s END CASE ;
INFO:root:    (275) loop_stmt -> . label_opt iteration basic_loop id_opt ;
INFO:root:    (287) block -> . label_opt block_decl block_body END id_opt ;
INFO:root:    (390) accept_stmt -> . accept_hdr ;
INFO:root:    (391) accept_stmt -> . accept_hdr DO handled_stmt_s END id_opt ;
INFO:root:    (397) select_stmt -> . select_wait
INFO:root:    (398) select_stmt -> . async_select
INFO:root:    (399) select_stmt -> . timed_entry_call
INFO:root:    (400) select_stmt -> . cond_entry_call
INFO:root:    (149) name -> . simple_name
INFO:root:    (150) name -> . indexed_comp
INFO:root:    (151) name -> . selected_comp
INFO:root:    (152) name -> . attribute
INFO:root:    (153) name -> . operator_symbol
INFO:root:    (233) qualified -> . name TICK parenthesized_primary
INFO:root:    (271) case_hdr -> . CASE expression IS
INFO:root:    (276) label_opt -> .
INFO:root:    (277) label_opt -> . IDENTIFIER :
INFO:root:    (392) accept_hdr -> . ACCEPT entry_name formal_part_opt
INFO:root:    (401) select_wait -> . SELECT guarded_select_alt or_select else_opt END SELECT ;
INFO:root:    (411) async_select -> . SELECT delay_or_entry_alt THEN ABORT statement_s END SELECT ;
INFO:root:    (412) timed_entry_call -> . SELECT entry_call stmts_opt OR delay_stmt stmts_opt END SELECT ;
INFO:root:    (413) cond_entry_call -> . SELECT entry_call stmts_opt ELSE statement_s END SELECT ;
INFO:root:    (157) simple_name -> . IDENTIFIER
INFO:root:    (164) indexed_comp -> . name ( value_s )
INFO:root:    (171) selected_comp -> . name . simple_name
INFO:root:    (172) selected_comp -> . name . used_char
INFO:root:    (173) selected_comp -> . name . operator_symbol
INFO:root:    (174) selected_comp -> . name . ALL
INFO:root:    (175) attribute -> . name TICK attribute_id
INFO:root:    (163) operator_symbol -> . STRING
INFO:root:
INFO:root:    LL              shift and go to state 344
INFO:root:    error           shift and go to state 341
INFO:root:    NuLL            shift and go to state 347
INFO:root:    EXIT            shift and go to state 340
INFO:root:    RETURN          shift and go to state 303
INFO:root:    DELAY           shift and go to state 332
INFO:root:    ABORT           shift and go to state 326
INFO:root:    RAISE           shift and go to state 314
INFO:root:    REQUEUE         shift and go to state 317
INFO:root:    IF              shift and go to state 327
INFO:root:    CASE            shift and go to state 312
INFO:root:    WHILE           reduce using rule 276 (label_opt -> .)
INFO:root:    DECLARE         reduce using rule 276 (label_opt -> .)
INFO:root:    FOR             reduce using rule 276 (label_opt -> .)
INFO:root:    LOOP            reduce using rule 276 (label_opt -> .)
INFO:root:    BEGIN           reduce using rule 276 (label_opt -> .)
INFO:root:    IDENTIFIER      shift and go to state 322
INFO:root:    ACCEPT          shift and go to state 310
INFO:root:    SELECT          shift and go to state 320
INFO:root:    STRING          shift and go to state 149
INFO:root:
INFO:root:    cond_entry_call                shift and go to state 345
INFO:root:    simple_stmt                    shift and go to state 302
INFO:root:    async_select                   shift and go to state 328
INFO:root:    simple_name                    shift and go to state 163
INFO:root:    requeue_stmt                   shift and go to state 329
INFO:root:    if_stmt                        shift and go to state 304
INFO:root:    procedure_call                 shift and go to state 305
INFO:root:    select_wait                    shift and go to state 330
INFO:root:    indexed_comp                   shift and go to state 140
INFO:root:    timed_entry_call               shift and go to state 307
INFO:root:    statement                      shift and go to state 308
INFO:root:    operator_symbol                shift and go to state 133
INFO:root:    exit_stmt                      shift and go to state 306
INFO:root:    code_stmt                      shift and go to state 331
INFO:root:    loop_stmt                      shift and go to state 333
INFO:root:    null_stmt                      shift and go to state 334
INFO:root:    label                          shift and go to state 335
INFO:root:    select_stmt                    shift and go to state 311
INFO:root:    label_opt                      shift and go to state 313
INFO:root:    assign_stmt                    shift and go to state 336
INFO:root:    selected_comp                  shift and go to state 139
INFO:root:    abort_stmt                     shift and go to state 315
INFO:root:    attribute                      shift and go to state 134
INFO:root:    name                           shift and go to state 316
INFO:root:    accept_hdr                     shift and go to state 318
INFO:root:    accept_stmt                    shift and go to state 337
INFO:root:    case_hdr                       shift and go to state 319
INFO:root:    delay_stmt                     shift and go to state 338
INFO:root:    statement_s                    shift and go to state 875
INFO:root:    compound_stmt                  shift and go to state 309
INFO:root:    raise_stmt                     shift and go to state 342
INFO:root:    qualified                      shift and go to state 321
INFO:root:    return_stmt                    shift and go to state 323
INFO:root:    case_stmt                      shift and go to state 324
INFO:root:    block                          shift and go to state 325
INFO:root:    unlabeled                      shift and go to state 346
INFO:root:
INFO:root:state 828
INFO:root:
INFO:root:    (452) except_choice_s -> except_choice_s | . except_choice
INFO:root:    (453) except_choice -> . name
INFO:root:    (454) except_choice -> . OTHERS
INFO:root:    (149) name -> . simple_name
INFO:root:    (150) name -> . indexed_comp
INFO:root:    (151) name -> . selected_comp
INFO:root:    (152) name -> . attribute
INFO:root:    (153) name -> . operator_symbol
INFO:root:    (157) simple_name -> . IDENTIFIER
INFO:root:    (164) indexed_comp -> . name ( value_s )
INFO:root:    (171) selected_comp -> . name . simple_name
INFO:root:    (172) selected_comp -> . name . used_char
INFO:root:    (173) selected_comp -> . name . operator_symbol
INFO:root:    (174) selected_comp -> . name . ALL
INFO:root:    (175) attribute -> . name TICK attribute_id
INFO:root:    (163) operator_symbol -> . STRING
INFO:root:
INFO:root:    OTHERS          shift and go to state 749
INFO:root:    IDENTIFIER      shift and go to state 33
INFO:root:    STRING          shift and go to state 149
INFO:root:
INFO:root:    except_choice                  shift and go to state 876
INFO:root:    selected_comp                  shift and go to state 139
INFO:root:    simple_name                    shift and go to state 163
INFO:root:    indexed_comp                   shift and go to state 140
INFO:root:    attribute                      shift and go to state 134
INFO:root:    name                           shift and go to state 748
INFO:root:    operator_symbol                shift and go to state 133
INFO:root:
INFO:root:state 829
INFO:root:
INFO:root:    (450) exception_handler -> WHEN IDENTIFIER : . except_choice_s ARROW statement_s
INFO:root:    (451) except_choice_s -> . except_choice
INFO:root:    (452) except_choice_s -> . except_choice_s | except_choice
INFO:root:    (453) except_choice -> . name
INFO:root:    (454) except_choice -> . OTHERS
INFO:root:    (149) name -> . simple_name
INFO:root:    (150) name -> . indexed_comp
INFO:root:    (151) name -> . selected_comp
INFO:root:    (152) name -> . attribute
INFO:root:    (153) name -> . operator_symbol
INFO:root:    (157) simple_name -> . IDENTIFIER
INFO:root:    (164) indexed_comp -> . name ( value_s )
INFO:root:    (171) selected_comp -> . name . simple_name
INFO:root:    (172) selected_comp -> . name . used_char
INFO:root:    (173) selected_comp -> . name . operator_symbol
INFO:root:    (174) selected_comp -> . name . ALL
INFO:root:    (175) attribute -> . name TICK attribute_id
INFO:root:    (163) operator_symbol -> . STRING
INFO:root:
INFO:root:    OTHERS          shift and go to state 749
INFO:root:    IDENTIFIER      shift and go to state 33
INFO:root:    STRING          shift and go to state 149
INFO:root:
INFO:root:    except_choice                  shift and go to state 751
INFO:root:    selected_comp                  shift and go to state 139
INFO:root:    indexed_comp                   shift and go to state 140
INFO:root:    attribute                      shift and go to state 134
INFO:root:    name                           shift and go to state 748
INFO:root:    operator_symbol                shift and go to state 133
INFO:root:    simple_name                    shift and go to state 163
INFO:root:    except_choice_s                shift and go to state 877
INFO:root:
INFO:root:state 830
INFO:root:
INFO:root:    (465) generic_formal -> WITH FUNCTION designator formal_part_opt RETURN name subp_default ; .
INFO:root:
INFO:root:    PACKAGE         reduce using rule 465 (generic_formal -> WITH FUNCTION designator formal_part_opt RETURN name subp_default ; .)
INFO:root:    PROCEDURE       reduce using rule 465 (generic_formal -> WITH FUNCTION designator formal_part_opt RETURN name subp_default ; .)
INFO:root:    FUNCTION        reduce using rule 465 (generic_formal -> WITH FUNCTION designator formal_part_opt RETURN name subp_default ; .)
INFO:root:    TYPE            reduce using rule 465 (generic_formal -> WITH FUNCTION designator formal_part_opt RETURN name subp_default ; .)
INFO:root:    WITH            reduce using rule 465 (generic_formal -> WITH FUNCTION designator formal_part_opt RETURN name subp_default ; .)
INFO:root:    error           reduce using rule 465 (generic_formal -> WITH FUNCTION designator formal_part_opt RETURN name subp_default ; .)
INFO:root:    USE             reduce using rule 465 (generic_formal -> WITH FUNCTION designator formal_part_opt RETURN name subp_default ; .)
INFO:root:    IDENTIFIER      reduce using rule 465 (generic_formal -> WITH FUNCTION designator formal_part_opt RETURN name subp_default ; .)
INFO:root:
INFO:root:
INFO:root:state 831
INFO:root:
INFO:root:    (466) generic_formal -> WITH PACKAGE simple_name IS NEW name ( BOX . ) ;
INFO:root:
INFO:root:    )               shift and go to state 878
INFO:root:
INFO:root:
INFO:root:state 832
INFO:root:
INFO:root:    (113) discrim_spec -> def_id_s : access_opt mark init_opt .
INFO:root:
INFO:root:    )               reduce using rule 113 (discrim_spec -> def_id_s : access_opt mark init_opt .)
INFO:root:    ;               reduce using rule 113 (discrim_spec -> def_id_s : access_opt mark init_opt .)
INFO:root:
INFO:root:
INFO:root:state 833
INFO:root:
INFO:root:    (487) generic_derived_type -> ABSTRACT NEW subtype_ind WITH . PRIVATE
INFO:root:
INFO:root:    PRIVATE         shift and go to state 879
INFO:root:
INFO:root:
INFO:root:state 834
INFO:root:
INFO:root:    (479) generic_type_def -> DELTA BOX DIGITS BOX .
INFO:root:
INFO:root:    ;               reduce using rule 479 (generic_type_def -> DELTA BOX DIGITS BOX .)
INFO:root:
INFO:root:
INFO:root:state 835
INFO:root:
INFO:root:    (486) generic_derived_type -> NEW subtype_ind WITH PRIVATE .
INFO:root:
INFO:root:    ;               reduce using rule 486 (generic_derived_type -> NEW subtype_ind WITH PRIVATE .)
INFO:root:
INFO:root:
INFO:root:state 836
INFO:root:
INFO:root:    (331) pkg_body -> PACKAGE BODY compound_name IS decl_part body_opt END c_id_opt ; .
INFO:root:
INFO:root:    PACKAGE         reduce using rule 331 (pkg_body -> PACKAGE BODY compound_name IS decl_part body_opt END c_id_opt ; .)
INFO:root:    TASK            reduce using rule 331 (pkg_body -> PACKAGE BODY compound_name IS decl_part body_opt END c_id_opt ; .)
INFO:root:    PROTECTED       reduce using rule 331 (pkg_body -> PACKAGE BODY compound_name IS decl_part body_opt END c_id_opt ; .)
INFO:root:    error           reduce using rule 331 (pkg_body -> PACKAGE BODY compound_name IS decl_part body_opt END c_id_opt ; .)
INFO:root:    USE             reduce using rule 331 (pkg_body -> PACKAGE BODY compound_name IS decl_part body_opt END c_id_opt ; .)
INFO:root:    PRAGMA          reduce using rule 331 (pkg_body -> PACKAGE BODY compound_name IS decl_part body_opt END c_id_opt ; .)
INFO:root:    TYPE            reduce using rule 331 (pkg_body -> PACKAGE BODY compound_name IS decl_part body_opt END c_id_opt ; .)
INFO:root:    SUBTYPE         reduce using rule 331 (pkg_body -> PACKAGE BODY compound_name IS decl_part body_opt END c_id_opt ; .)
INFO:root:    FOR             reduce using rule 331 (pkg_body -> PACKAGE BODY compound_name IS decl_part body_opt END c_id_opt ; .)
INFO:root:    PROCEDURE       reduce using rule 331 (pkg_body -> PACKAGE BODY compound_name IS decl_part body_opt END c_id_opt ; .)
INFO:root:    FUNCTION        reduce using rule 331 (pkg_body -> PACKAGE BODY compound_name IS decl_part body_opt END c_id_opt ; .)
INFO:root:    GENERIC         reduce using rule 331 (pkg_body -> PACKAGE BODY compound_name IS decl_part body_opt END c_id_opt ; .)
INFO:root:    IDENTIFIER      reduce using rule 331 (pkg_body -> PACKAGE BODY compound_name IS decl_part body_opt END c_id_opt ; .)
INFO:root:    BEGIN           reduce using rule 331 (pkg_body -> PACKAGE BODY compound_name IS decl_part body_opt END c_id_opt ; .)
INFO:root:    END             reduce using rule 331 (pkg_body -> PACKAGE BODY compound_name IS decl_part body_opt END c_id_opt ; .)
INFO:root:    PRIVATE         reduce using rule 331 (pkg_body -> PACKAGE BODY compound_name IS decl_part body_opt END c_id_opt ; .)
INFO:root:    WITH            reduce using rule 331 (pkg_body -> PACKAGE BODY compound_name IS decl_part body_opt END c_id_opt ; .)
INFO:root:    SEPARATE        reduce using rule 331 (pkg_body -> PACKAGE BODY compound_name IS decl_part body_opt END c_id_opt ; .)
INFO:root:    $end            reduce using rule 331 (pkg_body -> PACKAGE BODY compound_name IS decl_part body_opt END c_id_opt ; .)
INFO:root:
INFO:root:
INFO:root:state 837
INFO:root:
INFO:root:    (58) derived_type -> NEW subtype_ind WITH record_def .
INFO:root:
INFO:root:    ;               reduce using rule 58 (derived_type -> NEW subtype_ind WITH record_def .)
INFO:root:
INFO:root:
INFO:root:state 838
INFO:root:
INFO:root:    (57) derived_type -> NEW subtype_ind WITH PRIVATE .
INFO:root:
INFO:root:    ;               reduce using rule 57 (derived_type -> NEW subtype_ind WITH PRIVATE .)
INFO:root:
INFO:root:
INFO:root:state 839
INFO:root:
INFO:root:    (65) enum_id_s -> enum_id_s , enum_id .
INFO:root:
INFO:root:    )               reduce using rule 65 (enum_id_s -> enum_id_s , enum_id .)
INFO:root:    ,               reduce using rule 65 (enum_id_s -> enum_id_s , enum_id .)
INFO:root:
INFO:root:
INFO:root:state 840
INFO:root:
INFO:root:    (97) record_def -> NuLL RECORD .
INFO:root:
INFO:root:    ;               reduce using rule 97 (record_def -> NuLL RECORD .)
INFO:root:
INFO:root:
INFO:root:state 841
INFO:root:
INFO:root:    (96) record_def -> RECORD pragma_s . comp_list END RECORD
INFO:root:    (9) pragma_s -> pragma_s . pragma
INFO:root:    (101) comp_list -> . comp_decl_s variant_part_opt
INFO:root:    (102) comp_list -> . variant_part pragma_s
INFO:root:    (103) comp_list -> . NuLL ; pragma_s
INFO:root:    (2) pragma -> . PRAGMA IDENTIFIER ;
INFO:root:    (3) pragma -> . PRAGMA simple_name ( pragma_arg_s ) ;
INFO:root:    (104) comp_decl_s -> . comp_decl
INFO:root:    (105) comp_decl_s -> . comp_decl_s pragma_s comp_decl
INFO:root:    (117) variant_part -> . CASE simple_name IS pragma_s variant_s END CASE ;
INFO:root:    (108) comp_decl -> . def_id_s : component_subtype_def init_opt ;
INFO:root:    (109) comp_decl -> . error ;
INFO:root:    (24) def_id_s -> . def_id
INFO:root:    (25) def_id_s -> . def_id_s , def_id
INFO:root:    (26) def_id -> . IDENTIFIER
INFO:root:
INFO:root:    NuLL            shift and go to state 884
INFO:root:    PRAGMA          shift and go to state 2
INFO:root:    CASE            shift and go to state 881
INFO:root:    error           shift and go to state 807
INFO:root:    IDENTIFIER      shift and go to state 52
INFO:root:
INFO:root:    comp_decl_s                    shift and go to state 880
INFO:root:    def_id_s                       shift and go to state 806
INFO:root:    def_id                         shift and go to state 57
INFO:root:    pragma                         shift and go to state 43
INFO:root:    variant_part                   shift and go to state 885
INFO:root:    comp_list                      shift and go to state 882
INFO:root:    comp_decl                      shift and go to state 883
INFO:root:
INFO:root:state 842
INFO:root:
INFO:root:    (59) derived_type -> ABSTRACT NEW subtype_ind WITH . PRIVATE
INFO:root:    (60) derived_type -> ABSTRACT NEW subtype_ind WITH . record_def
INFO:root:    (96) record_def -> . RECORD pragma_s comp_list END RECORD
INFO:root:    (97) record_def -> . NuLL RECORD
INFO:root:
INFO:root:    PRIVATE         shift and go to state 887
INFO:root:    RECORD          shift and go to state 775
INFO:root:    NuLL            shift and go to state 774
INFO:root:
INFO:root:    record_def                     shift and go to state 886
INFO:root:
INFO:root:state 843
INFO:root:
INFO:root:    (77) fixed_type -> DELTA expression DIGITS expression . range_spec_opt
INFO:root:    (189) expression -> expression . logical relation
INFO:root:    (190) expression -> expression . short_circuit relation
INFO:root:    (71) range_spec_opt -> .
INFO:root:    (72) range_spec_opt -> . range_spec
INFO:root:    (191) logical -> . AND
INFO:root:    (192) logical -> . OR
INFO:root:    (193) logical -> . XOR
INFO:root:    (194) short_circuit -> . AND THEN
INFO:root:    (195) short_circuit -> . OR ELSE
INFO:root:    (70) range_spec -> . range_constraint
INFO:root:    (61) range_constraint -> . RANGE range
INFO:root:
INFO:root:    ;               reduce using rule 71 (range_spec_opt -> .)
INFO:root:    AND             shift and go to state 215
INFO:root:    OR              shift and go to state 216
INFO:root:    XOR             shift and go to state 214
INFO:root:    RANGE           shift and go to state 358
INFO:root:
INFO:root:    range_spec                     shift and go to state 777
INFO:root:    short_circuit                  shift and go to state 212
INFO:root:    logical                        shift and go to state 213
INFO:root:    range_constraint               shift and go to state 570
INFO:root:    range_spec_opt                 shift and go to state 888
INFO:root:
INFO:root:state 844
INFO:root:
INFO:root:    (90) iter_discrete_range_s -> iter_discrete_range_s , discrete_range .
INFO:root:
INFO:root:    )               reduce using rule 90 (iter_discrete_range_s -> iter_discrete_range_s , discrete_range .)
INFO:root:    ,               reduce using rule 90 (iter_discrete_range_s -> iter_discrete_range_s , discrete_range .)
INFO:root:
INFO:root:
INFO:root:state 845
INFO:root:
INFO:root:    (80) unconstr_array_type -> ARRAY ( index_s ) OF . component_subtype_def
INFO:root:    (82) component_subtype_def -> . aliased_opt subtype_ind
INFO:root:    (83) aliased_opt -> .
INFO:root:    (84) aliased_opt -> . ALIASED
INFO:root:
INFO:root:    IDENTIFIER      reduce using rule 83 (aliased_opt -> .)
INFO:root:    STRING          reduce using rule 83 (aliased_opt -> .)
INFO:root:    ALIASED         shift and go to state 788
INFO:root:
INFO:root:    component_subtype_def          shift and go to state 889
INFO:root:    aliased_opt                    shift and go to state 790
INFO:root:
INFO:root:state 846
INFO:root:
INFO:root:    (87) index -> name . RANGE BOX
INFO:root:    (164) indexed_comp -> name . ( value_s )
INFO:root:    (171) selected_comp -> name . . simple_name
INFO:root:    (172) selected_comp -> name . . used_char
INFO:root:    (173) selected_comp -> name . . operator_symbol
INFO:root:    (174) selected_comp -> name . . ALL
INFO:root:    (175) attribute -> name . TICK attribute_id
INFO:root:
INFO:root:    RANGE           shift and go to state 890
INFO:root:    (               shift and go to state 237
INFO:root:    .               shift and go to state 239
INFO:root:    TICK            shift and go to state 260
INFO:root:
INFO:root:
INFO:root:state 847
INFO:root:
INFO:root:    (86) index_s -> index_s , index .
INFO:root:
INFO:root:    )               reduce using rule 86 (index_s -> index_s , index .)
INFO:root:    ,               reduce using rule 86 (index_s -> index_s , index .)
INFO:root:
INFO:root:
INFO:root:state 848
INFO:root:
INFO:root:    (87) index -> name RANGE BOX .
INFO:root:
INFO:root:    )               reduce using rule 87 (index -> name RANGE BOX .)
INFO:root:    ,               reduce using rule 87 (index -> name RANGE BOX .)
INFO:root:
INFO:root:
INFO:root:state 849
INFO:root:
INFO:root:    (82) component_subtype_def -> aliased_opt subtype_ind .
INFO:root:
INFO:root:    ASSIGN          reduce using rule 82 (component_subtype_def -> aliased_opt subtype_ind .)
INFO:root:    ;               reduce using rule 82 (component_subtype_def -> aliased_opt subtype_ind .)
INFO:root:
INFO:root:
INFO:root:state 850
INFO:root:
INFO:root:    (356) task_body -> TASK BODY simple_name IS decl_part block_body END id_opt . ;
INFO:root:
INFO:root:    ;               shift and go to state 891
INFO:root:
INFO:root:
INFO:root:state 851
INFO:root:
INFO:root:    (355) task_private_opt -> PRIVATE entry_decl_s rep_spec_s .
INFO:root:    (388) rep_spec_s -> rep_spec_s . rep_spec pragma_s
INFO:root:    (491) rep_spec -> . attrib_def
INFO:root:    (492) rep_spec -> . record_type_spec
INFO:root:    (493) rep_spec -> . address_spec
INFO:root:    (494) attrib_def -> . FOR mark USE expression ;
INFO:root:    (495) record_type_spec -> . FOR mark USE RECORD align_opt comp_loc_s END RECORD ;
INFO:root:    (500) address_spec -> . FOR mark USE AT expression ;
INFO:root:
INFO:root:    END             reduce using rule 355 (task_private_opt -> PRIVATE entry_decl_s rep_spec_s .)
INFO:root:    FOR             shift and go to state 102
INFO:root:
INFO:root:    record_type_spec               shift and go to state 108
INFO:root:    attrib_def                     shift and go to state 92
INFO:root:    rep_spec                       shift and go to state 708
INFO:root:    address_spec                   shift and go to state 83
INFO:root:
INFO:root:state 852
INFO:root:
INFO:root:    (353) task_def -> IS entry_decl_s rep_spec_s task_private_opt END id_opt .
INFO:root:
INFO:root:    ;               reduce using rule 353 (task_def -> IS entry_decl_s rep_spec_s task_private_opt END id_opt .)
INFO:root:
INFO:root:
INFO:root:state 853
INFO:root:
INFO:root:    (381) entry_decl -> ENTRY IDENTIFIER formal_part_opt ; .
INFO:root:
INFO:root:    PRAGMA          reduce using rule 381 (entry_decl -> ENTRY IDENTIFIER formal_part_opt ; .)
INFO:root:    ENTRY           reduce using rule 381 (entry_decl -> ENTRY IDENTIFIER formal_part_opt ; .)
INFO:root:    FOR             reduce using rule 381 (entry_decl -> ENTRY IDENTIFIER formal_part_opt ; .)
INFO:root:    END             reduce using rule 381 (entry_decl -> ENTRY IDENTIFIER formal_part_opt ; .)
INFO:root:    error           reduce using rule 381 (entry_decl -> ENTRY IDENTIFIER formal_part_opt ; .)
INFO:root:    PROCEDURE       reduce using rule 381 (entry_decl -> ENTRY IDENTIFIER formal_part_opt ; .)
INFO:root:    FUNCTION        reduce using rule 381 (entry_decl -> ENTRY IDENTIFIER formal_part_opt ; .)
INFO:root:    IDENTIFIER      reduce using rule 381 (entry_decl -> ENTRY IDENTIFIER formal_part_opt ; .)
INFO:root:    PRIVATE         reduce using rule 381 (entry_decl -> ENTRY IDENTIFIER formal_part_opt ; .)
INFO:root:
INFO:root:
INFO:root:state 854
INFO:root:
INFO:root:    (157) simple_name -> IDENTIFIER .
INFO:root:    (26) def_id -> IDENTIFIER .
INFO:root:
INFO:root:    (               reduce using rule 157 (simple_name -> IDENTIFIER .)
INFO:root:    .               reduce using rule 157 (simple_name -> IDENTIFIER .)
INFO:root:    TICK            reduce using rule 157 (simple_name -> IDENTIFIER .)
INFO:root:    RANGE           reduce using rule 157 (simple_name -> IDENTIFIER .)
INFO:root:    )               reduce using rule 157 (simple_name -> IDENTIFIER .)
INFO:root:    *               reduce using rule 157 (simple_name -> IDENTIFIER .)
INFO:root:    /               reduce using rule 157 (simple_name -> IDENTIFIER .)
INFO:root:    MOD             reduce using rule 157 (simple_name -> IDENTIFIER .)
INFO:root:    REM             reduce using rule 157 (simple_name -> IDENTIFIER .)
INFO:root:    STARSTAR        reduce using rule 157 (simple_name -> IDENTIFIER .)
INFO:root:    DOTDOT          reduce using rule 157 (simple_name -> IDENTIFIER .)
INFO:root:    +               reduce using rule 157 (simple_name -> IDENTIFIER .)
INFO:root:    -               reduce using rule 157 (simple_name -> IDENTIFIER .)
INFO:root:    &               reduce using rule 157 (simple_name -> IDENTIFIER .)
INFO:root:    :               reduce using rule 26 (def_id -> IDENTIFIER .)
INFO:root:    ,               reduce using rule 26 (def_id -> IDENTIFIER .)
INFO:root:
INFO:root:
INFO:root:state 855
INFO:root:
INFO:root:    (382) entry_decl -> ENTRY IDENTIFIER ( discrete_range . ) formal_part_opt ;
INFO:root:
INFO:root:    )               shift and go to state 892
INFO:root:
INFO:root:
INFO:root:state 856
INFO:root:
INFO:root:    (373) prot_body -> PROTECTED BODY simple_name IS prot_op_body_s END id_opt ; .
INFO:root:
INFO:root:    PACKAGE         reduce using rule 373 (prot_body -> PROTECTED BODY simple_name IS prot_op_body_s END id_opt ; .)
INFO:root:    TASK            reduce using rule 373 (prot_body -> PROTECTED BODY simple_name IS prot_op_body_s END id_opt ; .)
INFO:root:    PROTECTED       reduce using rule 373 (prot_body -> PROTECTED BODY simple_name IS prot_op_body_s END id_opt ; .)
INFO:root:    error           reduce using rule 373 (prot_body -> PROTECTED BODY simple_name IS prot_op_body_s END id_opt ; .)
INFO:root:    USE             reduce using rule 373 (prot_body -> PROTECTED BODY simple_name IS prot_op_body_s END id_opt ; .)
INFO:root:    PRAGMA          reduce using rule 373 (prot_body -> PROTECTED BODY simple_name IS prot_op_body_s END id_opt ; .)
INFO:root:    TYPE            reduce using rule 373 (prot_body -> PROTECTED BODY simple_name IS prot_op_body_s END id_opt ; .)
INFO:root:    SUBTYPE         reduce using rule 373 (prot_body -> PROTECTED BODY simple_name IS prot_op_body_s END id_opt ; .)
INFO:root:    FOR             reduce using rule 373 (prot_body -> PROTECTED BODY simple_name IS prot_op_body_s END id_opt ; .)
INFO:root:    PROCEDURE       reduce using rule 373 (prot_body -> PROTECTED BODY simple_name IS prot_op_body_s END id_opt ; .)
INFO:root:    FUNCTION        reduce using rule 373 (prot_body -> PROTECTED BODY simple_name IS prot_op_body_s END id_opt ; .)
INFO:root:    GENERIC         reduce using rule 373 (prot_body -> PROTECTED BODY simple_name IS prot_op_body_s END id_opt ; .)
INFO:root:    IDENTIFIER      reduce using rule 373 (prot_body -> PROTECTED BODY simple_name IS prot_op_body_s END id_opt ; .)
INFO:root:    BEGIN           reduce using rule 373 (prot_body -> PROTECTED BODY simple_name IS prot_op_body_s END id_opt ; .)
INFO:root:    END             reduce using rule 373 (prot_body -> PROTECTED BODY simple_name IS prot_op_body_s END id_opt ; .)
INFO:root:    PRIVATE         reduce using rule 373 (prot_body -> PROTECTED BODY simple_name IS prot_op_body_s END id_opt ; .)
INFO:root:    WITH            reduce using rule 373 (prot_body -> PROTECTED BODY simple_name IS prot_op_body_s END id_opt ; .)
INFO:root:    SEPARATE        reduce using rule 373 (prot_body -> PROTECTED BODY simple_name IS prot_op_body_s END id_opt ; .)
INFO:root:    $end            reduce using rule 373 (prot_body -> PROTECTED BODY simple_name IS prot_op_body_s END id_opt ; .)
INFO:root:
INFO:root:
INFO:root:state 857
INFO:root:
INFO:root:    (383) entry_body -> ENTRY IDENTIFIER formal_part_opt . WHEN condition entry_body_part
INFO:root:
INFO:root:    WHEN            shift and go to state 893
INFO:root:
INFO:root:
INFO:root:state 858
INFO:root:
INFO:root:    (384) entry_body -> ENTRY IDENTIFIER ( . iter_part discrete_range ) formal_part_opt WHEN condition entry_body_part
INFO:root:    (311) formal_part -> ( . param_s )
INFO:root:    (281) iter_part -> . FOR IDENTIFIER IN
INFO:root:    (312) param_s -> . param
INFO:root:    (313) param_s -> . param_s ; param
INFO:root:    (314) param -> . def_id_s : mode mark init_opt
INFO:root:    (315) param -> . error
INFO:root:    (24) def_id_s -> . def_id
INFO:root:    (25) def_id_s -> . def_id_s , def_id
INFO:root:    (26) def_id -> . IDENTIFIER
INFO:root:
INFO:root:    FOR             shift and go to state 464
INFO:root:    error           shift and go to state 55
INFO:root:    IDENTIFIER      shift and go to state 52
INFO:root:
INFO:root:    def_id_s                       shift and go to state 56
INFO:root:    def_id                         shift and go to state 57
INFO:root:    param_s                        shift and go to state 247
INFO:root:    iter_part                      shift and go to state 894
INFO:root:    param                          shift and go to state 248
INFO:root:
INFO:root:state 859
INFO:root:
INFO:root:    (108) comp_decl -> def_id_s : . component_subtype_def init_opt ;
INFO:root:    (82) component_subtype_def -> . aliased_opt subtype_ind
INFO:root:    (83) aliased_opt -> .
INFO:root:    (84) aliased_opt -> . ALIASED
INFO:root:
INFO:root:    IDENTIFIER      reduce using rule 83 (aliased_opt -> .)
INFO:root:    STRING          reduce using rule 83 (aliased_opt -> .)
INFO:root:    ALIASED         shift and go to state 788
INFO:root:
INFO:root:    component_subtype_def          shift and go to state 895
INFO:root:    aliased_opt                    shift and go to state 790
INFO:root:
INFO:root:state 860
INFO:root:
INFO:root:    (109) comp_decl -> error ; .
INFO:root:
INFO:root:    error           reduce using rule 109 (comp_decl -> error ; .)
INFO:root:    ENTRY           reduce using rule 109 (comp_decl -> error ; .)
INFO:root:    PROCEDURE       reduce using rule 109 (comp_decl -> error ; .)
INFO:root:    FUNCTION        reduce using rule 109 (comp_decl -> error ; .)
INFO:root:    PRAGMA          reduce using rule 109 (comp_decl -> error ; .)
INFO:root:    FOR             reduce using rule 109 (comp_decl -> error ; .)
INFO:root:    IDENTIFIER      reduce using rule 109 (comp_decl -> error ; .)
INFO:root:    END             reduce using rule 109 (comp_decl -> error ; .)
INFO:root:    CASE            reduce using rule 109 (comp_decl -> error ; .)
INFO:root:    WHEN            reduce using rule 109 (comp_decl -> error ; .)
INFO:root:
INFO:root:
INFO:root:state 861
INFO:root:
INFO:root:    (497) align_opt -> AT MOD expression ; .
INFO:root:
INFO:root:    END             reduce using rule 497 (align_opt -> AT MOD expression ; .)
INFO:root:    IDENTIFIER      reduce using rule 497 (align_opt -> AT MOD expression ; .)
INFO:root:
INFO:root:
INFO:root:state 862
INFO:root:
INFO:root:    (495) record_type_spec -> FOR mark USE RECORD align_opt comp_loc_s END RECORD . ;
INFO:root:
INFO:root:    ;               shift and go to state 896
INFO:root:
INFO:root:
INFO:root:state 863
INFO:root:
INFO:root:    (499) comp_loc_s -> comp_loc_s mark AT . expression RANGE range ;
INFO:root:    (188) expression -> . relation
INFO:root:    (189) expression -> . expression logical relation
INFO:root:    (190) expression -> . expression short_circuit relation
INFO:root:    (196) relation -> . simple_expression
INFO:root:    (197) relation -> . simple_expression relational simple_expression
INFO:root:    (198) relation -> . simple_expression membership range
INFO:root:    (199) relation -> . simple_expression membership name
INFO:root:    (208) simple_expression -> . unary term
INFO:root:    (209) simple_expression -> . term
INFO:root:    (210) simple_expression -> . simple_expression adding term
INFO:root:    (211) unary -> . +
INFO:root:    (212) unary -> . -
INFO:root:    (216) term -> . factor
INFO:root:    (217) term -> . term multiplying factor
INFO:root:    (223) factor -> . primary
INFO:root:    (224) factor -> . NOT primary
INFO:root:    (225) factor -> . ABS primary
INFO:root:    (226) primary -> . literal
INFO:root:    (227) primary -> . name
INFO:root:    (228) primary -> . allocator
INFO:root:    (229) primary -> . qualified
INFO:root:    (230) primary -> . parenthesized_primary
INFO:root:    (180) literal -> . INT
INFO:root:    (181) literal -> . FLOAT
INFO:root:    (182) literal -> . NuLL
INFO:root:    (149) name -> . simple_name
INFO:root:    (150) name -> . indexed_comp
INFO:root:    (151) name -> . selected_comp
INFO:root:    (152) name -> . attribute
INFO:root:    (153) name -> . operator_symbol
INFO:root:    (234) allocator -> . NEW name
INFO:root:    (235) allocator -> . NEW qualified
INFO:root:    (233) qualified -> . name TICK parenthesized_primary
INFO:root:    (231) parenthesized_primary -> . aggregate
INFO:root:    (232) parenthesized_primary -> . ( expression )
INFO:root:    (157) simple_name -> . IDENTIFIER
INFO:root:    (164) indexed_comp -> . name ( value_s )
INFO:root:    (171) selected_comp -> . name . simple_name
INFO:root:    (172) selected_comp -> . name . used_char
INFO:root:    (173) selected_comp -> . name . operator_symbol
INFO:root:    (174) selected_comp -> . name . ALL
INFO:root:    (175) attribute -> . name TICK attribute_id
INFO:root:    (163) operator_symbol -> . STRING
INFO:root:    (183) aggregate -> . ( comp_assoc )
INFO:root:    (184) aggregate -> . ( expression WITH value_s )
INFO:root:    (185) aggregate -> . ( expression WITH NuLL RECORD )
INFO:root:    (186) aggregate -> . ( NuLL RECORD )
INFO:root:
INFO:root:    +               shift and go to state 148
INFO:root:    -               shift and go to state 136
INFO:root:    NOT             shift and go to state 131
INFO:root:    ABS             shift and go to state 132
INFO:root:    INT             shift and go to state 120
INFO:root:    FLOAT           shift and go to state 128
INFO:root:    NuLL            shift and go to state 130
INFO:root:    NEW             shift and go to state 137
INFO:root:    (               shift and go to state 125
INFO:root:    IDENTIFIER      shift and go to state 33
INFO:root:    STRING          shift and go to state 149
INFO:root:
INFO:root:    literal                        shift and go to state 121
INFO:root:    allocator                      shift and go to state 122
INFO:root:    simple_name                    shift and go to state 163
INFO:root:    name                           shift and go to state 142
INFO:root:    selected_comp                  shift and go to state 139
INFO:root:    factor                         shift and go to state 126
INFO:root:    expression                     shift and go to state 897
INFO:root:    unary                          shift and go to state 144
INFO:root:    qualified                      shift and go to state 145
INFO:root:    aggregate                      shift and go to state 143
INFO:root:    simple_expression              shift and go to state 129
INFO:root:    term                           shift and go to state 146
INFO:root:    indexed_comp                   shift and go to state 140
INFO:root:    operator_symbol                shift and go to state 133
INFO:root:    parenthesized_primary          shift and go to state 147
INFO:root:    attribute                      shift and go to state 134
INFO:root:    primary                        shift and go to state 135
INFO:root:    relation                       shift and go to state 138
INFO:root:
INFO:root:state 864
INFO:root:
INFO:root:    (284) basic_loop -> LOOP statement_s END LOOP .
INFO:root:
INFO:root:    STRING          reduce using rule 284 (basic_loop -> LOOP statement_s END LOOP .)
INFO:root:    IDENTIFIER      reduce using rule 284 (basic_loop -> LOOP statement_s END LOOP .)
INFO:root:    ;               reduce using rule 284 (basic_loop -> LOOP statement_s END LOOP .)
INFO:root:
INFO:root:
INFO:root:state 865
INFO:root:
INFO:root:    (287) block -> label_opt block_decl block_body END id_opt ; .
INFO:root:
INFO:root:    LL              reduce using rule 287 (block -> label_opt block_decl block_body END id_opt ; .)
INFO:root:    error           reduce using rule 287 (block -> label_opt block_decl block_body END id_opt ; .)
INFO:root:    NuLL            reduce using rule 287 (block -> label_opt block_decl block_body END id_opt ; .)
INFO:root:    EXIT            reduce using rule 287 (block -> label_opt block_decl block_body END id_opt ; .)
INFO:root:    RETURN          reduce using rule 287 (block -> label_opt block_decl block_body END id_opt ; .)
INFO:root:    DELAY           reduce using rule 287 (block -> label_opt block_decl block_body END id_opt ; .)
INFO:root:    ABORT           reduce using rule 287 (block -> label_opt block_decl block_body END id_opt ; .)
INFO:root:    RAISE           reduce using rule 287 (block -> label_opt block_decl block_body END id_opt ; .)
INFO:root:    REQUEUE         reduce using rule 287 (block -> label_opt block_decl block_body END id_opt ; .)
INFO:root:    IF              reduce using rule 287 (block -> label_opt block_decl block_body END id_opt ; .)
INFO:root:    CASE            reduce using rule 287 (block -> label_opt block_decl block_body END id_opt ; .)
INFO:root:    IDENTIFIER      reduce using rule 287 (block -> label_opt block_decl block_body END id_opt ; .)
INFO:root:    ACCEPT          reduce using rule 287 (block -> label_opt block_decl block_body END id_opt ; .)
INFO:root:    SELECT          reduce using rule 287 (block -> label_opt block_decl block_body END id_opt ; .)
INFO:root:    STRING          reduce using rule 287 (block -> label_opt block_decl block_body END id_opt ; .)
INFO:root:    WHILE           reduce using rule 287 (block -> label_opt block_decl block_body END id_opt ; .)
INFO:root:    DECLARE         reduce using rule 287 (block -> label_opt block_decl block_body END id_opt ; .)
INFO:root:    FOR             reduce using rule 287 (block -> label_opt block_decl block_body END id_opt ; .)
INFO:root:    LOOP            reduce using rule 287 (block -> label_opt block_decl block_body END id_opt ; .)
INFO:root:    BEGIN           reduce using rule 287 (block -> label_opt block_decl block_body END id_opt ; .)
INFO:root:    WHEN            reduce using rule 287 (block -> label_opt block_decl block_body END id_opt ; .)
INFO:root:    END             reduce using rule 287 (block -> label_opt block_decl block_body END id_opt ; .)
INFO:root:    OR              reduce using rule 287 (block -> label_opt block_decl block_body END id_opt ; .)
INFO:root:    ELSE            reduce using rule 287 (block -> label_opt block_decl block_body END id_opt ; .)
INFO:root:    THEN            reduce using rule 287 (block -> label_opt block_decl block_body END id_opt ; .)
INFO:root:    EXCEPTION       reduce using rule 287 (block -> label_opt block_decl block_body END id_opt ; .)
INFO:root:    ELSIF           reduce using rule 287 (block -> label_opt block_decl block_body END id_opt ; .)
INFO:root:
INFO:root:
INFO:root:state 866
INFO:root:
INFO:root:    (391) accept_stmt -> accept_hdr DO handled_stmt_s END id_opt ; .
INFO:root:
INFO:root:    END             reduce using rule 391 (accept_stmt -> accept_hdr DO handled_stmt_s END id_opt ; .)
INFO:root:    LL              reduce using rule 391 (accept_stmt -> accept_hdr DO handled_stmt_s END id_opt ; .)
INFO:root:    error           reduce using rule 391 (accept_stmt -> accept_hdr DO handled_stmt_s END id_opt ; .)
INFO:root:    NuLL            reduce using rule 391 (accept_stmt -> accept_hdr DO handled_stmt_s END id_opt ; .)
INFO:root:    EXIT            reduce using rule 391 (accept_stmt -> accept_hdr DO handled_stmt_s END id_opt ; .)
INFO:root:    RETURN          reduce using rule 391 (accept_stmt -> accept_hdr DO handled_stmt_s END id_opt ; .)
INFO:root:    DELAY           reduce using rule 391 (accept_stmt -> accept_hdr DO handled_stmt_s END id_opt ; .)
INFO:root:    ABORT           reduce using rule 391 (accept_stmt -> accept_hdr DO handled_stmt_s END id_opt ; .)
INFO:root:    RAISE           reduce using rule 391 (accept_stmt -> accept_hdr DO handled_stmt_s END id_opt ; .)
INFO:root:    REQUEUE         reduce using rule 391 (accept_stmt -> accept_hdr DO handled_stmt_s END id_opt ; .)
INFO:root:    IF              reduce using rule 391 (accept_stmt -> accept_hdr DO handled_stmt_s END id_opt ; .)
INFO:root:    CASE            reduce using rule 391 (accept_stmt -> accept_hdr DO handled_stmt_s END id_opt ; .)
INFO:root:    IDENTIFIER      reduce using rule 391 (accept_stmt -> accept_hdr DO handled_stmt_s END id_opt ; .)
INFO:root:    ACCEPT          reduce using rule 391 (accept_stmt -> accept_hdr DO handled_stmt_s END id_opt ; .)
INFO:root:    SELECT          reduce using rule 391 (accept_stmt -> accept_hdr DO handled_stmt_s END id_opt ; .)
INFO:root:    STRING          reduce using rule 391 (accept_stmt -> accept_hdr DO handled_stmt_s END id_opt ; .)
INFO:root:    WHILE           reduce using rule 391 (accept_stmt -> accept_hdr DO handled_stmt_s END id_opt ; .)
INFO:root:    DECLARE         reduce using rule 391 (accept_stmt -> accept_hdr DO handled_stmt_s END id_opt ; .)
INFO:root:    FOR             reduce using rule 391 (accept_stmt -> accept_hdr DO handled_stmt_s END id_opt ; .)
INFO:root:    LOOP            reduce using rule 391 (accept_stmt -> accept_hdr DO handled_stmt_s END id_opt ; .)
INFO:root:    BEGIN           reduce using rule 391 (accept_stmt -> accept_hdr DO handled_stmt_s END id_opt ; .)
INFO:root:    OR              reduce using rule 391 (accept_stmt -> accept_hdr DO handled_stmt_s END id_opt ; .)
INFO:root:    ELSE            reduce using rule 391 (accept_stmt -> accept_hdr DO handled_stmt_s END id_opt ; .)
INFO:root:    EXCEPTION       reduce using rule 391 (accept_stmt -> accept_hdr DO handled_stmt_s END id_opt ; .)
INFO:root:    WHEN            reduce using rule 391 (accept_stmt -> accept_hdr DO handled_stmt_s END id_opt ; .)
INFO:root:    THEN            reduce using rule 391 (accept_stmt -> accept_hdr DO handled_stmt_s END id_opt ; .)
INFO:root:    ELSIF           reduce using rule 391 (accept_stmt -> accept_hdr DO handled_stmt_s END id_opt ; .)
INFO:root:
INFO:root:
INFO:root:state 867
INFO:root:
INFO:root:    (270) case_stmt -> case_hdr pragma_s alternative_s END CASE ; .
INFO:root:
INFO:root:    LL              reduce using rule 270 (case_stmt -> case_hdr pragma_s alternative_s END CASE ; .)
INFO:root:    error           reduce using rule 270 (case_stmt -> case_hdr pragma_s alternative_s END CASE ; .)
INFO:root:    NuLL            reduce using rule 270 (case_stmt -> case_hdr pragma_s alternative_s END CASE ; .)
INFO:root:    EXIT            reduce using rule 270 (case_stmt -> case_hdr pragma_s alternative_s END CASE ; .)
INFO:root:    RETURN          reduce using rule 270 (case_stmt -> case_hdr pragma_s alternative_s END CASE ; .)
INFO:root:    DELAY           reduce using rule 270 (case_stmt -> case_hdr pragma_s alternative_s END CASE ; .)
INFO:root:    ABORT           reduce using rule 270 (case_stmt -> case_hdr pragma_s alternative_s END CASE ; .)
INFO:root:    RAISE           reduce using rule 270 (case_stmt -> case_hdr pragma_s alternative_s END CASE ; .)
INFO:root:    REQUEUE         reduce using rule 270 (case_stmt -> case_hdr pragma_s alternative_s END CASE ; .)
INFO:root:    IF              reduce using rule 270 (case_stmt -> case_hdr pragma_s alternative_s END CASE ; .)
INFO:root:    CASE            reduce using rule 270 (case_stmt -> case_hdr pragma_s alternative_s END CASE ; .)
INFO:root:    IDENTIFIER      reduce using rule 270 (case_stmt -> case_hdr pragma_s alternative_s END CASE ; .)
INFO:root:    ACCEPT          reduce using rule 270 (case_stmt -> case_hdr pragma_s alternative_s END CASE ; .)
INFO:root:    SELECT          reduce using rule 270 (case_stmt -> case_hdr pragma_s alternative_s END CASE ; .)
INFO:root:    STRING          reduce using rule 270 (case_stmt -> case_hdr pragma_s alternative_s END CASE ; .)
INFO:root:    WHILE           reduce using rule 270 (case_stmt -> case_hdr pragma_s alternative_s END CASE ; .)
INFO:root:    DECLARE         reduce using rule 270 (case_stmt -> case_hdr pragma_s alternative_s END CASE ; .)
INFO:root:    FOR             reduce using rule 270 (case_stmt -> case_hdr pragma_s alternative_s END CASE ; .)
INFO:root:    LOOP            reduce using rule 270 (case_stmt -> case_hdr pragma_s alternative_s END CASE ; .)
INFO:root:    BEGIN           reduce using rule 270 (case_stmt -> case_hdr pragma_s alternative_s END CASE ; .)
INFO:root:    END             reduce using rule 270 (case_stmt -> case_hdr pragma_s alternative_s END CASE ; .)
INFO:root:    WHEN            reduce using rule 270 (case_stmt -> case_hdr pragma_s alternative_s END CASE ; .)
INFO:root:    EXCEPTION       reduce using rule 270 (case_stmt -> case_hdr pragma_s alternative_s END CASE ; .)
INFO:root:    ELSIF           reduce using rule 270 (case_stmt -> case_hdr pragma_s alternative_s END CASE ; .)
INFO:root:    ELSE            reduce using rule 270 (case_stmt -> case_hdr pragma_s alternative_s END CASE ; .)
INFO:root:    OR              reduce using rule 270 (case_stmt -> case_hdr pragma_s alternative_s END CASE ; .)
INFO:root:    THEN            reduce using rule 270 (case_stmt -> case_hdr pragma_s alternative_s END CASE ; .)
INFO:root:
INFO:root:
INFO:root:state 868
INFO:root:
INFO:root:    (274) alternative -> WHEN choice_s ARROW . statement_s
INFO:root:    (236) statement_s -> . statement
INFO:root:    (237) statement_s -> . statement_s statement
INFO:root:    (238) statement -> . unlabeled
INFO:root:    (239) statement -> . label statement
INFO:root:    (240) unlabeled -> . simple_stmt
INFO:root:    (241) unlabeled -> . compound_stmt
INFO:root:    (259) label -> . LL IDENTIFIER RR
INFO:root:    (242) simple_stmt -> . null_stmt
INFO:root:    (243) simple_stmt -> . assign_stmt
INFO:root:    (244) simple_stmt -> . exit_stmt
INFO:root:    (245) simple_stmt -> . return_stmt
INFO:root:    (246) simple_stmt -> . procedure_call
INFO:root:    (247) simple_stmt -> . delay_stmt
INFO:root:    (248) simple_stmt -> . abort_stmt
INFO:root:    (249) simple_stmt -> . raise_stmt
INFO:root:    (250) simple_stmt -> . code_stmt
INFO:root:    (251) simple_stmt -> . requeue_stmt
INFO:root:    (252) simple_stmt -> . error ;
INFO:root:    (253) compound_stmt -> . if_stmt
INFO:root:    (254) compound_stmt -> . case_stmt
INFO:root:    (255) compound_stmt -> . loop_stmt
INFO:root:    (256) compound_stmt -> . block
INFO:root:    (257) compound_stmt -> . accept_stmt
INFO:root:    (258) compound_stmt -> . select_stmt
INFO:root:    (260) null_stmt -> . NuLL ;
INFO:root:    (261) assign_stmt -> . name ASSIGN expression ;
INFO:root:    (294) exit_stmt -> . EXIT name_opt when_opt ;
INFO:root:    (299) return_stmt -> . RETURN ;
INFO:root:    (300) return_stmt -> . RETURN expression ;
INFO:root:    (323) procedure_call -> . name ;
INFO:root:    (395) delay_stmt -> . DELAY expression ;
INFO:root:    (396) delay_stmt -> . DELAY UNTIL expression ;
INFO:root:    (416) abort_stmt -> . ABORT name_s ;
INFO:root:    (455) raise_stmt -> . RAISE name_opt ;
INFO:root:    (501) code_stmt -> . qualified ;
INFO:root:    (456) requeue_stmt -> . REQUEUE name ;
INFO:root:    (457) requeue_stmt -> . REQUEUE name WITH ABORT ;
INFO:root:    (262) if_stmt -> . IF cond_clause_s else_opt END IF ;
INFO:root:    (270) case_stmt -> . case_hdr pragma_s alternative_s END CASE ;
INFO:root:    (275) loop_stmt -> . label_opt iteration basic_loop id_opt ;
INFO:root:    (287) block -> . label_opt block_decl block_body END id_opt ;
INFO:root:    (390) accept_stmt -> . accept_hdr ;
INFO:root:    (391) accept_stmt -> . accept_hdr DO handled_stmt_s END id_opt ;
INFO:root:    (397) select_stmt -> . select_wait
INFO:root:    (398) select_stmt -> . async_select
INFO:root:    (399) select_stmt -> . timed_entry_call
INFO:root:    (400) select_stmt -> . cond_entry_call
INFO:root:    (149) name -> . simple_name
INFO:root:    (150) name -> . indexed_comp
INFO:root:    (151) name -> . selected_comp
INFO:root:    (152) name -> . attribute
INFO:root:    (153) name -> . operator_symbol
INFO:root:    (233) qualified -> . name TICK parenthesized_primary
INFO:root:    (271) case_hdr -> . CASE expression IS
INFO:root:    (276) label_opt -> .
INFO:root:    (277) label_opt -> . IDENTIFIER :
INFO:root:    (392) accept_hdr -> . ACCEPT entry_name formal_part_opt
INFO:root:    (401) select_wait -> . SELECT guarded_select_alt or_select else_opt END SELECT ;
INFO:root:    (411) async_select -> . SELECT delay_or_entry_alt THEN ABORT statement_s END SELECT ;
INFO:root:    (412) timed_entry_call -> . SELECT entry_call stmts_opt OR delay_stmt stmts_opt END SELECT ;
INFO:root:    (413) cond_entry_call -> . SELECT entry_call stmts_opt ELSE statement_s END SELECT ;
INFO:root:    (157) simple_name -> . IDENTIFIER
INFO:root:    (164) indexed_comp -> . name ( value_s )
INFO:root:    (171) selected_comp -> . name . simple_name
INFO:root:    (172) selected_comp -> . name . used_char
INFO:root:    (173) selected_comp -> . name . operator_symbol
INFO:root:    (174) selected_comp -> . name . ALL
INFO:root:    (175) attribute -> . name TICK attribute_id
INFO:root:    (163) operator_symbol -> . STRING
INFO:root:
INFO:root:    LL              shift and go to state 344
INFO:root:    error           shift and go to state 341
INFO:root:    NuLL            shift and go to state 347
INFO:root:    EXIT            shift and go to state 340
INFO:root:    RETURN          shift and go to state 303
INFO:root:    DELAY           shift and go to state 332
INFO:root:    ABORT           shift and go to state 326
INFO:root:    RAISE           shift and go to state 314
INFO:root:    REQUEUE         shift and go to state 317
INFO:root:    IF              shift and go to state 327
INFO:root:    CASE            shift and go to state 312
INFO:root:    WHILE           reduce using rule 276 (label_opt -> .)
INFO:root:    DECLARE         reduce using rule 276 (label_opt -> .)
INFO:root:    FOR             reduce using rule 276 (label_opt -> .)
INFO:root:    LOOP            reduce using rule 276 (label_opt -> .)
INFO:root:    BEGIN           reduce using rule 276 (label_opt -> .)
INFO:root:    IDENTIFIER      shift and go to state 322
INFO:root:    ACCEPT          shift and go to state 310
INFO:root:    SELECT          shift and go to state 320
INFO:root:    STRING          shift and go to state 149
INFO:root:
INFO:root:    cond_entry_call                shift and go to state 345
INFO:root:    simple_stmt                    shift and go to state 302
INFO:root:    async_select                   shift and go to state 328
INFO:root:    simple_name                    shift and go to state 163
INFO:root:    requeue_stmt                   shift and go to state 329
INFO:root:    if_stmt                        shift and go to state 304
INFO:root:    procedure_call                 shift and go to state 305
INFO:root:    select_wait                    shift and go to state 330
INFO:root:    indexed_comp                   shift and go to state 140
INFO:root:    timed_entry_call               shift and go to state 307
INFO:root:    statement                      shift and go to state 308
INFO:root:    operator_symbol                shift and go to state 133
INFO:root:    exit_stmt                      shift and go to state 306
INFO:root:    code_stmt                      shift and go to state 331
INFO:root:    loop_stmt                      shift and go to state 333
INFO:root:    null_stmt                      shift and go to state 334
INFO:root:    label                          shift and go to state 335
INFO:root:    select_stmt                    shift and go to state 311
INFO:root:    label_opt                      shift and go to state 313
INFO:root:    assign_stmt                    shift and go to state 336
INFO:root:    selected_comp                  shift and go to state 139
INFO:root:    abort_stmt                     shift and go to state 315
INFO:root:    attribute                      shift and go to state 134
INFO:root:    name                           shift and go to state 316
INFO:root:    accept_hdr                     shift and go to state 318
INFO:root:    accept_stmt                    shift and go to state 337
INFO:root:    case_hdr                       shift and go to state 319
INFO:root:    delay_stmt                     shift and go to state 338
INFO:root:    statement_s                    shift and go to state 898
INFO:root:    compound_stmt                  shift and go to state 309
INFO:root:    raise_stmt                     shift and go to state 342
INFO:root:    qualified                      shift and go to state 321
INFO:root:    return_stmt                    shift and go to state 323
INFO:root:    case_stmt                      shift and go to state 324
INFO:root:    block                          shift and go to state 325
INFO:root:    unlabeled                      shift and go to state 346
INFO:root:
INFO:root:state 869
INFO:root:
INFO:root:    (413) cond_entry_call -> SELECT entry_call stmts_opt ELSE statement_s END . SELECT ;
INFO:root:
INFO:root:    SELECT          shift and go to state 899
INFO:root:
INFO:root:
INFO:root:state 870
INFO:root:
INFO:root:    (412) timed_entry_call -> SELECT entry_call stmts_opt OR delay_stmt stmts_opt . END SELECT ;
INFO:root:
INFO:root:    END             shift and go to state 900
INFO:root:
INFO:root:
INFO:root:state 871
INFO:root:
INFO:root:    (407) select_alt -> delay_stmt stmts_opt .
INFO:root:
INFO:root:    OR              reduce using rule 407 (select_alt -> delay_stmt stmts_opt .)
INFO:root:    ELSE            reduce using rule 407 (select_alt -> delay_stmt stmts_opt .)
INFO:root:    END             reduce using rule 407 (select_alt -> delay_stmt stmts_opt .)
INFO:root:
INFO:root:
INFO:root:state 872
INFO:root:
INFO:root:    (401) select_wait -> SELECT guarded_select_alt or_select else_opt END SELECT . ;
INFO:root:
INFO:root:    ;               shift and go to state 901
INFO:root:
INFO:root:
INFO:root:state 873
INFO:root:
INFO:root:    (411) async_select -> SELECT delay_or_entry_alt THEN ABORT statement_s END . SELECT ;
INFO:root:
INFO:root:    SELECT          shift and go to state 902
INFO:root:
INFO:root:
INFO:root:state 874
INFO:root:
INFO:root:    (262) if_stmt -> IF cond_clause_s else_opt END IF ; .
INFO:root:
INFO:root:    EXCEPTION       reduce using rule 262 (if_stmt -> IF cond_clause_s else_opt END IF ; .)
INFO:root:    LL              reduce using rule 262 (if_stmt -> IF cond_clause_s else_opt END IF ; .)
INFO:root:    error           reduce using rule 262 (if_stmt -> IF cond_clause_s else_opt END IF ; .)
INFO:root:    NuLL            reduce using rule 262 (if_stmt -> IF cond_clause_s else_opt END IF ; .)
INFO:root:    EXIT            reduce using rule 262 (if_stmt -> IF cond_clause_s else_opt END IF ; .)
INFO:root:    RETURN          reduce using rule 262 (if_stmt -> IF cond_clause_s else_opt END IF ; .)
INFO:root:    DELAY           reduce using rule 262 (if_stmt -> IF cond_clause_s else_opt END IF ; .)
INFO:root:    ABORT           reduce using rule 262 (if_stmt -> IF cond_clause_s else_opt END IF ; .)
INFO:root:    RAISE           reduce using rule 262 (if_stmt -> IF cond_clause_s else_opt END IF ; .)
INFO:root:    REQUEUE         reduce using rule 262 (if_stmt -> IF cond_clause_s else_opt END IF ; .)
INFO:root:    IF              reduce using rule 262 (if_stmt -> IF cond_clause_s else_opt END IF ; .)
INFO:root:    CASE            reduce using rule 262 (if_stmt -> IF cond_clause_s else_opt END IF ; .)
INFO:root:    IDENTIFIER      reduce using rule 262 (if_stmt -> IF cond_clause_s else_opt END IF ; .)
INFO:root:    ACCEPT          reduce using rule 262 (if_stmt -> IF cond_clause_s else_opt END IF ; .)
INFO:root:    SELECT          reduce using rule 262 (if_stmt -> IF cond_clause_s else_opt END IF ; .)
INFO:root:    STRING          reduce using rule 262 (if_stmt -> IF cond_clause_s else_opt END IF ; .)
INFO:root:    WHILE           reduce using rule 262 (if_stmt -> IF cond_clause_s else_opt END IF ; .)
INFO:root:    DECLARE         reduce using rule 262 (if_stmt -> IF cond_clause_s else_opt END IF ; .)
INFO:root:    FOR             reduce using rule 262 (if_stmt -> IF cond_clause_s else_opt END IF ; .)
INFO:root:    LOOP            reduce using rule 262 (if_stmt -> IF cond_clause_s else_opt END IF ; .)
INFO:root:    BEGIN           reduce using rule 262 (if_stmt -> IF cond_clause_s else_opt END IF ; .)
INFO:root:    END             reduce using rule 262 (if_stmt -> IF cond_clause_s else_opt END IF ; .)
INFO:root:    WHEN            reduce using rule 262 (if_stmt -> IF cond_clause_s else_opt END IF ; .)
INFO:root:    OR              reduce using rule 262 (if_stmt -> IF cond_clause_s else_opt END IF ; .)
INFO:root:    ELSE            reduce using rule 262 (if_stmt -> IF cond_clause_s else_opt END IF ; .)
INFO:root:    THEN            reduce using rule 262 (if_stmt -> IF cond_clause_s else_opt END IF ; .)
INFO:root:    ELSIF           reduce using rule 262 (if_stmt -> IF cond_clause_s else_opt END IF ; .)
INFO:root:
INFO:root:
INFO:root:state 875
INFO:root:
INFO:root:    (449) exception_handler -> WHEN except_choice_s ARROW statement_s .
INFO:root:    (237) statement_s -> statement_s . statement
INFO:root:    (238) statement -> . unlabeled
INFO:root:    (239) statement -> . label statement
INFO:root:    (240) unlabeled -> . simple_stmt
INFO:root:    (241) unlabeled -> . compound_stmt
INFO:root:    (259) label -> . LL IDENTIFIER RR
INFO:root:    (242) simple_stmt -> . null_stmt
INFO:root:    (243) simple_stmt -> . assign_stmt
INFO:root:    (244) simple_stmt -> . exit_stmt
INFO:root:    (245) simple_stmt -> . return_stmt
INFO:root:    (246) simple_stmt -> . procedure_call
INFO:root:    (247) simple_stmt -> . delay_stmt
INFO:root:    (248) simple_stmt -> . abort_stmt
INFO:root:    (249) simple_stmt -> . raise_stmt
INFO:root:    (250) simple_stmt -> . code_stmt
INFO:root:    (251) simple_stmt -> . requeue_stmt
INFO:root:    (252) simple_stmt -> . error ;
INFO:root:    (253) compound_stmt -> . if_stmt
INFO:root:    (254) compound_stmt -> . case_stmt
INFO:root:    (255) compound_stmt -> . loop_stmt
INFO:root:    (256) compound_stmt -> . block
INFO:root:    (257) compound_stmt -> . accept_stmt
INFO:root:    (258) compound_stmt -> . select_stmt
INFO:root:    (260) null_stmt -> . NuLL ;
INFO:root:    (261) assign_stmt -> . name ASSIGN expression ;
INFO:root:    (294) exit_stmt -> . EXIT name_opt when_opt ;
INFO:root:    (299) return_stmt -> . RETURN ;
INFO:root:    (300) return_stmt -> . RETURN expression ;
INFO:root:    (323) procedure_call -> . name ;
INFO:root:    (395) delay_stmt -> . DELAY expression ;
INFO:root:    (396) delay_stmt -> . DELAY UNTIL expression ;
INFO:root:    (416) abort_stmt -> . ABORT name_s ;
INFO:root:    (455) raise_stmt -> . RAISE name_opt ;
INFO:root:    (501) code_stmt -> . qualified ;
INFO:root:    (456) requeue_stmt -> . REQUEUE name ;
INFO:root:    (457) requeue_stmt -> . REQUEUE name WITH ABORT ;
INFO:root:    (262) if_stmt -> . IF cond_clause_s else_opt END IF ;
INFO:root:    (270) case_stmt -> . case_hdr pragma_s alternative_s END CASE ;
INFO:root:    (275) loop_stmt -> . label_opt iteration basic_loop id_opt ;
INFO:root:    (287) block -> . label_opt block_decl block_body END id_opt ;
INFO:root:    (390) accept_stmt -> . accept_hdr ;
INFO:root:    (391) accept_stmt -> . accept_hdr DO handled_stmt_s END id_opt ;
INFO:root:    (397) select_stmt -> . select_wait
INFO:root:    (398) select_stmt -> . async_select
INFO:root:    (399) select_stmt -> . timed_entry_call
INFO:root:    (400) select_stmt -> . cond_entry_call
INFO:root:    (149) name -> . simple_name
INFO:root:    (150) name -> . indexed_comp
INFO:root:    (151) name -> . selected_comp
INFO:root:    (152) name -> . attribute
INFO:root:    (153) name -> . operator_symbol
INFO:root:    (233) qualified -> . name TICK parenthesized_primary
INFO:root:    (271) case_hdr -> . CASE expression IS
INFO:root:    (276) label_opt -> .
INFO:root:    (277) label_opt -> . IDENTIFIER :
INFO:root:    (392) accept_hdr -> . ACCEPT entry_name formal_part_opt
INFO:root:    (401) select_wait -> . SELECT guarded_select_alt or_select else_opt END SELECT ;
INFO:root:    (411) async_select -> . SELECT delay_or_entry_alt THEN ABORT statement_s END SELECT ;
INFO:root:    (412) timed_entry_call -> . SELECT entry_call stmts_opt OR delay_stmt stmts_opt END SELECT ;
INFO:root:    (413) cond_entry_call -> . SELECT entry_call stmts_opt ELSE statement_s END SELECT ;
INFO:root:    (157) simple_name -> . IDENTIFIER
INFO:root:    (164) indexed_comp -> . name ( value_s )
INFO:root:    (171) selected_comp -> . name . simple_name
INFO:root:    (172) selected_comp -> . name . used_char
INFO:root:    (173) selected_comp -> . name . operator_symbol
INFO:root:    (174) selected_comp -> . name . ALL
INFO:root:    (175) attribute -> . name TICK attribute_id
INFO:root:    (163) operator_symbol -> . STRING
INFO:root:
INFO:root:    WHEN            reduce using rule 449 (exception_handler -> WHEN except_choice_s ARROW statement_s .)
INFO:root:    END             reduce using rule 449 (exception_handler -> WHEN except_choice_s ARROW statement_s .)
INFO:root:    LL              shift and go to state 344
INFO:root:    error           shift and go to state 341
INFO:root:    NuLL            shift and go to state 347
INFO:root:    EXIT            shift and go to state 340
INFO:root:    RETURN          shift and go to state 303
INFO:root:    DELAY           shift and go to state 332
INFO:root:    ABORT           shift and go to state 326
INFO:root:    RAISE           shift and go to state 314
INFO:root:    REQUEUE         shift and go to state 317
INFO:root:    IF              shift and go to state 327
INFO:root:    CASE            shift and go to state 312
INFO:root:    WHILE           reduce using rule 276 (label_opt -> .)
INFO:root:    DECLARE         reduce using rule 276 (label_opt -> .)
INFO:root:    FOR             reduce using rule 276 (label_opt -> .)
INFO:root:    LOOP            reduce using rule 276 (label_opt -> .)
INFO:root:    BEGIN           reduce using rule 276 (label_opt -> .)
INFO:root:    IDENTIFIER      shift and go to state 322
INFO:root:    ACCEPT          shift and go to state 310
INFO:root:    SELECT          shift and go to state 320
INFO:root:    STRING          shift and go to state 149
INFO:root:
INFO:root:    cond_entry_call                shift and go to state 345
INFO:root:    simple_stmt                    shift and go to state 302
INFO:root:    async_select                   shift and go to state 328
INFO:root:    simple_name                    shift and go to state 163
INFO:root:    requeue_stmt                   shift and go to state 329
INFO:root:    if_stmt                        shift and go to state 304
INFO:root:    procedure_call                 shift and go to state 305
INFO:root:    select_wait                    shift and go to state 330
INFO:root:    indexed_comp                   shift and go to state 140
INFO:root:    timed_entry_call               shift and go to state 307
INFO:root:    statement                      shift and go to state 497
INFO:root:    operator_symbol                shift and go to state 133
INFO:root:    exit_stmt                      shift and go to state 306
INFO:root:    code_stmt                      shift and go to state 331
INFO:root:    loop_stmt                      shift and go to state 333
INFO:root:    null_stmt                      shift and go to state 334
INFO:root:    label                          shift and go to state 335
INFO:root:    select_stmt                    shift and go to state 311
INFO:root:    label_opt                      shift and go to state 313
INFO:root:    assign_stmt                    shift and go to state 336
INFO:root:    selected_comp                  shift and go to state 139
INFO:root:    abort_stmt                     shift and go to state 315
INFO:root:    attribute                      shift and go to state 134
INFO:root:    name                           shift and go to state 316
INFO:root:    accept_hdr                     shift and go to state 318
INFO:root:    accept_stmt                    shift and go to state 337
INFO:root:    case_hdr                       shift and go to state 319
INFO:root:    delay_stmt                     shift and go to state 338
INFO:root:    compound_stmt                  shift and go to state 309
INFO:root:    raise_stmt                     shift and go to state 342
INFO:root:    qualified                      shift and go to state 321
INFO:root:    return_stmt                    shift and go to state 323
INFO:root:    case_stmt                      shift and go to state 324
INFO:root:    block                          shift and go to state 325
INFO:root:    unlabeled                      shift and go to state 346
INFO:root:
INFO:root:state 876
INFO:root:
INFO:root:    (452) except_choice_s -> except_choice_s | except_choice .
INFO:root:
INFO:root:    ARROW           reduce using rule 452 (except_choice_s -> except_choice_s | except_choice .)
INFO:root:    |               reduce using rule 452 (except_choice_s -> except_choice_s | except_choice .)
INFO:root:
INFO:root:
INFO:root:state 877
INFO:root:
INFO:root:    (450) exception_handler -> WHEN IDENTIFIER : except_choice_s . ARROW statement_s
INFO:root:    (452) except_choice_s -> except_choice_s . | except_choice
INFO:root:
INFO:root:    ARROW           shift and go to state 903
INFO:root:    |               shift and go to state 828
INFO:root:
INFO:root:
INFO:root:state 878
INFO:root:
INFO:root:    (466) generic_formal -> WITH PACKAGE simple_name IS NEW name ( BOX ) . ;
INFO:root:
INFO:root:    ;               shift and go to state 904
INFO:root:
INFO:root:
INFO:root:state 879
INFO:root:
INFO:root:    (487) generic_derived_type -> ABSTRACT NEW subtype_ind WITH PRIVATE .
INFO:root:
INFO:root:    ;               reduce using rule 487 (generic_derived_type -> ABSTRACT NEW subtype_ind WITH PRIVATE .)
INFO:root:
INFO:root:
INFO:root:state 880
INFO:root:
INFO:root:    (101) comp_list -> comp_decl_s . variant_part_opt
INFO:root:    (105) comp_decl_s -> comp_decl_s . pragma_s comp_decl
INFO:root:    (106) variant_part_opt -> . pragma_s
INFO:root:    (107) variant_part_opt -> . pragma_s variant_part pragma_s
INFO:root:    (8) pragma_s -> .
INFO:root:    (9) pragma_s -> . pragma_s pragma
INFO:root:
INFO:root:    error           reduce using rule 8 (pragma_s -> .)
INFO:root:    CASE            reduce using rule 8 (pragma_s -> .)
INFO:root:    PRAGMA          reduce using rule 8 (pragma_s -> .)
INFO:root:    IDENTIFIER      reduce using rule 8 (pragma_s -> .)
INFO:root:    END             reduce using rule 8 (pragma_s -> .)
INFO:root:    WHEN            reduce using rule 8 (pragma_s -> .)
INFO:root:
INFO:root:    pragma_s                       shift and go to state 905
INFO:root:    variant_part_opt               shift and go to state 906
INFO:root:
INFO:root:state 881
INFO:root:
INFO:root:    (117) variant_part -> CASE . simple_name IS pragma_s variant_s END CASE ;
INFO:root:    (157) simple_name -> . IDENTIFIER
INFO:root:
INFO:root:    IDENTIFIER      shift and go to state 33
INFO:root:
INFO:root:    simple_name                    shift and go to state 907
INFO:root:
INFO:root:state 882
INFO:root:
INFO:root:    (96) record_def -> RECORD pragma_s comp_list . END RECORD
INFO:root:
INFO:root:    END             shift and go to state 908
INFO:root:
INFO:root:
INFO:root:state 883
INFO:root:
INFO:root:    (104) comp_decl_s -> comp_decl .
INFO:root:
INFO:root:    error           reduce using rule 104 (comp_decl_s -> comp_decl .)
INFO:root:    CASE            reduce using rule 104 (comp_decl_s -> comp_decl .)
INFO:root:    PRAGMA          reduce using rule 104 (comp_decl_s -> comp_decl .)
INFO:root:    IDENTIFIER      reduce using rule 104 (comp_decl_s -> comp_decl .)
INFO:root:    END             reduce using rule 104 (comp_decl_s -> comp_decl .)
INFO:root:    WHEN            reduce using rule 104 (comp_decl_s -> comp_decl .)
INFO:root:
INFO:root:
INFO:root:state 884
INFO:root:
INFO:root:    (103) comp_list -> NuLL . ; pragma_s
INFO:root:
INFO:root:    ;               shift and go to state 909
INFO:root:
INFO:root:
INFO:root:state 885
INFO:root:
INFO:root:    (102) comp_list -> variant_part . pragma_s
INFO:root:    (8) pragma_s -> .
INFO:root:    (9) pragma_s -> . pragma_s pragma
INFO:root:
INFO:root:    PRAGMA          reduce using rule 8 (pragma_s -> .)
INFO:root:    END             reduce using rule 8 (pragma_s -> .)
INFO:root:    WHEN            reduce using rule 8 (pragma_s -> .)
INFO:root:
INFO:root:    pragma_s                       shift and go to state 910
INFO:root:
INFO:root:state 886
INFO:root:
INFO:root:    (60) derived_type -> ABSTRACT NEW subtype_ind WITH record_def .
INFO:root:
INFO:root:    ;               reduce using rule 60 (derived_type -> ABSTRACT NEW subtype_ind WITH record_def .)
INFO:root:
INFO:root:
INFO:root:state 887
INFO:root:
INFO:root:    (59) derived_type -> ABSTRACT NEW subtype_ind WITH PRIVATE .
INFO:root:
INFO:root:    ;               reduce using rule 59 (derived_type -> ABSTRACT NEW subtype_ind WITH PRIVATE .)
INFO:root:
INFO:root:
INFO:root:state 888
INFO:root:
INFO:root:    (77) fixed_type -> DELTA expression DIGITS expression range_spec_opt .
INFO:root:
INFO:root:    ;               reduce using rule 77 (fixed_type -> DELTA expression DIGITS expression range_spec_opt .)
INFO:root:
INFO:root:
INFO:root:state 889
INFO:root:
INFO:root:    (80) unconstr_array_type -> ARRAY ( index_s ) OF component_subtype_def .
INFO:root:
INFO:root:    ASSIGN          reduce using rule 80 (unconstr_array_type -> ARRAY ( index_s ) OF component_subtype_def .)
INFO:root:    ;               reduce using rule 80 (unconstr_array_type -> ARRAY ( index_s ) OF component_subtype_def .)
INFO:root:
INFO:root:
INFO:root:state 890
INFO:root:
INFO:root:    (87) index -> name RANGE . BOX
INFO:root:
INFO:root:    BOX             shift and go to state 848
INFO:root:
INFO:root:
INFO:root:state 891
INFO:root:
INFO:root:    (356) task_body -> TASK BODY simple_name IS decl_part block_body END id_opt ; .
INFO:root:
INFO:root:    PACKAGE         reduce using rule 356 (task_body -> TASK BODY simple_name IS decl_part block_body END id_opt ; .)
INFO:root:    TASK            reduce using rule 356 (task_body -> TASK BODY simple_name IS decl_part block_body END id_opt ; .)
INFO:root:    PROTECTED       reduce using rule 356 (task_body -> TASK BODY simple_name IS decl_part block_body END id_opt ; .)
INFO:root:    error           reduce using rule 356 (task_body -> TASK BODY simple_name IS decl_part block_body END id_opt ; .)
INFO:root:    USE             reduce using rule 356 (task_body -> TASK BODY simple_name IS decl_part block_body END id_opt ; .)
INFO:root:    PRAGMA          reduce using rule 356 (task_body -> TASK BODY simple_name IS decl_part block_body END id_opt ; .)
INFO:root:    TYPE            reduce using rule 356 (task_body -> TASK BODY simple_name IS decl_part block_body END id_opt ; .)
INFO:root:    SUBTYPE         reduce using rule 356 (task_body -> TASK BODY simple_name IS decl_part block_body END id_opt ; .)
INFO:root:    FOR             reduce using rule 356 (task_body -> TASK BODY simple_name IS decl_part block_body END id_opt ; .)
INFO:root:    PROCEDURE       reduce using rule 356 (task_body -> TASK BODY simple_name IS decl_part block_body END id_opt ; .)
INFO:root:    FUNCTION        reduce using rule 356 (task_body -> TASK BODY simple_name IS decl_part block_body END id_opt ; .)
INFO:root:    GENERIC         reduce using rule 356 (task_body -> TASK BODY simple_name IS decl_part block_body END id_opt ; .)
INFO:root:    IDENTIFIER      reduce using rule 356 (task_body -> TASK BODY simple_name IS decl_part block_body END id_opt ; .)
INFO:root:    BEGIN           reduce using rule 356 (task_body -> TASK BODY simple_name IS decl_part block_body END id_opt ; .)
INFO:root:    PRIVATE         reduce using rule 356 (task_body -> TASK BODY simple_name IS decl_part block_body END id_opt ; .)
INFO:root:    WITH            reduce using rule 356 (task_body -> TASK BODY simple_name IS decl_part block_body END id_opt ; .)
INFO:root:    SEPARATE        reduce using rule 356 (task_body -> TASK BODY simple_name IS decl_part block_body END id_opt ; .)
INFO:root:    $end            reduce using rule 356 (task_body -> TASK BODY simple_name IS decl_part block_body END id_opt ; .)
INFO:root:    END             reduce using rule 356 (task_body -> TASK BODY simple_name IS decl_part block_body END id_opt ; .)
INFO:root:
INFO:root:
INFO:root:state 892
INFO:root:
INFO:root:    (382) entry_decl -> ENTRY IDENTIFIER ( discrete_range ) . formal_part_opt ;
INFO:root:    (309) formal_part_opt -> .
INFO:root:    (310) formal_part_opt -> . formal_part
INFO:root:    (311) formal_part -> . ( param_s )
INFO:root:
INFO:root:    ;               reduce using rule 309 (formal_part_opt -> .)
INFO:root:    (               shift and go to state 151
INFO:root:
INFO:root:    formal_part_opt                shift and go to state 911
INFO:root:    formal_part                    shift and go to state 152
INFO:root:
INFO:root:state 893
INFO:root:
INFO:root:    (383) entry_body -> ENTRY IDENTIFIER formal_part_opt WHEN . condition entry_body_part
INFO:root:    (267) condition -> . expression
INFO:root:    (188) expression -> . relation
INFO:root:    (189) expression -> . expression logical relation
INFO:root:    (190) expression -> . expression short_circuit relation
INFO:root:    (196) relation -> . simple_expression
INFO:root:    (197) relation -> . simple_expression relational simple_expression
INFO:root:    (198) relation -> . simple_expression membership range
INFO:root:    (199) relation -> . simple_expression membership name
INFO:root:    (208) simple_expression -> . unary term
INFO:root:    (209) simple_expression -> . term
INFO:root:    (210) simple_expression -> . simple_expression adding term
INFO:root:    (211) unary -> . +
INFO:root:    (212) unary -> . -
INFO:root:    (216) term -> . factor
INFO:root:    (217) term -> . term multiplying factor
INFO:root:    (223) factor -> . primary
INFO:root:    (224) factor -> . NOT primary
INFO:root:    (225) factor -> . ABS primary
INFO:root:    (226) primary -> . literal
INFO:root:    (227) primary -> . name
INFO:root:    (228) primary -> . allocator
INFO:root:    (229) primary -> . qualified
INFO:root:    (230) primary -> . parenthesized_primary
INFO:root:    (180) literal -> . INT
INFO:root:    (181) literal -> . FLOAT
INFO:root:    (182) literal -> . NuLL
INFO:root:    (149) name -> . simple_name
INFO:root:    (150) name -> . indexed_comp
INFO:root:    (151) name -> . selected_comp
INFO:root:    (152) name -> . attribute
INFO:root:    (153) name -> . operator_symbol
INFO:root:    (234) allocator -> . NEW name
INFO:root:    (235) allocator -> . NEW qualified
INFO:root:    (233) qualified -> . name TICK parenthesized_primary
INFO:root:    (231) parenthesized_primary -> . aggregate
INFO:root:    (232) parenthesized_primary -> . ( expression )
INFO:root:    (157) simple_name -> . IDENTIFIER
INFO:root:    (164) indexed_comp -> . name ( value_s )
INFO:root:    (171) selected_comp -> . name . simple_name
INFO:root:    (172) selected_comp -> . name . used_char
INFO:root:    (173) selected_comp -> . name . operator_symbol
INFO:root:    (174) selected_comp -> . name . ALL
INFO:root:    (175) attribute -> . name TICK attribute_id
INFO:root:    (163) operator_symbol -> . STRING
INFO:root:    (183) aggregate -> . ( comp_assoc )
INFO:root:    (184) aggregate -> . ( expression WITH value_s )
INFO:root:    (185) aggregate -> . ( expression WITH NuLL RECORD )
INFO:root:    (186) aggregate -> . ( NuLL RECORD )
INFO:root:
INFO:root:    +               shift and go to state 148
INFO:root:    -               shift and go to state 136
INFO:root:    NOT             shift and go to state 131
INFO:root:    ABS             shift and go to state 132
INFO:root:    INT             shift and go to state 120
INFO:root:    FLOAT           shift and go to state 128
INFO:root:    NuLL            shift and go to state 130
INFO:root:    NEW             shift and go to state 137
INFO:root:    (               shift and go to state 125
INFO:root:    IDENTIFIER      shift and go to state 33
INFO:root:    STRING          shift and go to state 149
INFO:root:
INFO:root:    literal                        shift and go to state 121
INFO:root:    allocator                      shift and go to state 122
INFO:root:    simple_name                    shift and go to state 163
INFO:root:    indexed_comp                   shift and go to state 140
INFO:root:    name                           shift and go to state 142
INFO:root:    condition                      shift and go to state 912
INFO:root:    selected_comp                  shift and go to state 139
INFO:root:    factor                         shift and go to state 126
INFO:root:    expression                     shift and go to state 489
INFO:root:    unary                          shift and go to state 144
INFO:root:    qualified                      shift and go to state 145
INFO:root:    aggregate                      shift and go to state 143
INFO:root:    simple_expression              shift and go to state 129
INFO:root:    term                           shift and go to state 146
INFO:root:    operator_symbol                shift and go to state 133
INFO:root:    parenthesized_primary          shift and go to state 147
INFO:root:    attribute                      shift and go to state 134
INFO:root:    primary                        shift and go to state 135
INFO:root:    relation                       shift and go to state 138
INFO:root:
INFO:root:state 894
INFO:root:
INFO:root:    (384) entry_body -> ENTRY IDENTIFIER ( iter_part . discrete_range ) formal_part_opt WHEN condition entry_body_part
INFO:root:    (91) discrete_range -> . name range_constr_opt
INFO:root:    (92) discrete_range -> . range
INFO:root:    (149) name -> . simple_name
INFO:root:    (150) name -> . indexed_comp
INFO:root:    (151) name -> . selected_comp
INFO:root:    (152) name -> . attribute
INFO:root:    (153) name -> . operator_symbol
INFO:root:    (62) range -> . simple_expression DOTDOT simple_expression
INFO:root:    (157) simple_name -> . IDENTIFIER
INFO:root:    (164) indexed_comp -> . name ( value_s )
INFO:root:    (171) selected_comp -> . name . simple_name
INFO:root:    (172) selected_comp -> . name . used_char
INFO:root:    (173) selected_comp -> . name . operator_symbol
INFO:root:    (174) selected_comp -> . name . ALL
INFO:root:    (175) attribute -> . name TICK attribute_id
INFO:root:    (163) operator_symbol -> . STRING
INFO:root:    (208) simple_expression -> . unary term
INFO:root:    (209) simple_expression -> . term
INFO:root:    (210) simple_expression -> . simple_expression adding term
INFO:root:    (211) unary -> . +
INFO:root:    (212) unary -> . -
INFO:root:    (216) term -> . factor
INFO:root:    (217) term -> . term multiplying factor
INFO:root:    (223) factor -> . primary
INFO:root:    (224) factor -> . NOT primary
INFO:root:    (225) factor -> . ABS primary
INFO:root:    (226) primary -> . literal
INFO:root:    (227) primary -> . name
INFO:root:    (228) primary -> . allocator
INFO:root:    (229) primary -> . qualified
INFO:root:    (230) primary -> . parenthesized_primary
INFO:root:    (180) literal -> . INT
INFO:root:    (181) literal -> . FLOAT
INFO:root:    (182) literal -> . NuLL
INFO:root:    (234) allocator -> . NEW name
INFO:root:    (235) allocator -> . NEW qualified
INFO:root:    (233) qualified -> . name TICK parenthesized_primary
INFO:root:    (231) parenthesized_primary -> . aggregate
INFO:root:    (232) parenthesized_primary -> . ( expression )
INFO:root:    (183) aggregate -> . ( comp_assoc )
INFO:root:    (184) aggregate -> . ( expression WITH value_s )
INFO:root:    (185) aggregate -> . ( expression WITH NuLL RECORD )
INFO:root:    (186) aggregate -> . ( NuLL RECORD )
INFO:root:
INFO:root:    IDENTIFIER      shift and go to state 33
INFO:root:    STRING          shift and go to state 149
INFO:root:    +               shift and go to state 148
INFO:root:    -               shift and go to state 136
INFO:root:    NOT             shift and go to state 131
INFO:root:    ABS             shift and go to state 132
INFO:root:    INT             shift and go to state 120
INFO:root:    FLOAT           shift and go to state 128
INFO:root:    NuLL            shift and go to state 130
INFO:root:    NEW             shift and go to state 137
INFO:root:    (               shift and go to state 125
INFO:root:
INFO:root:    selected_comp                  shift and go to state 139
INFO:root:    allocator                      shift and go to state 122
INFO:root:    simple_name                    shift and go to state 163
INFO:root:    indexed_comp                   shift and go to state 140
INFO:root:    attribute                      shift and go to state 134
INFO:root:    name                           shift and go to state 730
INFO:root:    literal                        shift and go to state 121
INFO:root:    discrete_range                 shift and go to state 913
INFO:root:    aggregate                      shift and go to state 143
INFO:root:    unary                          shift and go to state 144
INFO:root:    simple_expression              shift and go to state 366
INFO:root:    term                           shift and go to state 146
INFO:root:    operator_symbol                shift and go to state 133
INFO:root:    parenthesized_primary          shift and go to state 147
INFO:root:    range                          shift and go to state 698
INFO:root:    qualified                      shift and go to state 145
INFO:root:    primary                        shift and go to state 135
INFO:root:    factor                         shift and go to state 126
INFO:root:
INFO:root:state 895
INFO:root:
INFO:root:    (108) comp_decl -> def_id_s : component_subtype_def . init_opt ;
INFO:root:    (33) init_opt -> .
INFO:root:    (34) init_opt -> . ASSIGN expression
INFO:root:
INFO:root:    ;               reduce using rule 33 (init_opt -> .)
INFO:root:    ASSIGN          shift and go to state 540
INFO:root:
INFO:root:    init_opt                       shift and go to state 914
INFO:root:
INFO:root:state 896
INFO:root:
INFO:root:    (495) record_type_spec -> FOR mark USE RECORD align_opt comp_loc_s END RECORD ; .
INFO:root:
INFO:root:    error           reduce using rule 495 (record_type_spec -> FOR mark USE RECORD align_opt comp_loc_s END RECORD ; .)
INFO:root:    USE             reduce using rule 495 (record_type_spec -> FOR mark USE RECORD align_opt comp_loc_s END RECORD ; .)
INFO:root:    PRAGMA          reduce using rule 495 (record_type_spec -> FOR mark USE RECORD align_opt comp_loc_s END RECORD ; .)
INFO:root:    TYPE            reduce using rule 495 (record_type_spec -> FOR mark USE RECORD align_opt comp_loc_s END RECORD ; .)
INFO:root:    SUBTYPE         reduce using rule 495 (record_type_spec -> FOR mark USE RECORD align_opt comp_loc_s END RECORD ; .)
INFO:root:    TASK            reduce using rule 495 (record_type_spec -> FOR mark USE RECORD align_opt comp_loc_s END RECORD ; .)
INFO:root:    PACKAGE         reduce using rule 495 (record_type_spec -> FOR mark USE RECORD align_opt comp_loc_s END RECORD ; .)
INFO:root:    PROTECTED       reduce using rule 495 (record_type_spec -> FOR mark USE RECORD align_opt comp_loc_s END RECORD ; .)
INFO:root:    FOR             reduce using rule 495 (record_type_spec -> FOR mark USE RECORD align_opt comp_loc_s END RECORD ; .)
INFO:root:    PROCEDURE       reduce using rule 495 (record_type_spec -> FOR mark USE RECORD align_opt comp_loc_s END RECORD ; .)
INFO:root:    FUNCTION        reduce using rule 495 (record_type_spec -> FOR mark USE RECORD align_opt comp_loc_s END RECORD ; .)
INFO:root:    GENERIC         reduce using rule 495 (record_type_spec -> FOR mark USE RECORD align_opt comp_loc_s END RECORD ; .)
INFO:root:    IDENTIFIER      reduce using rule 495 (record_type_spec -> FOR mark USE RECORD align_opt comp_loc_s END RECORD ; .)
INFO:root:    PRIVATE         reduce using rule 495 (record_type_spec -> FOR mark USE RECORD align_opt comp_loc_s END RECORD ; .)
INFO:root:    END             reduce using rule 495 (record_type_spec -> FOR mark USE RECORD align_opt comp_loc_s END RECORD ; .)
INFO:root:    BEGIN           reduce using rule 495 (record_type_spec -> FOR mark USE RECORD align_opt comp_loc_s END RECORD ; .)
INFO:root:    ENTRY           reduce using rule 495 (record_type_spec -> FOR mark USE RECORD align_opt comp_loc_s END RECORD ; .)
INFO:root:
INFO:root:
INFO:root:state 897
INFO:root:
INFO:root:    (499) comp_loc_s -> comp_loc_s mark AT expression . RANGE range ;
INFO:root:    (189) expression -> expression . logical relation
INFO:root:    (190) expression -> expression . short_circuit relation
INFO:root:    (191) logical -> . AND
INFO:root:    (192) logical -> . OR
INFO:root:    (193) logical -> . XOR
INFO:root:    (194) short_circuit -> . AND THEN
INFO:root:    (195) short_circuit -> . OR ELSE
INFO:root:
INFO:root:    RANGE           shift and go to state 915
INFO:root:    AND             shift and go to state 215
INFO:root:    OR              shift and go to state 216
INFO:root:    XOR             shift and go to state 214
INFO:root:
INFO:root:    short_circuit                  shift and go to state 212
INFO:root:    logical                        shift and go to state 213
INFO:root:
INFO:root:state 898
INFO:root:
INFO:root:    (274) alternative -> WHEN choice_s ARROW statement_s .
INFO:root:    (237) statement_s -> statement_s . statement
INFO:root:    (238) statement -> . unlabeled
INFO:root:    (239) statement -> . label statement
INFO:root:    (240) unlabeled -> . simple_stmt
INFO:root:    (241) unlabeled -> . compound_stmt
INFO:root:    (259) label -> . LL IDENTIFIER RR
INFO:root:    (242) simple_stmt -> . null_stmt
INFO:root:    (243) simple_stmt -> . assign_stmt
INFO:root:    (244) simple_stmt -> . exit_stmt
INFO:root:    (245) simple_stmt -> . return_stmt
INFO:root:    (246) simple_stmt -> . procedure_call
INFO:root:    (247) simple_stmt -> . delay_stmt
INFO:root:    (248) simple_stmt -> . abort_stmt
INFO:root:    (249) simple_stmt -> . raise_stmt
INFO:root:    (250) simple_stmt -> . code_stmt
INFO:root:    (251) simple_stmt -> . requeue_stmt
INFO:root:    (252) simple_stmt -> . error ;
INFO:root:    (253) compound_stmt -> . if_stmt
INFO:root:    (254) compound_stmt -> . case_stmt
INFO:root:    (255) compound_stmt -> . loop_stmt
INFO:root:    (256) compound_stmt -> . block
INFO:root:    (257) compound_stmt -> . accept_stmt
INFO:root:    (258) compound_stmt -> . select_stmt
INFO:root:    (260) null_stmt -> . NuLL ;
INFO:root:    (261) assign_stmt -> . name ASSIGN expression ;
INFO:root:    (294) exit_stmt -> . EXIT name_opt when_opt ;
INFO:root:    (299) return_stmt -> . RETURN ;
INFO:root:    (300) return_stmt -> . RETURN expression ;
INFO:root:    (323) procedure_call -> . name ;
INFO:root:    (395) delay_stmt -> . DELAY expression ;
INFO:root:    (396) delay_stmt -> . DELAY UNTIL expression ;
INFO:root:    (416) abort_stmt -> . ABORT name_s ;
INFO:root:    (455) raise_stmt -> . RAISE name_opt ;
INFO:root:    (501) code_stmt -> . qualified ;
INFO:root:    (456) requeue_stmt -> . REQUEUE name ;
INFO:root:    (457) requeue_stmt -> . REQUEUE name WITH ABORT ;
INFO:root:    (262) if_stmt -> . IF cond_clause_s else_opt END IF ;
INFO:root:    (270) case_stmt -> . case_hdr pragma_s alternative_s END CASE ;
INFO:root:    (275) loop_stmt -> . label_opt iteration basic_loop id_opt ;
INFO:root:    (287) block -> . label_opt block_decl block_body END id_opt ;
INFO:root:    (390) accept_stmt -> . accept_hdr ;
INFO:root:    (391) accept_stmt -> . accept_hdr DO handled_stmt_s END id_opt ;
INFO:root:    (397) select_stmt -> . select_wait
INFO:root:    (398) select_stmt -> . async_select
INFO:root:    (399) select_stmt -> . timed_entry_call
INFO:root:    (400) select_stmt -> . cond_entry_call
INFO:root:    (149) name -> . simple_name
INFO:root:    (150) name -> . indexed_comp
INFO:root:    (151) name -> . selected_comp
INFO:root:    (152) name -> . attribute
INFO:root:    (153) name -> . operator_symbol
INFO:root:    (233) qualified -> . name TICK parenthesized_primary
INFO:root:    (271) case_hdr -> . CASE expression IS
INFO:root:    (276) label_opt -> .
INFO:root:    (277) label_opt -> . IDENTIFIER :
INFO:root:    (392) accept_hdr -> . ACCEPT entry_name formal_part_opt
INFO:root:    (401) select_wait -> . SELECT guarded_select_alt or_select else_opt END SELECT ;
INFO:root:    (411) async_select -> . SELECT delay_or_entry_alt THEN ABORT statement_s END SELECT ;
INFO:root:    (412) timed_entry_call -> . SELECT entry_call stmts_opt OR delay_stmt stmts_opt END SELECT ;
INFO:root:    (413) cond_entry_call -> . SELECT entry_call stmts_opt ELSE statement_s END SELECT ;
INFO:root:    (157) simple_name -> . IDENTIFIER
INFO:root:    (164) indexed_comp -> . name ( value_s )
INFO:root:    (171) selected_comp -> . name . simple_name
INFO:root:    (172) selected_comp -> . name . used_char
INFO:root:    (173) selected_comp -> . name . operator_symbol
INFO:root:    (174) selected_comp -> . name . ALL
INFO:root:    (175) attribute -> . name TICK attribute_id
INFO:root:    (163) operator_symbol -> . STRING
INFO:root:
INFO:root:    END             reduce using rule 274 (alternative -> WHEN choice_s ARROW statement_s .)
INFO:root:    WHEN            reduce using rule 274 (alternative -> WHEN choice_s ARROW statement_s .)
INFO:root:    LL              shift and go to state 344
INFO:root:    error           shift and go to state 341
INFO:root:    NuLL            shift and go to state 347
INFO:root:    EXIT            shift and go to state 340
INFO:root:    RETURN          shift and go to state 303
INFO:root:    DELAY           shift and go to state 332
INFO:root:    ABORT           shift and go to state 326
INFO:root:    RAISE           shift and go to state 314
INFO:root:    REQUEUE         shift and go to state 317
INFO:root:    IF              shift and go to state 327
INFO:root:    CASE            shift and go to state 312
INFO:root:    WHILE           reduce using rule 276 (label_opt -> .)
INFO:root:    DECLARE         reduce using rule 276 (label_opt -> .)
INFO:root:    FOR             reduce using rule 276 (label_opt -> .)
INFO:root:    LOOP            reduce using rule 276 (label_opt -> .)
INFO:root:    BEGIN           reduce using rule 276 (label_opt -> .)
INFO:root:    IDENTIFIER      shift and go to state 322
INFO:root:    ACCEPT          shift and go to state 310
INFO:root:    SELECT          shift and go to state 320
INFO:root:    STRING          shift and go to state 149
INFO:root:
INFO:root:    cond_entry_call                shift and go to state 345
INFO:root:    simple_stmt                    shift and go to state 302
INFO:root:    async_select                   shift and go to state 328
INFO:root:    simple_name                    shift and go to state 163
INFO:root:    requeue_stmt                   shift and go to state 329
INFO:root:    if_stmt                        shift and go to state 304
INFO:root:    procedure_call                 shift and go to state 305
INFO:root:    select_wait                    shift and go to state 330
INFO:root:    indexed_comp                   shift and go to state 140
INFO:root:    timed_entry_call               shift and go to state 307
INFO:root:    statement                      shift and go to state 497
INFO:root:    operator_symbol                shift and go to state 133
INFO:root:    exit_stmt                      shift and go to state 306
INFO:root:    code_stmt                      shift and go to state 331
INFO:root:    loop_stmt                      shift and go to state 333
INFO:root:    null_stmt                      shift and go to state 334
INFO:root:    label                          shift and go to state 335
INFO:root:    select_stmt                    shift and go to state 311
INFO:root:    label_opt                      shift and go to state 313
INFO:root:    assign_stmt                    shift and go to state 336
INFO:root:    selected_comp                  shift and go to state 139
INFO:root:    abort_stmt                     shift and go to state 315
INFO:root:    attribute                      shift and go to state 134
INFO:root:    name                           shift and go to state 316
INFO:root:    accept_hdr                     shift and go to state 318
INFO:root:    accept_stmt                    shift and go to state 337
INFO:root:    case_hdr                       shift and go to state 319
INFO:root:    delay_stmt                     shift and go to state 338
INFO:root:    compound_stmt                  shift and go to state 309
INFO:root:    raise_stmt                     shift and go to state 342
INFO:root:    qualified                      shift and go to state 321
INFO:root:    return_stmt                    shift and go to state 323
INFO:root:    case_stmt                      shift and go to state 324
INFO:root:    block                          shift and go to state 325
INFO:root:    unlabeled                      shift and go to state 346
INFO:root:
INFO:root:state 899
INFO:root:
INFO:root:    (413) cond_entry_call -> SELECT entry_call stmts_opt ELSE statement_s END SELECT . ;
INFO:root:
INFO:root:    ;               shift and go to state 916
INFO:root:
INFO:root:
INFO:root:state 900
INFO:root:
INFO:root:    (412) timed_entry_call -> SELECT entry_call stmts_opt OR delay_stmt stmts_opt END . SELECT ;
INFO:root:
INFO:root:    SELECT          shift and go to state 917
INFO:root:
INFO:root:
INFO:root:state 901
INFO:root:
INFO:root:    (401) select_wait -> SELECT guarded_select_alt or_select else_opt END SELECT ; .
INFO:root:
INFO:root:    LL              reduce using rule 401 (select_wait -> SELECT guarded_select_alt or_select else_opt END SELECT ; .)
INFO:root:    error           reduce using rule 401 (select_wait -> SELECT guarded_select_alt or_select else_opt END SELECT ; .)
INFO:root:    NuLL            reduce using rule 401 (select_wait -> SELECT guarded_select_alt or_select else_opt END SELECT ; .)
INFO:root:    EXIT            reduce using rule 401 (select_wait -> SELECT guarded_select_alt or_select else_opt END SELECT ; .)
INFO:root:    RETURN          reduce using rule 401 (select_wait -> SELECT guarded_select_alt or_select else_opt END SELECT ; .)
INFO:root:    DELAY           reduce using rule 401 (select_wait -> SELECT guarded_select_alt or_select else_opt END SELECT ; .)
INFO:root:    ABORT           reduce using rule 401 (select_wait -> SELECT guarded_select_alt or_select else_opt END SELECT ; .)
INFO:root:    RAISE           reduce using rule 401 (select_wait -> SELECT guarded_select_alt or_select else_opt END SELECT ; .)
INFO:root:    REQUEUE         reduce using rule 401 (select_wait -> SELECT guarded_select_alt or_select else_opt END SELECT ; .)
INFO:root:    IF              reduce using rule 401 (select_wait -> SELECT guarded_select_alt or_select else_opt END SELECT ; .)
INFO:root:    CASE            reduce using rule 401 (select_wait -> SELECT guarded_select_alt or_select else_opt END SELECT ; .)
INFO:root:    IDENTIFIER      reduce using rule 401 (select_wait -> SELECT guarded_select_alt or_select else_opt END SELECT ; .)
INFO:root:    ACCEPT          reduce using rule 401 (select_wait -> SELECT guarded_select_alt or_select else_opt END SELECT ; .)
INFO:root:    SELECT          reduce using rule 401 (select_wait -> SELECT guarded_select_alt or_select else_opt END SELECT ; .)
INFO:root:    STRING          reduce using rule 401 (select_wait -> SELECT guarded_select_alt or_select else_opt END SELECT ; .)
INFO:root:    WHILE           reduce using rule 401 (select_wait -> SELECT guarded_select_alt or_select else_opt END SELECT ; .)
INFO:root:    DECLARE         reduce using rule 401 (select_wait -> SELECT guarded_select_alt or_select else_opt END SELECT ; .)
INFO:root:    FOR             reduce using rule 401 (select_wait -> SELECT guarded_select_alt or_select else_opt END SELECT ; .)
INFO:root:    LOOP            reduce using rule 401 (select_wait -> SELECT guarded_select_alt or_select else_opt END SELECT ; .)
INFO:root:    BEGIN           reduce using rule 401 (select_wait -> SELECT guarded_select_alt or_select else_opt END SELECT ; .)
INFO:root:    OR              reduce using rule 401 (select_wait -> SELECT guarded_select_alt or_select else_opt END SELECT ; .)
INFO:root:    ELSE            reduce using rule 401 (select_wait -> SELECT guarded_select_alt or_select else_opt END SELECT ; .)
INFO:root:    END             reduce using rule 401 (select_wait -> SELECT guarded_select_alt or_select else_opt END SELECT ; .)
INFO:root:    THEN            reduce using rule 401 (select_wait -> SELECT guarded_select_alt or_select else_opt END SELECT ; .)
INFO:root:    WHEN            reduce using rule 401 (select_wait -> SELECT guarded_select_alt or_select else_opt END SELECT ; .)
INFO:root:    EXCEPTION       reduce using rule 401 (select_wait -> SELECT guarded_select_alt or_select else_opt END SELECT ; .)
INFO:root:    ELSIF           reduce using rule 401 (select_wait -> SELECT guarded_select_alt or_select else_opt END SELECT ; .)
INFO:root:
INFO:root:
INFO:root:state 902
INFO:root:
INFO:root:    (411) async_select -> SELECT delay_or_entry_alt THEN ABORT statement_s END SELECT . ;
INFO:root:
INFO:root:    ;               shift and go to state 918
INFO:root:
INFO:root:
INFO:root:state 903
INFO:root:
INFO:root:    (450) exception_handler -> WHEN IDENTIFIER : except_choice_s ARROW . statement_s
INFO:root:    (236) statement_s -> . statement
INFO:root:    (237) statement_s -> . statement_s statement
INFO:root:    (238) statement -> . unlabeled
INFO:root:    (239) statement -> . label statement
INFO:root:    (240) unlabeled -> . simple_stmt
INFO:root:    (241) unlabeled -> . compound_stmt
INFO:root:    (259) label -> . LL IDENTIFIER RR
INFO:root:    (242) simple_stmt -> . null_stmt
INFO:root:    (243) simple_stmt -> . assign_stmt
INFO:root:    (244) simple_stmt -> . exit_stmt
INFO:root:    (245) simple_stmt -> . return_stmt
INFO:root:    (246) simple_stmt -> . procedure_call
INFO:root:    (247) simple_stmt -> . delay_stmt
INFO:root:    (248) simple_stmt -> . abort_stmt
INFO:root:    (249) simple_stmt -> . raise_stmt
INFO:root:    (250) simple_stmt -> . code_stmt
INFO:root:    (251) simple_stmt -> . requeue_stmt
INFO:root:    (252) simple_stmt -> . error ;
INFO:root:    (253) compound_stmt -> . if_stmt
INFO:root:    (254) compound_stmt -> . case_stmt
INFO:root:    (255) compound_stmt -> . loop_stmt
INFO:root:    (256) compound_stmt -> . block
INFO:root:    (257) compound_stmt -> . accept_stmt
INFO:root:    (258) compound_stmt -> . select_stmt
INFO:root:    (260) null_stmt -> . NuLL ;
INFO:root:    (261) assign_stmt -> . name ASSIGN expression ;
INFO:root:    (294) exit_stmt -> . EXIT name_opt when_opt ;
INFO:root:    (299) return_stmt -> . RETURN ;
INFO:root:    (300) return_stmt -> . RETURN expression ;
INFO:root:    (323) procedure_call -> . name ;
INFO:root:    (395) delay_stmt -> . DELAY expression ;
INFO:root:    (396) delay_stmt -> . DELAY UNTIL expression ;
INFO:root:    (416) abort_stmt -> . ABORT name_s ;
INFO:root:    (455) raise_stmt -> . RAISE name_opt ;
INFO:root:    (501) code_stmt -> . qualified ;
INFO:root:    (456) requeue_stmt -> . REQUEUE name ;
INFO:root:    (457) requeue_stmt -> . REQUEUE name WITH ABORT ;
INFO:root:    (262) if_stmt -> . IF cond_clause_s else_opt END IF ;
INFO:root:    (270) case_stmt -> . case_hdr pragma_s alternative_s END CASE ;
INFO:root:    (275) loop_stmt -> . label_opt iteration basic_loop id_opt ;
INFO:root:    (287) block -> . label_opt block_decl block_body END id_opt ;
INFO:root:    (390) accept_stmt -> . accept_hdr ;
INFO:root:    (391) accept_stmt -> . accept_hdr DO handled_stmt_s END id_opt ;
INFO:root:    (397) select_stmt -> . select_wait
INFO:root:    (398) select_stmt -> . async_select
INFO:root:    (399) select_stmt -> . timed_entry_call
INFO:root:    (400) select_stmt -> . cond_entry_call
INFO:root:    (149) name -> . simple_name
INFO:root:    (150) name -> . indexed_comp
INFO:root:    (151) name -> . selected_comp
INFO:root:    (152) name -> . attribute
INFO:root:    (153) name -> . operator_symbol
INFO:root:    (233) qualified -> . name TICK parenthesized_primary
INFO:root:    (271) case_hdr -> . CASE expression IS
INFO:root:    (276) label_opt -> .
INFO:root:    (277) label_opt -> . IDENTIFIER :
INFO:root:    (392) accept_hdr -> . ACCEPT entry_name formal_part_opt
INFO:root:    (401) select_wait -> . SELECT guarded_select_alt or_select else_opt END SELECT ;
INFO:root:    (411) async_select -> . SELECT delay_or_entry_alt THEN ABORT statement_s END SELECT ;
INFO:root:    (412) timed_entry_call -> . SELECT entry_call stmts_opt OR delay_stmt stmts_opt END SELECT ;
INFO:root:    (413) cond_entry_call -> . SELECT entry_call stmts_opt ELSE statement_s END SELECT ;
INFO:root:    (157) simple_name -> . IDENTIFIER
INFO:root:    (164) indexed_comp -> . name ( value_s )
INFO:root:    (171) selected_comp -> . name . simple_name
INFO:root:    (172) selected_comp -> . name . used_char
INFO:root:    (173) selected_comp -> . name . operator_symbol
INFO:root:    (174) selected_comp -> . name . ALL
INFO:root:    (175) attribute -> . name TICK attribute_id
INFO:root:    (163) operator_symbol -> . STRING
INFO:root:
INFO:root:    LL              shift and go to state 344
INFO:root:    error           shift and go to state 341
INFO:root:    NuLL            shift and go to state 347
INFO:root:    EXIT            shift and go to state 340
INFO:root:    RETURN          shift and go to state 303
INFO:root:    DELAY           shift and go to state 332
INFO:root:    ABORT           shift and go to state 326
INFO:root:    RAISE           shift and go to state 314
INFO:root:    REQUEUE         shift and go to state 317
INFO:root:    IF              shift and go to state 327
INFO:root:    CASE            shift and go to state 312
INFO:root:    WHILE           reduce using rule 276 (label_opt -> .)
INFO:root:    DECLARE         reduce using rule 276 (label_opt -> .)
INFO:root:    FOR             reduce using rule 276 (label_opt -> .)
INFO:root:    LOOP            reduce using rule 276 (label_opt -> .)
INFO:root:    BEGIN           reduce using rule 276 (label_opt -> .)
INFO:root:    IDENTIFIER      shift and go to state 322
INFO:root:    ACCEPT          shift and go to state 310
INFO:root:    SELECT          shift and go to state 320
INFO:root:    STRING          shift and go to state 149
INFO:root:
INFO:root:    cond_entry_call                shift and go to state 345
INFO:root:    simple_stmt                    shift and go to state 302
INFO:root:    async_select                   shift and go to state 328
INFO:root:    simple_name                    shift and go to state 163
INFO:root:    requeue_stmt                   shift and go to state 329
INFO:root:    if_stmt                        shift and go to state 304
INFO:root:    procedure_call                 shift and go to state 305
INFO:root:    select_wait                    shift and go to state 330
INFO:root:    indexed_comp                   shift and go to state 140
INFO:root:    timed_entry_call               shift and go to state 307
INFO:root:    statement                      shift and go to state 308
INFO:root:    operator_symbol                shift and go to state 133
INFO:root:    exit_stmt                      shift and go to state 306
INFO:root:    code_stmt                      shift and go to state 331
INFO:root:    loop_stmt                      shift and go to state 333
INFO:root:    null_stmt                      shift and go to state 334
INFO:root:    label                          shift and go to state 335
INFO:root:    select_stmt                    shift and go to state 311
INFO:root:    label_opt                      shift and go to state 313
INFO:root:    assign_stmt                    shift and go to state 336
INFO:root:    selected_comp                  shift and go to state 139
INFO:root:    abort_stmt                     shift and go to state 315
INFO:root:    attribute                      shift and go to state 134
INFO:root:    name                           shift and go to state 316
INFO:root:    accept_hdr                     shift and go to state 318
INFO:root:    accept_stmt                    shift and go to state 337
INFO:root:    case_hdr                       shift and go to state 319
INFO:root:    delay_stmt                     shift and go to state 338
INFO:root:    statement_s                    shift and go to state 919
INFO:root:    compound_stmt                  shift and go to state 309
INFO:root:    raise_stmt                     shift and go to state 342
INFO:root:    qualified                      shift and go to state 321
INFO:root:    return_stmt                    shift and go to state 323
INFO:root:    case_stmt                      shift and go to state 324
INFO:root:    block                          shift and go to state 325
INFO:root:    unlabeled                      shift and go to state 346
INFO:root:
INFO:root:state 904
INFO:root:
INFO:root:    (466) generic_formal -> WITH PACKAGE simple_name IS NEW name ( BOX ) ; .
INFO:root:
INFO:root:    PACKAGE         reduce using rule 466 (generic_formal -> WITH PACKAGE simple_name IS NEW name ( BOX ) ; .)
INFO:root:    PROCEDURE       reduce using rule 466 (generic_formal -> WITH PACKAGE simple_name IS NEW name ( BOX ) ; .)
INFO:root:    FUNCTION        reduce using rule 466 (generic_formal -> WITH PACKAGE simple_name IS NEW name ( BOX ) ; .)
INFO:root:    TYPE            reduce using rule 466 (generic_formal -> WITH PACKAGE simple_name IS NEW name ( BOX ) ; .)
INFO:root:    WITH            reduce using rule 466 (generic_formal -> WITH PACKAGE simple_name IS NEW name ( BOX ) ; .)
INFO:root:    error           reduce using rule 466 (generic_formal -> WITH PACKAGE simple_name IS NEW name ( BOX ) ; .)
INFO:root:    USE             reduce using rule 466 (generic_formal -> WITH PACKAGE simple_name IS NEW name ( BOX ) ; .)
INFO:root:    IDENTIFIER      reduce using rule 466 (generic_formal -> WITH PACKAGE simple_name IS NEW name ( BOX ) ; .)
INFO:root:
INFO:root:
INFO:root:state 905
INFO:root:
INFO:root:    (105) comp_decl_s -> comp_decl_s pragma_s . comp_decl
INFO:root:    (106) variant_part_opt -> pragma_s .
INFO:root:    (107) variant_part_opt -> pragma_s . variant_part pragma_s
INFO:root:    (9) pragma_s -> pragma_s . pragma
INFO:root:    (108) comp_decl -> . def_id_s : component_subtype_def init_opt ;
INFO:root:    (109) comp_decl -> . error ;
INFO:root:    (117) variant_part -> . CASE simple_name IS pragma_s variant_s END CASE ;
INFO:root:    (2) pragma -> . PRAGMA IDENTIFIER ;
INFO:root:    (3) pragma -> . PRAGMA simple_name ( pragma_arg_s ) ;
INFO:root:    (24) def_id_s -> . def_id
INFO:root:    (25) def_id_s -> . def_id_s , def_id
INFO:root:    (26) def_id -> . IDENTIFIER
INFO:root:
INFO:root:    END             reduce using rule 106 (variant_part_opt -> pragma_s .)
INFO:root:    WHEN            reduce using rule 106 (variant_part_opt -> pragma_s .)
INFO:root:    error           shift and go to state 807
INFO:root:    CASE            shift and go to state 881
INFO:root:    PRAGMA          shift and go to state 2
INFO:root:    IDENTIFIER      shift and go to state 52
INFO:root:
INFO:root:    def_id_s                       shift and go to state 806
INFO:root:    def_id                         shift and go to state 57
INFO:root:    variant_part                   shift and go to state 921
INFO:root:    pragma                         shift and go to state 43
INFO:root:    comp_decl                      shift and go to state 920
INFO:root:
INFO:root:state 906
INFO:root:
INFO:root:    (101) comp_list -> comp_decl_s variant_part_opt .
INFO:root:
INFO:root:    END             reduce using rule 101 (comp_list -> comp_decl_s variant_part_opt .)
INFO:root:    WHEN            reduce using rule 101 (comp_list -> comp_decl_s variant_part_opt .)
INFO:root:
INFO:root:
INFO:root:state 907
INFO:root:
INFO:root:    (117) variant_part -> CASE simple_name . IS pragma_s variant_s END CASE ;
INFO:root:
INFO:root:    IS              shift and go to state 922
INFO:root:
INFO:root:
INFO:root:state 908
INFO:root:
INFO:root:    (96) record_def -> RECORD pragma_s comp_list END . RECORD
INFO:root:
INFO:root:    RECORD          shift and go to state 923
INFO:root:
INFO:root:
INFO:root:state 909
INFO:root:
INFO:root:    (103) comp_list -> NuLL ; . pragma_s
INFO:root:    (8) pragma_s -> .
INFO:root:    (9) pragma_s -> . pragma_s pragma
INFO:root:
INFO:root:    PRAGMA          reduce using rule 8 (pragma_s -> .)
INFO:root:    END             reduce using rule 8 (pragma_s -> .)
INFO:root:    WHEN            reduce using rule 8 (pragma_s -> .)
INFO:root:
INFO:root:    pragma_s                       shift and go to state 924
INFO:root:
INFO:root:state 910
INFO:root:
INFO:root:    (102) comp_list -> variant_part pragma_s .
INFO:root:    (9) pragma_s -> pragma_s . pragma
INFO:root:    (2) pragma -> . PRAGMA IDENTIFIER ;
INFO:root:    (3) pragma -> . PRAGMA simple_name ( pragma_arg_s ) ;
INFO:root:
INFO:root:    END             reduce using rule 102 (comp_list -> variant_part pragma_s .)
INFO:root:    WHEN            reduce using rule 102 (comp_list -> variant_part pragma_s .)
INFO:root:    PRAGMA          shift and go to state 2
INFO:root:
INFO:root:    pragma                         shift and go to state 43
INFO:root:
INFO:root:state 911
INFO:root:
INFO:root:    (382) entry_decl -> ENTRY IDENTIFIER ( discrete_range ) formal_part_opt . ;
INFO:root:
INFO:root:    ;               shift and go to state 925
INFO:root:
INFO:root:
INFO:root:state 912
INFO:root:
INFO:root:    (383) entry_body -> ENTRY IDENTIFIER formal_part_opt WHEN condition . entry_body_part
INFO:root:    (385) entry_body_part -> . ;
INFO:root:    (386) entry_body_part -> . IS decl_part block_body END id_opt ;
INFO:root:
INFO:root:    ;               shift and go to state 928
INFO:root:    IS              shift and go to state 927
INFO:root:
INFO:root:    entry_body_part                shift and go to state 926
INFO:root:
INFO:root:state 913
INFO:root:
INFO:root:    (384) entry_body -> ENTRY IDENTIFIER ( iter_part discrete_range . ) formal_part_opt WHEN condition entry_body_part
INFO:root:
INFO:root:    )               shift and go to state 929
INFO:root:
INFO:root:
INFO:root:state 914
INFO:root:
INFO:root:    (108) comp_decl -> def_id_s : component_subtype_def init_opt . ;
INFO:root:
INFO:root:    ;               shift and go to state 930
INFO:root:
INFO:root:
INFO:root:state 915
INFO:root:
INFO:root:    (499) comp_loc_s -> comp_loc_s mark AT expression RANGE . range ;
INFO:root:    (62) range -> . simple_expression DOTDOT simple_expression
INFO:root:    (208) simple_expression -> . unary term
INFO:root:    (209) simple_expression -> . term
INFO:root:    (210) simple_expression -> . simple_expression adding term
INFO:root:    (211) unary -> . +
INFO:root:    (212) unary -> . -
INFO:root:    (216) term -> . factor
INFO:root:    (217) term -> . term multiplying factor
INFO:root:    (223) factor -> . primary
INFO:root:    (224) factor -> . NOT primary
INFO:root:    (225) factor -> . ABS primary
INFO:root:    (226) primary -> . literal
INFO:root:    (227) primary -> . name
INFO:root:    (228) primary -> . allocator
INFO:root:    (229) primary -> . qualified
INFO:root:    (230) primary -> . parenthesized_primary
INFO:root:    (180) literal -> . INT
INFO:root:    (181) literal -> . FLOAT
INFO:root:    (182) literal -> . NuLL
INFO:root:    (149) name -> . simple_name
INFO:root:    (150) name -> . indexed_comp
INFO:root:    (151) name -> . selected_comp
INFO:root:    (152) name -> . attribute
INFO:root:    (153) name -> . operator_symbol
INFO:root:    (234) allocator -> . NEW name
INFO:root:    (235) allocator -> . NEW qualified
INFO:root:    (233) qualified -> . name TICK parenthesized_primary
INFO:root:    (231) parenthesized_primary -> . aggregate
INFO:root:    (232) parenthesized_primary -> . ( expression )
INFO:root:    (157) simple_name -> . IDENTIFIER
INFO:root:    (164) indexed_comp -> . name ( value_s )
INFO:root:    (171) selected_comp -> . name . simple_name
INFO:root:    (172) selected_comp -> . name . used_char
INFO:root:    (173) selected_comp -> . name . operator_symbol
INFO:root:    (174) selected_comp -> . name . ALL
INFO:root:    (175) attribute -> . name TICK attribute_id
INFO:root:    (163) operator_symbol -> . STRING
INFO:root:    (183) aggregate -> . ( comp_assoc )
INFO:root:    (184) aggregate -> . ( expression WITH value_s )
INFO:root:    (185) aggregate -> . ( expression WITH NuLL RECORD )
INFO:root:    (186) aggregate -> . ( NuLL RECORD )
INFO:root:
INFO:root:    +               shift and go to state 148
INFO:root:    -               shift and go to state 136
INFO:root:    NOT             shift and go to state 131
INFO:root:    ABS             shift and go to state 132
INFO:root:    INT             shift and go to state 120
INFO:root:    FLOAT           shift and go to state 128
INFO:root:    NuLL            shift and go to state 130
INFO:root:    NEW             shift and go to state 137
INFO:root:    (               shift and go to state 125
INFO:root:    IDENTIFIER      shift and go to state 33
INFO:root:    STRING          shift and go to state 149
INFO:root:
INFO:root:    literal                        shift and go to state 121
INFO:root:    allocator                      shift and go to state 122
INFO:root:    simple_name                    shift and go to state 163
INFO:root:    indexed_comp                   shift and go to state 140
INFO:root:    name                           shift and go to state 142
INFO:root:    selected_comp                  shift and go to state 139
INFO:root:    factor                         shift and go to state 126
INFO:root:    aggregate                      shift and go to state 143
INFO:root:    unary                          shift and go to state 144
INFO:root:    qualified                      shift and go to state 145
INFO:root:    simple_expression              shift and go to state 366
INFO:root:    term                           shift and go to state 146
INFO:root:    operator_symbol                shift and go to state 133
INFO:root:    parenthesized_primary          shift and go to state 147
INFO:root:    attribute                      shift and go to state 134
INFO:root:    primary                        shift and go to state 135
INFO:root:    range                          shift and go to state 931
INFO:root:
INFO:root:state 916
INFO:root:
INFO:root:    (413) cond_entry_call -> SELECT entry_call stmts_opt ELSE statement_s END SELECT ; .
INFO:root:
INFO:root:    LL              reduce using rule 413 (cond_entry_call -> SELECT entry_call stmts_opt ELSE statement_s END SELECT ; .)
INFO:root:    error           reduce using rule 413 (cond_entry_call -> SELECT entry_call stmts_opt ELSE statement_s END SELECT ; .)
INFO:root:    NuLL            reduce using rule 413 (cond_entry_call -> SELECT entry_call stmts_opt ELSE statement_s END SELECT ; .)
INFO:root:    EXIT            reduce using rule 413 (cond_entry_call -> SELECT entry_call stmts_opt ELSE statement_s END SELECT ; .)
INFO:root:    RETURN          reduce using rule 413 (cond_entry_call -> SELECT entry_call stmts_opt ELSE statement_s END SELECT ; .)
INFO:root:    DELAY           reduce using rule 413 (cond_entry_call -> SELECT entry_call stmts_opt ELSE statement_s END SELECT ; .)
INFO:root:    ABORT           reduce using rule 413 (cond_entry_call -> SELECT entry_call stmts_opt ELSE statement_s END SELECT ; .)
INFO:root:    RAISE           reduce using rule 413 (cond_entry_call -> SELECT entry_call stmts_opt ELSE statement_s END SELECT ; .)
INFO:root:    REQUEUE         reduce using rule 413 (cond_entry_call -> SELECT entry_call stmts_opt ELSE statement_s END SELECT ; .)
INFO:root:    IF              reduce using rule 413 (cond_entry_call -> SELECT entry_call stmts_opt ELSE statement_s END SELECT ; .)
INFO:root:    CASE            reduce using rule 413 (cond_entry_call -> SELECT entry_call stmts_opt ELSE statement_s END SELECT ; .)
INFO:root:    IDENTIFIER      reduce using rule 413 (cond_entry_call -> SELECT entry_call stmts_opt ELSE statement_s END SELECT ; .)
INFO:root:    ACCEPT          reduce using rule 413 (cond_entry_call -> SELECT entry_call stmts_opt ELSE statement_s END SELECT ; .)
INFO:root:    SELECT          reduce using rule 413 (cond_entry_call -> SELECT entry_call stmts_opt ELSE statement_s END SELECT ; .)
INFO:root:    STRING          reduce using rule 413 (cond_entry_call -> SELECT entry_call stmts_opt ELSE statement_s END SELECT ; .)
INFO:root:    WHILE           reduce using rule 413 (cond_entry_call -> SELECT entry_call stmts_opt ELSE statement_s END SELECT ; .)
INFO:root:    DECLARE         reduce using rule 413 (cond_entry_call -> SELECT entry_call stmts_opt ELSE statement_s END SELECT ; .)
INFO:root:    FOR             reduce using rule 413 (cond_entry_call -> SELECT entry_call stmts_opt ELSE statement_s END SELECT ; .)
INFO:root:    LOOP            reduce using rule 413 (cond_entry_call -> SELECT entry_call stmts_opt ELSE statement_s END SELECT ; .)
INFO:root:    BEGIN           reduce using rule 413 (cond_entry_call -> SELECT entry_call stmts_opt ELSE statement_s END SELECT ; .)
INFO:root:    WHEN            reduce using rule 413 (cond_entry_call -> SELECT entry_call stmts_opt ELSE statement_s END SELECT ; .)
INFO:root:    END             reduce using rule 413 (cond_entry_call -> SELECT entry_call stmts_opt ELSE statement_s END SELECT ; .)
INFO:root:    OR              reduce using rule 413 (cond_entry_call -> SELECT entry_call stmts_opt ELSE statement_s END SELECT ; .)
INFO:root:    ELSE            reduce using rule 413 (cond_entry_call -> SELECT entry_call stmts_opt ELSE statement_s END SELECT ; .)
INFO:root:    EXCEPTION       reduce using rule 413 (cond_entry_call -> SELECT entry_call stmts_opt ELSE statement_s END SELECT ; .)
INFO:root:    THEN            reduce using rule 413 (cond_entry_call -> SELECT entry_call stmts_opt ELSE statement_s END SELECT ; .)
INFO:root:    ELSIF           reduce using rule 413 (cond_entry_call -> SELECT entry_call stmts_opt ELSE statement_s END SELECT ; .)
INFO:root:
INFO:root:
INFO:root:state 917
INFO:root:
INFO:root:    (412) timed_entry_call -> SELECT entry_call stmts_opt OR delay_stmt stmts_opt END SELECT . ;
INFO:root:
INFO:root:    ;               shift and go to state 932
INFO:root:
INFO:root:
INFO:root:state 918
INFO:root:
INFO:root:    (411) async_select -> SELECT delay_or_entry_alt THEN ABORT statement_s END SELECT ; .
INFO:root:
INFO:root:    LL              reduce using rule 411 (async_select -> SELECT delay_or_entry_alt THEN ABORT statement_s END SELECT ; .)
INFO:root:    error           reduce using rule 411 (async_select -> SELECT delay_or_entry_alt THEN ABORT statement_s END SELECT ; .)
INFO:root:    NuLL            reduce using rule 411 (async_select -> SELECT delay_or_entry_alt THEN ABORT statement_s END SELECT ; .)
INFO:root:    EXIT            reduce using rule 411 (async_select -> SELECT delay_or_entry_alt THEN ABORT statement_s END SELECT ; .)
INFO:root:    RETURN          reduce using rule 411 (async_select -> SELECT delay_or_entry_alt THEN ABORT statement_s END SELECT ; .)
INFO:root:    DELAY           reduce using rule 411 (async_select -> SELECT delay_or_entry_alt THEN ABORT statement_s END SELECT ; .)
INFO:root:    ABORT           reduce using rule 411 (async_select -> SELECT delay_or_entry_alt THEN ABORT statement_s END SELECT ; .)
INFO:root:    RAISE           reduce using rule 411 (async_select -> SELECT delay_or_entry_alt THEN ABORT statement_s END SELECT ; .)
INFO:root:    REQUEUE         reduce using rule 411 (async_select -> SELECT delay_or_entry_alt THEN ABORT statement_s END SELECT ; .)
INFO:root:    IF              reduce using rule 411 (async_select -> SELECT delay_or_entry_alt THEN ABORT statement_s END SELECT ; .)
INFO:root:    CASE            reduce using rule 411 (async_select -> SELECT delay_or_entry_alt THEN ABORT statement_s END SELECT ; .)
INFO:root:    IDENTIFIER      reduce using rule 411 (async_select -> SELECT delay_or_entry_alt THEN ABORT statement_s END SELECT ; .)
INFO:root:    ACCEPT          reduce using rule 411 (async_select -> SELECT delay_or_entry_alt THEN ABORT statement_s END SELECT ; .)
INFO:root:    SELECT          reduce using rule 411 (async_select -> SELECT delay_or_entry_alt THEN ABORT statement_s END SELECT ; .)
INFO:root:    STRING          reduce using rule 411 (async_select -> SELECT delay_or_entry_alt THEN ABORT statement_s END SELECT ; .)
INFO:root:    WHILE           reduce using rule 411 (async_select -> SELECT delay_or_entry_alt THEN ABORT statement_s END SELECT ; .)
INFO:root:    DECLARE         reduce using rule 411 (async_select -> SELECT delay_or_entry_alt THEN ABORT statement_s END SELECT ; .)
INFO:root:    FOR             reduce using rule 411 (async_select -> SELECT delay_or_entry_alt THEN ABORT statement_s END SELECT ; .)
INFO:root:    LOOP            reduce using rule 411 (async_select -> SELECT delay_or_entry_alt THEN ABORT statement_s END SELECT ; .)
INFO:root:    BEGIN           reduce using rule 411 (async_select -> SELECT delay_or_entry_alt THEN ABORT statement_s END SELECT ; .)
INFO:root:    THEN            reduce using rule 411 (async_select -> SELECT delay_or_entry_alt THEN ABORT statement_s END SELECT ; .)
INFO:root:    OR              reduce using rule 411 (async_select -> SELECT delay_or_entry_alt THEN ABORT statement_s END SELECT ; .)
INFO:root:    ELSE            reduce using rule 411 (async_select -> SELECT delay_or_entry_alt THEN ABORT statement_s END SELECT ; .)
INFO:root:    END             reduce using rule 411 (async_select -> SELECT delay_or_entry_alt THEN ABORT statement_s END SELECT ; .)
INFO:root:    ELSIF           reduce using rule 411 (async_select -> SELECT delay_or_entry_alt THEN ABORT statement_s END SELECT ; .)
INFO:root:    EXCEPTION       reduce using rule 411 (async_select -> SELECT delay_or_entry_alt THEN ABORT statement_s END SELECT ; .)
INFO:root:    WHEN            reduce using rule 411 (async_select -> SELECT delay_or_entry_alt THEN ABORT statement_s END SELECT ; .)
INFO:root:
INFO:root:
INFO:root:state 919
INFO:root:
INFO:root:    (450) exception_handler -> WHEN IDENTIFIER : except_choice_s ARROW statement_s .
INFO:root:    (237) statement_s -> statement_s . statement
INFO:root:    (238) statement -> . unlabeled
INFO:root:    (239) statement -> . label statement
INFO:root:    (240) unlabeled -> . simple_stmt
INFO:root:    (241) unlabeled -> . compound_stmt
INFO:root:    (259) label -> . LL IDENTIFIER RR
INFO:root:    (242) simple_stmt -> . null_stmt
INFO:root:    (243) simple_stmt -> . assign_stmt
INFO:root:    (244) simple_stmt -> . exit_stmt
INFO:root:    (245) simple_stmt -> . return_stmt
INFO:root:    (246) simple_stmt -> . procedure_call
INFO:root:    (247) simple_stmt -> . delay_stmt
INFO:root:    (248) simple_stmt -> . abort_stmt
INFO:root:    (249) simple_stmt -> . raise_stmt
INFO:root:    (250) simple_stmt -> . code_stmt
INFO:root:    (251) simple_stmt -> . requeue_stmt
INFO:root:    (252) simple_stmt -> . error ;
INFO:root:    (253) compound_stmt -> . if_stmt
INFO:root:    (254) compound_stmt -> . case_stmt
INFO:root:    (255) compound_stmt -> . loop_stmt
INFO:root:    (256) compound_stmt -> . block
INFO:root:    (257) compound_stmt -> . accept_stmt
INFO:root:    (258) compound_stmt -> . select_stmt
INFO:root:    (260) null_stmt -> . NuLL ;
INFO:root:    (261) assign_stmt -> . name ASSIGN expression ;
INFO:root:    (294) exit_stmt -> . EXIT name_opt when_opt ;
INFO:root:    (299) return_stmt -> . RETURN ;
INFO:root:    (300) return_stmt -> . RETURN expression ;
INFO:root:    (323) procedure_call -> . name ;
INFO:root:    (395) delay_stmt -> . DELAY expression ;
INFO:root:    (396) delay_stmt -> . DELAY UNTIL expression ;
INFO:root:    (416) abort_stmt -> . ABORT name_s ;
INFO:root:    (455) raise_stmt -> . RAISE name_opt ;
INFO:root:    (501) code_stmt -> . qualified ;
INFO:root:    (456) requeue_stmt -> . REQUEUE name ;
INFO:root:    (457) requeue_stmt -> . REQUEUE name WITH ABORT ;
INFO:root:    (262) if_stmt -> . IF cond_clause_s else_opt END IF ;
INFO:root:    (270) case_stmt -> . case_hdr pragma_s alternative_s END CASE ;
INFO:root:    (275) loop_stmt -> . label_opt iteration basic_loop id_opt ;
INFO:root:    (287) block -> . label_opt block_decl block_body END id_opt ;
INFO:root:    (390) accept_stmt -> . accept_hdr ;
INFO:root:    (391) accept_stmt -> . accept_hdr DO handled_stmt_s END id_opt ;
INFO:root:    (397) select_stmt -> . select_wait
INFO:root:    (398) select_stmt -> . async_select
INFO:root:    (399) select_stmt -> . timed_entry_call
INFO:root:    (400) select_stmt -> . cond_entry_call
INFO:root:    (149) name -> . simple_name
INFO:root:    (150) name -> . indexed_comp
INFO:root:    (151) name -> . selected_comp
INFO:root:    (152) name -> . attribute
INFO:root:    (153) name -> . operator_symbol
INFO:root:    (233) qualified -> . name TICK parenthesized_primary
INFO:root:    (271) case_hdr -> . CASE expression IS
INFO:root:    (276) label_opt -> .
INFO:root:    (277) label_opt -> . IDENTIFIER :
INFO:root:    (392) accept_hdr -> . ACCEPT entry_name formal_part_opt
INFO:root:    (401) select_wait -> . SELECT guarded_select_alt or_select else_opt END SELECT ;
INFO:root:    (411) async_select -> . SELECT delay_or_entry_alt THEN ABORT statement_s END SELECT ;
INFO:root:    (412) timed_entry_call -> . SELECT entry_call stmts_opt OR delay_stmt stmts_opt END SELECT ;
INFO:root:    (413) cond_entry_call -> . SELECT entry_call stmts_opt ELSE statement_s END SELECT ;
INFO:root:    (157) simple_name -> . IDENTIFIER
INFO:root:    (164) indexed_comp -> . name ( value_s )
INFO:root:    (171) selected_comp -> . name . simple_name
INFO:root:    (172) selected_comp -> . name . used_char
INFO:root:    (173) selected_comp -> . name . operator_symbol
INFO:root:    (174) selected_comp -> . name . ALL
INFO:root:    (175) attribute -> . name TICK attribute_id
INFO:root:    (163) operator_symbol -> . STRING
INFO:root:
INFO:root:    WHEN            reduce using rule 450 (exception_handler -> WHEN IDENTIFIER : except_choice_s ARROW statement_s .)
INFO:root:    END             reduce using rule 450 (exception_handler -> WHEN IDENTIFIER : except_choice_s ARROW statement_s .)
INFO:root:    LL              shift and go to state 344
INFO:root:    error           shift and go to state 341
INFO:root:    NuLL            shift and go to state 347
INFO:root:    EXIT            shift and go to state 340
INFO:root:    RETURN          shift and go to state 303
INFO:root:    DELAY           shift and go to state 332
INFO:root:    ABORT           shift and go to state 326
INFO:root:    RAISE           shift and go to state 314
INFO:root:    REQUEUE         shift and go to state 317
INFO:root:    IF              shift and go to state 327
INFO:root:    CASE            shift and go to state 312
INFO:root:    WHILE           reduce using rule 276 (label_opt -> .)
INFO:root:    DECLARE         reduce using rule 276 (label_opt -> .)
INFO:root:    FOR             reduce using rule 276 (label_opt -> .)
INFO:root:    LOOP            reduce using rule 276 (label_opt -> .)
INFO:root:    BEGIN           reduce using rule 276 (label_opt -> .)
INFO:root:    IDENTIFIER      shift and go to state 322
INFO:root:    ACCEPT          shift and go to state 310
INFO:root:    SELECT          shift and go to state 320
INFO:root:    STRING          shift and go to state 149
INFO:root:
INFO:root:    cond_entry_call                shift and go to state 345
INFO:root:    simple_stmt                    shift and go to state 302
INFO:root:    async_select                   shift and go to state 328
INFO:root:    simple_name                    shift and go to state 163
INFO:root:    requeue_stmt                   shift and go to state 329
INFO:root:    if_stmt                        shift and go to state 304
INFO:root:    procedure_call                 shift and go to state 305
INFO:root:    select_wait                    shift and go to state 330
INFO:root:    indexed_comp                   shift and go to state 140
INFO:root:    timed_entry_call               shift and go to state 307
INFO:root:    statement                      shift and go to state 497
INFO:root:    operator_symbol                shift and go to state 133
INFO:root:    exit_stmt                      shift and go to state 306
INFO:root:    code_stmt                      shift and go to state 331
INFO:root:    loop_stmt                      shift and go to state 333
INFO:root:    null_stmt                      shift and go to state 334
INFO:root:    label                          shift and go to state 335
INFO:root:    select_stmt                    shift and go to state 311
INFO:root:    label_opt                      shift and go to state 313
INFO:root:    assign_stmt                    shift and go to state 336
INFO:root:    selected_comp                  shift and go to state 139
INFO:root:    abort_stmt                     shift and go to state 315
INFO:root:    attribute                      shift and go to state 134
INFO:root:    name                           shift and go to state 316
INFO:root:    accept_hdr                     shift and go to state 318
INFO:root:    accept_stmt                    shift and go to state 337
INFO:root:    case_hdr                       shift and go to state 319
INFO:root:    delay_stmt                     shift and go to state 338
INFO:root:    compound_stmt                  shift and go to state 309
INFO:root:    raise_stmt                     shift and go to state 342
INFO:root:    qualified                      shift and go to state 321
INFO:root:    return_stmt                    shift and go to state 323
INFO:root:    case_stmt                      shift and go to state 324
INFO:root:    block                          shift and go to state 325
INFO:root:    unlabeled                      shift and go to state 346
INFO:root:
INFO:root:state 920
INFO:root:
INFO:root:    (105) comp_decl_s -> comp_decl_s pragma_s comp_decl .
INFO:root:
INFO:root:    error           reduce using rule 105 (comp_decl_s -> comp_decl_s pragma_s comp_decl .)
INFO:root:    CASE            reduce using rule 105 (comp_decl_s -> comp_decl_s pragma_s comp_decl .)
INFO:root:    PRAGMA          reduce using rule 105 (comp_decl_s -> comp_decl_s pragma_s comp_decl .)
INFO:root:    IDENTIFIER      reduce using rule 105 (comp_decl_s -> comp_decl_s pragma_s comp_decl .)
INFO:root:    END             reduce using rule 105 (comp_decl_s -> comp_decl_s pragma_s comp_decl .)
INFO:root:    WHEN            reduce using rule 105 (comp_decl_s -> comp_decl_s pragma_s comp_decl .)
INFO:root:
INFO:root:
INFO:root:state 921
INFO:root:
INFO:root:    (107) variant_part_opt -> pragma_s variant_part . pragma_s
INFO:root:    (8) pragma_s -> .
INFO:root:    (9) pragma_s -> . pragma_s pragma
INFO:root:
INFO:root:    PRAGMA          reduce using rule 8 (pragma_s -> .)
INFO:root:    END             reduce using rule 8 (pragma_s -> .)
INFO:root:    WHEN            reduce using rule 8 (pragma_s -> .)
INFO:root:
INFO:root:    pragma_s                       shift and go to state 933
INFO:root:
INFO:root:state 922
INFO:root:
INFO:root:    (117) variant_part -> CASE simple_name IS . pragma_s variant_s END CASE ;
INFO:root:    (8) pragma_s -> .
INFO:root:    (9) pragma_s -> . pragma_s pragma
INFO:root:
INFO:root:    PRAGMA          reduce using rule 8 (pragma_s -> .)
INFO:root:    WHEN            reduce using rule 8 (pragma_s -> .)
INFO:root:
INFO:root:    pragma_s                       shift and go to state 934
INFO:root:
INFO:root:state 923
INFO:root:
INFO:root:    (96) record_def -> RECORD pragma_s comp_list END RECORD .
INFO:root:
INFO:root:    ;               reduce using rule 96 (record_def -> RECORD pragma_s comp_list END RECORD .)
INFO:root:
INFO:root:
INFO:root:state 924
INFO:root:
INFO:root:    (103) comp_list -> NuLL ; pragma_s .
INFO:root:    (9) pragma_s -> pragma_s . pragma
INFO:root:    (2) pragma -> . PRAGMA IDENTIFIER ;
INFO:root:    (3) pragma -> . PRAGMA simple_name ( pragma_arg_s ) ;
INFO:root:
INFO:root:    END             reduce using rule 103 (comp_list -> NuLL ; pragma_s .)
INFO:root:    WHEN            reduce using rule 103 (comp_list -> NuLL ; pragma_s .)
INFO:root:    PRAGMA          shift and go to state 2
INFO:root:
INFO:root:    pragma                         shift and go to state 43
INFO:root:
INFO:root:state 925
INFO:root:
INFO:root:    (382) entry_decl -> ENTRY IDENTIFIER ( discrete_range ) formal_part_opt ; .
INFO:root:
INFO:root:    PRAGMA          reduce using rule 382 (entry_decl -> ENTRY IDENTIFIER ( discrete_range ) formal_part_opt ; .)
INFO:root:    ENTRY           reduce using rule 382 (entry_decl -> ENTRY IDENTIFIER ( discrete_range ) formal_part_opt ; .)
INFO:root:    FOR             reduce using rule 382 (entry_decl -> ENTRY IDENTIFIER ( discrete_range ) formal_part_opt ; .)
INFO:root:    END             reduce using rule 382 (entry_decl -> ENTRY IDENTIFIER ( discrete_range ) formal_part_opt ; .)
INFO:root:    error           reduce using rule 382 (entry_decl -> ENTRY IDENTIFIER ( discrete_range ) formal_part_opt ; .)
INFO:root:    PROCEDURE       reduce using rule 382 (entry_decl -> ENTRY IDENTIFIER ( discrete_range ) formal_part_opt ; .)
INFO:root:    FUNCTION        reduce using rule 382 (entry_decl -> ENTRY IDENTIFIER ( discrete_range ) formal_part_opt ; .)
INFO:root:    IDENTIFIER      reduce using rule 382 (entry_decl -> ENTRY IDENTIFIER ( discrete_range ) formal_part_opt ; .)
INFO:root:    PRIVATE         reduce using rule 382 (entry_decl -> ENTRY IDENTIFIER ( discrete_range ) formal_part_opt ; .)
INFO:root:
INFO:root:
INFO:root:state 926
INFO:root:
INFO:root:    (383) entry_body -> ENTRY IDENTIFIER formal_part_opt WHEN condition entry_body_part .
INFO:root:
INFO:root:    PRAGMA          reduce using rule 383 (entry_body -> ENTRY IDENTIFIER formal_part_opt WHEN condition entry_body_part .)
INFO:root:    END             reduce using rule 383 (entry_body -> ENTRY IDENTIFIER formal_part_opt WHEN condition entry_body_part .)
INFO:root:    ENTRY           reduce using rule 383 (entry_body -> ENTRY IDENTIFIER formal_part_opt WHEN condition entry_body_part .)
INFO:root:    PROCEDURE       reduce using rule 383 (entry_body -> ENTRY IDENTIFIER formal_part_opt WHEN condition entry_body_part .)
INFO:root:    FUNCTION        reduce using rule 383 (entry_body -> ENTRY IDENTIFIER formal_part_opt WHEN condition entry_body_part .)
INFO:root:
INFO:root:
INFO:root:state 927
INFO:root:
INFO:root:    (386) entry_body_part -> IS . decl_part block_body END id_opt ;
INFO:root:    (131) decl_part -> .
INFO:root:    (132) decl_part -> . decl_item_or_body_s1
INFO:root:    (141) decl_item_or_body_s1 -> . decl_item_or_body
INFO:root:    (142) decl_item_or_body_s1 -> . decl_item_or_body_s1 decl_item_or_body
INFO:root:    (143) decl_item_or_body -> . body
INFO:root:    (144) decl_item_or_body -> . decl_item
INFO:root:    (145) body -> . subprog_body
INFO:root:    (146) body -> . pkg_body
INFO:root:    (147) body -> . task_body
INFO:root:    (148) body -> . prot_body
INFO:root:    (137) decl_item -> . decl
INFO:root:    (138) decl_item -> . use_clause
INFO:root:    (139) decl_item -> . rep_spec
INFO:root:    (140) decl_item -> . pragma
INFO:root:    (322) subprog_body -> . subprog_spec_is_push decl_part block_body END id_opt ;
INFO:root:    (331) pkg_body -> . PACKAGE BODY compound_name IS decl_part body_opt END c_id_opt ;
INFO:root:    (356) task_body -> . TASK BODY simple_name IS decl_part block_body END id_opt ;
INFO:root:    (373) prot_body -> . PROTECTED BODY simple_name IS prot_op_body_s END id_opt ;
INFO:root:    (10) decl -> . object_decl
INFO:root:    (11) decl -> . number_decl
INFO:root:    (12) decl -> . type_decl
INFO:root:    (13) decl -> . subtype_decl
INFO:root:    (14) decl -> . subprog_decl
INFO:root:    (15) decl -> . pkg_decl
INFO:root:    (16) decl -> . task_decl
INFO:root:    (17) decl -> . prot_decl
INFO:root:    (18) decl -> . exception_decl
INFO:root:    (19) decl -> . rename_decl
INFO:root:    (20) decl -> . generic_decl
INFO:root:    (21) decl -> . body_stub
INFO:root:    (22) decl -> . error ;
INFO:root:    (337) use_clause -> . USE name_s ;
INFO:root:    (338) use_clause -> . USE TYPE name_s ;
INFO:root:    (491) rep_spec -> . attrib_def
INFO:root:    (492) rep_spec -> . record_type_spec
INFO:root:    (493) rep_spec -> . address_spec
INFO:root:    (2) pragma -> . PRAGMA IDENTIFIER ;
INFO:root:    (3) pragma -> . PRAGMA simple_name ( pragma_arg_s ) ;
INFO:root:    (321) subprog_spec_is_push -> . subprog_spec IS
INFO:root:    (23) object_decl -> . def_id_s : object_qualifier_opt object_subtype_def init_opt ;
INFO:root:    (35) number_decl -> . def_id_s : CONSTANT ASSIGN expression ;
INFO:root:    (36) type_decl -> . TYPE IDENTIFIER discrim_part_opt type_completion ;
INFO:root:    (50) subtype_decl -> . SUBTYPE IDENTIFIER IS subtype_ind ;
INFO:root:    (301) subprog_decl -> . subprog_spec ;
INFO:root:    (302) subprog_decl -> . generic_subp_inst ;
INFO:root:    (303) subprog_decl -> . subprog_spec_is_push ABSTRACT ;
INFO:root:    (324) pkg_decl -> . pkg_spec ;
INFO:root:    (325) pkg_decl -> . generic_pkg_inst ;
INFO:root:    (349) task_decl -> . task_spec ;
INFO:root:    (357) prot_decl -> . prot_spec ;
INFO:root:    (446) exception_decl -> . def_id_s : EXCEPTION ;
INFO:root:    (341) rename_decl -> . def_id_s : object_qualifier_opt subtype_ind renames ;
INFO:root:    (342) rename_decl -> . def_id_s : EXCEPTION renames ;
INFO:root:    (343) rename_decl -> . rename_unit
INFO:root:    (458) generic_decl -> . generic_formal_part subprog_spec ;
INFO:root:    (459) generic_decl -> . generic_formal_part pkg_spec ;
INFO:root:    (442) body_stub -> . TASK BODY simple_name IS SEPARATE ;
INFO:root:    (443) body_stub -> . PACKAGE BODY compound_name IS SEPARATE ;
INFO:root:    (444) body_stub -> . subprog_spec IS SEPARATE ;
INFO:root:    (445) body_stub -> . PROTECTED BODY simple_name IS SEPARATE ;
INFO:root:    (494) attrib_def -> . FOR mark USE expression ;
INFO:root:    (495) record_type_spec -> . FOR mark USE RECORD align_opt comp_loc_s END RECORD ;
INFO:root:    (500) address_spec -> . FOR mark USE AT expression ;
INFO:root:    (304) subprog_spec -> . PROCEDURE compound_name formal_part_opt
INFO:root:    (305) subprog_spec -> . FUNCTION designator formal_part_opt RETURN name
INFO:root:    (306) subprog_spec -> . FUNCTION designator
INFO:root:    (24) def_id_s -> . def_id
INFO:root:    (25) def_id_s -> . def_id_s , def_id
INFO:root:    (488) generic_subp_inst -> . subprog_spec IS generic_inst
INFO:root:    (326) pkg_spec -> . PACKAGE compound_name IS decl_item_s private_part END c_id_opt
INFO:root:    (489) generic_pkg_inst -> . PACKAGE compound_name IS generic_inst
INFO:root:    (350) task_spec -> . TASK simple_name task_def
INFO:root:    (351) task_spec -> . TASK TYPE simple_name discrim_part_opt task_def
INFO:root:    (358) prot_spec -> . PROTECTED IDENTIFIER prot_def
INFO:root:    (359) prot_spec -> . PROTECTED TYPE simple_name discrim_part_opt prot_def
INFO:root:    (344) rename_unit -> . PACKAGE compound_name renames ;
INFO:root:    (345) rename_unit -> . subprog_spec renames ;
INFO:root:    (346) rename_unit -> . generic_formal_part PACKAGE compound_name renames ;
INFO:root:    (347) rename_unit -> . generic_formal_part subprog_spec renames ;
INFO:root:    (460) generic_formal_part -> . GENERIC
INFO:root:    (461) generic_formal_part -> . generic_formal_part generic_formal
INFO:root:    (26) def_id -> . IDENTIFIER
INFO:root:
INFO:root:    BEGIN           reduce using rule 131 (decl_part -> .)
INFO:root:    PACKAGE         shift and go to state 73
INFO:root:    TASK            shift and go to state 84
INFO:root:    PROTECTED       shift and go to state 99
INFO:root:    error           shift and go to state 107
INFO:root:    USE             shift and go to state 53
INFO:root:    PRAGMA          shift and go to state 2
INFO:root:    TYPE            shift and go to state 74
INFO:root:    SUBTYPE         shift and go to state 110
INFO:root:    FOR             shift and go to state 102
INFO:root:    PROCEDURE       shift and go to state 17
INFO:root:    FUNCTION        shift and go to state 23
INFO:root:    GENERIC         shift and go to state 26
INFO:root:    IDENTIFIER      shift and go to state 52
INFO:root:
INFO:root:    generic_formal_part            shift and go to state 20
INFO:root:    pkg_decl                       shift and go to state 93
INFO:root:    pragma                         shift and go to state 94
INFO:root:    generic_pkg_inst               shift and go to state 19
INFO:root:    prot_decl                      shift and go to state 95
INFO:root:    body                           shift and go to state 75
INFO:root:    task_decl                      shift and go to state 76
INFO:root:    generic_decl                   shift and go to state 88
INFO:root:    subprog_decl                   shift and go to state 77
INFO:root:    type_decl                      shift and go to state 81
INFO:root:    def_id_s                       shift and go to state 79
INFO:root:    def_id                         shift and go to state 57
INFO:root:    rep_spec                       shift and go to state 72
INFO:root:    use_clause                     shift and go to state 97
INFO:root:    rename_decl                    shift and go to state 98
INFO:root:    body_stub                      shift and go to state 80
INFO:root:    address_spec                   shift and go to state 83
INFO:root:    task_spec                      shift and go to state 82
INFO:root:    number_decl                    shift and go to state 101
INFO:root:    generic_subp_inst              shift and go to state 24
INFO:root:    decl_item_or_body_s1           shift and go to state 103
INFO:root:    prot_spec                      shift and go to state 85
INFO:root:    rename_unit                    shift and go to state 104
INFO:root:    subprog_spec                   shift and go to state 86
INFO:root:    object_decl                    shift and go to state 87
INFO:root:    subtype_decl                   shift and go to state 105
INFO:root:    task_body                      shift and go to state 96
INFO:root:    prot_body                      shift and go to state 100
INFO:root:    pkg_body                       shift and go to state 90
INFO:root:    decl_part                      shift and go to state 935
INFO:root:    pkg_spec                       shift and go to state 16
INFO:root:    record_type_spec               shift and go to state 108
INFO:root:    decl                           shift and go to state 109
INFO:root:    decl_item                      shift and go to state 78
INFO:root:    exception_decl                 shift and go to state 91
INFO:root:    subprog_body                   shift and go to state 113
INFO:root:    attrib_def                     shift and go to state 92
INFO:root:    subprog_spec_is_push           shift and go to state 111
INFO:root:    decl_item_or_body              shift and go to state 112
INFO:root:
INFO:root:state 928
INFO:root:
INFO:root:    (385) entry_body_part -> ; .
INFO:root:
INFO:root:    PRAGMA          reduce using rule 385 (entry_body_part -> ; .)
INFO:root:    END             reduce using rule 385 (entry_body_part -> ; .)
INFO:root:    ENTRY           reduce using rule 385 (entry_body_part -> ; .)
INFO:root:    PROCEDURE       reduce using rule 385 (entry_body_part -> ; .)
INFO:root:    FUNCTION        reduce using rule 385 (entry_body_part -> ; .)
INFO:root:
INFO:root:
INFO:root:state 929
INFO:root:
INFO:root:    (384) entry_body -> ENTRY IDENTIFIER ( iter_part discrete_range ) . formal_part_opt WHEN condition entry_body_part
INFO:root:    (309) formal_part_opt -> .
INFO:root:    (310) formal_part_opt -> . formal_part
INFO:root:    (311) formal_part -> . ( param_s )
INFO:root:
INFO:root:    WHEN            reduce using rule 309 (formal_part_opt -> .)
INFO:root:    (               shift and go to state 151
INFO:root:
INFO:root:    formal_part_opt                shift and go to state 936
INFO:root:    formal_part                    shift and go to state 152
INFO:root:
INFO:root:state 930
INFO:root:
INFO:root:    (108) comp_decl -> def_id_s : component_subtype_def init_opt ; .
INFO:root:
INFO:root:    error           reduce using rule 108 (comp_decl -> def_id_s : component_subtype_def init_opt ; .)
INFO:root:    ENTRY           reduce using rule 108 (comp_decl -> def_id_s : component_subtype_def init_opt ; .)
INFO:root:    PROCEDURE       reduce using rule 108 (comp_decl -> def_id_s : component_subtype_def init_opt ; .)
INFO:root:    FUNCTION        reduce using rule 108 (comp_decl -> def_id_s : component_subtype_def init_opt ; .)
INFO:root:    PRAGMA          reduce using rule 108 (comp_decl -> def_id_s : component_subtype_def init_opt ; .)
INFO:root:    FOR             reduce using rule 108 (comp_decl -> def_id_s : component_subtype_def init_opt ; .)
INFO:root:    IDENTIFIER      reduce using rule 108 (comp_decl -> def_id_s : component_subtype_def init_opt ; .)
INFO:root:    END             reduce using rule 108 (comp_decl -> def_id_s : component_subtype_def init_opt ; .)
INFO:root:    CASE            reduce using rule 108 (comp_decl -> def_id_s : component_subtype_def init_opt ; .)
INFO:root:    WHEN            reduce using rule 108 (comp_decl -> def_id_s : component_subtype_def init_opt ; .)
INFO:root:
INFO:root:
INFO:root:state 931
INFO:root:
INFO:root:    (499) comp_loc_s -> comp_loc_s mark AT expression RANGE range . ;
INFO:root:
INFO:root:    ;               shift and go to state 937
INFO:root:
INFO:root:
INFO:root:state 932
INFO:root:
INFO:root:    (412) timed_entry_call -> SELECT entry_call stmts_opt OR delay_stmt stmts_opt END SELECT ; .
INFO:root:
INFO:root:    LL              reduce using rule 412 (timed_entry_call -> SELECT entry_call stmts_opt OR delay_stmt stmts_opt END SELECT ; .)
INFO:root:    error           reduce using rule 412 (timed_entry_call -> SELECT entry_call stmts_opt OR delay_stmt stmts_opt END SELECT ; .)
INFO:root:    NuLL            reduce using rule 412 (timed_entry_call -> SELECT entry_call stmts_opt OR delay_stmt stmts_opt END SELECT ; .)
INFO:root:    EXIT            reduce using rule 412 (timed_entry_call -> SELECT entry_call stmts_opt OR delay_stmt stmts_opt END SELECT ; .)
INFO:root:    RETURN          reduce using rule 412 (timed_entry_call -> SELECT entry_call stmts_opt OR delay_stmt stmts_opt END SELECT ; .)
INFO:root:    DELAY           reduce using rule 412 (timed_entry_call -> SELECT entry_call stmts_opt OR delay_stmt stmts_opt END SELECT ; .)
INFO:root:    ABORT           reduce using rule 412 (timed_entry_call -> SELECT entry_call stmts_opt OR delay_stmt stmts_opt END SELECT ; .)
INFO:root:    RAISE           reduce using rule 412 (timed_entry_call -> SELECT entry_call stmts_opt OR delay_stmt stmts_opt END SELECT ; .)
INFO:root:    REQUEUE         reduce using rule 412 (timed_entry_call -> SELECT entry_call stmts_opt OR delay_stmt stmts_opt END SELECT ; .)
INFO:root:    IF              reduce using rule 412 (timed_entry_call -> SELECT entry_call stmts_opt OR delay_stmt stmts_opt END SELECT ; .)
INFO:root:    CASE            reduce using rule 412 (timed_entry_call -> SELECT entry_call stmts_opt OR delay_stmt stmts_opt END SELECT ; .)
INFO:root:    IDENTIFIER      reduce using rule 412 (timed_entry_call -> SELECT entry_call stmts_opt OR delay_stmt stmts_opt END SELECT ; .)
INFO:root:    ACCEPT          reduce using rule 412 (timed_entry_call -> SELECT entry_call stmts_opt OR delay_stmt stmts_opt END SELECT ; .)
INFO:root:    SELECT          reduce using rule 412 (timed_entry_call -> SELECT entry_call stmts_opt OR delay_stmt stmts_opt END SELECT ; .)
INFO:root:    STRING          reduce using rule 412 (timed_entry_call -> SELECT entry_call stmts_opt OR delay_stmt stmts_opt END SELECT ; .)
INFO:root:    WHILE           reduce using rule 412 (timed_entry_call -> SELECT entry_call stmts_opt OR delay_stmt stmts_opt END SELECT ; .)
INFO:root:    DECLARE         reduce using rule 412 (timed_entry_call -> SELECT entry_call stmts_opt OR delay_stmt stmts_opt END SELECT ; .)
INFO:root:    FOR             reduce using rule 412 (timed_entry_call -> SELECT entry_call stmts_opt OR delay_stmt stmts_opt END SELECT ; .)
INFO:root:    LOOP            reduce using rule 412 (timed_entry_call -> SELECT entry_call stmts_opt OR delay_stmt stmts_opt END SELECT ; .)
INFO:root:    BEGIN           reduce using rule 412 (timed_entry_call -> SELECT entry_call stmts_opt OR delay_stmt stmts_opt END SELECT ; .)
INFO:root:    WHEN            reduce using rule 412 (timed_entry_call -> SELECT entry_call stmts_opt OR delay_stmt stmts_opt END SELECT ; .)
INFO:root:    END             reduce using rule 412 (timed_entry_call -> SELECT entry_call stmts_opt OR delay_stmt stmts_opt END SELECT ; .)
INFO:root:    EXCEPTION       reduce using rule 412 (timed_entry_call -> SELECT entry_call stmts_opt OR delay_stmt stmts_opt END SELECT ; .)
INFO:root:    OR              reduce using rule 412 (timed_entry_call -> SELECT entry_call stmts_opt OR delay_stmt stmts_opt END SELECT ; .)
INFO:root:    ELSE            reduce using rule 412 (timed_entry_call -> SELECT entry_call stmts_opt OR delay_stmt stmts_opt END SELECT ; .)
INFO:root:    THEN            reduce using rule 412 (timed_entry_call -> SELECT entry_call stmts_opt OR delay_stmt stmts_opt END SELECT ; .)
INFO:root:    ELSIF           reduce using rule 412 (timed_entry_call -> SELECT entry_call stmts_opt OR delay_stmt stmts_opt END SELECT ; .)
INFO:root:
INFO:root:
INFO:root:state 933
INFO:root:
INFO:root:    (107) variant_part_opt -> pragma_s variant_part pragma_s .
INFO:root:    (9) pragma_s -> pragma_s . pragma
INFO:root:    (2) pragma -> . PRAGMA IDENTIFIER ;
INFO:root:    (3) pragma -> . PRAGMA simple_name ( pragma_arg_s ) ;
INFO:root:
INFO:root:    END             reduce using rule 107 (variant_part_opt -> pragma_s variant_part pragma_s .)
INFO:root:    WHEN            reduce using rule 107 (variant_part_opt -> pragma_s variant_part pragma_s .)
INFO:root:    PRAGMA          shift and go to state 2
INFO:root:
INFO:root:    pragma                         shift and go to state 43
INFO:root:
INFO:root:state 934
INFO:root:
INFO:root:    (117) variant_part -> CASE simple_name IS pragma_s . variant_s END CASE ;
INFO:root:    (9) pragma_s -> pragma_s . pragma
INFO:root:    (118) variant_s -> . variant
INFO:root:    (119) variant_s -> . variant_s variant
INFO:root:    (2) pragma -> . PRAGMA IDENTIFIER ;
INFO:root:    (3) pragma -> . PRAGMA simple_name ( pragma_arg_s ) ;
INFO:root:    (120) variant -> . WHEN choice_s ARROW pragma_s comp_list
INFO:root:
INFO:root:    PRAGMA          shift and go to state 2
INFO:root:    WHEN            shift and go to state 939
INFO:root:
INFO:root:    variant_s                      shift and go to state 940
INFO:root:    variant                        shift and go to state 938
INFO:root:    pragma                         shift and go to state 43
INFO:root:
INFO:root:state 935
INFO:root:
INFO:root:    (386) entry_body_part -> IS decl_part . block_body END id_opt ;
INFO:root:    (290) block_body -> . BEGIN handled_stmt_s
INFO:root:
INFO:root:    BEGIN           shift and go to state 195
INFO:root:
INFO:root:    block_body                     shift and go to state 941
INFO:root:
INFO:root:state 936
INFO:root:
INFO:root:    (384) entry_body -> ENTRY IDENTIFIER ( iter_part discrete_range ) formal_part_opt . WHEN condition entry_body_part
INFO:root:
INFO:root:    WHEN            shift and go to state 942
INFO:root:
INFO:root:
INFO:root:state 937
INFO:root:
INFO:root:    (499) comp_loc_s -> comp_loc_s mark AT expression RANGE range ; .
INFO:root:
INFO:root:    END             reduce using rule 499 (comp_loc_s -> comp_loc_s mark AT expression RANGE range ; .)
INFO:root:    IDENTIFIER      reduce using rule 499 (comp_loc_s -> comp_loc_s mark AT expression RANGE range ; .)
INFO:root:
INFO:root:
INFO:root:state 938
INFO:root:
INFO:root:    (118) variant_s -> variant .
INFO:root:
INFO:root:    END             reduce using rule 118 (variant_s -> variant .)
INFO:root:    WHEN            reduce using rule 118 (variant_s -> variant .)
INFO:root:
INFO:root:
INFO:root:state 939
INFO:root:
INFO:root:    (120) variant -> WHEN . choice_s ARROW pragma_s comp_list
INFO:root:    (121) choice_s -> . choice
INFO:root:    (122) choice_s -> . choice_s | choice
INFO:root:    (123) choice -> . expression
INFO:root:    (124) choice -> . discrete_with_range
INFO:root:    (125) choice -> . OTHERS
INFO:root:    (188) expression -> . relation
INFO:root:    (189) expression -> . expression logical relation
INFO:root:    (190) expression -> . expression short_circuit relation
INFO:root:    (126) discrete_with_range -> . name range_constraint
INFO:root:    (127) discrete_with_range -> . range
INFO:root:    (196) relation -> . simple_expression
INFO:root:    (197) relation -> . simple_expression relational simple_expression
INFO:root:    (198) relation -> . simple_expression membership range
INFO:root:    (199) relation -> . simple_expression membership name
INFO:root:    (149) name -> . simple_name
INFO:root:    (150) name -> . indexed_comp
INFO:root:    (151) name -> . selected_comp
INFO:root:    (152) name -> . attribute
INFO:root:    (153) name -> . operator_symbol
INFO:root:    (62) range -> . simple_expression DOTDOT simple_expression
INFO:root:    (208) simple_expression -> . unary term
INFO:root:    (209) simple_expression -> . term
INFO:root:    (210) simple_expression -> . simple_expression adding term
INFO:root:    (157) simple_name -> . IDENTIFIER
INFO:root:    (164) indexed_comp -> . name ( value_s )
INFO:root:    (171) selected_comp -> . name . simple_name
INFO:root:    (172) selected_comp -> . name . used_char
INFO:root:    (173) selected_comp -> . name . operator_symbol
INFO:root:    (174) selected_comp -> . name . ALL
INFO:root:    (175) attribute -> . name TICK attribute_id
INFO:root:    (163) operator_symbol -> . STRING
INFO:root:    (211) unary -> . +
INFO:root:    (212) unary -> . -
INFO:root:    (216) term -> . factor
INFO:root:    (217) term -> . term multiplying factor
INFO:root:    (223) factor -> . primary
INFO:root:    (224) factor -> . NOT primary
INFO:root:    (225) factor -> . ABS primary
INFO:root:    (226) primary -> . literal
INFO:root:    (227) primary -> . name
INFO:root:    (228) primary -> . allocator
INFO:root:    (229) primary -> . qualified
INFO:root:    (230) primary -> . parenthesized_primary
INFO:root:    (180) literal -> . INT
INFO:root:    (181) literal -> . FLOAT
INFO:root:    (182) literal -> . NuLL
INFO:root:    (234) allocator -> . NEW name
INFO:root:    (235) allocator -> . NEW qualified
INFO:root:    (233) qualified -> . name TICK parenthesized_primary
INFO:root:    (231) parenthesized_primary -> . aggregate
INFO:root:    (232) parenthesized_primary -> . ( expression )
INFO:root:    (183) aggregate -> . ( comp_assoc )
INFO:root:    (184) aggregate -> . ( expression WITH value_s )
INFO:root:    (185) aggregate -> . ( expression WITH NuLL RECORD )
INFO:root:    (186) aggregate -> . ( NuLL RECORD )
INFO:root:
INFO:root:    OTHERS          shift and go to state 204
INFO:root:    IDENTIFIER      shift and go to state 33
INFO:root:    STRING          shift and go to state 149
INFO:root:    +               shift and go to state 148
INFO:root:    -               shift and go to state 136
INFO:root:    NOT             shift and go to state 131
INFO:root:    ABS             shift and go to state 132
INFO:root:    INT             shift and go to state 120
INFO:root:    FLOAT           shift and go to state 128
INFO:root:    NuLL            shift and go to state 130
INFO:root:    NEW             shift and go to state 137
INFO:root:    (               shift and go to state 125
INFO:root:
INFO:root:    selected_comp                  shift and go to state 139
INFO:root:    attribute                      shift and go to state 134
INFO:root:    factor                         shift and go to state 126
INFO:root:    indexed_comp                   shift and go to state 140
INFO:root:    name                           shift and go to state 377
INFO:root:    literal                        shift and go to state 121
INFO:root:    simple_name                    shift and go to state 163
INFO:root:    expression                     shift and go to state 507
INFO:root:    simple_expression              shift and go to state 374
INFO:root:    parenthesized_primary          shift and go to state 147
INFO:root:    unary                          shift and go to state 144
INFO:root:    allocator                      shift and go to state 122
INFO:root:    aggregate                      shift and go to state 143
INFO:root:    discrete_with_range            shift and go to state 210
INFO:root:    term                           shift and go to state 146
INFO:root:    operator_symbol                shift and go to state 133
INFO:root:    choice_s                       shift and go to state 943
INFO:root:    primary                        shift and go to state 135
INFO:root:    qualified                      shift and go to state 145
INFO:root:    relation                       shift and go to state 138
INFO:root:    range                          shift and go to state 211
INFO:root:    choice                         shift and go to state 207
INFO:root:
INFO:root:state 940
INFO:root:
INFO:root:    (117) variant_part -> CASE simple_name IS pragma_s variant_s . END CASE ;
INFO:root:    (119) variant_s -> variant_s . variant
INFO:root:    (120) variant -> . WHEN choice_s ARROW pragma_s comp_list
INFO:root:
INFO:root:    END             shift and go to state 944
INFO:root:    WHEN            shift and go to state 939
INFO:root:
INFO:root:    variant                        shift and go to state 945
INFO:root:
INFO:root:state 941
INFO:root:
INFO:root:    (386) entry_body_part -> IS decl_part block_body . END id_opt ;
INFO:root:
INFO:root:    END             shift and go to state 946
INFO:root:
INFO:root:
INFO:root:state 942
INFO:root:
INFO:root:    (384) entry_body -> ENTRY IDENTIFIER ( iter_part discrete_range ) formal_part_opt WHEN . condition entry_body_part
INFO:root:    (267) condition -> . expression
INFO:root:    (188) expression -> . relation
INFO:root:    (189) expression -> . expression logical relation
INFO:root:    (190) expression -> . expression short_circuit relation
INFO:root:    (196) relation -> . simple_expression
INFO:root:    (197) relation -> . simple_expression relational simple_expression
INFO:root:    (198) relation -> . simple_expression membership range
INFO:root:    (199) relation -> . simple_expression membership name
INFO:root:    (208) simple_expression -> . unary term
INFO:root:    (209) simple_expression -> . term
INFO:root:    (210) simple_expression -> . simple_expression adding term
INFO:root:    (211) unary -> . +
INFO:root:    (212) unary -> . -
INFO:root:    (216) term -> . factor
INFO:root:    (217) term -> . term multiplying factor
INFO:root:    (223) factor -> . primary
INFO:root:    (224) factor -> . NOT primary
INFO:root:    (225) factor -> . ABS primary
INFO:root:    (226) primary -> . literal
INFO:root:    (227) primary -> . name
INFO:root:    (228) primary -> . allocator
INFO:root:    (229) primary -> . qualified
INFO:root:    (230) primary -> . parenthesized_primary
INFO:root:    (180) literal -> . INT
INFO:root:    (181) literal -> . FLOAT
INFO:root:    (182) literal -> . NuLL
INFO:root:    (149) name -> . simple_name
INFO:root:    (150) name -> . indexed_comp
INFO:root:    (151) name -> . selected_comp
INFO:root:    (152) name -> . attribute
INFO:root:    (153) name -> . operator_symbol
INFO:root:    (234) allocator -> . NEW name
INFO:root:    (235) allocator -> . NEW qualified
INFO:root:    (233) qualified -> . name TICK parenthesized_primary
INFO:root:    (231) parenthesized_primary -> . aggregate
INFO:root:    (232) parenthesized_primary -> . ( expression )
INFO:root:    (157) simple_name -> . IDENTIFIER
INFO:root:    (164) indexed_comp -> . name ( value_s )
INFO:root:    (171) selected_comp -> . name . simple_name
INFO:root:    (172) selected_comp -> . name . used_char
INFO:root:    (173) selected_comp -> . name . operator_symbol
INFO:root:    (174) selected_comp -> . name . ALL
INFO:root:    (175) attribute -> . name TICK attribute_id
INFO:root:    (163) operator_symbol -> . STRING
INFO:root:    (183) aggregate -> . ( comp_assoc )
INFO:root:    (184) aggregate -> . ( expression WITH value_s )
INFO:root:    (185) aggregate -> . ( expression WITH NuLL RECORD )
INFO:root:    (186) aggregate -> . ( NuLL RECORD )
INFO:root:
INFO:root:    +               shift and go to state 148
INFO:root:    -               shift and go to state 136
INFO:root:    NOT             shift and go to state 131
INFO:root:    ABS             shift and go to state 132
INFO:root:    INT             shift and go to state 120
INFO:root:    FLOAT           shift and go to state 128
INFO:root:    NuLL            shift and go to state 130
INFO:root:    NEW             shift and go to state 137
INFO:root:    (               shift and go to state 125
INFO:root:    IDENTIFIER      shift and go to state 33
INFO:root:    STRING          shift and go to state 149
INFO:root:
INFO:root:    literal                        shift and go to state 121
INFO:root:    allocator                      shift and go to state 122
INFO:root:    indexed_comp                   shift and go to state 140
INFO:root:    name                           shift and go to state 142
INFO:root:    condition                      shift and go to state 947
INFO:root:    factor                         shift and go to state 126
INFO:root:    expression                     shift and go to state 489
INFO:root:    simple_name                    shift and go to state 163
INFO:root:    unary                          shift and go to state 144
INFO:root:    qualified                      shift and go to state 145
INFO:root:    aggregate                      shift and go to state 143
INFO:root:    simple_expression              shift and go to state 129
INFO:root:    term                           shift and go to state 146
INFO:root:    operator_symbol                shift and go to state 133
INFO:root:    parenthesized_primary          shift and go to state 147
INFO:root:    attribute                      shift and go to state 134
INFO:root:    primary                        shift and go to state 135
INFO:root:    relation                       shift and go to state 138
INFO:root:    selected_comp                  shift and go to state 139
INFO:root:
INFO:root:state 943
INFO:root:
INFO:root:    (120) variant -> WHEN choice_s . ARROW pragma_s comp_list
INFO:root:    (122) choice_s -> choice_s . | choice
INFO:root:
INFO:root:    ARROW           shift and go to state 948
INFO:root:    |               shift and go to state 351
INFO:root:
INFO:root:
INFO:root:state 944
INFO:root:
INFO:root:    (117) variant_part -> CASE simple_name IS pragma_s variant_s END . CASE ;
INFO:root:
INFO:root:    CASE            shift and go to state 949
INFO:root:
INFO:root:
INFO:root:state 945
INFO:root:
INFO:root:    (119) variant_s -> variant_s variant .
INFO:root:
INFO:root:    END             reduce using rule 119 (variant_s -> variant_s variant .)
INFO:root:    WHEN            reduce using rule 119 (variant_s -> variant_s variant .)
INFO:root:
INFO:root:
INFO:root:state 946
INFO:root:
INFO:root:    (386) entry_body_part -> IS decl_part block_body END . id_opt ;
INFO:root:    (285) id_opt -> .
INFO:root:    (286) id_opt -> . designator
INFO:root:    (307) designator -> . compound_name
INFO:root:    (308) designator -> . STRING
INFO:root:    (158) compound_name -> . simple_name
INFO:root:    (159) compound_name -> . compound_name . simple_name
INFO:root:    (157) simple_name -> . IDENTIFIER
INFO:root:
INFO:root:    ;               reduce using rule 285 (id_opt -> .)
INFO:root:    STRING          shift and go to state 62
INFO:root:    IDENTIFIER      shift and go to state 33
INFO:root:
INFO:root:    designator                     shift and go to state 455
INFO:root:    id_opt                         shift and go to state 950
INFO:root:    simple_name                    shift and go to state 34
INFO:root:    compound_name                  shift and go to state 64
INFO:root:
INFO:root:state 947
INFO:root:
INFO:root:    (384) entry_body -> ENTRY IDENTIFIER ( iter_part discrete_range ) formal_part_opt WHEN condition . entry_body_part
INFO:root:    (385) entry_body_part -> . ;
INFO:root:    (386) entry_body_part -> . IS decl_part block_body END id_opt ;
INFO:root:
INFO:root:    ;               shift and go to state 928
INFO:root:    IS              shift and go to state 927
INFO:root:
INFO:root:    entry_body_part                shift and go to state 951
INFO:root:
INFO:root:state 948
INFO:root:
INFO:root:    (120) variant -> WHEN choice_s ARROW . pragma_s comp_list
INFO:root:    (8) pragma_s -> .
INFO:root:    (9) pragma_s -> . pragma_s pragma
INFO:root:
INFO:root:    NuLL            reduce using rule 8 (pragma_s -> .)
INFO:root:    PRAGMA          reduce using rule 8 (pragma_s -> .)
INFO:root:    CASE            reduce using rule 8 (pragma_s -> .)
INFO:root:    error           reduce using rule 8 (pragma_s -> .)
INFO:root:    IDENTIFIER      reduce using rule 8 (pragma_s -> .)
INFO:root:
INFO:root:    pragma_s                       shift and go to state 952
INFO:root:
INFO:root:state 949
INFO:root:
INFO:root:    (117) variant_part -> CASE simple_name IS pragma_s variant_s END CASE . ;
INFO:root:
INFO:root:    ;               shift and go to state 953
INFO:root:
INFO:root:
INFO:root:state 950
INFO:root:
INFO:root:    (386) entry_body_part -> IS decl_part block_body END id_opt . ;
INFO:root:
INFO:root:    ;               shift and go to state 954
INFO:root:
INFO:root:
INFO:root:state 951
INFO:root:
INFO:root:    (384) entry_body -> ENTRY IDENTIFIER ( iter_part discrete_range ) formal_part_opt WHEN condition entry_body_part .
INFO:root:
INFO:root:    PRAGMA          reduce using rule 384 (entry_body -> ENTRY IDENTIFIER ( iter_part discrete_range ) formal_part_opt WHEN condition entry_body_part .)
INFO:root:    END             reduce using rule 384 (entry_body -> ENTRY IDENTIFIER ( iter_part discrete_range ) formal_part_opt WHEN condition entry_body_part .)
INFO:root:    ENTRY           reduce using rule 384 (entry_body -> ENTRY IDENTIFIER ( iter_part discrete_range ) formal_part_opt WHEN condition entry_body_part .)
INFO:root:    PROCEDURE       reduce using rule 384 (entry_body -> ENTRY IDENTIFIER ( iter_part discrete_range ) formal_part_opt WHEN condition entry_body_part .)
INFO:root:    FUNCTION        reduce using rule 384 (entry_body -> ENTRY IDENTIFIER ( iter_part discrete_range ) formal_part_opt WHEN condition entry_body_part .)
INFO:root:
INFO:root:
INFO:root:state 952
INFO:root:
INFO:root:    (120) variant -> WHEN choice_s ARROW pragma_s . comp_list
INFO:root:    (9) pragma_s -> pragma_s . pragma
INFO:root:    (101) comp_list -> . comp_decl_s variant_part_opt
INFO:root:    (102) comp_list -> . variant_part pragma_s
INFO:root:    (103) comp_list -> . NuLL ; pragma_s
INFO:root:    (2) pragma -> . PRAGMA IDENTIFIER ;
INFO:root:    (3) pragma -> . PRAGMA simple_name ( pragma_arg_s ) ;
INFO:root:    (104) comp_decl_s -> . comp_decl
INFO:root:    (105) comp_decl_s -> . comp_decl_s pragma_s comp_decl
INFO:root:    (117) variant_part -> . CASE simple_name IS pragma_s variant_s END CASE ;
INFO:root:    (108) comp_decl -> . def_id_s : component_subtype_def init_opt ;
INFO:root:    (109) comp_decl -> . error ;
INFO:root:    (24) def_id_s -> . def_id
INFO:root:    (25) def_id_s -> . def_id_s , def_id
INFO:root:    (26) def_id -> . IDENTIFIER
INFO:root:
INFO:root:    NuLL            shift and go to state 884
INFO:root:    PRAGMA          shift and go to state 2
INFO:root:    CASE            shift and go to state 881
INFO:root:    error           shift and go to state 807
INFO:root:    IDENTIFIER      shift and go to state 52
INFO:root:
INFO:root:    comp_decl_s                    shift and go to state 880
INFO:root:    def_id_s                       shift and go to state 806
INFO:root:    pragma                         shift and go to state 43
INFO:root:    def_id                         shift and go to state 57
INFO:root:    variant_part                   shift and go to state 885
INFO:root:    comp_list                      shift and go to state 955
INFO:root:    comp_decl                      shift and go to state 883
INFO:root:
INFO:root:state 953
INFO:root:
INFO:root:    (117) variant_part -> CASE simple_name IS pragma_s variant_s END CASE ; .
INFO:root:
INFO:root:    PRAGMA          reduce using rule 117 (variant_part -> CASE simple_name IS pragma_s variant_s END CASE ; .)
INFO:root:    END             reduce using rule 117 (variant_part -> CASE simple_name IS pragma_s variant_s END CASE ; .)
INFO:root:    WHEN            reduce using rule 117 (variant_part -> CASE simple_name IS pragma_s variant_s END CASE ; .)
INFO:root:
INFO:root:
INFO:root:state 954
INFO:root:
INFO:root:    (386) entry_body_part -> IS decl_part block_body END id_opt ; .
INFO:root:
INFO:root:    PRAGMA          reduce using rule 386 (entry_body_part -> IS decl_part block_body END id_opt ; .)
INFO:root:    END             reduce using rule 386 (entry_body_part -> IS decl_part block_body END id_opt ; .)
INFO:root:    ENTRY           reduce using rule 386 (entry_body_part -> IS decl_part block_body END id_opt ; .)
INFO:root:    PROCEDURE       reduce using rule 386 (entry_body_part -> IS decl_part block_body END id_opt ; .)
INFO:root:    FUNCTION        reduce using rule 386 (entry_body_part -> IS decl_part block_body END id_opt ; .)
INFO:root:
INFO:root:
INFO:root:state 955
INFO:root:
INFO:root:    (120) variant -> WHEN choice_s ARROW pragma_s comp_list .
INFO:root:
INFO:root:    END             reduce using rule 120 (variant -> WHEN choice_s ARROW pragma_s comp_list .)
INFO:root:    WHEN            reduce using rule 120 (variant -> WHEN choice_s ARROW pragma_s comp_list .)
INFO:root:
INFO:root:PLY: PARSE DEBUG START
INFO:root:Action : Reduce rule [compilation -> <empty>] with [] and goto state 1
INFO:root:Result : <Node @ 0x7fc3e7adfbe0> (<grammar.Node object at 0x7fc3e7adfbe0>)
INFO:root:Action : Reduce rule [simple_name -> IDENTIFIER] with ['Ada'] and goto state 34
INFO:root:Result : <Node @ 0x7fc3e7adfdd8> (<grammar.Node object at 0x7fc3e7adfdd8>)
INFO:root:Action : Reduce rule [compound_name -> simple_name] with [<Node @ 0x7fc3e7adfdd8>] and goto state 36
INFO:root:Result : <Node @ 0x7fc3e7adfd30> (<grammar.Node object at 0x7fc3e7adfd30>)
INFO:root:Action : Reduce rule [simple_name -> IDENTIFIER] with ['Text_IO'] and goto state 199
INFO:root:Result : <Node @ 0x7fc3e7adfcc0> (<grammar.Node object at 0x7fc3e7adfcc0>)
INFO:root:Action : Reduce rule [compound_name -> compound_name . simple_name] with [<Node @ 0x7fc3e7adfd30>,'.',<Node @ 0x7fc3e7adfcc0>] and goto state 36
INFO:root:Result : <Node @ 0x7fc3e7adfeb8> (<grammar.Node object at 0x7fc3e7adfeb8>)
INFO:root:Action : Reduce rule [c_name_list -> compound_name] with [<Node @ 0x7fc3e7adfeb8>] and goto state 35
INFO:root:Result : <Node @ 0x7fc3e7adfe10> (<grammar.Node object at 0x7fc3e7adfe10>)
INFO:root:Action : Reduce rule [with_clause -> WITH c_name_list ;] with ['with',<Node @ 0x7fc3e7adfe10>,';'] and goto state 10
INFO:root:Result : <Node @ 0x7fc3e7adff60> (<grammar.Node object at 0x7fc3e7adff60>)
INFO:root:Action : Reduce rule [use_clause_opt -> <empty>] with [] and goto state 40
INFO:root:Result : <Node @ 0x7fc3e772d160> (<grammar.Node object at 0x7fc3e772d160>)
INFO:root:Action : Reduce rule [simple_name -> IDENTIFIER] with ['Ada'] and goto state 163
INFO:root:Result : <Node @ 0x7fc3e77bb048> (<grammar.Node object at 0x7fc3e77bb048>)
INFO:root:Action : Reduce rule [name -> simple_name] with [<Node @ 0x7fc3e77bb048>] and goto state 161
INFO:root:Result : <Node @ 0x7fc3e77bb048> (<grammar.Node object at 0x7fc3e77bb048>)
INFO:root:Action : Reduce rule [simple_name -> IDENTIFIER] with ['Text_IO'] and goto state 387
INFO:root:Result : <Node @ 0x7fc3e7adfe48> (<grammar.Node object at 0x7fc3e7adfe48>)
INFO:root:Action : Reduce rule [selected_comp -> name . simple_name] with [<Node @ 0x7fc3e77bb048>,'.',<Node @ 0x7fc3e7adfe48>] and goto state 139
INFO:root:Result : <Node @ 0x7fc3e77bb0b8> (<grammar.Node object at 0x7fc3e77bb0b8>)
INFO:root:Action : Reduce rule [name -> selected_comp] with [<Node @ 0x7fc3e77bb0b8>] and goto state 161
INFO:root:Result : <Node @ 0x7fc3e77bb0b8> (<grammar.Node object at 0x7fc3e77bb0b8>)
INFO:root:Action : Reduce rule [name_s -> name] with [<Node @ 0x7fc3e77bb0b8>] and goto state 160
INFO:root:Result : <Node @ 0x7fc3e77bb0b8> (<grammar.Node object at 0x7fc3e77bb0b8>)
INFO:root:Action : Reduce rule [use_clause -> USE name_s ;] with ['use',<Node @ 0x7fc3e77bb0b8>,';'] and goto state 119
INFO:root:Result : <Node @ 0x7fc3e77bb1d0> (<grammar.Node object at 0x7fc3e77bb1d0>)
INFO:root:Action : Reduce rule [use_clause_opt -> use_clause_opt use_clause] with [<Node @ 0x7fc3e772d160>,<Node @ 0x7fc3e77bb1d0>] and goto state 40
INFO:root:Result : <Node @ 0x7fc3e7adfda0> (<grammar.Node object at 0x7fc3e7adfda0>)
INFO:root:Action : Reduce rule [context_spec -> with_clause use_clause_opt] with [<Node @ 0x7fc3e7adff60>,<Node @ 0x7fc3e7adfda0>] and goto state 8
INFO:root:Result : <Node @ 0x7fc3e772d160> (<grammar.Node object at 0x7fc3e772d160>)
INFO:root:Action : Reduce rule [private_opt -> <empty>] with [] and goto state 37
INFO:root:Result : <Node @ 0x7fc3e7adfd30> (<grammar.Node object at 0x7fc3e7adfd30>)
INFO:root:Action : Reduce rule [simple_name -> IDENTIFIER] with ['demo'] and goto state 34
INFO:root:Result : <Node @ 0x7fc3e77bb160> (<grammar.Node object at 0x7fc3e77bb160>)
INFO:root:Action : Reduce rule [compound_name -> simple_name] with [<Node @ 0x7fc3e77bb160>] and goto state 45
INFO:root:Result : <Node @ 0x7fc3e7adff98> (<grammar.Node object at 0x7fc3e7adff98>)
INFO:root:Action : Reduce rule [formal_part_opt -> <empty>] with [] and goto state 150
INFO:root:Result : <Node @ 0x7fc3e7adffd0> (<grammar.Node object at 0x7fc3e7adffd0>)
INFO:root:Action : Reduce rule [subprog_spec -> PROCEDURE compound_name formal_part_opt] with ['procedure',<Node @ 0x7fc3e7adff98>,<Node @ 0x7fc3e7adffd0>] and goto state 27
INFO:root:Result : <Node @ 0x7fc3e77bb278> (<grammar.Node object at 0x7fc3e77bb278>)
INFO:root:Action : Reduce rule [subprog_spec_is_push -> subprog_spec IS] with [<Node @ 0x7fc3e77bb278>,'is'] and goto state 31
INFO:root:Result : <Node @ 0x7fc3e77bb048> (<grammar.Node object at 0x7fc3e77bb048>)
INFO:root:Action : Reduce rule [def_id -> IDENTIFIER] with ['squares'] and goto state 57
INFO:root:Result : <Node @ 0x7fc3e77bb240> (<grammar.Node object at 0x7fc3e77bb240>)
INFO:root:Action : Reduce rule [def_id_s -> def_id] with [<Node @ 0x7fc3e77bb240>] and goto state 79
INFO:root:Result : <Node @ 0x7fc3e77bb240> (<grammar.Node object at 0x7fc3e77bb240>)
INFO:root:Action : Reduce rule [object_qualifier_opt -> <empty>] with [] and goto state 285
INFO:root:Result : <Node @ 0x7fc3e77bb208> (<grammar.Node object at 0x7fc3e77bb208>)
INFO:root:Action : Reduce rule [literal -> INT] with [1] and goto state 121
INFO:root:Result : <Node @ 0x7fc3e77bb4a8> (<grammar.Node object at 0x7fc3e77bb4a8>)
INFO:root:Action : Reduce rule [primary -> literal] with [<Node @ 0x7fc3e77bb4a8>] and goto state 135
INFO:root:Result : <Node @ 0x7fc3e77bb4a8> (<grammar.Node object at 0x7fc3e77bb4a8>)
INFO:root:Action : Reduce rule [factor -> primary] with [<Node @ 0x7fc3e77bb4a8>] and goto state 126
INFO:root:Result : <Node @ 0x7fc3e77bb4a8> (<grammar.Node object at 0x7fc3e77bb4a8>)
INFO:root:Action : Reduce rule [term -> factor] with [<Node @ 0x7fc3e77bb4a8>] and goto state 146
INFO:root:Result : <Node @ 0x7fc3e77bb4a8> (<grammar.Node object at 0x7fc3e77bb4a8>)
INFO:root:Action : Reduce rule [simple_expression -> term] with [<Node @ 0x7fc3e77bb4a8>] and goto state 366
INFO:root:Result : <Node @ 0x7fc3e77bb4a8> (<grammar.Node object at 0x7fc3e77bb4a8>)
INFO:root:Action : Reduce rule [literal -> INT] with [10] and goto state 121
INFO:root:Result : <Node @ 0x7fc3e77bb3c8> (<grammar.Node object at 0x7fc3e77bb3c8>)
INFO:root:Action : Reduce rule [primary -> literal] with [<Node @ 0x7fc3e77bb3c8>] and goto state 135
INFO:root:Result : <Node @ 0x7fc3e77bb3c8> (<grammar.Node object at 0x7fc3e77bb3c8>)
INFO:root:Action : Reduce rule [factor -> primary] with [<Node @ 0x7fc3e77bb3c8>] and goto state 126
INFO:root:Result : <Node @ 0x7fc3e77bb3c8> (<grammar.Node object at 0x7fc3e77bb3c8>)
INFO:root:Action : Reduce rule [term -> factor] with [<Node @ 0x7fc3e77bb3c8>] and goto state 146
INFO:root:Result : <Node @ 0x7fc3e77bb3c8> (<grammar.Node object at 0x7fc3e77bb3c8>)
INFO:root:Action : Reduce rule [simple_expression -> term] with [<Node @ 0x7fc3e77bb3c8>] and goto state 511
INFO:root:Result : <Node @ 0x7fc3e77bb3c8> (<grammar.Node object at 0x7fc3e77bb3c8>)
INFO:root:Action : Reduce rule [range -> simple_expression DOTDOT simple_expression] with [<Node @ 0x7fc3e77bb4a8>,'..',<Node @ 0x7fc3e77bb3c8>] and goto state 698
INFO:root:Result : <Node @ 0x7fc3e77bb550> (<grammar.Node object at 0x7fc3e77bb550>)
INFO:root:Action : Reduce rule [discrete_range -> range] with [<Node @ 0x7fc3e77bb550>] and goto state 697
INFO:root:Result : <Node @ 0x7fc3e77bb550> (<grammar.Node object at 0x7fc3e77bb550>)
INFO:root:Action : Reduce rule [iter_discrete_range_s -> discrete_range] with [<Node @ 0x7fc3e77bb550>] and goto state 693
INFO:root:Result : <Node @ 0x7fc3e77bb550> (<grammar.Node object at 0x7fc3e77bb550>)
INFO:root:Action : Reduce rule [iter_index_constraint -> ( iter_discrete_range_s )] with ['(',<Node @ 0x7fc3e77bb550>,')'] and goto state 576
INFO:root:Result : <Node @ 0x7fc3e77bb550> (<grammar.Node object at 0x7fc3e77bb550>)
INFO:root:Action : Reduce rule [aliased_opt -> <empty>] with [] and goto state 790
INFO:root:Result : <Node @ 0x7fc3e77bb358> (<grammar.Node object at 0x7fc3e77bb358>)
INFO:root:Action : Reduce rule [simple_name -> IDENTIFIER] with ['integer'] and goto state 163
INFO:root:Result : <Node @ 0x7fc3e77bb630> (<grammar.Node object at 0x7fc3e77bb630>)
INFO:root:Action : Reduce rule [name -> simple_name] with [<Node @ 0x7fc3e77bb630>] and goto state 432
INFO:root:Result : <Node @ 0x7fc3e77bb630> (<grammar.Node object at 0x7fc3e77bb630>)
INFO:root:Action : Reduce rule [subtype_ind -> name] with [<Node @ 0x7fc3e77bb630>] and goto state 849
INFO:root:Result : <Node @ 0x7fc3e77bb630> (<grammar.Node object at 0x7fc3e77bb630>)
INFO:root:Action : Reduce rule [component_subtype_def -> aliased_opt subtype_ind] with [<Node @ 0x7fc3e77bb358>,<Node @ 0x7fc3e77bb630>] and goto state 789
INFO:root:Result : <Node @ 0x7fc3e77bb668> (<grammar.Node object at 0x7fc3e77bb668>)
INFO:root:Action : Reduce rule [constr_array_type -> ARRAY iter_index_constraint OF component_subtype_def] with ['array',<Node @ 0x7fc3e77bb550>,'of',<Node @ 0x7fc3e77bb668>] and goto state 436
INFO:root:Result : <Node @ 0x7fc3e77bb5f8> (<grammar.Node object at 0x7fc3e77bb5f8>)
INFO:root:Action : Reduce rule [array_type -> constr_array_type] with [<Node @ 0x7fc3e77bb5f8>] and goto state 435
INFO:root:Result : <Node @ 0x7fc3e77bb5f8> (<grammar.Node object at 0x7fc3e77bb5f8>)
INFO:root:Action : Reduce rule [object_subtype_def -> array_type] with [<Node @ 0x7fc3e77bb5f8>] and goto state 437
INFO:root:Result : <Node @ 0x7fc3e77bb5f8> (<grammar.Node object at 0x7fc3e77bb5f8>)
INFO:root:Action : Reduce rule [init_opt -> <empty>] with [] and goto state 582
INFO:root:Result : <Node @ 0x7fc3e77bb438> (<grammar.Node object at 0x7fc3e77bb438>)
INFO:root:Action : Reduce rule [object_decl -> def_id_s : object_qualifier_opt object_subtype_def init_opt ;] with [<Node @ 0x7fc3e77bb240>,':',<Node @ 0x7fc3e77bb208>,<Node @ 0x7fc3e77bb5f8>,<Node @ 0x7fc3e77bb438>,';'] and goto state 87
INFO:root:Result : <Node @ 0x7fc3e77bb710> (<grammar.Node object at 0x7fc3e77bb710>)
INFO:root:Action : Reduce rule [decl -> object_decl] with [<Node @ 0x7fc3e77bb710>] and goto state 109
INFO:root:Result : <Node @ 0x7fc3e77bb710> (<grammar.Node object at 0x7fc3e77bb710>)
INFO:root:Action : Reduce rule [decl_item -> decl] with [<Node @ 0x7fc3e77bb710>] and goto state 78
INFO:root:Result : <Node @ 0x7fc3e77bb710> (<grammar.Node object at 0x7fc3e77bb710>)
INFO:root:Action : Reduce rule [decl_item_or_body -> decl_item] with [<Node @ 0x7fc3e77bb710>] and goto state 112
INFO:root:Result : <Node @ 0x7fc3e77bb710> (<grammar.Node object at 0x7fc3e77bb710>)
INFO:root:Action : Reduce rule [decl_item_or_body_s1 -> decl_item_or_body] with [<Node @ 0x7fc3e77bb710>] and goto state 103
INFO:root:Result : <Node @ 0x7fc3e77bb710> (<grammar.Node object at 0x7fc3e77bb710>)
INFO:root:Action : Reduce rule [decl_part -> decl_item_or_body_s1] with [<Node @ 0x7fc3e77bb710>] and goto state 106
INFO:root:Result : <Node @ 0x7fc3e77bb710> (<grammar.Node object at 0x7fc3e77bb710>)
INFO:root:Action : Reduce rule [label_opt -> <empty>] with [] and goto state 313
INFO:root:Result : <Node @ 0x7fc3e77bb748> (<grammar.Node object at 0x7fc3e77bb748>)
INFO:root:Action : Reduce rule [iter_part -> FOR IDENTIFIER IN] with ['for','i','in'] and goto state 467
INFO:root:Result : <Node @ 0x7fc3e77bb7f0> (<grammar.Node object at 0x7fc3e77bb7f0>)
INFO:root:Action : Reduce rule [reverse_opt -> <empty>] with [] and goto state 618
INFO:root:Result : <Node @ 0x7fc3e77bb320> (<grammar.Node object at 0x7fc3e77bb320>)
INFO:root:Action : Reduce rule [literal -> INT] with [1] and goto state 121
INFO:root:Result : <Node @ 0x7fc3e77bb400> (<grammar.Node object at 0x7fc3e77bb400>)
INFO:root:Action : Reduce rule [primary -> literal] with [<Node @ 0x7fc3e77bb400>] and goto state 135
INFO:root:Result : <Node @ 0x7fc3e77bb400> (<grammar.Node object at 0x7fc3e77bb400>)
INFO:root:Action : Reduce rule [factor -> primary] with [<Node @ 0x7fc3e77bb400>] and goto state 126
INFO:root:Result : <Node @ 0x7fc3e77bb400> (<grammar.Node object at 0x7fc3e77bb400>)
INFO:root:Action : Reduce rule [term -> factor] with [<Node @ 0x7fc3e77bb400>] and goto state 146
INFO:root:Result : <Node @ 0x7fc3e77bb400> (<grammar.Node object at 0x7fc3e77bb400>)
INFO:root:Action : Reduce rule [simple_expression -> term] with [<Node @ 0x7fc3e77bb400>] and goto state 366
INFO:root:Result : <Node @ 0x7fc3e77bb400> (<grammar.Node object at 0x7fc3e77bb400>)
INFO:root:Action : Reduce rule [literal -> INT] with [10] and goto state 121
INFO:root:Result : <Node @ 0x7fc3e77bb198> (<grammar.Node object at 0x7fc3e77bb198>)
INFO:root:Action : Reduce rule [primary -> literal] with [<Node @ 0x7fc3e77bb198>] and goto state 135
INFO:root:Result : <Node @ 0x7fc3e77bb198> (<grammar.Node object at 0x7fc3e77bb198>)
INFO:root:Action : Reduce rule [factor -> primary] with [<Node @ 0x7fc3e77bb198>] and goto state 126
INFO:root:Result : <Node @ 0x7fc3e77bb198> (<grammar.Node object at 0x7fc3e77bb198>)
INFO:root:Action : Reduce rule [term -> factor] with [<Node @ 0x7fc3e77bb198>] and goto state 146
INFO:root:Result : <Node @ 0x7fc3e77bb198> (<grammar.Node object at 0x7fc3e77bb198>)
INFO:root:Action : Reduce rule [simple_expression -> term] with [<Node @ 0x7fc3e77bb198>] and goto state 511
INFO:root:Result : <Node @ 0x7fc3e77bb198> (<grammar.Node object at 0x7fc3e77bb198>)
INFO:root:Action : Reduce rule [range -> simple_expression DOTDOT simple_expression] with [<Node @ 0x7fc3e77bb400>,'..',<Node @ 0x7fc3e77bb198>] and goto state 698
INFO:root:Result : <Node @ 0x7fc3e77bb6d8> (<grammar.Node object at 0x7fc3e77bb6d8>)
INFO:root:Action : Reduce rule [discrete_range -> range] with [<Node @ 0x7fc3e77bb6d8>] and goto state 731
INFO:root:Result : <Node @ 0x7fc3e77bb6d8> (<grammar.Node object at 0x7fc3e77bb6d8>)
INFO:root:Action : Reduce rule [iteration -> iter_part reverse_opt discrete_range] with [<Node @ 0x7fc3e77bb7f0>,<Node @ 0x7fc3e77bb320>,<Node @ 0x7fc3e77bb6d8>] and goto state 462
INFO:root:Result : <Node @ 0x7fc3e77bb860> (<grammar.Node object at 0x7fc3e77bb860>)
INFO:root:Action : Reduce rule [simple_name -> IDENTIFIER] with ['squares'] and goto state 163
INFO:root:Result : <Node @ 0x7fc3e77bb128> (<grammar.Node object at 0x7fc3e77bb128>)
INFO:root:Action : Reduce rule [name -> simple_name] with [<Node @ 0x7fc3e77bb128>] and goto state 316
INFO:root:Result : <Node @ 0x7fc3e77bb128> (<grammar.Node object at 0x7fc3e77bb128>)
INFO:root:Action : Reduce rule [simple_name -> IDENTIFIER] with ['i'] and goto state 163
INFO:root:Result : <Node @ 0x7fc3e77bb940> (<grammar.Node object at 0x7fc3e77bb940>)
INFO:root:Action : Reduce rule [name -> simple_name] with [<Node @ 0x7fc3e77bb940>] and goto state 377
INFO:root:Result : <Node @ 0x7fc3e77bb940> (<grammar.Node object at 0x7fc3e77bb940>)
INFO:root:Action : Reduce rule [primary -> name] with [<Node @ 0x7fc3e77bb940>] and goto state 135
INFO:root:Result : <Node @ 0x7fc3e77bb940> (<grammar.Node object at 0x7fc3e77bb940>)
INFO:root:Action : Reduce rule [factor -> primary] with [<Node @ 0x7fc3e77bb940>] and goto state 126
INFO:root:Result : <Node @ 0x7fc3e77bb940> (<grammar.Node object at 0x7fc3e77bb940>)
INFO:root:Action : Reduce rule [term -> factor] with [<Node @ 0x7fc3e77bb940>] and goto state 146
INFO:root:Result : <Node @ 0x7fc3e77bb940> (<grammar.Node object at 0x7fc3e77bb940>)
INFO:root:Action : Reduce rule [simple_expression -> term] with [<Node @ 0x7fc3e77bb940>] and goto state 374
INFO:root:Result : <Node @ 0x7fc3e77bb940> (<grammar.Node object at 0x7fc3e77bb940>)
INFO:root:Action : Reduce rule [relation -> simple_expression] with [<Node @ 0x7fc3e77bb940>] and goto state 138
INFO:root:Result : <Node @ 0x7fc3e77bb940> (<grammar.Node object at 0x7fc3e77bb940>)
INFO:root:Action : Reduce rule [expression -> relation] with [<Node @ 0x7fc3e77bb940>] and goto state 373
INFO:root:Result : <Node @ 0x7fc3e77bb940> (<grammar.Node object at 0x7fc3e77bb940>)
INFO:root:Action : Reduce rule [value -> expression] with [<Node @ 0x7fc3e77bb940>] and goto state 372
INFO:root:Result : <Node @ 0x7fc3e77bb940> (<grammar.Node object at 0x7fc3e77bb940>)
INFO:root:Action : Reduce rule [value_s -> value] with [<Node @ 0x7fc3e77bb940>] and goto state 375
INFO:root:Result : <Node @ 0x7fc3e77bb940> (<grammar.Node object at 0x7fc3e77bb940>)
INFO:root:Action : Reduce rule [indexed_comp -> name ( value_s )] with [<Node @ 0x7fc3e77bb128>,'(',<Node @ 0x7fc3e77bb940>,')'] and goto state 140
INFO:root:Result : <Node @ 0x7fc3e77bb978> (<grammar.Node object at 0x7fc3e77bb978>)
INFO:root:Action : Reduce rule [name -> indexed_comp] with [<Node @ 0x7fc3e77bb978>] and goto state 316
INFO:root:Result : <Node @ 0x7fc3e77bb978> (<grammar.Node object at 0x7fc3e77bb978>)
INFO:root:Action : Reduce rule [simple_name -> IDENTIFIER] with ['i'] and goto state 163
INFO:root:Result : <Node @ 0x7fc3e77bb9e8> (<grammar.Node object at 0x7fc3e77bb9e8>)
INFO:root:Action : Reduce rule [name -> simple_name] with [<Node @ 0x7fc3e77bb9e8>] and goto state 142
INFO:root:Result : <Node @ 0x7fc3e77bb9e8> (<grammar.Node object at 0x7fc3e77bb9e8>)
INFO:root:Action : Reduce rule [primary -> name] with [<Node @ 0x7fc3e77bb9e8>] and goto state 135
INFO:root:Result : <Node @ 0x7fc3e77bb9e8> (<grammar.Node object at 0x7fc3e77bb9e8>)
INFO:root:Action : Reduce rule [factor -> primary] with [<Node @ 0x7fc3e77bb9e8>] and goto state 126
INFO:root:Result : <Node @ 0x7fc3e77bb9e8> (<grammar.Node object at 0x7fc3e77bb9e8>)
INFO:root:Action : Reduce rule [term -> factor] with [<Node @ 0x7fc3e77bb9e8>] and goto state 146
INFO:root:Result : <Node @ 0x7fc3e77bb9e8> (<grammar.Node object at 0x7fc3e77bb9e8>)
INFO:root:Action : Reduce rule [multiplying -> *] with ['*'] and goto state 244
INFO:root:Result : <Node @ 0x7fc3e77bb9b0> (<grammar.Node object at 0x7fc3e77bb9b0>)
INFO:root:Action : Reduce rule [literal -> INT] with [2] and goto state 121
INFO:root:Result : <Node @ 0x7fc3e77bb828> (<grammar.Node object at 0x7fc3e77bb828>)
INFO:root:Action : Reduce rule [primary -> literal] with [<Node @ 0x7fc3e77bb828>] and goto state 135
INFO:root:Result : <Node @ 0x7fc3e77bb828> (<grammar.Node object at 0x7fc3e77bb828>)
INFO:root:Action : Reduce rule [factor -> primary] with [<Node @ 0x7fc3e77bb828>] and goto state 391
INFO:root:Result : <Node @ 0x7fc3e77bb828> (<grammar.Node object at 0x7fc3e77bb828>)
INFO:root:Action : Reduce rule [term -> term multiplying factor] with [<Node @ 0x7fc3e77bb9e8>,<Node @ 0x7fc3e77bb9b0>,<Node @ 0x7fc3e77bb828>] and goto state 146
INFO:root:Result : <Node @ 0x7fc3e77bbb70> (<grammar.Node object at 0x7fc3e77bbb70>)
INFO:root:Action : Reduce rule [simple_expression -> term] with [<Node @ 0x7fc3e77bbb70>] and goto state 129
INFO:root:Result : <Node @ 0x7fc3e77bbb70> (<grammar.Node object at 0x7fc3e77bbb70>)
INFO:root:Action : Reduce rule [relation -> simple_expression] with [<Node @ 0x7fc3e77bbb70>] and goto state 138
INFO:root:Result : <Node @ 0x7fc3e77bbb70> (<grammar.Node object at 0x7fc3e77bbb70>)
INFO:root:Action : Reduce rule [expression -> relation] with [<Node @ 0x7fc3e77bbb70>] and goto state 620
INFO:root:Result : <Node @ 0x7fc3e77bbb70> (<grammar.Node object at 0x7fc3e77bbb70>)
INFO:root:Action : Reduce rule [assign_stmt -> name ASSIGN expression ;] with [<Node @ 0x7fc3e77bb978>,':=',<Node @ 0x7fc3e77bbb70>,';'] and goto state 336
INFO:root:Result : <Node @ 0x7fc3e77bb908> (<grammar.Node object at 0x7fc3e77bb908>)
INFO:root:Action : Reduce rule [simple_stmt -> assign_stmt] with [<Node @ 0x7fc3e77bb908>] and goto state 302
INFO:root:Result : <Node @ 0x7fc3e77bb908> (<grammar.Node object at 0x7fc3e77bb908>)
INFO:root:Action : Reduce rule [unlabeled -> simple_stmt] with [<Node @ 0x7fc3e77bb908>] and goto state 346
INFO:root:Result : <Node @ 0x7fc3e77bb908> (<grammar.Node object at 0x7fc3e77bb908>)
INFO:root:Action : Reduce rule [statement -> unlabeled] with [<Node @ 0x7fc3e77bb908>] and goto state 308
INFO:root:Result : <Node @ 0x7fc3e77bb908> (<grammar.Node object at 0x7fc3e77bb908>)
INFO:root:Action : Reduce rule [statement_s -> statement] with [<Node @ 0x7fc3e77bb908>] and goto state 727
INFO:root:Result : <Node @ 0x7fc3e77bb908> (<grammar.Node object at 0x7fc3e77bb908>)
INFO:root:Action : Reduce rule [simple_name -> IDENTIFIER] with ['i'] and goto state 163
INFO:root:Result : <Node @ 0x7fc3e77bbba8> (<grammar.Node object at 0x7fc3e77bbba8>)
INFO:root:Action : Reduce rule [name -> simple_name] with [<Node @ 0x7fc3e77bbba8>] and goto state 316
INFO:root:Result : <Node @ 0x7fc3e77bbba8> (<grammar.Node object at 0x7fc3e77bbba8>)
INFO:root:Action : Reduce rule [simple_name -> IDENTIFIER] with ['i'] and goto state 163
INFO:root:Result : <Node @ 0x7fc3e77bbac8> (<grammar.Node object at 0x7fc3e77bbac8>)
INFO:root:Action : Reduce rule [name -> simple_name] with [<Node @ 0x7fc3e77bbac8>] and goto state 142
INFO:root:Result : <Node @ 0x7fc3e77bbac8> (<grammar.Node object at 0x7fc3e77bbac8>)
INFO:root:Action : Reduce rule [primary -> name] with [<Node @ 0x7fc3e77bbac8>] and goto state 135
INFO:root:Result : <Node @ 0x7fc3e77bbac8> (<grammar.Node object at 0x7fc3e77bbac8>)
INFO:root:Action : Reduce rule [factor -> primary] with [<Node @ 0x7fc3e77bbac8>] and goto state 126
INFO:root:Result : <Node @ 0x7fc3e77bbac8> (<grammar.Node object at 0x7fc3e77bbac8>)
INFO:root:Action : Reduce rule [term -> factor] with [<Node @ 0x7fc3e77bbac8>] and goto state 146
INFO:root:Result : <Node @ 0x7fc3e77bbac8> (<grammar.Node object at 0x7fc3e77bbac8>)
INFO:root:Action : Reduce rule [simple_expression -> term] with [<Node @ 0x7fc3e77bbac8>] and goto state 129
INFO:root:Result : <Node @ 0x7fc3e77bbac8> (<grammar.Node object at 0x7fc3e77bbac8>)
INFO:root:Action : Reduce rule [adding -> +] with ['+'] and goto state 230
INFO:root:Result : <Node @ 0x7fc3e77bbc18> (<grammar.Node object at 0x7fc3e77bbc18>)
INFO:root:Action : Reduce rule [literal -> INT] with [5] and goto state 121
INFO:root:Result : <Node @ 0x7fc3e77bb9b0> (<grammar.Node object at 0x7fc3e77bb9b0>)
INFO:root:Action : Reduce rule [primary -> literal] with [<Node @ 0x7fc3e77bb9b0>] and goto state 135
INFO:root:Result : <Node @ 0x7fc3e77bb9b0> (<grammar.Node object at 0x7fc3e77bb9b0>)
INFO:root:Action : Reduce rule [factor -> primary] with [<Node @ 0x7fc3e77bb9b0>] and goto state 126
INFO:root:Result : <Node @ 0x7fc3e77bb9b0> (<grammar.Node object at 0x7fc3e77bb9b0>)
INFO:root:Action : Reduce rule [term -> factor] with [<Node @ 0x7fc3e77bb9b0>] and goto state 369
INFO:root:Result : <Node @ 0x7fc3e77bb9b0> (<grammar.Node object at 0x7fc3e77bb9b0>)
INFO:root:Action : Reduce rule [simple_expression -> simple_expression adding term] with [<Node @ 0x7fc3e77bbac8>,<Node @ 0x7fc3e77bbc18>,<Node @ 0x7fc3e77bb9b0>] and goto state 129
INFO:root:Result : <Node @ 0x7fc3e77bbc50> (<grammar.Node object at 0x7fc3e77bbc50>)
INFO:root:Action : Reduce rule [relation -> simple_expression] with [<Node @ 0x7fc3e77bbc50>] and goto state 138
INFO:root:Result : <Node @ 0x7fc3e77bbc50> (<grammar.Node object at 0x7fc3e77bbc50>)
INFO:root:Action : Reduce rule [expression -> relation] with [<Node @ 0x7fc3e77bbc50>] and goto state 620
INFO:root:Result : <Node @ 0x7fc3e77bbc50> (<grammar.Node object at 0x7fc3e77bbc50>)
INFO:root:Action : Reduce rule [assign_stmt -> name ASSIGN expression ;] with [<Node @ 0x7fc3e77bbba8>,':=',<Node @ 0x7fc3e77bbc50>,';'] and goto state 336
INFO:root:Result : <Node @ 0x7fc3e77bbd30> (<grammar.Node object at 0x7fc3e77bbd30>)
INFO:root:Action : Reduce rule [simple_stmt -> assign_stmt] with [<Node @ 0x7fc3e77bbd30>] and goto state 302
INFO:root:Result : <Node @ 0x7fc3e77bbd30> (<grammar.Node object at 0x7fc3e77bbd30>)
INFO:root:Action : Reduce rule [unlabeled -> simple_stmt] with [<Node @ 0x7fc3e77bbd30>] and goto state 346
INFO:root:Result : <Node @ 0x7fc3e77bbd30> (<grammar.Node object at 0x7fc3e77bbd30>)
INFO:root:Action : Reduce rule [statement -> unlabeled] with [<Node @ 0x7fc3e77bbd30>] and goto state 497
INFO:root:Result : <Node @ 0x7fc3e77bbd30> (<grammar.Node object at 0x7fc3e77bbd30>)
INFO:root:Action : Reduce rule [statement_s -> statement_s statement] with [<Node @ 0x7fc3e77bb908>,<Node @ 0x7fc3e77bbd30>] and goto state 727
INFO:root:Result : <Node @ 0x7fc3e77bba90> (<grammar.Node object at 0x7fc3e77bba90>)
INFO:root:Action : Reduce rule [basic_loop -> LOOP statement_s END LOOP] with ['loop',<Node @ 0x7fc3e77bba90>,'end','loop'] and goto state 611
INFO:root:Result : <Node @ 0x7fc3e77bbb00> (<grammar.Node object at 0x7fc3e77bbb00>)
INFO:root:Action : Reduce rule [id_opt -> <empty>] with [] and goto state 726
INFO:root:Result : <Node @ 0x7fc3e77bb898> (<grammar.Node object at 0x7fc3e77bb898>)
INFO:root:Action : Reduce rule [loop_stmt -> label_opt iteration basic_loop id_opt ;] with [<Node @ 0x7fc3e77bb748>,<Node @ 0x7fc3e77bb860>,<Node @ 0x7fc3e77bbb00>,<Node @ 0x7fc3e77bb898>,';'] and goto state 333
INFO:root:Result : <Node @ 0x7fc3e77bbc88> (<grammar.Node object at 0x7fc3e77bbc88>)
INFO:root:Action : Reduce rule [compound_stmt -> loop_stmt] with [<Node @ 0x7fc3e77bbc88>] and goto state 309
INFO:root:Result : <Node @ 0x7fc3e77bbc88> (<grammar.Node object at 0x7fc3e77bbc88>)
INFO:root:Action : Reduce rule [unlabeled -> compound_stmt] with [<Node @ 0x7fc3e77bbc88>] and goto state 346
INFO:root:Result : <Node @ 0x7fc3e77bbc88> (<grammar.Node object at 0x7fc3e77bbc88>)
INFO:root:Action : Reduce rule [statement -> unlabeled] with [<Node @ 0x7fc3e77bbc88>] and goto state 308
INFO:root:Result : <Node @ 0x7fc3e77bbc88> (<grammar.Node object at 0x7fc3e77bbc88>)
INFO:root:Action : Reduce rule [statement_s -> statement] with [<Node @ 0x7fc3e77bbc88>] and goto state 339
INFO:root:Result : <Node @ 0x7fc3e77bbc88> (<grammar.Node object at 0x7fc3e77bbc88>)
INFO:root:Action : Reduce rule [except_handler_part_opt -> <empty>] with [] and goto state 500
INFO:root:Result : <Node @ 0x7fc3e77bbd68> (<grammar.Node object at 0x7fc3e77bbd68>)
INFO:root:Action : Reduce rule [handled_stmt_s -> statement_s except_handler_part_opt] with [<Node @ 0x7fc3e77bbc88>,<Node @ 0x7fc3e77bbd68>] and goto state 343
INFO:root:Result : <Node @ 0x7fc3e77bbda0> (<grammar.Node object at 0x7fc3e77bbda0>)
INFO:root:Action : Reduce rule [block_body -> BEGIN handled_stmt_s] with ['begin',<Node @ 0x7fc3e77bbda0>] and goto state 194
INFO:root:Result : <Node @ 0x7fc3e77bbbe0> (<grammar.Node object at 0x7fc3e77bbbe0>)
INFO:root:Action : Reduce rule [simple_name -> IDENTIFIER] with ['demo'] and goto state 34
INFO:root:Result : <Node @ 0x7fc3e77bb588> (<grammar.Node object at 0x7fc3e77bb588>)
INFO:root:Action : Reduce rule [compound_name -> simple_name] with [<Node @ 0x7fc3e77bb588>] and goto state 64
INFO:root:Result : <Node @ 0x7fc3e77bbdd8> (<grammar.Node object at 0x7fc3e77bbdd8>)
INFO:root:Action : Reduce rule [designator -> compound_name] with [<Node @ 0x7fc3e77bbdd8>] and goto state 455
INFO:root:Result : <Node @ 0x7fc3e77bbdd8> (<grammar.Node object at 0x7fc3e77bbdd8>)
INFO:root:Action : Reduce rule [id_opt -> designator] with [<Node @ 0x7fc3e77bbdd8>] and goto state 456
INFO:root:Result : <Node @ 0x7fc3e77bb780> (<grammar.Node object at 0x7fc3e77bb780>)
INFO:root:Action : Reduce rule [subprog_body -> subprog_spec_is_push decl_part block_body END id_opt ;] with [<Node @ 0x7fc3e77bb048>,<Node @ 0x7fc3e77bb710>,<Node @ 0x7fc3e77bbbe0>,'end',<Node @ 0x7fc3e77bb780>,';'] and goto state 32
INFO:root:Result : <Node @ 0x7fc3e77bbe48> (<grammar.Node object at 0x7fc3e77bbe48>)
INFO:root:Action : Reduce rule [unit -> subprog_body] with [<Node @ 0x7fc3e77bbe48>] and goto state 117
INFO:root:Result : <Node @ 0x7fc3e77bb2b0> (<grammar.Node object at 0x7fc3e77bb2b0>)
INFO:root:Action : Reduce rule [pragma_s -> <empty>] with [] and goto state 200
INFO:root:Result : <Node @ 0x7fc3e77bbe80> (<grammar.Node object at 0x7fc3e77bbe80>)
INFO:root:Action : Reduce rule [comp_unit -> context_spec private_opt unit pragma_s] with [<Node @ 0x7fc3e772d160>,<Node @ 0x7fc3e7adfd30>,<Node @ 0x7fc3e77bb2b0>,<Node @ 0x7fc3e77bbe80>] and goto state 9
INFO:root:Result : <Node @ 0x7fc3e77bb6a0> (<grammar.Node object at 0x7fc3e77bb6a0>)
INFO:root:Action : Reduce rule [compilation -> compilation comp_unit] with [<Node @ 0x7fc3e7adfbe0>,<Node @ 0x7fc3e77bb6a0>] and goto state 1
INFO:root:Result : <Node @ 0x7fc3e7adfdd8> (<grammar.Node object at 0x7fc3e7adfdd8>)
INFO:root:Action : Reduce rule [goal_symbol -> compilation] with [<Node @ 0x7fc3e7adfdd8>] and goto state 3
INFO:root:Result : <Node @ 0x7fc3e772d748> (<grammar.Node object at 0x7fc3e772d748>)
INFO:root:Done   : Returning <Node @ 0x7fc3e772d748> (<grammar.Node object at 0x7fc3e772d748>)
INFO:root:PLY: PARSE DEBUG END
